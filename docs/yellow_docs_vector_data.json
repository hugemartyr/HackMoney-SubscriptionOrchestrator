[
  {
    "id": "https://docs.yellow.org/docs/api-reference",
    "text": "* [](/)\n  * API Reference\n\nOn this page\n\n# API Reference\n\nComplete reference for all Yellow SDK methods, types, and utilities.\n\n## NitroliteRPC Functionsâ€‹\n\n### Message Creationâ€‹\n\n#### `createAppSessionMessage(signer: MessageSigner, sessions: AppSession[]): Promise<string>`â€‹\n\nCreates a signed application session message.\n\n**Parameters:**\n    \n    \n    type MessageSigner = (payload: any) => Promise<Hex>;  \n      \n    interface AppSession {  \n      definition: AppDefinition;  \n      allocations: AppAllocation[];  \n    }  \n      \n    interface AppDefinition {  \n      protocol: string;  \n      participants: Address[];  \n      weights: number[];  \n      quorum: number;  \n      challenge: number;  \n      nonce: number;  \n    }  \n      \n    interface AppAllocation {  \n      participant: Address;  \n      asset: string;  \n      amount: string;  \n    }  \n    \n\n#### `createStateUpdateMessage(signer: MessageSigner, update: StateUpdate): Promise<string>`â€‹\n\nCreates a signed state update message.\n\n#### `parseRPCResponse(data: string): RPCMessage`â€‹\n\nParses ClearNode response messages.\n\n**Returns:**\n    \n    \n    interface RPCMessage {  \n      id?: number;  \n      method?: string;  \n      params?: any;  \n      result?: any;  \n      error?: RPCError;  \n    }  \n    \n\n### Utilitiesâ€‹\n\n#### `computeChannelId(channel: Channel): ChannelId`â€‹\n\nCalculates deterministic channel identifier.\n\n#### `computeStateHash(state: State, channelId: ChannelId): Hash`â€‹\n\nCalculates state hash for signatures.\n\n#### `validateSignature(state: State, signature: Hex, signer: Address): Promise<boolean>`â€‹\n\nVerifies state signature.\n\n## Type Definitionsâ€‹\n\n### Core Typesâ€‹\n    \n    \n    type Address = `0x${string}`;  \n    type Hash = `0x${string}`;  \n    type Hex = `0x${string}`;  \n    type ChannelId = Hash;  \n      \n    interface Channel {  \n      participants: Address[];  \n      adjudicator: Address;  \n      challenge: bigint;  \n      nonce: bigint;  \n    }  \n      \n    interface State {  \n      intent: StateIntent;  \n      version: bigint;  \n      data: Hex;  \n      allocations: Allocation[];  \n      sigs: Hex[];  \n    }  \n      \n    interface Allocation {  \n      destination: Address;  \n      token: Address;  \n      amount: bigint;  \n    }  \n      \n    enum StateIntent {  \n      OPERATE = 0,  \n      INITIALIZE = 1,  \n      RESIZE = 2,  \n      FINALIZE = 3  \n    }  \n      \n    enum ChannelStatus {  \n      VOID = 0,  \n      INITIAL = 1,  \n      ACTIVE = 2,  \n      DISPUTE = 3,  \n      FINAL = 4  \n    }  \n    \n\n### Connection Configurationâ€‹\n    \n    \n    interface ClearNodeConfig {  \n      endpoint: string;          // WebSocket endpoint  \n      apiKey?: string;          // Optional authentication  \n      timeout: number;          // Connection timeout  \n      retryAttempts: number;    // Reconnection attempts  \n    }  \n      \n    const config = {  \n      endpoint: 'wss://clearnet-sandbox.yellow.com/ws', // or wss://clearnet.yellow.com/ws for production  \n      timeout: 30000,  \n      retryAttempts: 3  \n    };  \n    \n\n### RPC Typesâ€‹\n    \n    \n    interface RPCRequest {  \n      id: number;  \n      method: string;  \n      params: any[];  \n      timestamp?: number;  \n    }  \n      \n    interface RPCResponse {  \n      id: number;  \n      result?: any;  \n      error?: RPCError;  \n      timestamp: number;  \n    }  \n      \n    interface RPCError {  \n      code: number;  \n      message: string;  \n      data?: any;  \n    }  \n    \n\n## Error Typesâ€‹\n\n### Client Errorsâ€‹\n    \n    \n    class YellowSDKError extends Error {  \n      constructor(message: string, public code: string, public context?: any) {  \n        super(message);  \n        this.name = 'YellowSDKError';  \n      }  \n    }  \n      \n    class NetworkError extends YellowSDKError {  \n      constructor(message: string, context?: any) {  \n        super(message, 'NETWORK_ERROR', context);  \n      }  \n    }  \n      \n    class ContractError extends YellowSDKError {  \n      constructor(message: string, context?: any) {  \n        super(message, 'CONTRACT_ERROR', context);  \n      }  \n    }  \n      \n    class ValidationError extends YellowSDKError {  \n      constructor(message: string, context?: any) {  \n        super(message, 'VALIDATION_ERROR', context);  \n      }  \n    }  \n    \n\n### Error Handlingâ€‹\n    \n    \n    try {  \n      const sessionMessage = await createAppSessionMessage(messageSigner, sessionData);  \n      ws.send(sessionMessage);  \n    } catch (error) {  \n      if (error instanceof NetworkError) {  \n        // Handle network connectivity issues  \n        await this.reconnectToClearNode();  \n      } else if (error instanceof ValidationError) {  \n        // Handle input validation errors  \n        console.error('Invalid session parameters:', error.context);  \n      } else if (error instanceof SigningError) {  \n        // Handle wallet signing errors  \n        console.error('Message signing failed:', error.message);  \n      } else {  \n        // Handle unexpected errors  \n        console.error('Unexpected error:', error);  \n      }  \n    }  \n    \n\n## Constantsâ€‹\n\n### Network Endpointsâ€‹\n    \n    \n    const CLEARNODE_ENDPOINTS = {  \n      PRODUCTION: 'wss://clearnet.yellow.com/ws',  \n      SANDBOX: 'wss://clearnet-sandbox.yellow.com/ws',  \n      LOCAL: 'ws://localhost:8080/ws'  \n    };  \n      \n    const PROTOCOLS = {  \n      PAYMENT: 'payment-app-v1',  \n      GAMING: 'gaming-app-v1',  \n      ESCROW: 'escrow-app-v1',  \n      TOURNAMENT: 'tournament-v1',  \n      SUBSCRIPTION: 'subscription-v1'  \n    };  \n    \n\n### Message Typesâ€‹\n    \n    \n    const MESSAGE_TYPES = {  \n      SESSION_CREATE: 'session_create',  \n      SESSION_MESSAGE: 'session_message',  \n      PAYMENT: 'payment',  \n      STATE_UPDATE: 'state_update',  \n      PARTICIPANT_JOIN: 'participant_join',  \n      SESSION_CLOSE: 'session_close',  \n      ERROR: 'error'  \n    };  \n      \n    const SESSION_STATUS = {  \n      PENDING: 'pending',  \n      ACTIVE: 'active',  \n      CLOSING: 'closing',  \n      CLOSED: 'closed',  \n      ERROR: 'error'  \n    };  \n    \n\nThis API reference provides everything you need to integrate NitroliteRPC into your applications with confidence and precision.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/api-reference/index.md)\n\n[PreviousApp Sessions](/docs/api-reference/app-sessions)\n\n  * NitroliteRPC Functions\n    * Message Creation\n    * Utilities\n  * Type Definitions\n    * Core Types\n    * Connection Configuration\n    * RPC Types\n  * Error Types\n    * Client Errors\n    * Error Handling\n  * Constants\n    * Network Endpoints\n    * Message Types",
    "metadata": {
      "title": "API Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/api-reference",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/api-reference/app-sessions",
    "text": "* [](/)\n  * App Sessions\n\nOn this page\n\n# App Sessions\n\nAPI methods for managing virtual application sessions.\n\n## create_app_sessionâ€‹\n\nCreates a virtual application session between participants.\n\n**Request:**\n    \n    \n    {  \n      \"req\": [1, \"create_app_session\", {  \n        \"definition\": {  \n          \"protocol\": \"NitroRPC/0.2\" | \"NitroRPC/0.4\",  \n          \"participants\": Address[],  \n          \"weights\": number[],  \n          \"quorum\": number,  \n          \"challenge\": number,  \n          \"nonce\": number  \n        },  \n        \"allocations\": AppAllocation[],  \n        \"session_data\": string // Optional  \n      }, timestamp],  \n      \"sig\": Hex[]  \n    }  \n    \n\n**Response:**\n    \n    \n    {  \n      \"res\": [1, \"create_app_session\", {  \n        \"app_session_id\": Hex,  \n        \"version\": string,  \n        \"status\": \"open\"  \n      }, timestamp],  \n      \"sig\": [Hex]  \n    }  \n    \n\n## submit_app_stateâ€‹\n\nUpdates session state and redistributes funds.\n\n### NitroRPC/0.2â€‹\n\n**Request:**\n    \n    \n    {  \n      \"req\": [1, \"submit_app_state\", {  \n        \"app_session_id\": Hex,  \n        \"allocations\": AppAllocation[],  \n        \"session_data\": string // Optional  \n      }, timestamp],  \n      \"sig\": Hex[]  \n    }  \n    \n\n### NitroRPC/0.4â€‹\n\n**Request:**\n    \n    \n    {  \n      \"req\": [1, \"submit_app_state\", {  \n        \"app_session_id\": Hex,  \n        \"intent\": \"operate\" | \"deposit\" | \"withdraw\",  \n        \"version\": number,  \n        \"allocations\": AppAllocation[],  \n        \"session_data\": string // Optional  \n      }, timestamp],  \n      \"sig\": Hex[]  \n    }  \n    \n\n**Response:**\n    \n    \n    {  \n      \"res\": [1, \"submit_app_state\", {  \n        \"app_session_id\": Hex,  \n        \"version\": string,  \n        \"status\": \"open\"  \n      }, timestamp],  \n      \"sig\": [Hex]  \n    }  \n    \n\n## close_app_sessionâ€‹\n\nCloses session and finalizes fund distribution.\n\n**Request:**\n    \n    \n    {  \n      \"req\": [1, \"close_app_session\", {  \n        \"app_session_id\": Hex,  \n        \"allocations\": AppAllocation[],  \n        \"session_data\": string // Optional  \n      }, timestamp],  \n      \"sig\": Hex[]  \n    }  \n    \n\n**Response:**\n    \n    \n    {  \n      \"res\": [1, \"close_app_session\", {  \n        \"app_session_id\": Hex,  \n        \"version\": string,  \n        \"status\": \"closed\"  \n      }, timestamp],  \n      \"sig\": [Hex]  \n    }  \n    \n\n## Typesâ€‹\n\n### AppAllocationâ€‹\n    \n    \n    interface AppAllocation {  \n      participant: Address;  \n      asset: string;  \n      amount: string;  \n    }  \n    \n\n### AppDefinitionâ€‹\n    \n    \n    interface AppDefinition {  \n      protocol: \"NitroRPC/0.2\" | \"NitroRPC/0.4\";  \n      participants: Address[];  \n      weights: number[];  \n      quorum: number;  \n      challenge: number;  \n      nonce: number;  \n    }  \n    \n\n## Intent Types (NitroRPC/0.4)â€‹\n\n  * `operate`: Redistribute existing session funds\n  * `deposit`: Add funds from participants' unified balances\n  * `withdraw`: Remove funds to participants' unified balances\n\n## Session Statusâ€‹\n\n  * `open`: Session is active and accepting state updates\n  * `closed`: Session is finalized, no further updates allowed\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/api-reference/app-sessions.md)\n\n[NextAPI Reference](/docs/api-reference/)\n\n  * create_app_session\n  * submit_app_state\n    * NitroRPC/0.2\n    * NitroRPC/0.4\n  * close_app_session\n  * Types\n    * AppAllocation\n    * AppDefinition\n  * Intent Types (NitroRPC/0.4)\n  * Session Status",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/api-reference/app-sessions",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/build/quick-start",
    "text": "* [](/)\n  * Quick Start\n\nOn this page\n\n# Quick Start Guide\n\nBuild your first Yellow App in 5 minutes! This guide walks you through creating a simple payment application using state channels.\n\n## What You'll Buildâ€‹\n\nA basic payment app where users can:\n\n  * Deposit funds into a state channel\n  * Send instant payments to another user\n  * Withdraw remaining funds\n\nNo blockchain knowledge required - we'll handle the complexity for you!\n\n## Prerequisitesâ€‹\n\n  * **Node.js 16+** installed on your computer\n  * **A wallet** (MetaMask recommended)\n  * **Basic JavaScript/TypeScript** knowledge\n\n## Step 1: Installationâ€‹\n\nCreate a new project and install the Yellow SDK:\n\n  * npm\n  * yarn\n  * pnpm\n    \n    \n    mkdir my-yellow-app  \n    cd my-yellow-app  \n    npm init -y  \n    npm install @erc7824/nitrolite  \n    \n    \n    \n    mkdir my-yellow-app  \n    cd my-yellow-app  \n    yarn init -y  \n    yarn add @erc7824/nitrolite  \n    \n    \n    \n    mkdir my-yellow-app  \n    cd my-yellow-app  \n    pnpm init  \n    pnpm add @erc7824/nitrolite  \n    \n\n## Step 2: Connect to ClearNodeâ€‹\n\nCreate a file `app.js` and connect to the Yellow Network.\n\nClearnode Endpoints\n\n  * **Production** : `wss://clearnet.yellow.com/ws`\n  * **Sandbox** : `wss://clearnet-sandbox.yellow.com/ws` (recommended for testing)\n\napp.js\n    \n    \n    import { createAppSessionMessage, parseRPCResponse } from '@erc7824/nitrolite';  \n      \n    // Connect to Yellow Network (using sandbox for testing)  \n    const ws = new WebSocket('wss://clearnet-sandbox.yellow.com/ws');  \n      \n    ws.onopen = () => {  \n      console.log('âœ… Connected to Yellow Network!');  \n    };  \n      \n    ws.onmessage = (event) => {  \n      const message = parseRPCResponse(event.data);  \n      console.log('ðŸ“¨ Received:', message);  \n    };  \n      \n    ws.onerror = (error) => {  \n      console.error('Connection error:', error);  \n    };  \n      \n    console.log('Connecting to Yellow Network...');  \n    \n\n## Step 3: Create Application Sessionâ€‹\n\nSet up your wallet for signing messages:\n    \n    \n    // Set up message signer for your wallet  \n    async function setupMessageSigner() {  \n      if (!window.ethereum) {  \n        throw new Error('Please install MetaMask');  \n      }  \n      \n      // Request wallet connection  \n      const accounts = await window.ethereum.request({  \n        method: 'eth_requestAccounts'  \n      });  \n        \n      const userAddress = accounts[0];  \n        \n      // Create message signer function  \n      const messageSigner = async (message) => {  \n        return await window.ethereum.request({  \n          method: 'personal_sign',  \n          params: [message, userAddress]  \n        });  \n      };  \n      \n      console.log('âœ… Wallet connected:', userAddress);  \n      return { userAddress, messageSigner };  \n    }  \n    \n\n## Step 4: Create Application Sessionâ€‹\n\nCreate a session for your payment app:\n    \n    \n    async function createPaymentSession(messageSigner, userAddress, partnerAddress) {  \n      // Define your payment application  \n      const appDefinition = {  \n        protocol: 'payment-app-v1',  \n        participants: [userAddress, partnerAddress],  \n        weights: [50, 50], // Equal participation  \n        quorum: 100, // Both participants must agree  \n        challenge: 0,  \n        nonce: Date.now()  \n      };  \n      \n      // Initial balances (1 USDC = 1,000,000 units with 6 decimals)  \n      const allocations = [  \n        { participant: userAddress, asset: 'usdc', amount: '800000' }, // 0.8 USDC  \n        { participant: partnerAddress, asset: 'usdc', amount: '200000' } // 0.2 USDC  \n      ];  \n      \n      // Create signed session message  \n      const sessionMessage = await createAppSessionMessage(  \n        messageSigner,  \n        [{ definition: appDefinition, allocations }]  \n      );  \n      \n      // Send to ClearNode  \n      ws.send(sessionMessage);  \n      console.log('âœ… Payment session created!');  \n        \n      return { appDefinition, allocations };  \n    }  \n    \n\n## Step 5: Send Instant Paymentsâ€‹\n    \n    \n    async function sendPayment(ws, messageSigner, amount, recipient) {  \n      // Create payment message  \n      const paymentData = {  \n        type: 'payment',  \n        amount: amount.toString(),  \n        recipient,  \n        timestamp: Date.now()  \n      };  \n      \n      // Sign the payment  \n      const signature = await messageSigner(JSON.stringify(paymentData));  \n        \n      const signedPayment = {  \n        ...paymentData,  \n        signature,  \n        sender: await getCurrentUserAddress()  \n      };  \n      \n      // Send instantly through ClearNode  \n      ws.send(JSON.stringify(signedPayment));  \n      console.log('ðŸ’¸ Payment sent instantly!');  \n    }  \n      \n    // Usage  \n    await sendPayment(ws, messageSigner, 100000n, partnerAddress); // Send 0.1 USDC  \n    \n\n## Step 6: Handle Incoming Messagesâ€‹\n    \n    \n    // Enhanced message handling  \n    ws.onmessage = (event) => {  \n      const message = parseRPCResponse(event.data);  \n        \n      switch (message.type) {  \n        case 'session_created':  \n          console.log('âœ… Session confirmed:', message.sessionId);  \n          break;  \n            \n        case 'payment':  \n          console.log('ðŸ’° Payment received:', message.amount);  \n          // Update your app's UI  \n          updateBalance(message.amount, message.sender);  \n          break;  \n            \n        case 'session_message':  \n          console.log('ðŸ“¨ App message:', message.data);  \n          handleAppMessage(message);  \n          break;  \n            \n        case 'error':  \n          console.error('âŒ Error:', message.error);  \n          break;  \n      }  \n    };  \n      \n    function updateBalance(amount, sender) {  \n      console.log(`Received ${amount} from ${sender}`);  \n      // Update your application state  \n    }  \n    \n\n## Complete Exampleâ€‹\n\nHere's a complete working example you can copy and run:\n\nSimplePaymentApp.js\n    \n    \n    import { createAppSessionMessage, parseRPCResponse } from '@erc7824/nitrolite';  \n      \n    class SimplePaymentApp {  \n      constructor() {  \n        this.ws = null;  \n        this.messageSigner = null;  \n        this.userAddress = null;  \n        this.sessionId = null;  \n      }  \n      \n      async init() {  \n        // Step 1: Set up wallet  \n        const { userAddress, messageSigner } = await this.setupWallet();  \n        this.userAddress = userAddress;  \n        this.messageSigner = messageSigner;  \n          \n        // Step 2: Connect to ClearNode (sandbox for testing)  \n        this.ws = new WebSocket('wss://clearnet-sandbox.yellow.com/ws');  \n          \n        this.ws.onopen = () => {  \n          console.log('ðŸŸ¢ Connected to Yellow Network!');  \n        };  \n          \n        this.ws.onmessage = (event) => {  \n          this.handleMessage(parseRPCResponse(event.data));  \n        };  \n          \n        return userAddress;  \n      }  \n      \n      async setupWallet() {  \n        const accounts = await window.ethereum.request({  \n          method: 'eth_requestAccounts'  \n        });  \n          \n        const userAddress = accounts[0];  \n        const messageSigner = async (message) => {  \n          return await window.ethereum.request({  \n            method: 'personal_sign',  \n            params: [message, userAddress]  \n          });  \n        };  \n      \n        return { userAddress, messageSigner };  \n      }  \n      \n      async createSession(partnerAddress) {  \n        const appDefinition = {  \n          protocol: 'payment-app-v1',  \n          participants: [this.userAddress, partnerAddress],  \n          weights: [50, 50],  \n          quorum: 100,  \n          challenge: 0,  \n          nonce: Date.now()  \n        };  \n      \n        const allocations = [  \n          { participant: this.userAddress, asset: 'usdc', amount: '800000' },  \n          { participant: partnerAddress, asset: 'usdc', amount: '200000' }  \n        ];  \n      \n        const sessionMessage = await createAppSessionMessage(  \n          this.messageSigner,  \n          [{ definition: appDefinition, allocations }]  \n        );  \n      \n        this.ws.send(sessionMessage);  \n        console.log('âœ… Payment session created!');  \n      }  \n      \n      async sendPayment(amount, recipient) {  \n        const paymentData = {  \n          type: 'payment',  \n          amount: amount.toString(),  \n          recipient,  \n          timestamp: Date.now()  \n        };  \n      \n        const signature = await this.messageSigner(JSON.stringify(paymentData));  \n          \n        this.ws.send(JSON.stringify({  \n          ...paymentData,  \n          signature,  \n          sender: this.userAddress  \n        }));  \n          \n        console.log(`ðŸ’¸ Sent ${amount} instantly!`);  \n      }  \n      \n      handleMessage(message) {  \n        switch (message.type) {  \n          case 'session_created':  \n            this.sessionId = message.sessionId;  \n            console.log('âœ… Session ready:', this.sessionId);  \n            break;  \n          case 'payment':  \n            console.log('ðŸ’° Payment received:', message.amount);  \n            break;  \n        }  \n      }  \n    }  \n      \n    // Usage  \n    const app = new SimplePaymentApp();  \n    await app.init();  \n    await app.createSession('0xPartnerAddress');  \n    await app.sendPayment('100000', '0xPartnerAddress'); // Send 0.1 USDC  \n    \n\n## What's Next?â€‹\n\nCongratulations! You've built your first Yellow App. Here's what to explore next:\n\n  * **[Advanced Topics](/docs/learn/advanced/architecture)** : Learn about architecture, multi-party applications, and production deployment\n  * **[API Reference](/docs/api-reference)** : Explore all available SDK methods and options\n\n## Need Help?â€‹\n\n  * **Documentation** : Continue reading the guides for in-depth explanations\n  * **Community** : Join our developer community for support\n  * **Examples** : Check out our GitHub repository for sample applications\n\nYou're now ready to build fast, scalable apps with Yellow SDK!\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/build/quick-start/index.md)\n\n  * What You'll Build\n  * Prerequisites\n  * Step 1: Installation\n  * Step 2: Connect to ClearNode\n  * Step 3: Create Application Session\n  * Step 4: Create Application Session\n  * Step 5: Send Instant Payments\n  * Step 6: Handle Incoming Messages\n  * Complete Example\n  * What's Next?\n  * Need Help?",
    "metadata": {
      "title": "Quick Start | Yellow Network",
      "url": "https://docs.yellow.org/docs/build/quick-start",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/guides",
    "text": "* [](/)\n  * Guides\n\n# Guides\n\n**[Migration Guide](/docs/guides/migration-guide)** \\- Guide for migrating from previous versions of the Yellow SDK.\n\n**[Multi-Party App Sessions](/docs/guides/multi-party-app-sessions)** \\- Learn how to create, manage, and close multi-party application sessions using the Yellow Network and Nitrolite protocol.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guides/index.md)\n\n[NextMigration Guide](/docs/guides/migration-guide)",
    "metadata": {
      "title": "Guides | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/guides/migration-guide",
    "text": "* [](/)\n  * Migration Guide\n\nOn this page\n\n# Migration Guide\n\nIf you are coming from an earlier version of Nitrolite, you will need to account for the following breaking changes.\n\n## 0.5.x Breaking changesâ€‹\n\nThe 0.5.x release includes fundamental protocol changes affecting session keys, channel operations, state signatures, and channel resize rules. The main objective of these changes is to enhance security, and provide better experience for developers and users by ability to limit allowances for specific applications.\n\n**Not ready to migrate?** Unfortunately, at this time Yellow Network does not provide ClearNodes running the previous version of the protocol, so you will need to migrate to the latest version to continue using the Network.\n\n### Protocol Changesâ€‹\n\nThese protocol-level changes affect all implementations and integrations with the Yellow Network.\n\n#### Session Keys: Applications, Allowances, and Expirationâ€‹\n\nSession keys now have enhanced properties that define their access levels and capabilities:\n\n  * **Application field** : Determines the scope of session key permissions. Setting this to an application name (e.g., \"My Trading App\") grants application-scoped access with enforced allowances. Setting it to \"clearnode\" grants root access equivalent to the wallet itself.\n\n  * **Allowances field** : Defines spending limits for application-scoped session keys. These limits are tracked cumulatively across all operations and are enforced by the protocol.\n\n  * **Expires_at field** : Uses a bigint timestamp (seconds since epoch). Once expired, session keys are permanently frozen and cannot be reactivated. This is particularly critical for root access keys (application set to \"clearnode\") - if they expire, you lose the ability to perform channel operations.\n\n\n#### Channel Creation: Separate Create and Fund Stepsâ€‹\n\nClearnode no longer supports creating channels with an initial deposit. All channels must be created with zero balance and funded separately through a resize operation. This two-step process ensures cleaner state management and prevents edge cases in channel initialization.\n\n#### State Signatures: Wallet vs Session Key Signingâ€‹\n\nA fundamental change in how channel states are signed:\n\n  * **Channels created before v0.5.0** : The participant address is the session key, and all states must be signed by that session key.\n\n  * **Channels created after v0.5.0** : The participant address is the wallet address, and all states must be signed by the wallet.\n\n\nThis change improves security and aligns with standard practices, but requires careful handling during the transition period.\n\n#### Resize Operations: Strict Channel Balance Rulesâ€‹\n\nThe protocol now enforces strict rules about channel balances and their impact on other operations:\n\n  * **Blocked operations** : Users with any channel containing non-zero amounts cannot perform transfers, submit app states with deposit intent, or create app sessions with non-zero allocations.\n\n  * **Resizing state** : After a resize request, channels enter a \"resizing\" state with locked funds until the on-chain transaction is confirmed. If a channel remains stuck in this state for an extended period, the recommended action is to close the channel and create a new one.\n\n  * **Allocate amount semantics** : The resize operation uses `allocate_amount` where negative values withdraw from the channel to unified balance, and positive values deposit to the channel.\n\n\nwarning\n\n**Legacy channel migration** : Users with existing channels containing non-zero amounts must either resize them to zero (by providing \"resize_amount\" as 0 and \"allocate_amount\" as your **negative** on-chain balance) or close them to enable full protocol functionality. If you are unsure how to adjust resize parameters, the safe option is to close the old on-chain channel entirely, and open a new one.\n\n#### Non-Zero Channel Allocations: Operation Restrictionsâ€‹\n\nThe following operations will return errors if the user has any channel with non-zero amount:\n\n  * **Transfer** : Returns error code indicating blocked due to non-zero channel balance\n  * **Submit App State** (with deposit intent): Rejected if attempting to deposit\n  * **Create App Session** (with allocations): Rejected if attempting to allocate\n\nThe returned error has the following format: `operation denied: non-zero allocation in <count> channel(s) detected owned by wallet <address>\"`\n\n### Nitrolite SDKâ€‹\n\nYou should definitely read this section if you are using the Nitrolite SDK.\n\n#### Update Authenticationâ€‹\n\nImplementing the new session key protocol changes:\n\n  * Application Session Key\n  * Root Access (Clearnode)\n    \n    \n    const authRequest = {  \n      address: '0x...',  \n      session_key: '0x...',  \n      application: 'My Trading App', // Application name for confined access  \n      allowances: [  \n        { asset: 'usdc', amount: '1000.0' },  \n        { asset: 'eth', amount: '0.5' }  \n      ],  \n      scope: 'app.create',  \n      expires_at: BigInt(Math.floor(Date.now() / 1000) + 7 * 24 * 60 * 60) // 7 days  \n    };  \n    \n    \n    \n    const authRequest = {  \n      address: '0x...',  \n      session_key: '0x...',  \n      application: 'clearnode', // Special value for root access  \n      allowances: [], // Not enforced for root access  \n      scope: 'app.create',  \n      expires_at: BigInt(Math.floor(Date.now() / 1000) + 365 * 24 * 60 * 60) // Long expiration recommended  \n    };  \n    \n\n**Important considerations:**\n\n  * Root access keys (application: \"clearnode\") cannot perform channel operations after expiration\n  * Plan expiration times based on your operational needs\n  * Application-scoped keys track cumulative spending against allowances\n\n#### Auth Verify Changesâ€‹\n\nThe `createEIP712AuthMessageSigner` function signature has changed to align with the new session key structure.\n    \n    \n    const eip712SigningFunction = createEIP712AuthMessageSigner(  \n        walletClient,  \n        {  \n            scope: authMessage.scope,  \n            application: authMessage.application,  \n            participant: authMessage.session_key,  \n            expire: authMessage.expire,  \n            session_key: authMessage.session_key,  \n            expires_at: authMessage.expires_at,  \n            allowances: authMessage.allowances,  \n        },  \n        getAuthDomain(),  \n    );  \n    \n\n#### Migrate Channel Creationâ€‹\n\nChannels must now be created with zero initial deposit and funded separately via the `resizeChannel` method:\n    \n    \n    const { channelId } = await client.createChannel({  \n      chain_id: 1,  \n      token: tokenAddress,  \n      amount: BigInt(1000000), // Initial deposit  \n      session_key: '0x...' // Optional  \n    });  \n      \n    // Step 2: Fund the channel separately  \n    await client.resizeChannel({  \n      channel_id: channelId,  \n      amount: BigInt(1000000),  \n    });  \n    \n\n#### Resize correctlyâ€‹\n\nChannel resizing must be negotiated with the ClearNode through WebSocket. Use `resize_amount` and `allocate_amount` with correct sign convention (`resize_amount = -allocate_amount`) and help users with non-zero channel balances migrate by resizing to zero or reopening channels.\n\nChannel resize can be requested as follows:\n    \n    \n    const resizeMessage = await createResizeChannelMessage(messageSigner, {  \n      channel_id: channelId,  \n      resize_amount: BigInt(50), // Positive = deposit to channel, negative = withdraw from channel to custody ledger  \n      allocate_amount: BigInt(-50), // Negative = deposit to unified balance, negative = withdraw from unified balance to channel  \n      funds_destination: walletAddress,  \n    });  \n      \n    const resizeResponse = {}; // send the message and wait for Clearnode's response  \n      \n    const { params: resizeResponseParams } = parseResizeChannelResponse(resizeResponse);  \n    const resizeParams = {  \n      resizeState: {  \n          channelId,  \n          ...resizeResponseParams.state,  \n          serverSignature: resizeResponseParams.serverSignature,  \n          data: resizeResponseParams.state.stateData as Hex,  \n          version: BigInt(resizeResponseParams.state.version),  \n      },  \n      // `previousState` is either initial or previous resizing state, depending on which has higher version number  \n      // can be obtained with `await (client.getChannelData(channelId)).lastValidState`  \n      proofStates: [previousState],  \n    }  \n      \n    const {txHash} = await client.resizeChannel(resizeParams);  \n    \n\nHere is how you can migrate your channels:\n    \n    \n    // Check and migrate channels with non-zero amounts  \n    const channels = await client.getOpenChannels();  \n      \n    for (const channel of channels) {  \n      if (channel.amount > 0) {  \n        // Must empty channel to enable transfers/app operations  \n        const resizeMessage = await createResizeChannelMessage(messageSigner, {  \n          channel_id: channel.channelId,  \n          resize_amount: BigInt(0),  \n          allocate_amount: -BigInt(channel.amount),  \n          funds_destination: walletAddress,  \n        });  \n          \n        // perform the resize as shown above  \n      }  \n    }  \n    \n\n**Critical:** Operations blocked when any channel has non-zero amount:\n\n  * Off-chain transfers\n  * App state submissions with deposit intent\n  * Creating app sessions with allocations\n\n#### Test State Signaturesâ€‹\n\nIf you plan to work with on-chain channels opened PRIOR to v0.5.0, then on NitroliteClient initialization the `stateSigner` you specify must be based on a Session Key used in the channel as participant. Even if this session key is or will expire, you still need to provide a `stateSigner` based on it.\n\nOn the other hand, if you plan to work with channels created SINCE v0.5.0, you can specify the `stateSigner` based on the `walletClient` you have specified.\n\n#### Manage Session Keysâ€‹\n\nNew methods have been added for comprehensive session key management, including retrieval and revocation.\n    \n    \n    // Get all active session keys  \n    const sessionKeys = await client.getSessionKeys();  \n      \n    // Revoke a specific session key  \n    await client.revokeSessionKey({  \n      session_key: '0x...'  \n    });  \n      \n    // Session key data structure  \n    interface RPCSessionKey {  \n      id: string;  \n      sessionKey: Address;  \n      application: string;  \n      allowances: RPCAllowanceUsage[]; // Includes usage tracking  \n      scope: string;  \n      expiresAt: bigint;  \n      createdAt: bigint;  \n    }  \n    \n\n#### EIP-712 Signatures: String-based Amountsâ€‹\n\nEIP-712 signature types now use string values for amounts instead of numeric types to support better precision with decimal values.\n    \n    \n    const types = {  \n      Allowance: [  \n        { name: 'asset', type: 'string' },  \n        { name: 'amount', type: 'uint256' },  \n        { name: 'amount', type: 'string' },  \n      ]  \n    };  \n    \n\n### ClearNode APIâ€‹\n\nYou should read this section only if you are using the ClearNode API directly.\n\n#### Update Authenticationâ€‹\n\nUse the new session key parameters with proper `application`, `allowances`, and `expires_at` fields:\n\n  * Application Auth\n  * Root Auth (Clearnode)\n    \n    \n    {  \n      \"req\": [1, \"auth_request\", {  \n        \"address\": \"0x1234567890abcdef...\",  \n        \"session_key\": \"0x9876543210fedcba...\",  \n        \"application\": \"My Trading App\",  \n        \"allowances\": [  \n          { \"asset\": \"usdc\", \"amount\": \"1000.0\" },  \n          { \"asset\": \"eth\", \"amount\": \"0.5\" }  \n        ],  \n        \"scope\": \"app.create\",  \n        \"expires_at\": 1719123456789  \n      }, 1619123456789],  \n      \"sig\": [\"0x...\"]  \n    }  \n    \n    \n    \n    {  \n      \"req\": [1, \"auth_request\", {  \n        \"address\": \"0x1234567890abcdef...\",  \n        \"session_key\": \"0x9876543210fedcba...\",  \n        \"application\": \"clearnode\",  \n        \"allowances\": [],  \n        \"scope\": \"app.create\",  \n        \"expires_at\": 1750659456789  \n      }, 1619123456789],  \n      \"sig\": [\"0x...\"]  \n    }  \n    \n\n#### Migrate Channel Creationâ€‹\n\nImplement the two-step process (create empty, then resize to fund)\n\nThe `create_channel` method no longer accepts `amount` and `session_key` parameters:\n    \n    \n    {  \n      \"req\": [1, \"create_channel\", {  \n        \"chain_id\": 137,  \n        \"token\": \"0xeeee567890abcdef...\",  \n        \"amount\": \"100000000\",  \n        \"session_key\": \"0x1234567890abcdef...\"  \n      }, 1619123456789],  \n      \"sig\": [\"0x9876fedcba...\"]  \n    }  \n    \n\n#### Manage Session Keysâ€‹\n\nNew methods for session key operations have been added.\n\n##### Get Session Keysâ€‹\n\nRequest:\n    \n    \n    {  \n      \"req\": [1, \"get_session_keys\", {}, 1619123456789],  \n      \"sig\": [\"0x...\"]  \n    }  \n    \n\nResponse:\n    \n    \n    {  \n      \"res\": [1, \"get_session_keys\", {  \n        \"session_keys\": [{  \n          \"id\": \"sk_123\",  \n          \"session_key\": \"0x9876543210fedcba...\",  \n          \"application\": \"My Trading App\",  \n          \"allowances\": [  \n            { \"asset\": \"usdc\", \"amount\": \"1000.0\", \"used\": \"250.0\" }  \n          ],  \n          \"scope\": \"app.create\",  \n          \"expires_at\": 1719123456789,  \n          \"created_at\": 1619123456789  \n        }]  \n      }, 1619123456789],  \n      \"sig\": [\"0x...\"]  \n    }  \n    \n\n##### Revoke Session Key Requestâ€‹\n\nRequest:\n    \n    \n    {  \n      \"req\": [1, \"revoke_session_key\", {  \n        \"session_key\": \"0x1234567890abcdef...\"  \n      }, 1619123456789],  \n      \"sig\": [\"0x...\"]  \n    }  \n    \n\nResponse:\n    \n    \n    {  \n      \"res\": [1, \"revoke_session_key\", {  \n        \"session_key\": \"0x1234567890abcdef...\"  \n      }, 1619123456789],  \n      \"sig\": [\"0x...\"]  \n    }  \n    \n\n## 0.3.x Breaking changesâ€‹\n\nThe 0.3.x release includes breaking changes to the SDK architecture, smart contract interfaces, and Clearnode API enhancements listed below.\n\n**Not ready to migrate?** Unfortunately, at this time Yellow Network does not provide ClearNodes running the previous version of the protocol, so you will need to migrate to the latest version to continue using the Network.\n\n### Nitrolite SDKâ€‹\n\nYou should definitely read this section if you are using the Nitrolite SDK.\n\n#### Client: Replaced `stateWalletClient` with `StateSigner`â€‹\n\nThe `stateWalletClient` parameter of `NitroliteClient` has been replaced with a required `stateSigner` parameter that implements the `StateSigner` interface.\n\nWhen initializing the client, you should use either `WalletStateSigner` or `SessionKeyStateSigner` to handle state signing.\n    \n    \n    import { createNitroliteClient } from '@erc7824/nitrolite';  \n    import {   \n      createNitroliteClient,  \n      WalletStateSigner  \n    } from '@erc7824/nitrolite';  \n      \n    const client = createNitroliteClient({  \n      publicClient,  \n      walletClient,  \n      stateWalletClient: sessionWalletClient,  \n      stateSigner: new WalletStateSigner(walletClient),  \n      addresses,  \n    });  \n    \n\n**For session key signing:**\n    \n    \n    import { SessionKeyStateSigner } from '@erc7824/nitrolite';  \n      \n    const stateSigner = new SessionKeyStateSigner('0x...' as Hex);  \n    \n\n#### Actions: Modified `createChannel` Parametersâ€‹\n\nThe `CreateChannelParams` interface has been fully restructured for better clarity.\n\nYou should use the new `CreateChannel` ClearNode API endpoint to get the response, that fully resembles the channel creation parameters.\n    \n    \n    const { channelId, initialState, txHash } = await client.createChannel(  \n      tokenAddress,  \n      {  \n        initialAllocationAmounts: [amount1, amount2],  \n        stateData: '0x...',  \n      }  \n    );  \n    const { channelId, initialState, txHash } = await client.createChannel({  \n      channel: {  \n        participants: [address1, address2],  \n        adjudicator: adjudicatorAddress,  \n        challenge: 86400n,  \n        nonce: 42n,  \n      },  \n      unsignedInitialState: {  \n        intent: StateIntent.Initialize,  \n        version: 0n,  \n        data: '0x',  \n        allocations: [  \n          { destination: address1, token: tokenAddress, amount: amount1 },  \n          { destination: address2, token: tokenAddress, amount: amount2 },  \n        ],  \n      },  \n      serverSignature: '0x...',  \n    });  \n    \n\n#### Actions: Structured Typed RPC Request Parametersâ€‹\n\nRPC requests now use endpoint-specific object-based parameters instead of untyped arrays for improved type safety.\n\nYou should update your RPC request creation code to use the new structured format and RPC types.\n    \n    \n    const request = NitroliteRPC.createRequest(  \n      requestId,  \n      RPCMethod.GetChannels,  \n      [participant, status],  \n      timestamp  \n    );  \n    const request = NitroliteRPC.createRequest({  \n      method: RPCMethod.GetChannels,  \n      params: {  \n        participant,  \n        status,  \n      },  \n      requestId,  \n      timestamp,  \n    });  \n    \n\n#### Actions: Standardized Channel Operations Responsesâ€‹\n\nThe responses for `CloseChannel` and `ResizeChannel` methods have been aligned with newly added `CreateChannel` endpoint for consistency.\n\nUpdate your response handling code to use the new `RPCChannelOperation` type.\n    \n    \n    export interface ResizeChannelResponseParams {  \n      channelId: Hex;  \n      stateData: Hex;  \n      intent: number;  \n      version: number;  \n      allocations: RPCAllocation[];  \n      stateHash: Hex;  \n      serverSignature: ServerSignature;  \n    }  \n      \n    export interface CloseChannelResponseParams {  \n      channelId: Hex;  \n      intent: number;  \n      version: number;  \n      stateData: Hex;  \n      allocations: RPCAllocation[];  \n      stateHash: Hex;  \n      serverSignature: ServerSignature;  \n    }  \n    export interface RPCChannelOperation {  \n      channelId: Hex;  \n      state: RPCChannelOperationState;  \n      serverSignature: Hex;  \n    }  \n      \n    export interface CreateChannelResponse extends GenericRPCMessage {  \n      method: RPCMethod.CreateChannel;  \n      params: RPCChannelOperation & {  \n        channel: RPCChannel;  \n      };  \n    }  \n      \n    export interface ResizeChannelResponse extends GenericRPCMessage {  \n      method: RPCMethod.ResizeChannel;  \n      params: RPCChannelOperation;  \n    }  \n      \n    export interface CloseChannelResponse extends GenericRPCMessage {  \n      method: RPCMethod.CloseChannel;  \n      params: RPCChannelOperation;  \n    }  \n    \n\n#### Actions: Modified `Signature` Typeâ€‹\n\nThe `Signature` struct has been replaced with a simple `Hex` type to support EIP-1271 and EIP-6492 signatures.\n\nUpdate your signature-handling code to use the new `Hex` type. Still, if using Nitrolite utils correctly, you will not need to change anything, as the utils will handle the conversion for you.\n    \n    \n    interface Signature {  \n      v: number;  \n      r: Hex;  \n      s: Hex;  \n    }  \n      \n    const sig: Signature = {  \n      v: 27,  \n      r: '0x...',  \n      s: '0x...'  \n    };  \n    type Signature = Hex;  \n      \n    const sig: Signature = '0x...';  \n    \n\n#### Added: Pagination Types and Parametersâ€‹\n\nTo support pagination in ClearNode API requests, new types and parameters have been added.\n\nFor now, only `GetLedgerTransactions` request has been updated to include pagination.\n    \n    \n    export interface PaginationFilters {  \n        /** Pagination offset. */  \n        offset?: number;  \n        /** Number of transactions to return. */  \n        limit?: number;  \n        /** Sort order by created_at. */  \n        sort?: 'asc' | 'desc';  \n    }  \n    \n\n### Clearnode APIâ€‹\n\nYou should read this section only if you are using the ClearNode API directly, or if you are using the Nitrolite SDK with custom ClearNode API requests.\n\n#### Actions: Structured Request Parametersâ€‹\n\nClearNode API requests have migrated from array-based parameters to structured object parameters for improved type safety and API clarity.\n\nUpdate all your ClearNode API requests to use object-based parameters instead of arrays.\n    \n    \n    {  \n      \"req\": [1, \"auth_request\", [{  \n      \"req\": [1, \"auth_request\", {  \n        \"address\": \"0x1234567890abcdef...\",  \n        \"session_key\": \"0x9876543210fedcba...\",  \n        \"app_name\": \"Example App\",  \n        \"allowances\": [ \"usdc\", \"100.0\" ],  \n        \"allowances\": [  \n          {  \n            \"asset\": \"usdc\",  \n            \"amount\": \"100.0\"  \n          }  \n        ],  \n        \"scope\": \"app.create\",  \n        \"expire\": \"3600\",  \n        \"application\": \"0xApp1234567890abcdef...\"  \n      }], 1619123456789],  \n      }, 1619123456789],  \n      \"sig\": [\"0x5432abcdef...\"]  \n    }  \n    \n\n#### Added: `create_channel` Methodâ€‹\n\nA new `create_channel` method has been added to facilitate the improved single-transaction channel opening flow.\n\nUse this method to request channel creation parameters from the broker, then submit the returned data to the smart contract via Nitrolite SDK or directly.\n\n**Request:**\n    \n    \n    {  \n      \"req\": [1, \"create_channel\", {  \n        \"chain_id\": 137,  \n        \"token\": \"0xeeee567890abcdef...\",  \n        \"amount\": \"100000000\",  \n        \"session_key\": \"0x1234567890abcdef...\" // Optional  \n      }, 1619123456789],  \n      \"sig\": [\"0x9876fedcba...\"]  \n    }  \n    \n\n**Response:**\n    \n    \n    {  \n      \"res\": [1, \"create_channel\", {  \n        \"channel_id\": \"0x4567890123abcdef...\",  \n        \"channel\": {  \n          \"participants\": [\"0x1234567890abcdef...\", \"0xbbbb567890abcdef...\"],  \n          \"adjudicator\": \"0xAdjudicatorContractAddress...\",  \n          \"challenge\": 3600,  \n          \"nonce\": 1619123456789  \n        },  \n        \"state\": {  \n          \"intent\": 1,  \n          \"version\": 0,  \n          \"state_data\": \"0xc0ffee\",  \n          \"allocations\": [  \n            {  \n              \"destination\": \"0x1234567890abcdef...\",  \n              \"token\": \"0xeeee567890abcdef...\",  \n              \"amount\": \"100000000\"  \n            },  \n            {  \n              \"destination\": \"0xbbbb567890abcdef...\",  \n              \"token\": \"0xeeee567890abcdef...\",  \n              \"amount\": \"0\"  \n            }  \n          ]  \n        },  \n        \"server_signature\": \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1c\"  \n      }, 1619123456789],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    \n\n#### API: Standardized Channel Operation Responsesâ€‹\n\nThe responses for `create_channel`, `close_channel`, and `resize_channel` methods have been unified for consistency.\n\nUpdate your response parsing to handle the new unified structure with `channel_id`, `state`, and `server_signature` fields.\n    \n    \n    {  \n      \"res\": [1, \"close_channel\", {  \n        \"channelId\": \"0x4567890123abcdef...\",  \n        \"intent\": 3,  \n        \"version\": 123,  \n        \"stateData\": \"0x0000000000000000000000000000000000000000000000000000000000001ec7\",  \n        \"allocations\": [...],  \n        \"stateHash\": \"0x...\",  \n        \"serverSignature\": \"0x...\"  \n      }, 1619123456789],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    {  \n      \"res\": [1, \"close_channel\", {  \n        \"channel_id\": \"0x4567890123abcdef...\",  \n        \"state\": {  \n          \"intent\": 3,  \n          \"version\": 123,  \n          \"state_data\": \"0xc0ffee\",  \n          \"allocations\": [  \n            {  \n              \"destination\": \"0x1234567890abcdef...\",  \n              \"token\": \"0xeeee567890abcdef...\",  \n              \"amount\": \"50000\"  \n            }  \n          ]  \n        },  \n        \"server_signature\": \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1c\"  \n      }, 1619123456789],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    \n\n#### Added: Pagination Metadataâ€‹\n\nPagination-supporting endpoints now include a `metadata` struct in their responses with pagination information.\n\nUpdate your response handling for `get_channels`, `get_app_sessions`, `get_ledger_entries`, and `get_ledger_transactions` to use the new metadata structure.\n    \n    \n    {  \n      \"res\": [1, \"get_channels\", [  \n        [  \n          {  \n            \"channel_id\": \"0xfedcba9876543210...\",  \n            \"status\": \"open\",  \n            // ... channel data  \n          }  \n        ]  \n      ], 1619123456789],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    {  \n      \"res\": [1, \"get_channels\", {  \n        \"channels\": [  \n          {  \n            \"channel_id\": \"0xfedcba9876543210...\",  \n            \"status\": \"open\",  \n            // ... channel data  \n          }  \n        ],  \n        \"metadata\": {  \n          \"page\": 1,  \n          \"per_page\": 10,  \n          \"total_count\": 56,  \n          \"page_count\": 6  \n        }  \n      }, 1619123456789],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    \n\nThe metadata fields provide:\n\n  * `page`: Current page number\n  * `per_page`: Number of items per page\n  * `total_count`: Total number of items available\n  * `page_count`: Total number of pages\n\n### Contractsâ€‹\n\nYou should read this section only if you are using the Nitrolite smart contracts directly.\n\n#### Action: Replaced `Signature` Struct with `bytes`â€‹\n\nThe `Signature` struct has been removed and replaced with `bytes` type to support EIP-1271, EIP-6492, and other signature formats.\n\nUpdate all contract interactions that use signatures to pass `bytes` instead of the struct.\n    \n    \n    struct Signature {  \n      uint8 v;  \n      bytes32 r;  \n      bytes32 s;  \n    }  \n      \n    function join(  \n      bytes32 channelId,  \n      uint256 index,  \n      Signature calldata sig  \n    ) external returns (bytes32);  \n      \n    function challenge(  \n      bytes32 channelId,  \n      State calldata candidate,  \n      State[] calldata proofs,  \n      Signature calldata challengerSig  \n    ) external;  \n    // Signature struct is removed  \n      \n    function join(  \n      bytes32 channelId,  \n      uint256 index,  \n      bytes calldata sig  \n    ) external returns (bytes32);  \n      \n    function challenge(  \n      bytes32 channelId,  \n      State calldata candidate,  \n      State[] calldata proofs,  \n      bytes calldata challengerSig  \n    ) external;  \n    \n\n#### Actions: Updated `State` Signature Arrayâ€‹\n\nThe `State` struct now uses `bytes[]` for signatures instead of `Signature[]`.\n    \n    \n    struct State {  \n      uint8 intent;  \n      uint256 version;  \n      bytes data;  \n      Allocation[] allocations;  \n      Signature[] sigs;  \n      bytes[] sigs;  \n    }  \n    \n\n#### Added: Auto-Join Channel Creation Flowâ€‹\n\nChannels can now become operational immediately after the `create()` call if all participant signatures are provided.\n\nWhen calling `create()` with complete signatures from all participants, the channel automatically becomes active without requiring a separate `join()` call.\n\n**Single signature (requires join):**\n    \n    \n    // Create channel with only creator's signature  \n    State memory initialState = State({  \n        intent: StateIntent.Fund,  \n        version: 0,  \n        data: \"0x\",  \n        allocations: allocations,  \n        sigs: [creatorSignature] // Only one signature  \n    });  \n      \n    bytes32 channelId = custody.create(channel, initialState);  \n    // Channel status: JOINING - requires server to call join()  \n    \n\n**Complete signatures (auto-active):**\n    \n    \n    // Create channel with all participants' signatures  \n    State memory initialState = State({  \n        intent: StateIntent.Fund,  \n        version: 0,  \n        data: \"0x\",  \n        allocations: allocations,  \n        sigs: [creatorSignature, serverSignature] // All signatures  \n    });  \n      \n    bytes32 channelId = custody.create(channel, initialState);  \n    // Channel status: ACTIVE - ready for use immediately  \n    \n\n#### Actions: Update Adjudicator Contracts for EIP-712 Supportâ€‹\n\nA new `EIP712AdjudicatorBase` base contract has been added to support EIP-712 typed structured data signatures in adjudicator implementations.\n\nThe `EIP712AdjudicatorBase` provides:\n\n  * **Domain separator retrieval** : Gets EIP-712 domain separator from the channel implementation contract\n  * **ERC-5267 compliance** : Automatically handles EIP-712 domain data retrieval\n  * **Ownership management** : Built-in access control for updating channel implementation address\n  * **Graceful fallbacks** : Returns `NO_EIP712_SUPPORT` constant when EIP-712 is not available\n\nIf you have custom adjudicator contracts, inherit from `EIP712AdjudicatorBase` to enable EIP-712 signature verification.\n    \n    \n    import {IAdjudicator} from \"../interfaces/IAdjudicator.sol\";  \n    import {Channel, State, Allocation, StateIntent} from \"../interfaces/Types.sol\";  \n      \n    contract MyAdjudicator is IAdjudicator {  \n        function adjudicate(  \n            Channel calldata chan,   \n            State calldata candidate,   \n            State[] calldata proofs  \n        ) external view override returns (bool valid) {  \n            return candidate.validateUnanimousSignatures(chan);  \n        }  \n    }  \n    import {IAdjudicator} from \"../interfaces/IAdjudicator.sol\";  \n    import {Channel, State, Allocation, StateIntent} from \"../interfaces/Types.sol\";  \n    import {EIP712AdjudicatorBase} from \"./EIP712AdjudicatorBase.sol\";  \n      \n    contract MyAdjudicator is IAdjudicator, EIP712AdjudicatorBase {  \n        constructor(address owner, address channelImpl)   \n            EIP712AdjudicatorBase(owner, channelImpl) {}  \n      \n        function adjudicate(  \n            Channel calldata chan,   \n            State calldata candidate,   \n            State[] calldata proofs  \n        ) external override returns (bool valid) {  \n            bytes32 domainSeparator = getChannelImplDomainSeparator();  \n            return candidate.validateUnanimousStateSignatures(chan, domainSeparator);  \n        }  \n    }  \n    \n\n#### Added: Enhanced Signature Supportâ€‹\n\nSmart contracts now support EIP-191, EIP-712, EIP-1271, and EIP-6492 signature formats for greater compatibility.\n\nThe contracts automatically detect and verify the appropriate signature format:\n\n  * **Raw ECDSA** : Traditional `(r, s, v)` signatures\n  * **EIP-191** : Personal message signatures (`\\x19Ethereum Signed Message:\\n`)\n  * **EIP-712** : Typed structured data signatures\n  * **EIP-1271** : Smart contract wallet signatures\n  * **EIP-6492** : Signatures for undeployed contracts\n\nNo changes are needed in your contract calls - the signature verification is handled automatically by the contract.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guides/migration-guide.md)\n\n[PreviousGuides](/docs/guides/)[NextMulti-Party Application Sessions](/docs/guides/multi-party-app-sessions)\n\n  * 0.5.x Breaking changes\n    * Protocol Changes\n    * Nitrolite SDK\n    * ClearNode API\n  * 0.3.x Breaking changes\n    * Nitrolite SDK\n    * Clearnode API\n    * Contracts",
    "metadata": {
      "title": "Migration Guide | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/migration-guide",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
    "text": "* [](/)\n  * Multi-Party Application Sessions\n\nOn this page\n\n# Multi-Party Application Sessions Tutorial\n\n## Overviewâ€‹\n\nApplication sessions in Nitrolite enable multiple participants to interact within a shared off-chain state channel. This is particularly powerful for use cases requiring coordinated actions between parties without on-chain overhead.\n\nThis tutorial demonstrates how to create, manage, and close a multi-party application session using the Yellow Network and Nitrolite protocol.\n\nRun the Full Example\n\nThe complete runnable script for this tutorial is available at: [`scripts/app_sessions/app_session_two_signers.ts`](https://github.com/stevenzeiler/yellow-sdk-tutorials/blob/main/scripts/app_sessions/app_session_two_signers.ts)\n    \n    \n    npx tsx scripts/app_sessions/app_session_two_signers.ts  \n    \n\n## What is an Application Session?â€‹\n\nAn **application session** is a multi-party state channel that allows participants to:\n\n  * **Execute off-chain logic** without blockchain transactions\n  * **Update shared state** with cryptographic signatures\n  * **Transfer value** between participants instantly\n\nUnlike simple payment channels (1-to-1), application sessions support:\n\n  * Multiple participants (2+)\n  * Complex state logic\n  * Voting mechanisms (weights and quorum)\n  * Flexible allocation rules\n\n## Prerequisitesâ€‹\n\n### Environment Setupâ€‹\n\nYou'll need two wallet seed phrases in your `.env` file:\n    \n    \n    WALLET_1_SEED_PHRASE=\"first wallet 12 or 24 word mnemonic here\"  \n    WALLET_2_SEED_PHRASE=\"second wallet 12 or 24 word mnemonic here\"  \n    \n\n### Funded Walletsâ€‹\n\nBoth wallets should have:\n\n  1. **Funds in Yellow ledger** (deposited via custody contract)\n\n### Install Dependenciesâ€‹\n    \n    \n    npm install  \n    \n\n* * *\n\n## Key Conceptsâ€‹\n\n### 1\\. App Definitionâ€‹\n\nThe application definition specifies the rules of the session:\n    \n    \n    const appDefinition: RPCAppDefinition = {  \n        protocol: RPCProtocolVersion.NitroRPC_0_5,  \n        participants: [address1, address2],  \n        weights: [50, 50],        // Voting power distribution  \n        quorum: 100,              // Percentage needed for decisions (100 = unanimous)  \n        challenge: 0,             // Challenge period in seconds  \n        nonce: Date.now(),        // Unique session ID  \n        application: 'Test app',  \n    };  \n    \n\n**Key parameters:**\n\nParameter| Description  \n---|---  \n`participants`| Array of wallet addresses involved  \n`weights`| Voting power for each participant (must sum to 100 or appropriate total)  \n`quorum`| Required percentage of votes for actions (50 = majority, 100 = unanimous)  \n`challenge`| Time window for disputing state changes  \n`nonce`| Unique identifier to prevent replay attacks  \n  \n### 2\\. Allocationsâ€‹\n\nAllocations define how assets are distributed among participants:\n\n  * Sandbox\n  * Production\n    \n    \n    const allocations: RPCAppSessionAllocation[] = [  \n        { participant: address1, asset: 'ytest.usd', amount: '0.01' },  \n        { participant: address2, asset: 'ytest.usd', amount: '0.00' }  \n    ];  \n    \n    \n    \n    const allocations: RPCAppSessionAllocation[] = [  \n        { participant: address1, asset: 'usdc', amount: '0.01' },  \n        { participant: address2, asset: 'usdc', amount: '0.00' }  \n    ];  \n    \n\n**Rules:**\n\n  * Total allocations cannot exceed session funding\n  * Amounts are strings (to maintain precision)\n  * Must account for all participants\n\n### 3\\. Multi-Party Signaturesâ€‹\n\nFor actions requiring consensus (closing, etc.), signatures from multiple participants are collected:\n    \n    \n    // First participant signs  \n    const closeMessage = await createCloseAppSessionMessage(  \n        messageSigner1,  \n        { app_session_id: sessionId, allocations: finalAllocations }  \n    );  \n      \n    // Second participant signs  \n    const signature2 = await messageSigner2(closeMessage.req);  \n      \n    // Add second signature  \n    closeMessage.sig.push(signature2);  \n      \n    // Submit with all signatures  \n    await yellow.sendMessage(JSON.stringify(closeMessage));  \n    \n\n* * *\n\n## Step-by-Step Walkthroughâ€‹\n\n### Step 1: Connect to Yellow Networkâ€‹\n\n  * Sandbox\n  * Production\n    \n    \n    const yellow = new Client({  \n        url: 'wss://clearnet-sandbox.yellow.com/ws',  \n    });  \n      \n    await yellow.connect();  \n    console.log('Connected to Yellow clearnet (Sandbox)');  \n    \n    \n    \n    const yellow = new Client({  \n        url: 'wss://clearnet.yellow.com/ws',  \n    });  \n      \n    await yellow.connect();  \n    console.log('Connected to Yellow clearnet (Production)');  \n    \n\n### Step 2: Set Up Participant Walletsâ€‹\n    \n    \n    // Create wallet clients for both participants  \n    const wallet1Client = createWalletClient({  \n        account: mnemonicToAccount(process.env.WALLET_1_SEED_PHRASE as string),  \n        chain: base,  \n        transport: http(),  \n    });  \n      \n    const wallet2Client = createWalletClient({  \n        account: mnemonicToAccount(process.env.WALLET_2_SEED_PHRASE as string),  \n        chain: base,  \n        transport: http(),  \n    });  \n    \n\n### Step 3: Authenticate Both Participantsâ€‹\n\nEach participant needs their own session key:\n    \n    \n    // Authenticate first participant  \n    const sessionKey1 = await authenticateWallet(yellow, wallet1Client);  \n    const messageSigner1 = createECDSAMessageSigner(sessionKey1.privateKey);  \n      \n    // Authenticate second participant  \n    const sessionKey2 = await authenticateWallet(yellow, wallet2Client);  \n    const messageSigner2 = createECDSAMessageSigner(sessionKey2.privateKey);  \n    \n\n### Step 4: Define Application Configurationâ€‹\n    \n    \n    const appDefinition: RPCAppDefinition = {  \n        protocol: RPCProtocolVersion.NitroRPC_0_5,  \n        participants: [wallet1Client.account.address, wallet2Client.account.address],  \n        weights: [50, 50],  \n        quorum: 100,  \n        challenge: 0,  \n        nonce: Date.now(),  \n        application: 'Test app',  \n    };  \n    \n\n### Step 5: Create Session with Initial Allocationsâ€‹\n\n  * Sandbox\n  * Production\n    \n    \n    const allocations = [  \n        { participant: wallet1Client.account.address, asset: 'ytest.usd', amount: '0.01' },  \n        { participant: wallet2Client.account.address, asset: 'ytest.usd', amount: '0.00' }  \n    ];  \n      \n    const sessionMessage = await createAppSessionMessage(  \n        messageSigner1,  \n        { definition: appDefinition, allocations }  \n    );  \n      \n    const sessionResponse = await yellow.sendMessage(sessionMessage);  \n    const sessionId = sessionResponse.params.appSessionId;  \n    \n    \n    \n    const allocations = [  \n        { participant: wallet1Client.account.address, asset: 'usdc', amount: '0.01' },  \n        { participant: wallet2Client.account.address, asset: 'usdc', amount: '0.00' }  \n    ];  \n      \n    const sessionMessage = await createAppSessionMessage(  \n        messageSigner1,  \n        { definition: appDefinition, allocations }  \n    );  \n      \n    const sessionResponse = await yellow.sendMessage(sessionMessage);  \n    const sessionId = sessionResponse.params.appSessionId;  \n    \n\n### Step 6: Update Session Stateâ€‹\n\nYou can update allocations to reflect state changes (e.g., a transfer). Since the quorum is 100%, both participants must sign:\n\n  * Sandbox\n  * Production\n    \n    \n    const newAllocations = [  \n        { participant: wallet1Client.account.address, asset: 'ytest.usd', amount: '0.00' },  \n        { participant: wallet2Client.account.address, asset: 'ytest.usd', amount: '0.01' }  \n    ];  \n      \n    // Create update message signed by first participant  \n    const updateMessage = await createSubmitAppStateMessage(  \n        messageSigner1,  \n        { app_session_id: sessionId, allocations: newAllocations }  \n    );  \n      \n    const updateMessageJson = JSON.parse(updateMessage);  \n      \n    // Second participant signs the same state update  \n    const signature2 = await messageSigner2(updateMessageJson.req as RPCData);  \n      \n    // Append second signature to meet quorum requirement  \n    updateMessageJson.sig.push(signature2);  \n      \n    // Submit with all required signatures  \n    await yellow.sendMessage(JSON.stringify(updateMessageJson));  \n    \n    \n    \n    const newAllocations = [  \n        { participant: wallet1Client.account.address, asset: 'usdc', amount: '0.00' },  \n        { participant: wallet2Client.account.address, asset: 'usdc', amount: '0.01' }  \n    ];  \n      \n    // Create update message signed by first participant  \n    const updateMessage = await createSubmitAppStateMessage(  \n        messageSigner1,  \n        { app_session_id: sessionId, allocations: newAllocations }  \n    );  \n      \n    const updateMessageJson = JSON.parse(updateMessage);  \n      \n    // Second participant signs the same state update  \n    const signature2 = await messageSigner2(updateMessageJson.req as RPCData);  \n      \n    // Append second signature to meet quorum requirement  \n    updateMessageJson.sig.push(signature2);  \n      \n    // Submit with all required signatures  \n    await yellow.sendMessage(JSON.stringify(updateMessageJson));  \n    \n\n### Step 7: Close Session with Multi-Party Signaturesâ€‹\n    \n    \n    // Create close message (signed by participant 1)  \n    const closeMessage = await createCloseAppSessionMessage(  \n        messageSigner1,  \n        { app_session_id: sessionId, allocations: finalAllocations }  \n    );  \n      \n    const closeMessageJson = JSON.parse(closeMessage);  \n      \n    // Participant 2 signs  \n    const signature2 = await messageSigner2(closeMessageJson.req as RPCData);  \n    closeMessageJson.sig.push(signature2);  \n      \n    // Submit with all signatures  \n    const closeResponse = await yellow.sendMessage(JSON.stringify(closeMessageJson));  \n    \n\n* * *\n\n## Running the Exampleâ€‹\n    \n    \n    npx tsx scripts/app_session_two_signers.ts  \n    \n\n### Expected Outputâ€‹\n    \n    \n    Connected to Yellow clearnet  \n    Wallet address: 0x1234...  \n    Wallet address: 0x5678...  \n    Session message created: {...}  \n    Session message sent  \n    Session response: { appSessionId: '0xabc...' }  \n    Submit app state message: {...}  \n    Wallet 2 signed close session message: 0xdef...  \n    Close session message (with all signatures): {...}  \n    Close session message sent  \n    Close session response: { success: true }  \n    \n\n* * *\n\n## Use Casesâ€‹\n\nAsset Names in Examples\n\nThe examples below use `usdc` for production scenarios. When testing on Sandbox, replace `usdc` with `ytest.usd`.\n\n### 1\\. Peer-to-Peer Escrowâ€‹\n    \n    \n    // Buyer and seller agree on terms  \n    const appDefinition = {  \n        participants: [buyer, seller],  \n        weights: [50, 50],  \n        quorum: 100,  // Both must agree to release funds  \n        // ...  \n    };  \n      \n    // Buyer funds escrow  \n    const allocations = [  \n        { participant: buyer, asset: 'usdc', amount: '0' },  \n        { participant: seller, asset: 'usdc', amount: '100' }  // Released to seller  \n    ];  \n    \n\n### 2\\. Multi-Player Gamingâ€‹\n    \n    \n    const appDefinition = {  \n        participants: [player1, player2, player3, player4],  \n        weights: [25, 25, 25, 25],  \n        quorum: 75,  // 3 out of 4 players must agree  \n        challenge: 3600,  // 1 hour challenge period  \n        application: 'poker-game',  \n    };  \n    \n\n### 3\\. DAO Treasury Managementâ€‹\n    \n    \n    const appDefinition = {  \n        participants: [member1, member2, member3, member4, member5],  \n        weights: [20, 20, 20, 20, 20],  \n        quorum: 60,  // 60% approval needed  \n        application: 'dao-treasury',  \n    };  \n    \n\n### 4\\. Atomic Swapsâ€‹\n    \n    \n    // Party A has USDC, wants ETH  \n    // Party B has ETH, wants USDC  \n    const allocations = [  \n        { participant: partyA, asset: 'usdc', amount: '100' },  \n        { participant: partyA, asset: 'eth', amount: '0' },  \n        { participant: partyB, asset: 'usdc', amount: '0' },  \n        { participant: partyB, asset: 'eth', amount: '0.05' }  \n    ];  \n      \n    // After swap  \n    const finalAllocations = [  \n        { participant: partyA, asset: 'usdc', amount: '0' },  \n        { participant: partyA, asset: 'eth', amount: '0.05' },  \n        { participant: partyB, asset: 'usdc', amount: '100' },  \n        { participant: partyB, asset: 'eth', amount: '0' }  \n    ];  \n    \n\n* * *\n\n## Advanced Topicsâ€‹\n\n### Dynamic Participantsâ€‹\n\nFor applications requiring flexible participation:\n    \n    \n    // Start with 2 participants  \n    let participants = [user1, user2];  \n      \n    // Add a third participant (requires re-creating session)  \n    participants.push(user3);  \n      \n    const newAppDefinition = {  \n        participants,  \n        weights: [33, 33, 34],  \n        // ...  \n    };  \n    \n\n### Weighted Votingâ€‹\n\nDifferent participants can have different voting power:\n    \n    \n    const appDefinition = {  \n        participants: [founder, investor1, investor2],  \n        weights: [50, 30, 20],  // Founder has 50% voting power  \n        quorum: 60,  // Founder + one investor = 60%  \n        // ...  \n    };  \n    \n\n### Challenge Periodsâ€‹\n\nAdd time for participants to dispute state changes:\n    \n    \n    const appDefinition = {  \n        // ...  \n        challenge: 86400,  // 24 hours in seconds  \n    };  \n      \n    // Participants have 24 hours to challenge a close request before finalization  \n    \n\n### State Validationâ€‹\n\nImplement custom logic to validate state transitions:\n    \n    \n    function validateStateTransition(  \n        oldAllocations: RPCAppSessionAllocation[],  \n        newAllocations: RPCAppSessionAllocation[]  \n    ): boolean {  \n        // Ensure total amounts are preserved  \n        const oldTotal = oldAllocations.reduce((sum, a) => sum + parseFloat(a.amount), 0);  \n        const newTotal = newAllocations.reduce((sum, a) => sum + parseFloat(a.amount), 0);  \n          \n        return Math.abs(oldTotal - newTotal) < 0.000001;  \n    }  \n    \n\n* * *\n\n## Troubleshootingâ€‹\n\n### \"Authentication failed for participant\"â€‹\n\n**Cause** : Session key authentication failed\n\n**Solution** :\n\n  * Ensure both `WALLET_1_SEED_PHRASE` and `WALLET_2_SEED_PHRASE` are set in `.env`\n  * Verify wallets have been authenticated on Yellow network before\n\n### \"Unsupported token\"â€‹\n\n**Cause** : Using the wrong asset for your environment (e.g., `usdc` on Sandbox or `ytest.usd` on Production)\n\n**Solution** :\n\n  * **Sandbox** (`wss://clearnet-sandbox.yellow.com/ws`): Use `ytest.usd`\n  * **Production** (`wss://clearnet.yellow.com/ws`): Use `usdc`\n\nEnsure the asset in your allocations matches the connected network.\n\n### \"Insufficient balance\"â€‹\n\n**Cause** : Participant doesn't have enough funds in Yellow ledger\n\n**Solution** :\n\nDeposit sufficient funds into the yellow network account unified balance for each wallet\n\n### \"Invalid signatures\"â€‹\n\n**Cause** : Not all required signatures were collected\n\n**Solution** :\n\n  * Ensure quorum is met (if quorum is 100, need all signatures)\n  * Check that signatures are added in correct order\n  * Verify message signers correspond to participants\n\n### \"Session already closed\"â€‹\n\n**Cause** : Trying to update or close an already-finalized session\n\n**Solution** :\n\n  * Create a new session\n  * Check session status before operations\n\n### \"Quorum not reached\"â€‹\n\n**Cause** : Insufficient voting weight for action\n\n**Solution** :\n    \n    \n    // Example: quorum is 60, weights are [30, 30, 40]  \n    // Need at least 2 participants to sign  \n      \n    // Check current signature weight  \n    const signatureWeight = signatures.reduce((sum, sig) => {  \n        const participantIndex = findParticipantIndex(sig);  \n        return sum + weights[participantIndex];  \n    }, 0);  \n      \n    console.log(`Current weight: ${signatureWeight}, Required: ${quorum}`);  \n    \n\n* * *\n\n## Best Practicesâ€‹\n\n  1. **Always validate allocations** before submitting state updates\n  2. **Store session IDs** for future reference and auditing\n  3. **Implement timeout handling** for multi-party signatures\n  4. **Use appropriate quorum settings** based on trust model\n  5. **Test with small amounts** before production use\n  6. **Keep participants informed** of state changes\n  7. **Handle disconnections gracefully** (participants may come back)\n  8. **Document application logic** for all participants\n\n* * *\n\n## Further Readingâ€‹\n\n  * [App Sessions Core Concepts](/docs/learn/core-concepts/app-sessions) â€” Understanding app sessions\n  * [App Session Methods](/docs/protocol/off-chain/app-sessions) â€” Complete API reference\n  * [Client-Side App Session Signing Guide](/docs/guides/client-side-app-session-signing) â€” Signing implementation details\n  * [Session Keys](/docs/learn/core-concepts/session-keys) â€” Managing session keys\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guides/multi-party-app-sessions.mdx)\n\n[PreviousMigration Guide](/docs/guides/migration-guide)\n\n  * Overview\n  * What is an Application Session?\n  * Prerequisites\n    * Environment Setup\n    * Funded Wallets\n    * Install Dependencies\n  * Key Concepts\n    * 1\\. App Definition\n    * 2\\. Allocations\n    * 3\\. Multi-Party Signatures\n  * Step-by-Step Walkthrough\n    * Step 1: Connect to Yellow Network\n    * Step 2: Set Up Participant Wallets\n    * Step 3: Authenticate Both Participants\n    * Step 4: Define Application Configuration\n    * Step 5: Create Session with Initial Allocations\n    * Step 6: Update Session State\n    * Step 7: Close Session with Multi-Party Signatures\n  * Running the Example\n    * Expected Output\n  * Use Cases\n    * 1\\. Peer-to-Peer Escrow\n    * 2\\. Multi-Player Gaming\n    * 3\\. DAO Treasury Management\n    * 4\\. Atomic Swaps\n  * Advanced Topics\n    * Dynamic Participants\n    * Weighted Voting\n    * Challenge Periods\n    * State Validation\n  * Troubleshooting\n    * \"Authentication failed for participant\"\n    * \"Unsupported token\"\n    * \"Insufficient balance\"\n    * \"Invalid signatures\"\n    * \"Session already closed\"\n    * \"Quorum not reached\"\n  * Best Practices\n  * Further Reading",
    "metadata": {
      "title": "Multi-Party Application Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/learn",
    "text": "* [](/)\n  * Learn\n\nOn this page\n\n# Learn\n\nWelcome to the Yellow Network learning path. This section builds your understanding from fundamentals to advanced concepts.\n\n* * *\n\n## Introductionâ€‹\n\nStart here to understand what Yellow Network solves and how it works.\n\n**[What Yellow Solves](/docs/learn/introduction/what-yellow-solves)** â€” Understand the core problems: scaling, cost, and speed. Learn why state channels are the answer for high-frequency applications.\n\n**[Architecture at a Glance](/docs/learn/introduction/architecture-at-a-glance)** â€” See how the three protocol layers (on-chain, off-chain, application) work together to enable fast, secure transactions.\n\n* * *\n\n## Getting Startedâ€‹\n\nGet hands-on with Yellow Network in minutes.\n\n**[Quickstart: Your First Channel](/docs/learn/getting-started/quickstart)** â€” Create a state channel, perform an off-chain transfer, and verify the transaction in under 10 minutes.\n\n**[Prerequisites& Environment](/docs/learn/getting-started/prerequisites)** â€” Set up a complete development environment with Node.js, TypeScript, and the Nitrolite SDK.\n\n**[Key Terms& Mental Models](/docs/learn/getting-started/key-terms)** â€” Build your vocabulary and conceptual framework for understanding state channels.\n\n* * *\n\n## Core Conceptsâ€‹\n\nDeep dive into the technology powering Yellow Network.\n\n**[State Channels vs L1/L2](/docs/learn/core-concepts/state-channels-vs-l1-l2)** â€” Compare state channels with Layer 1 and Layer 2 solutions. Understand when each approach is the right choice.\n\n**[App Sessions](/docs/learn/core-concepts/app-sessions)** â€” Multi-party application channels with custom governance and state management.\n\n**[Session Keys](/docs/learn/core-concepts/session-keys)** â€” Delegated keys for secure, gasless interactions without repeated wallet prompts.\n\n**[Challenge-Response& Disputes](/docs/learn/core-concepts/challenge-response)** â€” How Yellow Network handles disputes and ensures your funds are always recoverable.\n\n**[Message Envelope](/docs/learn/core-concepts/message-envelope)** â€” Overview of the Nitro RPC message format and communication protocol.\n\n* * *\n\n## Next Stepsâ€‹\n\nAfter completing the Learn section, continue to:\n\n  * **[Build](/docs/build/quick-start)** â€” Implement complete Yellow Applications\n  * **[Protocol Reference](/docs/protocol/introduction)** â€” Authoritative protocol specification\n\n* * *\n\n## Quick Referenceâ€‹\n\nTopic| Time| Difficulty  \n---|---|---  \n[What Yellow Solves](/docs/learn/introduction/what-yellow-solves)| 5 min| Beginner  \n[Architecture at a Glance](/docs/learn/introduction/architecture-at-a-glance)| 8 min| Beginner  \n[Quickstart](/docs/learn/getting-started/quickstart)| 10 min| Beginner  \n[Key Terms](/docs/learn/getting-started/key-terms)| 10 min| Beginner  \n[State Channels vs L1/L2](/docs/learn/core-concepts/state-channels-vs-l1-l2)| 12 min| Intermediate  \n[App Sessions](/docs/learn/core-concepts/app-sessions)| 8 min| Intermediate  \n[Session Keys](/docs/learn/core-concepts/session-keys)| 8 min| Intermediate  \n[Challenge-Response](/docs/learn/core-concepts/challenge-response)| 6 min| Intermediate  \n[Message Envelope](/docs/learn/core-concepts/message-envelope)| 5 min| Intermediate  \n  \n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn/index.mdx)\n\n[NextWhat Yellow Solves](/docs/learn/introduction/what-yellow-solves)\n\n  * Introduction\n  * Getting Started\n  * Core Concepts\n  * Next Steps\n  * Quick Reference",
    "metadata": {
      "title": "Learn | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/learn/advanced/managing-session-keys",
    "text": "* [](/)\n  * Advanced\n  * Managing Session Keys\n\nOn this page\n\n# Managing Session Keys\n\nThis guide covers the operational details of creating, listing, and revoking session keys via the Clearnode API.\n\nPrerequisites\n\nBefore diving into session key management, make sure you understand the core concepts: what session keys are, how applications and allowances work, and the expiration rules. See **[Session Keys](/docs/learn/core-concepts/session-keys)** for the conceptual foundation.\n\n* * *\n\n## How to Manage Session Keysâ€‹\n\n### Clearnodeâ€‹\n\n#### Create and Configureâ€‹\n\nTo create a session key, use the `auth_request` method during authentication. This registers the session key with its configuration:\n\n**Request:**\n    \n    \n    {  \n      \"req\": [  \n        1,  \n        \"auth_request\",  \n        {  \n          \"address\": \"0x1234567890abcdef...\",  \n          \"session_key\": \"0x9876543210fedcba...\",  \n          \"application\": \"Chess Game\",  \n          \"allowances\": [  \n            {  \n              \"asset\": \"usdc\",  \n              \"amount\": \"100.0\"  \n            },  \n            {  \n              \"asset\": \"eth\",  \n              \"amount\": \"0.5\"  \n            }  \n          ],  \n          \"scope\": \"app.create\",  \n          \"expires_at\": 1762417328  \n        },  \n        1619123456789  \n      ],  \n      \"sig\": [\"0x5432abcdef...\"]  \n    }  \n    \n\n**Parameters:**\n\n  * `address` (required): The wallet address that owns this session key\n  * `session_key` (required): The address of the session key to register\n  * `application` (optional): Name of the application using this session key (defaults to \"clearnode\" if not provided)\n  * `allowances` (optional): Array of asset allowances specifying spending limits\n  * `scope` (optional): Permission scope (e.g., \"app.create\", \"ledger.readonly\"). **Note:** This feature is not yet implemented\n  * `expires_at` (required): Unix timestamp (in seconds) when this session key expires\n\nnote\n\nWhen authenticating with an already registered session key, you must still fill in all fields in the request, at least with arbitrary values. This is required by the request itself, however, the values will be ignored as the system uses the session key configuration stored during initial registration. This behavior will be improved in future versions.\n\n#### List Active Session Keysâ€‹\n\nUse the `get_session_keys` method to retrieve all active (non-expired) session keys for the authenticated user:\n\n**Request:**\n    \n    \n    {  \n      \"req\": [1, \"get_session_keys\", {}, 1619123456789],  \n      \"sig\": [\"0x9876fedcba...\"]  \n    }  \n    \n\n**Response:**\n    \n    \n    {  \n      \"res\": [  \n        1,  \n        \"get_session_keys\",  \n        {  \n          \"session_keys\": [  \n            {  \n              \"id\": 1,  \n              \"session_key\": \"0xabcdef1234567890...\",  \n              \"application\": \"Chess Game\",  \n              \"allowances\": [  \n                {  \n                  \"asset\": \"usdc\",  \n                  \"allowance\": \"100.0\",  \n                  \"used\": \"45.0\"  \n                },  \n                {  \n                  \"asset\": \"eth\",  \n                  \"allowance\": \"0.5\",  \n                  \"used\": \"0.0\"  \n                }  \n              ],  \n              \"scope\": \"app.create\",  \n              \"expires_at\": \"2024-12-31T23:59:59Z\",  \n              \"created_at\": \"2024-01-01T00:00:00Z\"  \n            }  \n          ]  \n        },  \n        1619123456789  \n      ],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    \n\n**Response Fields:**\n\n  * `id`: Unique identifier for the session key record\n  * `session_key`: The address of the session key\n  * `application`: Application name this session key is authorized for\n  * `allowances`: Array of allowances with usage tracking:\n    * `asset`: Symbol of the asset (e.g., \"usdc\", \"eth\")\n    * `allowance`: Maximum amount the session key can spend\n    * `used`: Amount already spent by this session key\n  * `scope`: Permission scope (omitted if empty)\n  * `expires_at`: When this session key expires (ISO 8601 format)\n  * `created_at`: When the session key was created (ISO 8601 format)\n\n#### Revoke a Session Keyâ€‹\n\nTo immediately invalidate a session key, use the `revoke_session_key` method:\n\n**Request:**\n    \n    \n    {  \n      \"req\": [  \n        1,  \n        \"revoke_session_key\",  \n        {  \n          \"session_key\": \"0xabcdef1234567890...\"  \n        },  \n        1619123456789  \n      ],  \n      \"sig\": [\"0x9876fedcba...\"]  \n    }  \n    \n\n**Response:**\n    \n    \n    {  \n      \"res\": [  \n        1,  \n        \"revoke_session_key\",  \n        {  \n          \"session_key\": \"0xabcdef1234567890...\"  \n        },  \n        1619123456789  \n      ],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    \n\n**Permission Rules:**\n\n  * A wallet can revoke any of its session keys\n  * A session key can revoke itself\n  * A session key with `application: \"clearnode\"` can revoke other session keys belonging to the same wallet\n  * A non-\"clearnode\" session key cannot revoke other session keys (only itself)\n\n**Important Notes:**\n\n  * Revocation is **immediate and cannot be undone**\n  * After revocation, any operations attempted with the revoked session key will fail with a validation error\n  * The revoked session key will no longer appear in the `get_session_keys` response\n  * Revocation is useful for security purposes when a session key may have been compromised\n\n**Error Cases:**\n\n  * Session key does not exist, belongs to another wallet, or is expired: `\"operation denied: provided address is not an active session key of this user\"`\n  * Non-\"clearnode\" session key attempting to revoke another session key: `\"operation denied: insufficient permissions for the active session key\"`\n\n### Nitrolite SDKâ€‹\n\nThe Nitrolite SDK provides a higher-level abstraction for managing session keys. For detailed information on using session keys with the Nitrolite SDK, please refer to the SDK documentation.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn/advanced/managing-session-keys.mdx)\n\n[PreviousMessage Envelope (RPC Protocol)](/docs/learn/core-concepts/message-envelope)\n\n  * How to Manage Session Keys\n    * Clearnode\n    * Nitrolite SDK",
    "metadata": {
      "title": "Managing Session Keys | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/advanced/managing-session-keys",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/learn/core-concepts/app-sessions",
    "text": "* [](/)\n  * Core Concepts\n  * App Sessions\n\nOn this page\n\n# App Sessions\n\nApp sessions are off-chain channels built on top of the unified balance that enable multi-party applications with custom governance rules.\n\n**Goal** : Understand how app sessions work for building multi-party applications.\n\n* * *\n\n## What is an App Session?â€‹\n\nAn **app session** is a temporary shared account where multiple participants can:\n\n  * Lock funds from their unified balance\n  * Execute application-specific logic (games, escrow, predictions)\n  * Redistribute funds based on outcomes\n  * Close and release funds back to unified balances\n\nThink of it as a programmable escrow with custom voting rules.\n\n* * *\n\n## App Session vs Payment Channelâ€‹\n\nFeature| Payment Channel| App Session  \n---|---|---  \n**Participants**|  Always 2| 2 or more  \n**Governance**|  Both must sign| Quorum-based  \n**Fund source**|  On-chain deposit| Unified balance  \n**Mid-session changes**|  Via resize (on-chain)| Via intent (off-chain)  \n**Use case**|  Transfers| Applications  \n  \n* * *\n\n## App Session Definitionâ€‹\n\nEvery app session starts with a **definition** that specifies the rules:\n\nField| Description  \n---|---  \n`protocol`| Version (`NitroRPC/0.4` recommended)  \n`participants`| Wallet addresses (order matters for signatures)  \n`weights`| Voting power per participant  \n`quorum`| Minimum weight required for state updates  \n`challenge`| Dispute window in seconds  \n`nonce`| Unique identifier (typically timestamp)  \n  \nThe `app_session_id` is computed deterministically from the definition using `keccak256(JSON.stringify(definition))`.\n\n* * *\n\n## Governance with Quorumâ€‹\n\nThe quorum system enables flexible governance patterns.\n\n### How It Worksâ€‹\n\n  1. Each participant has a **weight** (voting power)\n  2. State updates require signatures with total weight â‰¥ **quorum**\n  3. Not everyone needs to signâ€”just enough to meet quorum\n\n### Common Patternsâ€‹\n\nPattern| Setup| Use Case  \n---|---|---  \n**Unanimous**| `weights: [50, 50]`, `quorum: 100`| Both must agree  \n**Trusted Judge**| `weights: [0, 0, 100]`, `quorum: 100`| App determines outcome  \n**2-of-3 Escrow**| `weights: [40, 40, 50]`, `quorum: 80`| Any two can proceed  \n**Weighted DAO**| `weights: [20, 25, 30, 25]`, `quorum: 51`| Majority by stake  \n  \n* * *\n\n## Session Lifecycleâ€‹\n\ncreate_app_session\n\nsubmit_app_state\n\nclose_app_session\n\nOpen\n\nClosed\n\n### 1\\. Creationâ€‹\n\n  * Funds locked from participants' unified balances\n  * All participants with non-zero allocations must sign\n  * Status becomes `open`, version starts at `1`\n\n### 2\\. State Updatesâ€‹\n\n  * Redistribute funds with `submit_app_state`\n  * Version must increment by exactly 1\n  * Quorum of signatures required\n\n### 3\\. Closureâ€‹\n\n  * Final allocations distributed to unified balances\n  * Session becomes `closed` (cannot reopen)\n  * Quorum of signatures required\n\n* * *\n\n## Intent System (NitroRPC/0.4)â€‹\n\nThe intent system enables dynamic fund management during active sessions:\n\nIntent| Purpose| Rule  \n---|---|---  \n**OPERATE**|  Redistribute existing funds| Sum unchanged  \n**DEPOSIT**|  Add funds from unified balance| Sum increases  \n**WITHDRAW**|  Remove funds to unified balance| Sum decreases  \n  \nAllocations Are Final State\n\nAllocations always represent the **final state** , not the delta. The Clearnode computes deltas internally.\n\n* * *\n\n## Fund Flowâ€‹\n\nApp Session\n\nUnified Balances\n\ncreate (lock)\n\ncreate (lock)\n\nclose (release)\n\nclose (release)\n\nAlice: 200 USDC\n\nBob: 200 USDC\n\nAlice: 100 USDC\n\nBob: 100 USDC\n\n* * *\n\n## Protocol Versionsâ€‹\n\nVersion| Status| Key Features  \n---|---|---  \n**NitroRPC/0.2**|  Legacy| Basic state updates only  \n**NitroRPC/0.4**|  Current| Intent system (OPERATE, DEPOSIT, WITHDRAW)  \n  \nAlways use `NitroRPC/0.4` for new applications. Protocol version is set at creation and cannot be changed.\n\n* * *\n\n## Best Practicesâ€‹\n\n  1. **Set appropriate challenge periods** : 1 hour minimum, 24 hours recommended\n  2. **Include commission participants** : Apps often have a judge that takes a small fee\n  3. **Plan for disputes** : Design allocations that can be verified by third parties\n  4. **Version carefully** : Each state update must be exactly `current + 1`\n\n* * *\n\n## Deep Diveâ€‹\n\nFor complete method specifications and implementation details:\n\n  * **[App Session Methods](/docs/protocol/off-chain/app-sessions)** â€” Complete method specifications\n  * **[Communication Flows](/docs/protocol/communication-flows#app-session-lifecycle-flow)** â€” Sequence diagrams\n  * **[Implementation Checklist](/docs/protocol/implementation-checklist#state-management)** â€” Building app session support\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn/core-concepts/app-sessions.mdx)\n\n[PreviousState Channels vs L1/L2](/docs/learn/core-concepts/state-channels-vs-l1-l2)[NextSession Keys](/docs/learn/core-concepts/session-keys)\n\n  * What is an App Session?\n  * App Session vs Payment Channel\n  * App Session Definition\n  * Governance with Quorum\n    * How It Works\n    * Common Patterns\n  * Session Lifecycle\n    * 1\\. Creation\n    * 2\\. State Updates\n    * 3\\. Closure\n  * Intent System (NitroRPC/0.4)\n  * Fund Flow\n  * Protocol Versions\n  * Best Practices\n  * Deep Dive",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/app-sessions",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/learn/core-concepts/challenge-response",
    "text": "* [](/)\n  * Core Concepts\n  * Challenge-Response & Disputes\n\nOn this page\n\n# Challenge-Response & Disputes\n\nIn this guide, you will learn how Yellow Network resolves disputes and ensures your funds are always recoverable.\n\n**Goal** : Understand the security guarantees that make off-chain transactions safe.\n\n* * *\n\n## Why Challenge-Response Mattersâ€‹\n\nIn any off-chain system, a critical question arises: **What if someone tries to cheat?**\n\nState channels solve this with a challenge-response mechanism:\n\n  1. Anyone can submit a state to the blockchain\n  2. Counterparties have time to respond with a newer state\n  3. The newest valid state always wins\n  4. Funds are distributed according to that state\n\n* * *\n\n## The Trust Modelâ€‹\n\nState channels are **trustless** because:\n\nGuarantee| How It's Achieved  \n---|---  \n**Fund custody**|  Smart contract holds funds, not Clearnode  \n**State validity**|  Only signed states are accepted  \n**Dispute resolution**|  On-chain fallback if disagreement  \n**Recovery**|  You can always get your funds back  \n  \n* * *\n\n## Channel Dispute Flowâ€‹\n\n### Scenario: Clearnode Becomes Unresponsiveâ€‹\n\nYou have a channel with 100 USDC. The Clearnode stops responding.\n\n**Your options:**\n\n  1. Wait for Clearnode to recover\n  2. Force settlement on-chain via challenge\n\n### The Processâ€‹\n\n  1. **Initiate Challenge** : Submit your latest signed state to the blockchain\n  2. **Challenge Period** : Contract sets a timer (e.g., 24 hours)\n  3. **Response Window** : Counterparty can submit a newer state\n  4. **Resolution** : After timeout, challenged state becomes final\n\nchallenge()\n\ncheckpoint() with newer state\n\nTimeout expires\n\nACTIVE\n\nDISPUTE\n\nFINAL\n\nAnyone can submit  \nnewer valid state\n\n* * *\n\n## Why This Worksâ€‹\n\n### States Are Orderedâ€‹\n\nEvery state has a version number. A newer (higher version) state always supersedes older states.\n\n### States Are Signedâ€‹\n\nWith the default SimpleConsensus adjudicator, both parties must sign every state. If someone signed a state, they can't later claim they didn't agree.\n\nOther Adjudicators\n\nDifferent adjudicators may have different signing requirements. For example, a Remittance adjudicator may only require the sender's signature. The signing rules are defined by the channel's adjudicator contract.\n\n### Challenge Period Provides Fairnessâ€‹\n\nThe waiting window ensures honest parties have time to respond. Network delays don't cause losses.\n\n### On-Chain Contract is Neutralâ€‹\n\nThe smart contract accepts any valid signed state, picks the highest version, and distributes funds exactly as specified.\n\n* * *\n\n## Challenge Period Selectionâ€‹\n\nDuration| Trade-offs  \n---|---  \n**1 hour**|  Fast resolution, tight response window  \n**24 hours**|  Balanced (recommended)  \n**7 days**|  Maximum safety, slow settlement  \n  \nThe Custody Contract enforces a minimum of 1 hour.\n\n* * *\n\n## Checkpoint vs Challengeâ€‹\n\nOperation| Purpose| Channel Status  \n---|---|---  \n`checkpoint()`| Record state without dispute| Stays ACTIVE  \n`challenge()`| Force dispute resolution| Changes to DISPUTE  \n  \nUse checkpoint for safety snapshots. Use challenge when you need to force settlement.\n\n* * *\n\n## What Happens If...â€‹\n\nScenario| Outcome  \n---|---  \n**Clearnode goes offline**|  Challenge with latest state, withdraw after timeout  \n**You lose state history**|  Challenge with old state; counterparty submits newer if they have it  \n**Counterparty submits wrong state**|  Submit your newer state via checkpoint  \n**Block reorg occurs**|  Replay events from last confirmed block  \n  \n* * *\n\n## Key Takeawaysâ€‹\n\nConcept| Remember  \n---|---  \n**Challenge**|  Force on-chain dispute resolution  \n**Response**|  Submit newer state to defeat challenge  \n**Timeout**|  After period, challenged state becomes final  \n**Checkpoint**|  Record state without dispute  \n  \nSecurity Guarantee\n\nYou can **always** recover your funds according to the latest mutually signed state, regardless of counterparty behavior.\n\n* * *\n\n## Deep Diveâ€‹\n\nFor technical implementation details:\n\n  * **[Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle)** â€” Full state machine\n  * **[Security Considerations](/docs/protocol/on-chain/security)** â€” Threat model and best practices\n  * **[Communication Flows](/docs/protocol/communication-flows#challenge-response-closure-flow)** â€” Sequence diagrams\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn/core-concepts/challenge-response.mdx)\n\n[PreviousSession Keys](/docs/learn/core-concepts/session-keys)[NextMessage Envelope (RPC Protocol)](/docs/learn/core-concepts/message-envelope)\n\n  * Why Challenge-Response Matters\n  * The Trust Model\n  * Channel Dispute Flow\n    * Scenario: Clearnode Becomes Unresponsive\n    * The Process\n  * Why This Works\n    * States Are Ordered\n    * States Are Signed\n    * Challenge Period Provides Fairness\n    * On-Chain Contract is Neutral\n  * Challenge Period Selection\n  * Checkpoint vs Challenge\n  * What Happens If...\n  * Key Takeaways\n  * Deep Dive",
    "metadata": {
      "title": "Challenge-Response & Disputes | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/challenge-response",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/learn/core-concepts/message-envelope",
    "text": "* [](/)\n  * Core Concepts\n  * Message Envelope (RPC Protocol)\n\nOn this page\n\n# Message Envelope (RPC Protocol)\n\nIn this guide, you will learn the essentials of how messages are structured and transmitted in Yellow Network.\n\n**Goal** : Understand the Nitro RPC protocol at a conceptual level.\n\n* * *\n\n## Protocol Overviewâ€‹\n\n**Nitro RPC** is a lightweight RPC protocol optimized for state channel communication:\n\nFeature| Benefit  \n---|---  \n**Compact format**|  ~30% smaller than traditional JSON-RPC  \n**Signature-based auth**|  Every message is cryptographically verified  \n**Bidirectional**|  Real-time updates via WebSocket  \n**Ordered timestamps**|  Replay attack prevention  \n  \n* * *\n\n## Message Structureâ€‹\n\nEvery Nitro RPC message uses a compact JSON array format:\n\nComponent| Type| Description  \n---|---|---  \n**requestId**|  uint64| Unique identifier for correlation  \n**method**|  string| RPC method name (snake_case)  \n**params/result**|  object| Method-specific data  \n**timestamp**|  uint64| Unix milliseconds  \n  \n### Request Wrapperâ€‹\n    \n    \n    { \"req\": [requestId, method, params, timestamp], \"sig\": [...] }  \n    \n\n### Response Wrapperâ€‹\n    \n    \n    { \"res\": [requestId, method, result, timestamp], \"sig\": [...] }  \n    \n\n### Error Responseâ€‹\n    \n    \n    { \"res\": [requestId, \"error\", { \"error\": \"description\" }, timestamp], \"sig\": [...] }  \n    \n\n* * *\n\n## Signature Formatâ€‹\n\nEach signature is a 65-byte ECDSA signature (r + s + v) represented as a 0x-prefixed hex string.\n\nContext| What's Signed| Who Signs  \n---|---|---  \n**Requests**|  JSON payload hash| Session key (or main wallet)  \n**Responses**|  JSON payload hash| Clearnode  \n  \n* * *\n\n## Method Categoriesâ€‹\n\nCategory| Methods  \n---|---  \n**Auth**| `auth_request`, `auth_verify`  \n**Channels**| `create_channel`, `close_channel`, `resize_channel`  \n**Transfers**| `transfer`  \n**App Sessions**| `create_app_session`, `submit_app_state`, `close_app_session`  \n**Queries**| `get_ledger_balances`, `get_channels`, `get_app_sessions`, etc.  \n  \n* * *\n\n## Notificationsâ€‹\n\nThe Clearnode pushes real-time updates:\n\nNotification| When Sent  \n---|---  \n`bu` (balance update)| Balance changed  \n`cu` (channel update)| Channel status changed  \n`tr` (transfer)| Incoming/outgoing transfer  \n`asu` (app session update)| App session state changed  \n  \n* * *\n\n## Communication Flowâ€‹\n\nClearnodeClientClearnodeClientRequest (signed)Verify signatureProcessResponse (signed)Verify signatureNotification (async)\n\n* * *\n\n## Protocol Versionsâ€‹\n\nVersion| Status| Key Features  \n---|---|---  \n**NitroRPC/0.2**|  Legacy| Basic state updates  \n**NitroRPC/0.4**|  Current| Intent system, enhanced validation  \n  \nAlways use NitroRPC/0.4 for new implementations.\n\n* * *\n\n## Key Pointsâ€‹\n\n  1. **Compact arrays** instead of verbose JSON objects\n  2. **Every message signed** for authenticity\n  3. **Timestamps** prevent replay attacks\n  4. **Bidirectional** WebSocket for real-time updates\n\n* * *\n\n## Deep Diveâ€‹\n\nFor complete technical specifications:\n\n  * **[Message Format](/docs/protocol/off-chain/message-format)** â€” Full format specification\n  * **[Off-Chain Overview](/docs/protocol/off-chain/overview)** â€” Protocol architecture\n  * **[Implementation Checklist](/docs/protocol/implementation-checklist#off-chain-rpc)** â€” Building RPC support\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn/core-concepts/message-envelope.mdx)\n\n[PreviousChallenge-Response & Disputes](/docs/learn/core-concepts/challenge-response)[NextManaging Session Keys](/docs/learn/advanced/managing-session-keys)\n\n  * Protocol Overview\n  * Message Structure\n    * Request Wrapper\n    * Response Wrapper\n    * Error Response\n  * Signature Format\n  * Method Categories\n  * Notifications\n  * Communication Flow\n  * Protocol Versions\n  * Key Points\n  * Deep Dive",
    "metadata": {
      "title": "Message Envelope (RPC Protocol) | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/message-envelope",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/learn/core-concepts/session-keys",
    "text": "* [](/)\n  * Core Concepts\n  * Session Keys\n\nOn this page\n\n# Session Keys\n\nSession keys are delegated keys that enable applications to perform operations on behalf of a user's wallet with specified spending limits, permissions, and expiration times. They provide a secure way to grant limited access to applications without exposing the main wallet's private key.\n\nimportant\n\nSession keys are **no longer used as on-chain channel participant addresses** for new channels created after the v0.5.0 release. For all new channels, the wallet address is used directly as the participant address. However, session keys still function correctly for channels that were created before v0.5.0, ensuring backward compatibility.\n\n**Goal** : Understand how session keys enable seamless UX while maintaining security.\n\n* * *\n\n## Why Session Keys Matterâ€‹\n\nEvery blockchain operation traditionally requires a wallet signature popup. For high-frequency applications like games or trading, this creates terrible UXâ€”imagine 40+ wallet prompts during a chess game.\n\nSession keys solve this by allowing you to **sign once** , then operate seamlessly for the duration of the session.\n\n* * *\n\n## Core Conceptsâ€‹\n\n### General Rulesâ€‹\n\nimportant\n\nWhen authenticating with an already registered session key, you must still provide all parameters in the `auth_request`. However, the configuration values (`application`, `allowances`, `scope`, and `expires_at`) from the request will be ignored, as the system uses the settings from the initial registration. You may provide arbitrary values for these fields, as they are required by the request format but will not be used.\n\n### Applicationsâ€‹\n\nEach session key is associated with a specific **application name** , which identifies the application or service that will use the session key. The application name is also used to identify **app sessions** that are created using that session key.\n\nThis association serves several purposes:\n\n  * **Application Isolation** : Different applications get separate session keys, preventing one application from using another's delegated access\n  * **Access Control** : Operations performed with a session key are validated against the application specified during registration\n  * **Single Active Key** : Only one session key can be active per wallet+application combination. Registering a new session key for the same application automatically invalidates any existing session key for that application\n\nimportant\n\nOnly one session key is allowed per wallet+application combination. If you register a new session key for the same application, the old one is automatically invalidated and removed from the database.\n\n#### Special Application: \"clearnode\"â€‹\n\nSession keys registered with the application name `\"clearnode\"` receive special treatment:\n\n  * **Root Access** : These session keys bypass spending allowance validation and application restrictions\n  * **Full Permissions** : They can perform any operation the wallet itself could perform\n  * **Backward Compatibility** : This special behavior facilitates migration from older versions\n  * **Expiration Still Applies** : Even with root access, the session key expires according to its `expires_at` timestamp\n\nnote\n\nThe \"clearnode\" application name is primarily for backward compatibility and will be deprecated after a migration period for developers.\n\n### Expirationâ€‹\n\nAll session keys must have an **expiration timestamp** (`expires_at`) that defines when the session key becomes invalid:\n\n  * **Future Timestamp Required** : The expiration time must be set to a future date when registering a session key\n  * **Automatic Invalidation** : Once the expiration time passes, the session key can no longer be used for any operations\n  * **No Re-registration** : It is not possible to re-register an expired session key. You must create a new session key instead\n  * **Applies to All Keys** : Even \"clearnode\" application session keys must respect the expiration timestamp\n\n### Allowancesâ€‹\n\nAllowances define **spending limits** for session keys, specifying which assets the session key can spend and how much:\n    \n    \n    {  \n      \"allowances\": [  \n        {  \n          \"asset\": \"usdc\",  \n          \"amount\": \"100.0\"  \n        },  \n        {  \n          \"asset\": \"eth\",  \n          \"amount\": \"0.5\"  \n        }  \n      ]  \n    }  \n    \n\n#### Allowance Validationâ€‹\n\n  * **Supported Assets Only** : All assets specified in allowances must be supported by the system. Unsupported assets cause authentication to fail\n  * **Usage Tracking** : The system tracks spending per session key by recording which session key was used for each ledger debit operation\n  * **Spending Limits** : Once a session key reaches its spending cap for an asset, further operations requiring that asset are rejected with: `\"operation denied: insufficient session key allowance: X required, Y available\"`\n  * **Empty Allowances** : Providing an empty `allowances` array (`[]`) means zero spending allowed for all assetsâ€”any operation attempting to spend funds will be rejected\n\n#### Allowances for \"clearnode\" Applicationâ€‹\n\nSession keys with `application: \"clearnode\"` are exempt from allowance enforcement:\n\n  * **No Spending Limits** : Allowance checks are bypassed entirely\n  * **Full Financial Access** : These keys can spend any amount of any supported asset\n  * **Expiration Still Matters** : Even without allowance restrictions, the session key still expires according to its `expires_at` timestamp\n\n* * *\n\n## Session Key Lifecycleâ€‹\n\nauth_verify success\n\nUsing session key\n\nexpires_at reached\n\nAllowance depleted\n\nManual revocation\n\nRe-authenticate\n\nRe-authenticate\n\nRe-authenticate\n\nUnauthenticated\n\nAuthenticated\n\nExpired\n\nExhausted\n\nRevoked\n\n* * *\n\n## Security Modelâ€‹\n\nApproach| Risk if Compromised| UX Impact  \n---|---|---  \n**Main wallet always**|  Full wallet access| Constant prompts  \n**Session key (limited)**|  Only allowance at risk| Seamless  \n**Session key (unlimited)**|  Unified balance at risk| Seamless but risky  \n  \nSession Key Compromise\n\nIf a session key is compromised, attackers can only spend up to the configured allowance before expiration. This is why setting appropriate limits is critical.\n\n* * *\n\n## Best Practicesâ€‹\n\n### For Usersâ€‹\n\n  1. **Set reasonable allowances** : Don't authorize more than you'll use\n  2. **Use short expirations** : 24 hours is usually sufficient\n  3. **Different keys for different apps** : Isolate risk per application\n  4. **Monitor spending** : Use `get_session_keys` to check usage\n  5. **Revoke when done** : Clean up unused sessions\n\n### For Developersâ€‹\n\n  1. **Secure storage** : Encrypt session keys at rest\n  2. **Never transmit private keys** : Session key stays on device\n  3. **Handle expiration gracefully** : Prompt re-authentication before expiry\n  4. **Verify Clearnode signatures** : Always validate response signatures\n  5. **Clear on logout** : Delete session keys when user logs out\n\n* * *\n\n## Alternative: Main Wallet as Root Signerâ€‹\n\nYou can skip session keys entirely and sign every request with your main wallet. Use this approach for:\n\n  * Single operations\n  * High-value transactions\n  * Maximum security required\n  * Non-interactive applications\n\n* * *\n\n## Next Stepsâ€‹\n\n  * **[Managing Session Keys](/docs/learn/advanced/managing-session-keys)** â€” Create, list, and revoke session keys with full API examples\n  * **[Authentication Flow](/docs/protocol/off-chain/authentication)** â€” Full 3-step authentication protocol\n  * **[Communication Flows](/docs/protocol/communication-flows#authentication-flow)** â€” Sequence diagrams for auth\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn/core-concepts/session-keys.mdx)\n\n[PreviousApp Sessions](/docs/learn/core-concepts/app-sessions)[NextChallenge-Response & Disputes](/docs/learn/core-concepts/challenge-response)\n\n  * Why Session Keys Matter\n  * Core Concepts\n    * General Rules\n    * Applications\n    * Expiration\n    * Allowances\n  * Session Key Lifecycle\n  * Security Model\n  * Best Practices\n    * For Users\n    * For Developers\n  * Alternative: Main Wallet as Root Signer\n  * Next Steps",
    "metadata": {
      "title": "Session Keys | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/session-keys",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/learn/core-concepts/state-channels-vs-l1-l2",
    "text": "* [](/)\n  * Core Concepts\n  * State Channels vs L1/L2\n\nOn this page\n\n# State Channels vs L1/L2\n\nIn this guide, you will learn how state channels compare to Layer 1 and Layer 2 solutions, and when each approach is the right choice.\n\n**Goal** : Understand where state channels fit in the blockchain scaling landscape.\n\n* * *\n\n## Solution Comparisonâ€‹\n\nSolution| Throughput| Latency| Cost per Op| Best For  \n---|---|---|---|---  \n**Layer 1**|  15-65K TPS| 1-15 sec| $0.001-$50| Settlement, contracts  \n**Layer 2**|  2,000-4,000 TPS| 1-10 sec| $0.01-$0.50| General dApps  \n**State Channels**| **Unlimited** *|  **< 1 sec**| **$0**|  High-frequency, known parties  \n  \n_*Theoretically unlimitedâ€”no consensus bottleneck. Real-world throughput depends on signature generation, network latency, and application logic. Benchmarking documentation coming soon._\n\n* * *\n\n## How State Channels Workâ€‹\n\nState channels operate on a simple principle:\n\n  1. **Lock funds** in a smart contract (on-chain)\n  2. **Exchange signed states** directly between participants (off-chain)\n  3. **Settle** when done or if there's a dispute (on-chain)\n\nThe key insight: most interactions between parties don't need immediate on-chain settlement.\n\n* * *\n\n## State Channel Advantagesâ€‹\n\n### Instant Finalityâ€‹\n\nUnlike L2 solutions that still have block times, state channels provide sub-second finality:\n\nSolution| Transaction Flow  \n---|---  \nL1| Transaction â†’ Mempool â†’ Block â†’ Confirmation  \nL2| Transaction â†’ Sequencer â†’ L2 Block â†’ L1 Data  \nChannels| Signature â†’ Validation â†’ Done  \n  \n### Zero Operational Costâ€‹\n\nOperation| L1 Cost| L2 Cost| State Channel  \n---|---|---|---  \n100 transfers| $500-5000| $10-50| **$0**  \n1000 transfers| $5000-50000| $100-500| **$0**  \n  \n### Privacyâ€‹\n\nOff-chain transactions are only visible to participants. Only opening and final states appear on-chain.\n\n* * *\n\n## State Channel Limitationsâ€‹\n\n### Known Participantsâ€‹\n\nChannels work between specific participants. Yellow Network addresses this through Clearnodesâ€”off-chain service providers that coordinate channels and provide a unified balance across multiple users and chains.\n\n### Liquidity Requirementsâ€‹\n\nFunds must be locked upfront. You can't spend more than what's locked in the channel.\n\n### Liveness Requirementsâ€‹\n\nParticipants must respond to challenges within the challenge period. Users should ensure they can monitor for challenges or use services that provide this functionality.\n\n* * *\n\n## When to Use Eachâ€‹\n\nChoose| When  \n---|---  \n**L1**|  Deploying contracts, one-time large transfers, final settlement  \n**L2**|  General dApps, many unknown users, complex smart contracts  \n**State Channels**|  Known parties, real-time speed, high frequency, zero gas needed  \n  \n* * *\n\n## Decision Frameworkâ€‹\n\nNo\n\nYes\n\nYes\n\nNo\n\nYes\n\nNo\n\nTransaction\n\nKnown counterparty?\n\nUse L1/L2\n\nHigh frequency?\n\nUse State Channel\n\nLarge value?\n\n* * *\n\n## How Yellow Network Addresses Limitationsâ€‹\n\nLimitation| Solution  \n---|---  \nKnown participants| Clearnode coordination layer  \nLiquidity| Unified balance across chains  \nLiveness| Always-on Clearnode monitoring  \n  \n* * *\n\n## Key Takeawaysâ€‹\n\nState channels shine when you have identified participants who will interact frequentlyâ€”like players in a game, counterparties in a trade, or parties in a payment relationship.\n\nState Channel Sweet Spot\n\n  * Real-time interactions between known parties\n  * High transaction volumes\n  * Zero gas costs required\n  * Instant finality needed\n\n* * *\n\n## Deep Diveâ€‹\n\nFor technical details on channel implementation:\n\n  * **[Architecture](/docs/protocol/architecture)** â€” System design and fund flows\n  * **[Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle)** â€” State machine and operations\n  * **[Data Structures](/docs/protocol/on-chain/data-structures)** â€” Channel and state formats\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn/core-concepts/state-channels-vs-l1-l2.mdx)\n\n[PreviousKey Terms & Mental Models](/docs/learn/getting-started/key-terms)[NextApp Sessions](/docs/learn/core-concepts/app-sessions)\n\n  * Solution Comparison\n  * How State Channels Work\n  * State Channel Advantages\n    * Instant Finality\n    * Zero Operational Cost\n    * Privacy\n  * State Channel Limitations\n    * Known Participants\n    * Liquidity Requirements\n    * Liveness Requirements\n  * When to Use Each\n  * Decision Framework\n  * How Yellow Network Addresses Limitations\n  * Key Takeaways\n  * Deep Dive",
    "metadata": {
      "title": "State Channels vs L1/L2 | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/state-channels-vs-l1-l2",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/learn/getting-started/key-terms",
    "text": "* [](/)\n  * Getting Started\n  * Key Terms & Mental Models\n\nOn this page\n\n# Key Terms & Mental Models\n\nIn this guide, you will learn the essential vocabulary and mental models for understanding Yellow Network and state channel technology.\n\n**Goal** : Build a solid conceptual foundation before diving into implementation.\n\n* * *\n\n## Core Mental Model: Off-Chain Executionâ€‹\n\nThe fundamental insight behind Yellow Network is simple:\n\n> **Most interactions don't need immediate on-chain settlement.**\n\nThink of it like a bar tab:\n\nTraditional (L1)| State Channels  \n---|---  \nPay for each drink separately| Open a tab, pay once at the end  \nWait for bartender each time| Instant service, settle later  \nTransaction per item| One transaction for the whole session  \n  \nState channels apply this pattern to blockchain: **lock funds once** , **transact off-chain** , **settle once**.\n\n* * *\n\n## Essential Vocabularyâ€‹\n\n### State Channelâ€‹\n\nA **state channel** is a secure pathway for exchanging cryptographically signed states between participants without touching the blockchain.\n\n**Key properties:**\n\n  * Funds are locked in a smart contract\n  * Participants exchange signed state updates off-chain\n  * Only opening and closing require on-chain transactions\n  * Either party can force on-chain settlement if needed\n\n**Analogy** : Like a private Venmo between two parties, backed by a bank escrow.\n\n* * *\n\n### Channelâ€‹\n\nA **Channel** is the on-chain representation of a state channel. It defines:\n    \n    \n    {  \n      participants: ['0xAlice', '0xBob'],   // Who can participate  \n      adjudicator: '0xContract',            // Rules for state validation  \n      challenge: 86400,                     // Dispute window (seconds)  \n      nonce: 1699123456789                  // Unique identifier  \n    }  \n    \n\nThe **channelId** is computed deterministically from these parameters:\n    \n    \n    channelId = keccak256(participants, adjudicator, challenge, nonce, chainId)  \n    \n\n* * *\n\n### Stateâ€‹\n\nA **State** is a snapshot of the channel at a specific moment:\n    \n    \n    {  \n      intent: 'OPERATE',           // Purpose: INITIALIZE, OPERATE, RESIZE, FINALIZE  \n      version: 5,                  // Incremental counter (higher = newer)  \n      data: '0x...',               // Application-specific data  \n      allocations: [...],          // How funds are distributed  \n      sigs: ['0xSig1', '0xSig2']   // Participant signatures  \n    }  \n    \n\n**Key rule** : A higher version number always supersedes a lower one, regardless of allocations.\n\n* * *\n\n### Allocationâ€‹\n\nAn **Allocation** specifies how funds should be distributed:\n    \n    \n    {  \n      destination: '0xAlice',              // Recipient address  \n      token: '0xUSDC_CONTRACT',            // Token contract  \n      amount: 50000000n                    // Amount in smallest unit (6 decimals for USDC)  \n    }  \n    \n\nThe sum of allocations represents the total funds in the channel.\n\n* * *\n\n### Clearnodeâ€‹\n\nA **Clearnode** is the off-chain service that:\n\n  1. **Manages the Nitro RPC protocol** for state channel operations\n  2. **Provides unified balance** aggregated across multiple chains\n  3. **Coordinates channels** between users\n  4. **Hosts app sessions** for multi-party applications\n\n**Think of it as** : A game server that acts as your entry point to Yellow Networkâ€”centralized for speed, but trustless because of on-chain guarantees.\n\n* * *\n\n### Unified Balanceâ€‹\n\nYour **unified balance** is the aggregation of funds across all chains where you have deposits:\n    \n    \n    Polygon: 50 USDC  â”  \n    Base:    30 USDC  â”œâ”€â†’ Unified Balance: 100 USDC  \n    Arbitrum: 20 USDC â”˜  \n    \n\nYou can:\n\n  * Transfer from unified balance instantly (off-chain)\n  * Withdraw to any supported chain\n  * Lock funds into app sessions\n\n* * *\n\n### App Sessionâ€‹\n\nAn **App Session** is an off-chain channel built on top of the unified balance for multi-party applications:\n    \n    \n    {  \n      protocol: 'NitroRPC/0.4',  \n      participants: ['0xAlice', '0xBob', '0xJudge'],  \n      weights: [40, 40, 50],         // Voting power  \n      quorum: 80,                    // Required weight for state updates  \n      challenge: 3600,               // Dispute window  \n      nonce: 1699123456789  \n    }  \n    \n\n**Use cases** : Games, prediction markets, escrow, any multi-party coordination.\n\n* * *\n\n### Session Keyâ€‹\n\nA **session key** is a temporary cryptographic key that:\n\n  * Is generated locally on your device\n  * Has limited permissions and spending caps\n  * Expires after a specified time\n  * Allows gasless signing without wallet prompts\n\n**Flow** :\n\n  1. Generate session keypair locally\n  2. Main wallet authorizes the session key (one-time EIP-712 signature)\n  3. All subsequent operations use the session key\n  4. Session expires or can be revoked\n\n* * *\n\n## Protocol Componentsâ€‹\n\n### Nitroliteâ€‹\n\n**Nitrolite** is the on-chain smart contract protocol:\n\n  * Defines channel data structures\n  * Implements create, close, challenge, resize operations\n  * Provides cryptographic verification\n  * Currently version 0.5.0\n\n* * *\n\n### Nitro RPCâ€‹\n\n**Nitro RPC** is the off-chain communication protocol:\n\n  * Compact JSON array format for efficiency\n  * Every message is cryptographically signed\n  * Bidirectional real-time communication\n  * Currently version 0.4\n\n**Message format** :\n    \n    \n    [requestId, method, params, timestamp]  \n      \n    // Example  \n    [42, \"transfer\", {\"destination\": \"0x...\", \"amount\": \"50.0\"}, 1699123456789]  \n    \n\n* * *\n\n### Custody Contractâ€‹\n\nThe **Custody Contract** is the main on-chain entry point:\n\n  * Locks and unlocks participant funds\n  * Tracks channel status (VOID â†’ ACTIVE â†’ FINAL)\n  * Validates signatures and state transitions\n  * Handles dispute resolution\n\n* * *\n\n### Adjudicatorâ€‹\n\nAn **Adjudicator** defines rules for valid state transitions:\n\nType| Rule  \n---|---  \n**SimpleConsensus**|  Both participants must sign (default)  \n**Remittance**|  Only sender must sign  \n**Custom**|  Application-specific logic  \n  \n* * *\n\n## State Lifecycleâ€‹\n\n### Channel Statesâ€‹\n\nChannel doesn't exist\n\ncreate()\n\nOff-chain updates\n\nchallenge()\n\nclose()\n\ncheckpoint()\n\nTimeout\n\nDeleted\n\nVOID\n\nACTIVE\n\nDISPUTE\n\nFINAL\n\nStatus| Meaning  \n---|---  \n**VOID**|  Channel doesn't exist on-chain  \n**INITIAL**|  Created, waiting for all participants (legacy)  \n**ACTIVE**|  Fully operational, off-chain updates happening  \n**DISPUTE**|  Challenge period active, parties can submit newer states  \n**FINAL**|  Closed, funds distributed, metadata deleted  \n  \n* * *\n\n### State Intentsâ€‹\n\nIntent| When Used| Purpose  \n---|---|---  \n**INITIALIZE**| `create()`| First state when opening channel  \n**OPERATE**|  Off-chain updates| Normal operation, redistribution  \n**RESIZE**| `resize()`| Add or remove funds  \n**FINALIZE**| `close()`| Final state for cooperative closure  \n  \n* * *\n\n## Security Conceptsâ€‹\n\n### Challenge Periodâ€‹\n\nWhen a dispute arises:\n\n  1. Party A submits their latest state via `challenge()`\n  2. **Challenge period** starts (typically 24 hours)\n  3. Party B can submit a newer valid state via `checkpoint()`\n  4. If no newer state, Party A's state becomes final after timeout\n\n**Purpose** : Gives honest parties time to respond to incorrect claims.\n\n* * *\n\n### Signaturesâ€‹\n\nTwo contexts for signatures:\n\nContext| Hash Method| Signed By  \n---|---|---  \n**On-chain**|  Raw `packedState` (no prefix)| Main wallet  \n**Off-chain RPC**|  JSON payload hash| Session key  \n  \n**On-chain packedState** :\n    \n    \n    keccak256(abi.encode(channelId, intent, version, data, allocations))  \n    \n\n* * *\n\n### Quorumâ€‹\n\nFor app sessions, **quorum** defines the minimum voting weight required for state updates:\n    \n    \n    Participants: [Alice, Bob, Judge]  \n    Weights:      [40,    40,   50]  \n    Quorum: 80  \n      \n    Valid combinations:  \n    - Alice + Bob = 80 âœ“  \n    - Alice + Judge = 90 âœ“  \n    - Bob + Judge = 90 âœ“  \n    - Alice alone = 40 âœ—  \n    \n\n* * *\n\n## Quick Reference Tableâ€‹\n\nTerm| One-Line Definition  \n---|---  \n**State Channel**|  Off-chain execution backed by on-chain funds  \n**Clearnode**|  Off-chain service coordinating state channels  \n**Unified Balance**|  Aggregated funds across all chains  \n**App Session**|  Multi-party application channel  \n**Session Key**|  Temporary key with limited permissions  \n**Challenge Period**|  Dispute resolution window  \n**Quorum**|  Minimum signature weight for approval  \n**Allocation**|  Fund distribution specification  \n**packedState**|  Canonical payload for signing  \n  \n* * *\n\n## Next Stepsâ€‹\n\nNow that you understand the vocabulary, continue to:\n\n  * **[State Channels vs L1/L2](/docs/learn/core-concepts/state-channels-vs-l1-l2)** â€” Deep comparison with other scaling solutions\n  * **[App Sessions](/docs/learn/core-concepts/app-sessions)** â€” Multi-party application patterns\n  * **[Session Keys](/docs/learn/core-concepts/session-keys)** â€” Authentication and security\n\nFor complete definitions, see the **[Glossary](/docs/protocol/glossary)**.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn/getting-started/key-terms.mdx)\n\n[PreviousPrerequisites & Environment](/docs/learn/getting-started/prerequisites)[NextState Channels vs L1/L2](/docs/learn/core-concepts/state-channels-vs-l1-l2)\n\n  * Core Mental Model: Off-Chain Execution\n  * Essential Vocabulary\n    * State Channel\n    * Channel\n    * State\n    * Allocation\n    * Clearnode\n    * Unified Balance\n    * App Session\n    * Session Key\n  * Protocol Components\n    * Nitrolite\n    * Nitro RPC\n    * Custody Contract\n    * Adjudicator\n  * State Lifecycle\n    * Channel States\n    * State Intents\n  * Security Concepts\n    * Challenge Period\n    * Signatures\n    * Quorum\n  * Quick Reference Table\n  * Next Steps",
    "metadata": {
      "title": "Key Terms & Mental Models | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/key-terms",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
    "text": "* [](/)\n  * Getting Started\n  * Prerequisites & Environment\n\nOn this page\n\n# Prerequisites & Environment\n\nIn this guide, you will set up a complete development environment for building applications on Yellow Network.\n\n**Goal** : Have a working local environment ready for Yellow App development.\n\n* * *\n\n## System Requirementsâ€‹\n\nRequirement| Minimum| Recommended  \n---|---|---  \n**Node.js**|  18.x| 20.x or later  \n**npm/yarn/pnpm**|  Latest stable| Latest stable  \n**Operating System**|  macOS, Linux, Windows| macOS, Linux  \n  \n* * *\n\n## Required Knowledgeâ€‹\n\nBefore building on Yellow Network, you should be comfortable with:\n\nTopic| Why It Matters  \n---|---  \n**JavaScript/TypeScript**|  SDK and examples are in TypeScript  \n**Async/await patterns**|  All network operations are asynchronous  \n**Basic Web3 concepts**|  Wallets, transactions, signatures  \n**ERC-20 tokens**|  Fund management involves token operations  \n  \nNew to Web3?\n\nIf you're new to blockchain development, start with the [Ethereum Developer Documentation](https://ethereum.org/developers) to understand wallets, transactions, and smart contract basics.\n\n* * *\n\n## Step 1: Install Node.jsâ€‹\n\n### macOS (using Homebrew)â€‹\n    \n    \n    # Install Homebrew if you don't have it  \n    /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"  \n      \n    # Install Node.js  \n    brew install node@20  \n      \n    # Verify installation  \n    node --version  # Should show v20.x.x  \n    npm --version   # Should show 10.x.x  \n    \n\n### Linux (Ubuntu/Debian)â€‹\n    \n    \n    # Install Node.js via NodeSource  \n    curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -  \n    sudo apt-get install -y nodejs  \n      \n    # Verify installation  \n    node --version  \n    npm --version  \n    \n\n### Windowsâ€‹\n\nDownload and run the installer from [nodejs.org](https://nodejs.org/).\n\n* * *\n\n## Step 2: Install Core Dependenciesâ€‹\n\nCreate a new project and install the required packages:\n    \n    \n    # Create project directory  \n    mkdir yellow-app && cd yellow-app  \n      \n    # Initialize project  \n    npm init -y  \n      \n    # Install core dependencies  \n    npm install @erc7824/nitrolite viem  \n      \n    # Install development dependencies  \n    npm install -D typescript @types/node tsx  \n    \n\n### Package Overviewâ€‹\n\nPackage| Purpose  \n---|---  \n`@erc7824/nitrolite`| Yellow Network SDK for state channel operations  \n`viem`| Modern Ethereum library for wallet and contract interactions  \n`typescript`| Type safety and better developer experience  \n`tsx`| Run TypeScript files directly  \n  \n* * *\n\n## Step 3: Configure TypeScriptâ€‹\n\nCreate `tsconfig.json`:\n    \n    \n    {  \n      \"compilerOptions\": {  \n        \"target\": \"ES2022\",  \n        \"module\": \"ESNext\",  \n        \"moduleResolution\": \"bundler\",  \n        \"strict\": true,  \n        \"esModuleInterop\": true,  \n        \"skipLibCheck\": true,  \n        \"outDir\": \"./dist\",  \n        \"rootDir\": \"./src\"  \n      },  \n      \"include\": [\"src/**/*\"],  \n      \"exclude\": [\"node_modules\"]  \n    }  \n    \n\nUpdate `package.json`:\n    \n    \n    {  \n      \"type\": \"module\",  \n      \"scripts\": {  \n        \"dev\": \"tsx watch src/index.ts\",  \n        \"build\": \"tsc\",  \n        \"start\": \"node dist/index.js\"  \n      }  \n    }  \n    \n\n* * *\n\n## Step 4: Set Up Environment Variablesâ€‹\n\nCreate `.env` for sensitive configuration:\n    \n    \n    # .env - Never commit this file!  \n      \n    # Your wallet private key (for development only)  \n    PRIVATE_KEY=0x...  \n      \n    # RPC endpoints  \n    SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_KEY  \n    BASE_RPC_URL=https://base-sepolia.g.alchemy.com/v2/YOUR_KEY  \n      \n    # Clearnode WebSocket endpoint  \n    # Production: wss://clearnet.yellow.com/ws  \n    # Sandbox: wss://clearnet-sandbox.yellow.com/ws  \n    CLEARNODE_WS_URL=wss://clearnet-sandbox.yellow.com/ws  \n    \n\nAdd to `.gitignore`:\n    \n    \n    # .gitignore  \n    .env  \n    .env.local  \n    node_modules/  \n    dist/  \n    \n\nInstall dotenv for loading environment variables:\n    \n    \n    npm install dotenv  \n    \n\n* * *\n\n## Step 5: Wallet Setupâ€‹\n\n### Development Walletâ€‹\n\nFor development, create a dedicated wallet:\n    \n    \n    // scripts/create-wallet.ts  \n    import { generatePrivateKey, privateKeyToAccount } from 'viem/accounts';  \n      \n    const privateKey = generatePrivateKey();  \n    const account = privateKeyToAccount(privateKey);  \n      \n    console.log('New Development Wallet');  \n    console.log('----------------------');  \n    console.log('Address:', account.address);  \n    console.log('Private Key:', privateKey);  \n    console.log('\\nâš ï¸  Save this private key securely and add to .env');  \n    \n\nRun it:\n    \n    \n    npx tsx scripts/create-wallet.ts  \n    \n\n### Get Test Tokensâ€‹\n\n#### Yellow Network Sandbox Faucet (Recommended)â€‹\n\nFor testing on the Yellow Network Sandbox, you can request test tokens directly to your unified balance:\n    \n    \n    curl -XPOST https://clearnet-sandbox.yellow.com/faucet/requestTokens \\  \n      -H \"Content-Type: application/json\" \\  \n      -d '{\"userAddress\":\"<your_wallet_address>\"}'  \n    \n\nReplace `<your_wallet_address>` with your actual wallet address.\n\nNo On-Chain Operations Needed\n\nTest tokens (ytest.USD) are credited directly to your unified balance on the Sandbox Clearnode. No deposit or channel operations are requiredâ€”you can start transacting immediately!\n\n#### Testnet Faucets (For On-Chain Testing)â€‹\n\nIf you need on-chain test tokens for Sepolia or Base Sepolia:\n\nNetwork| Faucet  \n---|---  \nSepolia| [sepoliafaucet.com](https://sepoliafaucet.com)  \nBase Sepolia| [base.org/faucet](https://www.coinbase.com/faucets/base-ethereum-goerli-faucet)  \n  \nDevelopment Only\n\nNever use your main wallet or real funds for development. Always create a separate development wallet with test tokens.\n\n* * *\n\n## Step 6: Verify Setupâ€‹\n\nCreate `src/index.ts` to verify everything works:\n    \n    \n    import 'dotenv/config';  \n    import { createPublicClient, http } from 'viem';  \n    import { sepolia } from 'viem/chains';  \n    import { privateKeyToAccount } from 'viem/accounts';  \n      \n    async function main() {  \n      // Verify environment variables  \n      const privateKey = process.env.PRIVATE_KEY;  \n      if (!privateKey) {  \n        throw new Error('PRIVATE_KEY not set in .env');  \n      }  \n      \n      // Create account from private key  \n      const account = privateKeyToAccount(privateKey as `0x${string}`);  \n      console.log('âœ“ Wallet loaded:', account.address);  \n      \n      // Create public client  \n      const client = createPublicClient({  \n        chain: sepolia,  \n        transport: http(process.env.SEPOLIA_RPC_URL),  \n      });  \n      \n      // Check connection  \n      const blockNumber = await client.getBlockNumber();  \n      console.log('âœ“ Connected to Sepolia, block:', blockNumber);  \n      \n      // Check balance  \n      const balance = await client.getBalance({ address: account.address });  \n      console.log('âœ“ ETH balance:', balance.toString(), 'wei');  \n      \n      console.log('\\nðŸŽ‰ Environment setup complete!');  \n    }  \n      \n    main().catch(console.error);  \n    \n\nRun the verification:\n    \n    \n    npm run dev  \n    \n\nExpected output:\n    \n    \n    âœ“ Wallet loaded: 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb  \n    âœ“ Connected to Sepolia, block: 12345678  \n    âœ“ ETH balance: 100000000000000000 wei  \n      \n    ðŸŽ‰ Environment setup complete!  \n    \n\n* * *\n\n## Project Structureâ€‹\n\nRecommended folder structure for Yellow Apps:\n    \n    \n    yellow-app/  \n    â”œâ”€â”€ src/  \n    â”‚   â”œâ”€â”€ index.ts          # Entry point  \n    â”‚   â”œâ”€â”€ config.ts         # Configuration  \n    â”‚   â”œâ”€â”€ client.ts         # Nitrolite client setup  \n    â”‚   â”œâ”€â”€ auth.ts           # Authentication logic  \n    â”‚   â””â”€â”€ channels/  \n    â”‚       â”œâ”€â”€ create.ts     # Channel creation  \n    â”‚       â”œâ”€â”€ transfer.ts   # Transfer operations  \n    â”‚       â””â”€â”€ close.ts      # Channel closure  \n    â”œâ”€â”€ scripts/  \n    â”‚   â””â”€â”€ create-wallet.ts  # Utility scripts  \n    â”œâ”€â”€ .env                  # Environment variables (git-ignored)  \n    â”œâ”€â”€ .gitignore  \n    â”œâ”€â”€ package.json  \n    â””â”€â”€ tsconfig.json  \n    \n\n* * *\n\n## Supported Networksâ€‹\n\nTo get the current list of supported chains and contract addresses, query the Clearnode's `get_config` endpoint:\n    \n    \n    // Example: Fetch supported chains and contract addresses  \n    const ws = new WebSocket('wss://clearnet-sandbox.yellow.com/ws');  \n      \n    ws.onopen = () => {  \n      const request = {  \n        req: [1, 'get_config', {}, Date.now()],  \n        sig: [] // get_config is a public endpoint, no signature required  \n      };  \n      ws.send(JSON.stringify(request));  \n    };  \n      \n    ws.onmessage = (event) => {  \n      const response = JSON.parse(event.data);  \n      console.log('Supported chains:', response.res[2].chains);  \n      console.log('Contract addresses:', response.res[2].contracts);  \n    };  \n    \n\nDynamic Configuration\n\nThe `get_config` method returns real-time information about supported chains, contract addresses, and Clearnode capabilities. This ensures you always have the most up-to-date network information.\n\n* * *\n\n## Next Stepsâ€‹\n\nYour environment is ready! Continue to:\n\n  * **[Key Terms& Mental Models](/docs/learn/getting-started/key-terms)** â€” Understand the core concepts\n  * **[Quickstart](/docs/learn/getting-started/quickstart)** â€” Build your first Yellow App\n  * **[State Channels vs L1/L2](/docs/learn/core-concepts/state-channels-vs-l1-l2)** â€” Deep dive into state channels\n\n* * *\n\n## Common Issuesâ€‹\n\n### \"Module not found\" errorsâ€‹\n\nEnsure you have `\"type\": \"module\"` in `package.json` and are using ESM imports.\n\n### \"Cannot find module 'viem'\"â€‹\n\nRun `npm install` to ensure all dependencies are installed.\n\n### RPC rate limitingâ€‹\n\nUse a dedicated RPC provider (Infura, Alchemy) instead of public endpoints for production.\n\n### TypeScript errors with viemâ€‹\n\nEnsure your `tsconfig.json` has `\"moduleResolution\": \"bundler\"` or `\"node16\"`.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn/getting-started/prerequisites.mdx)\n\n[PreviousQuickstart](/docs/learn/getting-started/quickstart)[NextKey Terms & Mental Models](/docs/learn/getting-started/key-terms)\n\n  * System Requirements\n  * Required Knowledge\n  * Step 1: Install Node.js\n    * macOS (using Homebrew)\n    * Linux (Ubuntu/Debian)\n    * Windows\n  * Step 2: Install Core Dependencies\n    * Package Overview\n  * Step 3: Configure TypeScript\n  * Step 4: Set Up Environment Variables\n  * Step 5: Wallet Setup\n    * Development Wallet\n    * Get Test Tokens\n  * Step 6: Verify Setup\n  * Project Structure\n  * Supported Networks\n  * Next Steps\n  * Common Issues\n    * \"Module not found\" errors\n    * \"Cannot find module 'viem'\"\n    * RPC rate limiting\n    * TypeScript errors with viem",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/learn/getting-started/quickstart",
    "text": "* [](/)\n  * Getting Started\n  * Quickstart\n\nOn this page\n\n# Quickstart Guide\n\nThis guide provides a step-by-step walkthrough of integrating with the Yellow Network using the Nitrolite SDK. We will build a script to connect to the network, authenticate, manage state channels, and transfer funds.\n\n## Prerequisitesâ€‹\n\n  * [Node.js](https://nodejs.org/) (v18 or higher)\n  * [npm](https://www.npmjs.com/)\n\n## Setupâ€‹\n\n  1. **Install Dependencies**\n         \n         npm install  \n         \n\n  2. **Environment Variables**\n\nCreate a `.env` file in your project root:\n         \n         # .env  \n         PRIVATE_KEY=your_sepolia_private_key_here  \n         ALCHEMY_RPC_URL=your_alchemy_rpc_url_here  \n         \n\n\n## 1\\. Getting Fundsâ€‹\n\nBefore we write code, you need test tokens (`ytest.usd`). In the Sandbox, these tokens land in your **Unified Balance** (Off-Chain), which sits in the Yellow Network's clearing layer.\n\nRequest tokens via the Faucet:\n    \n    \n    curl -XPOST https://clearnet-sandbox.yellow.com/faucet/requestTokens \\  \n      -H \"Content-Type: application/json\" \\  \n      -d '{\"userAddress\":\"<your_wallet_address>\"}'  \n    \n\n## 2\\. Initializationâ€‹\n\nFirst, we setup the `NitroliteClient` with Viem. This client handles all communication with the Yellow Network nodes and smart contracts.\n    \n    \n    import { NitroliteClient, WalletStateSigner, createECDSAMessageSigner } from '@erc7824/nitrolite';  \n    import { createPublicClient, createWalletClient, http } from 'viem';  \n    import { sepolia } from 'viem/chains';  \n    import { privateKeyToAccount } from 'viem/accounts';  \n    import WebSocket from 'ws';  \n    import 'dotenv/config';  \n      \n    // Setup Viem Clients  \n    const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);  \n    const publicClient = createPublicClient({ chain: sepolia, transport: http(process.env.ALCHEMY_RPC_URL) });  \n    const walletClient = createWalletClient({ chain: sepolia, transport: http(), account });  \n      \n    // Initialize Nitrolite Client  \n    const client = new NitroliteClient({  \n        publicClient,  \n        walletClient,  \n        stateSigner: new WalletStateSigner(walletClient),  \n        addresses: {  \n            custody: '0x019B65A265EB3363822f2752141b3dF16131b262',  \n            adjudicator: '0x7c7ccbc98469190849BCC6c926307794fDfB11F2',  \n        },  \n        chainId: sepolia.id,  \n        challengeDuration: 3600n,  \n    });  \n      \n    // Connect to Sandbox Node  \n    const ws = new WebSocket('wss://clearnet-sandbox.yellow.com/ws');  \n    \n\n## 3\\. Authenticationâ€‹\n\nAuthentication involves generating a temporary **Session Key** and verifying your identity using your main wallet (EIP-712).\n    \n    \n    // Generate temporary session key  \n    const sessionPrivateKey = generatePrivateKey();  \n    const sessionSigner = createECDSAMessageSigner(sessionPrivateKey);  \n    const sessionAccount = privateKeyToAccount(sessionPrivateKey);  \n      \n    // Send auth request  \n    const authRequestMsg = await createAuthRequestMessage({  \n        address: account.address,  \n        application: 'Test app',  \n        session_key: sessionAccount.address,  \n        allowances: [{ asset: 'ytest.usd', amount: '1000000000' }],  \n        expires_at: BigInt(Math.floor(Date.now() / 1000) + 3600), // 1 hour  \n        scope: 'test.app',  \n    });  \n    ws.send(authRequestMsg);  \n      \n    // Handle Challenge (in ws.onmessage)  \n    if (type === 'auth_challenge') {  \n        const challenge = response.res[2].challenge_message;  \n        // Sign with MAIN wallet  \n        const signer = createEIP712AuthMessageSigner(walletClient, authParams, { name: 'Test app' });  \n        const verifyMsg = await createAuthVerifyMessageFromChallenge(signer, challenge);  \n        ws.send(verifyMsg);  \n    }  \n    \n\n## 4\\. Channel Lifecycleâ€‹\n\n### Creating a Channelâ€‹\n\nIf no channel exists, we request the Node to open one.\n    \n    \n    const createChannelMsg = await createCreateChannelMessage(  \n        sessionSigner, // Sign with session key  \n        {  \n            chain_id: 11155111, // Sepolia  \n            token: '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238', // ytest.usd  \n        }  \n    );  \n    ws.send(createChannelMsg);  \n      \n    // Listen for 'create_channel' response, then submit to chain  \n    const createResult = await client.createChannel({  \n        channel,  \n        unsignedInitialState,  \n        serverSignature,  \n    });  \n    \n\n### Funding (Resizing)â€‹\n\nTo fund the channel, we perform a \"Resize\". Since your funds are in your **Unified Balance** (from the Faucet), we use `allocate_amount` to move them into the Channel.\n\n> **Important:** Do NOT use `resize_amount` unless you have deposited funds directly into the L1 Custody Contract.\n    \n    \n    const resizeMsg = await createResizeChannelMessage(  \n        sessionSigner,  \n        {  \n            channel_id: channelId,  \n            allocate_amount: 20n, // Moves 20 units from Unified Balance -> Channel  \n            funds_destination: account.address,  \n        }  \n    );  \n    ws.send(resizeMsg);  \n      \n    // Submit resize proof to chain  \n    await client.resizeChannel({ resizeState, proofStates });  \n    \n\n### Closing & Withdrawingâ€‹\n\nFinally, we cooperatively close the channel. This settles the balance on the L1 Custody Contract, allowing you to withdraw.\n    \n    \n    // Close Channel  \n    const closeMsg = await createCloseChannelMessage(sessionSigner, channelId, account.address);  \n    ws.send(closeMsg);  \n      \n    // Submit close to chain  \n    await client.closeChannel({ finalState, stateData });  \n      \n    // Withdraw from Custody Contract to Wallet  \n    const withdrawalTx = await client.withdrawal(tokenAddress, withdrawableBalance);  \n    console.log('Funds withdrawn:', withdrawalTx);  \n    \n\n## Troubleshootingâ€‹\n\nHere are common issues and solutions:\n\n  * **`InsufficientBalance`** :\n\n    * **Cause** : Trying to use `resize_amount` (L1 funds) without depositing first.\n    * **Fix** : Use `allocate_amount` to fund from your Off-chain Unified Balance (Faucet).\n  * **`DepositAlreadyFulfilled`** :\n\n    * **Cause** : Double-submitting a funding request or channel creation.\n    * **Fix** : Check if the channel is already open or funded before sending requests.\n  * **`InvalidState`** :\n\n    * **Cause** : Resizing a closed channel or version mismatch.\n    * **Fix** : Ensure you are using the latest channel state from the Node.\n  * **`operation denied: non-zero allocation`** :\n\n    * **Cause** : Too many \"stale\" channels open.\n    * **Fix** : Run the cleanup script `npx tsx close_all.ts`.\n  * **Timeout waiting for User to fund Custody** :\n\n    * **Cause** : Re-running scripts without closing channels accumulates balance requirements.\n    * **Fix** : Run `close_all.ts` to reset.\n\n### Cleanup Scriptâ€‹\n\nIf you get stuck, use this script to close all open channels:\n    \n    \n    npx tsx close_all.ts  \n    \n\n## Complete Codeâ€‹\n\n### index.tsâ€‹\n\nClick to view full index.ts\n    \n    \n    import {  \n        NitroliteClient,  \n        WalletStateSigner,  \n        createTransferMessage,  \n        createGetConfigMessage,  \n        createECDSAMessageSigner,  \n        createEIP712AuthMessageSigner,  \n        createAuthVerifyMessageFromChallenge,  \n        createCreateChannelMessage,  \n        createResizeChannelMessage,  \n        createGetLedgerBalancesMessage,  \n        createAuthRequestMessage,  \n        createCloseChannelMessage  \n    } from '@erc7824/nitrolite';  \n    import type {  \n        RPCNetworkInfo,  \n        RPCAsset,  \n        RPCData  \n    } from '@erc7824/nitrolite';  \n    import { createPublicClient, createWalletClient, http } from 'viem';  \n    import { sepolia } from 'viem/chains';  \n    import { privateKeyToAccount, generatePrivateKey } from 'viem/accounts';  \n    import WebSocket from 'ws';  \n    import 'dotenv/config';  \n    import * as readline from 'readline';  \n      \n    console.log('Starting script...');  \n      \n    // Helper to prompt for input  \n    const askQuestion = (query: string): Promise<string> => {  \n        const rl = readline.createInterface({  \n            input: process.stdin,  \n            output: process.stdout,  \n        });  \n        return new Promise(resolve => rl.question(query, ans => {  \n            rl.close();  \n            resolve(ans);  \n        }));  \n    };  \n      \n    // Your wallet private key (use environment variables in production!)  \n    let PRIVATE_KEY = process.env.PRIVATE_KEY as `0x${string}`;  \n      \n    if (!PRIVATE_KEY) {  \n        console.log('PRIVATE_KEY not found in .env');  \n        const inputKey = await askQuestion('Please enter your Private Key: ');  \n        if (!inputKey) {  \n            throw new Error('Private Key is required');  \n        }  \n        PRIVATE_KEY = inputKey.startsWith('0x') ? inputKey as `0x${string}` : `0x${inputKey}` as `0x${string}`;  \n    }  \n      \n    const account = privateKeyToAccount(PRIVATE_KEY);  \n      \n    // Create viem clients  \n    const ALCHEMY_RPC_URL = process.env.ALCHEMY_RPC_URL;  \n    const FALLBACK_RPC_URL = 'https://1rpc.io/sepolia'; // Public fallback  \n      \n    const publicClient = createPublicClient({  \n        chain: sepolia,  \n        transport: http(ALCHEMY_RPC_URL || FALLBACK_RPC_URL),  \n    });  \n      \n    const walletClient = createWalletClient({  \n        chain: sepolia,  \n        transport: http(),  \n        account,  \n    });  \n      \n    interface Config {  \n        assets?: RPCAsset[];  \n        networks?: RPCNetworkInfo[];  \n        [key: string]: any;  \n    }  \n      \n    async function fetchConfig(): Promise<Config> {  \n        const signer = createECDSAMessageSigner(PRIVATE_KEY);  \n        const message = await createGetConfigMessage(signer);  \n      \n        const ws = new WebSocket('wss://clearnet-sandbox.yellow.com/ws');  \n      \n        return new Promise((resolve, reject) => {  \n            ws.onopen = () => {  \n                ws.send(message);  \n            };  \n      \n            ws.onmessage = (event) => {  \n                try {  \n                    const response = JSON.parse(event.data.toString());  \n                    // Response format: [requestId, method, result, timestamp]  \n                    // or NitroliteRPCMessage structure depending on implementation  \n                    // Based on types: NitroliteRPCMessage { res: RPCData }  \n                    // RPCData: [RequestID, RPCMethod, object, Timestamp?]  \n      \n                    if (response.res && response.res[2]) {  \n                        resolve(response.res[2] as Config);  \n                        ws.close();  \n                    } else if (response.error) {  \n                        reject(new Error(response.error.message || 'Unknown RPC error'));  \n                        ws.close();  \n                    }  \n                } catch (err) {  \n                    reject(err);  \n                    ws.close();  \n                }  \n            };  \n      \n            ws.onerror = (error) => {  \n                reject(error);  \n                ws.close();  \n            };  \n        });  \n    }  \n      \n    // Initialize Nitrolite client  \n    console.log('Fetching configuration...');  \n    const config = await fetchConfig();  \n    console.log('Configuration fetched. Assets count:', config.assets?.length);  \n      \n    const client = new NitroliteClient({  \n        publicClient,  \n        walletClient,  \n        // Use WalletStateSigner for signing states  \n        stateSigner: new WalletStateSigner(walletClient),  \n        // Contract addresses  \n        addresses: {  \n            custody: '0x019B65A265EB3363822f2752141b3dF16131b262',  \n            adjudicator: '0x7c7ccbc98469190849BCC6c926307794fDfB11F2',  \n        },  \n        chainId: sepolia.id,  \n        challengeDuration: 3600n, // 1 hour challenge period  \n    });  \n      \n    console.log('âœ“ Client initialized');  \n    console.log('  Wallet Address:', account.address);  \n    console.log('  (Please ensure this address has Sepolia ETH)');  \n      \n    // Connect to Clearnode WebSocket (using sandbox for testing)  \n    const ws = new WebSocket('wss://clearnet-sandbox.yellow.com/ws');  \n      \n    // Step 1: Generate session keypair locally  \n    const sessionPrivateKey = generatePrivateKey();  \n    const sessionAccount = privateKeyToAccount(sessionPrivateKey);  \n    const sessionAddress = sessionAccount.address;  \n      \n    // Helper: Create a signer for the session key  \n    const sessionSigner = createECDSAMessageSigner(sessionPrivateKey);  \n      \n    // Step 2: Send auth_request  \n    const authParams = {  \n        session_key: sessionAddress,        // Session key you generated  \n        allowances: [{                      // Add allowance for ytest.usd  \n            asset: 'ytest.usd',  \n            amount: '1000000000'            // Large amount  \n        }],  \n        expires_at: BigInt(Math.floor(Date.now() / 1000) + 3600), // 1 hour in seconds  \n        scope: 'test.app',  \n    };  \n      \n    const authRequestMsg = await createAuthRequestMessage({  \n        address: account.address,           // Your main wallet address  \n        application: 'Test app',            // Match domain name  \n        ...authParams  \n    });  \n      \n    // We need to capture channelId to close it.  \n    let activeChannelId: string | undefined;  \n      \n    // Helper function to trigger resize  \n    const triggerResize = async (channelId: string, token: string, skipResize: boolean = false) => {  \n        console.log('  Using existing channel:', channelId);  \n      \n        // Add delay to ensure Node indexes the channel  \n        console.log('  Waiting 5s for Node to index channel...');  \n        await new Promise(resolve => setTimeout(resolve, 5000));  \n      \n        // For withdrawal, we don't need to check user balance or allowance  \n        // because the Node (counterparty) is the one depositing funds.  \n      \n      \n        // For withdrawal, we don't deposit (we are withdrawing off-chain funds).  \n        // -------------------------------------------------------------------  \n        // 3. Fund Channel (Resize)  \n        // -------------------------------------------------------------------  \n        // We use 'allocate_amount' to move funds from the User's Unified Balance (off-chain)  \n        // into the Channel. This assumes the user has funds in their Unified Balance (e.g. from faucet).  \n      \n        const amountToFund = 20n;  \n        if (!skipResize) console.log('\\nRequesting resize to fund channel with 20 tokens...');  \n      \n        if (!skipResize) {  \n            const resizeMsg = await createResizeChannelMessage(  \n                sessionSigner,  \n                {  \n                    channel_id: channelId as `0x${string}`,  \n                    // resize_amount: 10n, // <-- This requires L1 funds in Custody (which we don't have)  \n                    allocate_amount: amountToFund,  // <-- This pulls from Unified Balance (Faucet) (Variable name adjusted)  \n                    funds_destination: account.address,  \n                }  \n            );  \n      \n            ws.send(resizeMsg);  \n      \n            // Wait for resize confirmation  \n            console.log('  Waiting for resize confirmation...');  \n            await new Promise<void>((resolve, reject) => {  \n                const timeout = setTimeout(() => reject(new Error('Resize timeout')), 30000);  \n                const handler = (data: any) => {  \n                    const msg = JSON.parse(data.toString());  \n                    if (msg.res && msg.res[1] === 'resize_channel') {  \n                        const payload = msg.res[2];  \n                        if (payload.channel_id === channelId) {  \n                            clearTimeout(timeout);  \n                            ws.off('message', handler);  \n                            resolve();  \n                        }  \n                    }  \n                };  \n                ws.on('message', handler);  \n            });  \n      \n            // Wait for balance update  \n            await new Promise(r => setTimeout(r, 2000));  \n            console.log('âœ“ Resize complete.');  \n        } else {  \n            console.log('  Skipping resize step (already funded).');  \n        }  \n      \n        // Verify Channel Balance  \n        const channelBalances = await publicClient.readContract({  \n            address: client.addresses.custody,  \n            abi: [{  \n                name: 'getChannelBalances',  \n                type: 'function',  \n                stateMutability: 'view',  \n                inputs: [{ name: 'channelId', type: 'bytes32' }, { name: 'tokens', type: 'address[]' }],  \n                outputs: [{ name: 'balances', type: 'uint256[]' }]  \n            }],  \n            functionName: 'getChannelBalances',  \n            args: [channelId as `0x${string}`, [token as `0x${string}`]],  \n        }) as bigint[];  \n        console.log(`âœ“ Channel funded with ${channelBalances[0]} USDC`);  \n      \n        // Check User Balance again  \n        let finalUserBalance = 0n;  \n        try {  \n            const result = await publicClient.readContract({  \n                address: client.addresses.custody,  \n                abi: [{  \n                    type: 'function',  \n                    name: 'getAccountsBalances',  \n                    inputs: [{ name: 'users', type: 'address[]' }, { name: 'tokens', type: 'address[]' }],  \n                    outputs: [{ type: 'uint256[]' }],  \n                    stateMutability: 'view'  \n                }] as const,  \n                functionName: 'getAccountsBalances',  \n                args: [[client.account.address], [token as `0x${string}`]],  \n            }) as bigint[];  \n            finalUserBalance = result[0];  \n            console.log(`âœ“ User Custody Balance after resize: ${finalUserBalance}`);  \n        } catch (e) {  \n            console.warn('    Error checking final user balance:', e);  \n        }  \n      \n        // -------------------------------------------------------------------  \n        // 4. Off-Chain Transfer  \n        // -------------------------------------------------------------------  \n    };  \n      \n    // State to prevent infinite auth loops  \n    let isAuthenticated = false;  \n      \n    // Step 3: Sign the challenge with your MAIN wallet (EIP-712)  \n    ws.onmessage = async (event) => {  \n        const response = JSON.parse(event.data.toString());  \n        console.log('Received WS message:', JSON.stringify(response, null, 2));  \n      \n        if (response.error) {  \n            console.error('RPC Error:', response.error);  \n            process.exit(1); // Exit on error to prevent infinite loops  \n        }  \n      \n        if (response.res && response.res[1] === 'auth_challenge') {  \n            if (isAuthenticated) {  \n                console.log('  Ignoring auth_challenge (already authenticated)');  \n                return;  \n            }  \n      \n            const challenge = response.res[2].challenge_message;  \n      \n            // Create EIP-712 typed data signature with main wallet  \n            const signer = createEIP712AuthMessageSigner(  \n                walletClient,  \n                authParams,  \n                { name: 'Test app' }  \n            );  \n      \n            // Send auth_verify using builder  \n            // We sign with the MAIN wallet for the first verification  \n            const verifyMsg = await createAuthVerifyMessageFromChallenge(  \n                signer,  \n                challenge  \n            );  \n      \n            ws.send(verifyMsg);  \n        }  \n      \n        if (response.res && response.res[1] === 'auth_verify') {  \n            console.log('âœ“ Authenticated successfully');  \n            isAuthenticated = true; // Mark as authenticated  \n            const sessionKey = response.res[2].session_key;  \n            console.log('  Session key:', sessionKey);  \n            console.log('  JWT token received');  \n      \n            // Query Ledger Balances  \n            const ledgerMsg = await createGetLedgerBalancesMessage(  \n                sessionSigner,  \n                account.address,  \n                Date.now()  \n            );  \n            ws.send(ledgerMsg);  \n            console.log('  Sent get_ledger_balances request...');  \n      \n            // Wait for 'channels' message to proceed  \n      \n        }  \n      \n        if (response.res && response.res[1] === 'channels') {  \n            const channels = response.res[2].channels;  \n            const openChannel = channels.find((c: any) => c.status === 'open');  \n      \n            // Derive token  \n            const chainId = sepolia.id;  \n            const supportedAsset = (config.assets as any)?.find((a: any) => a.chain_id === chainId);  \n            const token = supportedAsset ? supportedAsset.token : '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238';  \n      \n            if (openChannel) {  \n                console.log('âœ“ Found existing open channel');  \n      \n                // CORRECT: Check if channel is already funded  \n                const currentAmount = BigInt(openChannel.amount || 0); // Need to parse amount  \n                // Wait, standard RPC returns strings. Let's rely on openChannel structure.  \n                // openChannel object from logs: { ..., amount: \"40\", ... }  \n      \n                if (BigInt(openChannel.amount) >= 20n) {  \n                    console.log(`  Channel already funded with ${openChannel.amount} USDC.`);  \n                    console.log('  Skipping resize to avoid \"Insufficient Balance\" errors.');  \n                    // Call triggerResize but indicate skipping actual resize  \n                    await triggerResize(openChannel.channel_id, token, true);  \n                } else {  \n                    await triggerResize(openChannel.channel_id, token, false);  \n                }  \n            } else {  \n                console.log('  No existing open channel found, creating new one...');  \n                console.log('  Using token:', token, 'for chain:', chainId);  \n      \n                // Request channel creation  \n                const createChannelMsg = await createCreateChannelMessage(  \n                    sessionSigner,  \n                    {  \n                        chain_id: 11155111, // Sepolia  \n                        token: token,  \n                    }  \n                );  \n                ws.send(createChannelMsg);  \n            }  \n        }  \n      \n        if (response.res && response.res[1] === 'create_channel') {  \n            const { channel_id, channel, state, server_signature } = response.res[2];  \n            activeChannelId = channel_id;  \n      \n            console.log('âœ“ Channel prepared:', channel_id);  \n            console.log('  State object:', JSON.stringify(state, null, 2));  \n      \n            // Transform state object to match UnsignedState interface  \n            const unsignedInitialState = {  \n                intent: state.intent,  \n                version: BigInt(state.version),  \n                data: state.state_data, // Map state_data to data  \n                allocations: state.allocations.map((a: any) => ({  \n                    destination: a.destination,  \n                    token: a.token,  \n                    amount: BigInt(a.amount),  \n                })),  \n            };  \n      \n            // Submit to blockchain  \n            const createResult = await client.createChannel({  \n                channel,  \n                unsignedInitialState,  \n                serverSignature: server_signature,  \n            });  \n      \n            // createChannel returns an object { txHash, ... } or just hash depending on version.  \n            // Based on logs: { channelId: ..., initialState: ..., txHash: ... }  \n            // We need to handle both or just the object.  \n            const txHash = typeof createResult === 'string' ? createResult : createResult.txHash;  \n      \n            console.log('âœ“ Channel created on-chain:', txHash);  \n            console.log('  Waiting for transaction confirmation...');  \n            await publicClient.waitForTransactionReceipt({ hash: txHash });  \n            console.log('âœ“ Transaction confirmed');  \n      \n            // Retrieve token from allocations  \n      \n            const token = state.allocations[0].token;  \n            await triggerResize(channel_id, token, false);  \n        }  \n      \n        if (response.res && response.res[1] === 'resize_channel') {  \n            const { channel_id, state, server_signature } = response.res[2];  \n      \n            console.log('âœ“ Resize prepared');  \n            console.log('  Server returned allocations:', JSON.stringify(state.allocations, null, 2));  \n      \n            // Construct the resize state object expected by the SDK  \n            const resizeState = {  \n                intent: state.intent,  \n                version: BigInt(state.version),  \n                data: state.state_data || state.data, // Handle potential naming differences  \n                allocations: state.allocations.map((a: any) => ({  \n                    destination: a.destination,  \n                    token: a.token,  \n                    amount: BigInt(a.amount),  \n                })),  \n                channelId: channel_id,  \n                serverSignature: server_signature,  \n            };  \n      \n            console.log('DEBUG: resizeState:', JSON.stringify(resizeState, (key, value) =>  \n                typeof value === 'bigint' ? value.toString() : value, 2));  \n      \n            let proofStates: any[] = [];  \n            try {  \n                const onChainData = await client.getChannelData(channel_id as `0x${string}`);  \n                console.log('DEBUG: On-chain channel data:', JSON.stringify(onChainData, (key, value) =>  \n                    typeof value === 'bigint' ? value.toString() : value, 2));  \n                if (onChainData.lastValidState) {  \n                    proofStates = [onChainData.lastValidState];  \n                }  \n            } catch (e) {  \n                console.log('DEBUG: Failed to fetch on-chain data:', e);  \n            }  \n      \n            // Calculate total required for the token  \n            const token = resizeState.allocations[0].token;  \n            const requiredAmount = resizeState.allocations.reduce((sum: bigint, a: any) => {  \n                if (a.token === token) return sum + BigInt(a.amount);  \n                return sum;  \n            }, 0n);  \n      \n            console.log(`  Waiting for channel funding (Required: ${requiredAmount})...`);  \n      \n            // Poll for User's Custody Balance (since User allocation is increasing)  \n            let userBalance = 0n;  \n            let retries = 0;  \n            const userAddress = client.account.address;  \n      \n            console.log(`  Checking User Custody Balance for ${userAddress}... [v2]`);  \n      \n            // Check initial balance first  \n            try {  \n                const result = await publicClient.readContract({  \n                    address: client.addresses.custody,  \n                    abi: [  \n                        {  \n                            type: 'function',  \n                            name: 'getAccountsBalances',  \n                            inputs: [  \n                                { name: 'users', type: 'address[]' },  \n                                { name: 'tokens', type: 'address[]' }  \n                            ],  \n                            outputs: [{ type: 'uint256[]' }],  \n                            stateMutability: 'view'  \n                        }  \n                    ] as const,  \n                    functionName: 'getAccountsBalances',  \n                    args: [[userAddress], [token as `0x${string}`]],  \n                }) as bigint[];  \n                userBalance = result[0];  \n            } catch (e) {  \n                console.warn('    Error checking initial user balance:', e);  \n            }  \n      \n            console.log('  Skipping L1 deposit (using off-chain faucet funds)...');  \n      \n            if (true) { // Skip the wait loop as we just deposited  \n                // Define ABI fragment for getAccountsBalances  \n                const custodyAbiFragment = [  \n                    {  \n                        type: 'function',  \n                        name: 'getAccountsBalances',  \n                        inputs: [  \n                            { name: 'users', type: 'address[]' },  \n                            { name: 'tokens', type: 'address[]' }  \n                        ],  \n                        outputs: [{ type: 'uint256[]' }],  \n                        stateMutability: 'view'  \n                    }  \n                ] as const;  \n      \n                while (retries < 30) { // Wait up to 60 seconds  \n                    try {  \n                        const result = await publicClient.readContract({  \n                            address: client.addresses.custody,  \n                            abi: custodyAbiFragment,  \n                            functionName: 'getAccountsBalances',  \n                            args: [[userAddress], [token as `0x${string}`]],  \n                        }) as bigint[];  \n      \n                        userBalance = result[0];  \n                    } catch (e) {  \n                        console.warn('    Error checking user balance:', e);  \n                    }  \n      \n                    if (userBalance >= requiredAmount) {  \n                        console.log(`âœ“ User funded in Custody (Balance: ${userBalance})`);  \n                        break;  \n                    }  \n                    await new Promise(r => setTimeout(r, 2000));  \n                    retries++;  \n                    if (retries % 5 === 0) console.log(`    User Custody Balance: ${userBalance}, Waiting...`);  \n                }  \n      \n                if (userBalance < requiredAmount) {  \n                    console.error('Timeout waiting for User to fund Custody account');  \n                    console.warn('Proceeding with resize despite low user balance...');  \n                }  \n            } else {  \n                console.log(`âœ“ User funded in Custody (Balance: ${userBalance})`);  \n            }  \n      \n            console.log('  Submitting resize to chain...');  \n            // Submit to blockchain  \n            const { txHash } = await client.resizeChannel({  \n                resizeState,  \n                proofStates: proofStates,  \n            });  \n      \n            console.log('âœ“ Channel resized on-chain:', txHash);  \n            console.log('âœ“ Channel funded with 20 USDC');  \n      \n            // Skip Transfer for debugging  \n            console.log('  Skipping transfer to verify withdrawal amount...');  \n            console.log('  Debug: channel_id =', channel_id);  \n      \n            // Wait for server to sync state  \n            await new Promise(r => setTimeout(r, 3000));  \n      \n            if (channel_id) {  \n                console.log('  Closing channel:', channel_id);  \n                const closeMsg = await createCloseChannelMessage(  \n                    sessionSigner,  \n                    channel_id as `0x${string}`,  \n                    account.address  \n                );  \n                ws.send(closeMsg);  \n            } else {  \n                console.log('  No channel ID available to close.');  \n            }  \n        }  \n        // const secondaryAddress = '0x7df1fef832b57e46de2e1541951289c04b2781aa';  \n        // console.log(`  Attempting Transfer to Secondary Wallet: ${secondaryAddress}...`);  \n      \n        // const transferMsg = await createTransferMessage(  \n        //     sessionSigner,  \n        //     {  \n        //         destination: secondaryAddress,  \n        //         allocations: [{  \n        //             asset: 'ytest.usd',  \n        //             amount: '10'  \n        //         }]  \n        //     },  \n        //     Date.now()  \n        // );  \n        // ws.send(transferMsg);  \n        // console.log('  Sent transfer request...');  \n      \n        // if (response.res && response.res[1] === 'transfer') {  \n        //     console.log('âœ“ Transfer complete!');  \n        //     console.log('  Amount: 10 USDC');  \n      \n        //     if (activeChannelId) {  \n        //         console.log('  Closing channel:', activeChannelId);  \n        //         const closeMsg = await createCloseChannelMessage(  \n        //             sessionSigner,  \n        //             activeChannelId as `0x${string}`,  \n        //             account.address  \n        //         );  \n        //         ws.send(closeMsg);  \n        //     } else {  \n        //         console.log('  No active channel ID to close.');  \n        //     }  \n        // }  \n      \n        if (response.res && response.res[1] === 'close_channel') {  \n            const { channel_id, state, server_signature } = response.res[2];  \n            console.log('âœ“ Close prepared');  \n            console.log('  Submitting close to chain...');  \n      \n            // Submit to blockchain  \n            const txHash = await client.closeChannel({  \n                finalState: {  \n                    intent: state.intent,  \n                    version: BigInt(state.version),  \n                    data: state.state_data || state.data,  \n                    allocations: state.allocations.map((a: any) => ({  \n                        destination: a.destination,  \n                        token: a.token,  \n                        amount: BigInt(a.amount),  \n                    })),  \n                    channelId: channel_id,  \n                    serverSignature: server_signature,  \n                },  \n                stateData: state.state_data || state.data || '0x',  \n            });  \n      \n            console.log('âœ“ Channel closed on-chain:', txHash);  \n      \n            // Withdraw funds  \n            console.log('  Withdrawing funds...');  \n            const token = state.allocations[0].token;  \n      \n            await new Promise(r => setTimeout(r, 2000)); // Wait for close to settle  \n      \n            let withdrawableBalance = 0n;  \n            try {  \n                const result = await publicClient.readContract({  \n                    address: client.addresses.custody,  \n                    abi: [{  \n                        type: 'function',  \n                        name: 'getAccountsBalances',  \n                        inputs: [{ name: 'users', type: 'address[]' }, { name: 'tokens', type: 'address[]' }],  \n                        outputs: [{ type: 'uint256[]' }],  \n                        stateMutability: 'view'  \n                    }] as const,  \n                    functionName: 'getAccountsBalances',  \n                    args: [[client.account.address], [token as `0x${string}`]],  \n                }) as bigint[];  \n                withdrawableBalance = result[0];  \n                console.log(`âœ“ User Custody Balance (Withdrawable): ${withdrawableBalance}`);  \n            } catch (e) {  \n                console.warn('    Error checking withdrawable balance:', e);  \n            }  \n      \n            if (withdrawableBalance > 0n) {  \n                console.log(`  Withdrawing ${withdrawableBalance} of ${token}...`);  \n                const withdrawalTx = await client.withdrawal(token as `0x${string}`, withdrawableBalance);  \n                console.log('âœ“ Funds withdrawn:', withdrawalTx);  \n            } else {  \n                console.log('  No funds to withdraw.');  \n            }  \n      \n            process.exit(0);  \n        }  \n    };  \n      \n    // Start the flow  \n    if (ws.readyState === WebSocket.OPEN) {  \n        ws.send(authRequestMsg);  \n    } else {  \n        ws.on('open', () => {  \n            ws.send(authRequestMsg);  \n        });  \n    }  \n    \n\n### close_all.tsâ€‹\n\nClick to view full close_all.ts\n    \n    \n    import {  \n        NitroliteClient,  \n        WalletStateSigner,  \n        createECDSAMessageSigner,  \n        createEIP712AuthMessageSigner,  \n        createAuthRequestMessage,  \n        createAuthVerifyMessageFromChallenge,  \n        createCloseChannelMessage,  \n    } from '@erc7824/nitrolite';  \n    import { createPublicClient, createWalletClient, http } from 'viem';  \n    import { sepolia } from 'viem/chains';  \n    import { privateKeyToAccount, generatePrivateKey } from 'viem/accounts';  \n    import WebSocket from 'ws';  \n    import 'dotenv/config';  \n    import * as readline from 'readline';  \n      \n    // Helper to prompt for input  \n    const askQuestion = (query: string): Promise<string> => {  \n        const rl = readline.createInterface({  \n            input: process.stdin,  \n            output: process.stdout,  \n        });  \n        return new Promise(resolve => rl.question(query, ans => {  \n            rl.close();  \n            resolve(ans);  \n        }));  \n    };  \n      \n    // Configuration  \n    const WS_URL = 'wss://clearnet-sandbox.yellow.com/ws';  \n      \n    async function main() {  \n        console.log('Starting cleanup script...');  \n      \n        // Setup Viem Clients  \n        let PRIVATE_KEY = process.env.PRIVATE_KEY as `0x${string}`;  \n      \n        if (!PRIVATE_KEY) {  \n            console.log('PRIVATE_KEY not found in .env');  \n            const inputKey = await askQuestion('Please enter your Private Key: ');  \n            if (!inputKey) {  \n                throw new Error('Private Key is required');  \n            }  \n            PRIVATE_KEY = inputKey.startsWith('0x') ? inputKey as `0x${string}` : `0x${inputKey}` as `0x${string}`;  \n        }  \n      \n        const account = privateKeyToAccount(PRIVATE_KEY);  \n      \n        const ALCHEMY_RPC_URL = process.env.ALCHEMY_RPC_URL;  \n        const FALLBACK_RPC_URL = 'https://1rpc.io/sepolia'; // Public fallback  \n        const RPC_URL = ALCHEMY_RPC_URL || FALLBACK_RPC_URL;  \n        const publicClient = createPublicClient({  \n            chain: sepolia,  \n            transport: http(RPC_URL),  \n        });  \n        const walletClient = createWalletClient({  \n            account,  \n            chain: sepolia,  \n            transport: http(RPC_URL),  \n        });  \n      \n        // Initialize Nitrolite Client  \n        const client = new NitroliteClient({  \n            publicClient,  \n            walletClient,  \n            addresses: {  \n                custody: '0x019B65A265EB3363822f2752141b3dF16131b262',  \n                adjudicator: '0x7c7ccbc98469190849BCC6c926307794fDfB11F2',  \n            },  \n            challengeDuration: 3600n,  \n            chainId: sepolia.id,  \n            stateSigner: new WalletStateSigner(walletClient),  \n        });  \n      \n        // Connect to WebSocket  \n        const ws = new WebSocket(WS_URL);  \n        const sessionPrivateKey = generatePrivateKey();  \n        const sessionSigner = createECDSAMessageSigner(sessionPrivateKey);  \n        const sessionAccount = privateKeyToAccount(sessionPrivateKey);  \n      \n        await new Promise<void>((resolve, reject) => {  \n            ws.on('open', () => resolve());  \n            ws.on('error', (err) => reject(err));  \n        });  \n        console.log('âœ“ Connected to WebSocket');  \n      \n        // Authenticate  \n        const authParams = {  \n            session_key: sessionAccount.address,  \n            allowances: [{ asset: 'ytest.usd', amount: '1000000000' }],  \n            expires_at: BigInt(Math.floor(Date.now() / 1000) + 3600),  \n            scope: 'test.app',  \n        };  \n      \n        const authRequestMsg = await createAuthRequestMessage({  \n            address: account.address,  \n            application: 'Test app',  \n            ...authParams  \n        });  \n        ws.send(authRequestMsg);  \n      \n        ws.on('message', async (data) => {  \n            const response = JSON.parse(data.toString());  \n      \n            if (response.res) {  \n                const type = response.res[1];  \n      \n                if (type === 'auth_challenge') {  \n                    const challenge = response.res[2].challenge_message;  \n                    const signer = createEIP712AuthMessageSigner(walletClient, authParams, { name: 'Test app' });  \n                    const verifyMsg = await createAuthVerifyMessageFromChallenge(signer, challenge);  \n                    ws.send(verifyMsg);  \n                }  \n      \n                if (type === 'auth_verify') {  \n                    console.log('âœ“ Authenticated');  \n      \n                    // Fetch open channels from L1 Contract  \n                    console.log('Fetching open channels from L1...');  \n                    try {  \n                        const openChannelsL1 = await client.getOpenChannels();  \n                        console.log(`Found ${openChannelsL1.length} open channels on L1.`);  \n      \n                        if (openChannelsL1.length === 0) {  \n                            console.log('No open channels on L1 to close.');  \n                            process.exit(0);  \n                        }  \n      \n                        // Iterate and close  \n                        for (const channelId of openChannelsL1) {  \n                            console.log(`Attempting to close channel ${channelId}...`);  \n      \n                            // Send close request to Node  \n                            const closeMsg = await createCloseChannelMessage(  \n                                sessionSigner,  \n                                channelId,  \n                                account.address  \n                            );  \n                            ws.send(closeMsg);  \n      \n                            // Small delay to avoid rate limits  \n                            await new Promise(r => setTimeout(r, 500));  \n                        }  \n      \n                    } catch (e) {  \n                        console.error('Error fetching L1 channels:', e);  \n                        process.exit(1);  \n                    }  \n                }  \n      \n                if (type === 'close_channel') {  \n                    const { channel_id, state, server_signature } = response.res[2];  \n                    console.log(`âœ“ Node signed close for ${channel_id}`);  \n      \n                    const finalState = {  \n                        intent: state.intent,  \n                        version: BigInt(state.version),  \n                        data: state.state_data,  \n                        allocations: state.allocations.map((a: any) => ({  \n                            destination: a.destination,  \n                            token: a.token,  \n                            amount: BigInt(a.amount),  \n                        })),  \n                        channelId: channel_id,  \n                        serverSignature: server_signature,  \n                    };  \n      \n                    try {  \n                        console.log(`  Submitting close to L1 for ${channel_id}...`);  \n                        const txHash = await client.closeChannel({  \n                            finalState,  \n                            stateData: finalState.data  \n                        });  \n                        console.log(`âœ“ Closed on-chain: ${txHash}`);  \n                    } catch (e) {  \n                        // If it fails (e.g. already closed or race condition), just log and continue  \n                        console.error(`Failed to close ${channel_id} on-chain:`, e);  \n                    }  \n                }  \n      \n                if (response.error) {  \n                    console.error('WS Error:', response.error);  \n                }  \n            }  \n        });  \n    }  \n      \n    main();  \n    \n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn/getting-started/quickstart.mdx)\n\n[PreviousArchitecture at a Glance](/docs/learn/introduction/architecture-at-a-glance)[NextPrerequisites & Environment](/docs/learn/getting-started/prerequisites)\n\n  * Prerequisites\n  * Setup\n  * 1\\. Getting Funds\n  * 2\\. Initialization\n  * 3\\. Authentication\n  * 4\\. Channel Lifecycle\n    * Creating a Channel\n    * Funding (Resizing)\n    * Closing & Withdrawing\n  * Troubleshooting\n    * Cleanup Script\n  * Complete Code\n    * index.ts\n    * close_all.ts",
    "metadata": {
      "title": "Quickstart | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/quickstart",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/learn/introduction/architecture-at-a-glance",
    "text": "* [](/)\n  * Introduction\n  * Architecture at a Glance\n\nOn this page\n\n# Architecture at a Glance\n\nIn this guide, you will learn how Yellow Network's three protocol layers work together to enable fast, secure, off-chain transactions.\n\n* * *\n\n## The Three Layersâ€‹\n\nYellow Network consists of three interconnected layers, each with a specific responsibility:\n\nBlockchain Layer\n\nOn-Chain Layer\n\nOff-Chain Layer\n\nApplication Layer\n\nNitro RPC Protocol\n\nOn-chain operations\n\nMonitors events\n\nYour Application  \nGames, Payments, DeFi\n\nClient SDK\n\nClearnode\n\nCustody & Adjudicator Contracts\n\nEthereum, Polygon, Base, etc.\n\nLayer| Purpose| Speed| Cost  \n---|---|---|---  \n**Application**|  Your business logic and user interface| â€”| â€”  \n**Off-Chain**|  Instant state updates via Nitro RPC| < 1 second| Zero gas  \n**On-Chain**|  Fund custody, disputes, final settlement| Block time| Gas fees  \n  \n* * *\n\n## On-Chain Layer: Security Foundationâ€‹\n\nThe on-chain layer provides cryptographic guarantees through smart contracts:\n\n### Custody Contractâ€‹\n\nThe **Custody Contract** is the core of Nitrolite's on-chain implementation. It handles:\n\n  * **Channel Creation** : Lock funds and establish participant relationships\n  * **Dispute Resolution** : Process challenges and validate states\n  * **Final Settlement** : Distribute funds according to signed final state\n  * **Fund Management** : Deposit and withdrawal operations\n\n### Adjudicator Contractsâ€‹\n\n**Adjudicators** validate state transitions according to application-specific rules:\n\n  * **SimpleConsensus** : Both participants must sign (default for payment channels)\n  * **Custom Adjudicators** : Application-specific validation logic\n\nOn-Chain Operations\n\nYou only touch the blockchain for:\n\n  1. Opening a channel (lock funds)\n  2. Resizing a channel (add or remove funds)\n  3. Closing a channel (unlock and distribute funds)\n  4. Disputing a state (if counterparty is uncooperative)\n\n* * *\n\n## Off-Chain Layer: Speed and Efficiencyâ€‹\n\nThe off-chain layer handles high-frequency operations without blockchain transactions.\n\n### Clearnodeâ€‹\n\nA **Clearnode** is the off-chain service that:\n\n  * Manages the Nitro RPC protocol for state channel operations\n  * Provides a unified balance across multiple chains\n  * Coordinates payment channels between users\n  * Hosts app sessions for multi-party applications\n\n### Nitro RPC Protocolâ€‹\n\n**Nitro RPC** is a lightweight protocol optimized for state channel communication:\n\n  * **Compact format** : JSON array structure reduces message size by ~30%\n  * **Signed messages** : Every request and response is cryptographically signed\n  * **Real-time updates** : Bidirectional communication via WebSocket\n    \n    \n    // Compact Nitro RPC format  \n    [requestId, method, params, timestamp]  \n      \n    // Example: Transfer 50 USDC  \n    [42, \"transfer\", {\"destination\": \"0x...\", \"amount\": \"50.0\", \"asset\": \"usdc\"}, 1699123456789]  \n    \n\n* * *\n\n## How Funds Flowâ€‹\n\nThis diagram shows how your tokens move through the system:\n\n1\\. deposit\n\n2\\. resize\n\n3\\. resize\n\n4\\. open session\n\n5\\. close session\n\n6\\. resize/close\n\n7\\. withdraw\n\nUser Wallet  \n(ERC-20)\n\nAvailable Balance  \n(Custody Contract)\n\nChannel-Locked  \n(Custody Contract)\n\nUnified Balance  \n(Clearnode)\n\nApp Sessions  \n(Applications)\n\n### Fund Statesâ€‹\n\nState| Location| What It Means  \n---|---|---  \n**User Wallet**|  Your EOA| Full control, on-chain  \n**Available Balance**|  Custody Contract| Deposited, ready for channels  \n**Channel-Locked**|  Custody Contract| Committed to a specific channel  \n**Unified Balance**|  Clearnode| Available for off-chain operations  \n**App Session**|  Application| Locked in a specific app session  \n  \n* * *\n\n## Channel Lifecycleâ€‹\n\nA payment channel progresses through distinct states:\n\ncreate() with both signatures\n\nresize() (add/remove funds)\n\nclose() (cooperative)\n\nchallenge() (if disagreement)\n\ncheckpoint() (newer state)\n\nTimeout expires\n\nVOID\n\nACTIVE\n\nFINAL\n\nDISPUTE\n\nThis is where  \n99% of activity happens\n\nLegacy Flow\n\nThe diagram above shows the recommended flow where both participants sign the initial state, creating the channel directly in ACTIVE status. A legacy flow also exists where only the creator signs initially (status becomes INITIAL), and other participants call `join()` separately. See [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle) for details.\n\n### Typical Flowâ€‹\n\n  1. **Create** : Both parties sign initial state â†’ channel becomes ACTIVE\n  2. **Operate** : Exchange signed states off-chain (unlimited, zero gas)\n  3. **Close** : Both sign final state â†’ funds distributed\n\n### Dispute Path (Rare)â€‹\n\nIf your counterparty becomes unresponsive:\n\n  1. **Challenge** : Submit your latest signed state on-chain\n  2. **Wait** : Challenge period (typically 24 hours) allows counterparty to respond\n  3. **Finalize** : If no newer state is submitted, your state becomes final\n\n* * *\n\n## Communication Patternsâ€‹\n\n### Opening a Channelâ€‹\n\nBlockchainClearnodeClientBlockchainClearnodeClientcreate_channel requestchannel config + Clearnode signatureSign statecreate() with BOTH signaturesVerify, lock funds, emit eventEvent detectedChannel now ACTIVE\n\n### Off-Chain Transferâ€‹\n\nReceiverClearnodeSenderReceiverClearnodeSenderComplete in < 1 second, zero gastransfer(destination, amount)Validate, update ledgerConfirmed âœ“balance_update notification\n\n* * *\n\n## Key Takeawaysâ€‹\n\nConcept| What to Remember  \n---|---  \n**On-Chain**|  Only for opening, closing, disputesâ€”security layer  \n**Off-Chain**|  Where all the action happensâ€”speed layer  \n**Clearnode**|  Your gateway to the networkâ€”coordination layer  \n**State Channels**|  Lock once, transact unlimited times, settle once  \n  \nSecurity Guarantee\n\nAt every stage, funds remain cryptographically secured. You can always recover your funds according to the latest valid signed state, even if a Clearnode becomes unresponsive.\n\n* * *\n\n## Next Stepsâ€‹\n\nReady to start building? Continue to:\n\n  * **[Quickstart](/docs/learn/getting-started/quickstart)** â€” Create your first channel in minutes\n  * **[Prerequisites](/docs/learn/getting-started/prerequisites)** â€” Set up your development environment\n  * **[Core Concepts](/docs/learn/core-concepts/state-channels-vs-l1-l2)** â€” Deep dive into state channels\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn/introduction/architecture-at-a-glance.mdx)\n\n[PreviousWhat Yellow Solves](/docs/learn/introduction/what-yellow-solves)[NextQuickstart](/docs/learn/getting-started/quickstart)\n\n  * The Three Layers\n  * On-Chain Layer: Security Foundation\n    * Custody Contract\n    * Adjudicator Contracts\n  * Off-Chain Layer: Speed and Efficiency\n    * Clearnode\n    * Nitro RPC Protocol\n  * How Funds Flow\n    * Fund States\n  * Channel Lifecycle\n    * Typical Flow\n    * Dispute Path (Rare)\n  * Communication Patterns\n    * Opening a Channel\n    * Off-Chain Transfer\n  * Key Takeaways\n  * Next Steps",
    "metadata": {
      "title": "Architecture at a Glance | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/architecture-at-a-glance",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/learn/introduction/what-yellow-solves",
    "text": "* [](/)\n  * Introduction\n  * What Yellow Solves\n\nOn this page\n\n# What Yellow Solves\n\nIn this guide, you will learn why Yellow Network exists, what problems it addresses, and how it provides a faster, cheaper way to build Web3 applications.\n\n* * *\n\n## The Blockchain Scalability Problemâ€‹\n\nEvery blockchain transaction requires global consensus. While this guarantees security and decentralization, it creates three fundamental limitations:\n\nChallenge| Impact on Users  \n---|---  \n**High Latency**|  Transactions take 15 seconds to several minutes for confirmation  \n**High Costs**|  Gas fees spike during network congestion, making microtransactions impractical  \n**Limited Throughput**|  Networks like Ethereum process ~15-30 transactions per second  \n  \nFor applications requiring real-time interactionsâ€”gaming, trading, micropaymentsâ€”these constraints make traditional blockchain unusable as a backend.\n\n* * *\n\n## How Yellow Network Solves Thisâ€‹\n\nYellow Network uses **state channels** to move high-frequency operations off-chain while preserving blockchain-level security guarantees.\n\n### The Core Insightâ€‹\n\nMost interactions between parties don't need immediate on-chain settlement. Consider a chess game with a 10 USDC wager:\n\n  * **On-chain approach** : Every move requires a transaction â†’ 40+ transactions â†’ $100s in fees\n  * **State channel approach** : Lock funds once, play off-chain, settle once â†’ 2 transactions â†’ minimal fees\n\nState channels let you execute unlimited off-chain operations between on-chain checkpoints.\n\n### What You Getâ€‹\n\nFeature| Benefit  \n---|---  \n**Instant Transactions**|  Sub-second finality (< 1 second typical)  \n**Zero Gas Costs**|  Off-chain operations incur no blockchain fees  \n**Unlimited Throughput** *| No consensus bottleneck limiting operations  \n**Blockchain Security**|  Funds are always recoverable via on-chain contracts  \n  \n_*Theoretically unlimitedâ€”state channels have no blockchain consensus overhead. Real-world performance depends on signature generation speed, network latency between participants, and application complexity. We'll be publishing detailed benchmarks soon._\n\n* * *\n\n## The Nitrolite Protocolâ€‹\n\nYellow Network is built on **Nitrolite** , a state channel protocol designed for EVM-compatible chains. Nitrolite provides:\n\n  * **Fund Custody** : Smart contracts that securely lock and release assets\n  * **Dispute Resolution** : Challenge-response mechanism ensuring fair outcomes\n  * **Final Settlement** : Cryptographic guarantees that final allocations are honored\n\nWhen to Use Yellow Network\n\nChoose Yellow Network when your application needs:\n\n  * Real-time interactions between users\n  * Microtransactions or streaming payments\n  * High transaction volumes without gas costs\n  * Multi-party coordination with instant settlement\n\n* * *\n\n## Chain Abstraction with Clearnodeâ€‹\n\nA **Clearnode** serves as your entry point to Yellow Network. When you connect to a Clearnode:\n\n  1. **Deposit** tokens into the Custody Contract on any supported chain\n  2. **Resize** your channel to move funds to your unified balance\n  3. **Transact** instantly with any other user on the network\n  4. **Withdraw** back through the Custody Contract to any supported chain\n\nFund Flow\n\nFunds flow through the Custody Contract (on-chain) before reaching your unified balance (off-chain). The `resize` operation moves funds between your on-chain available balance and your off-chain unified balance. See [Architecture](/docs/learn/introduction/architecture-at-a-glance#how-funds-flow) for the complete flow.\n\nFor example, deposit 50 USDC on Polygon and 50 USDC on Baseâ€”after resizing, your unified balance shows 100 USDC. You can then withdraw all 100 USDC to Arbitrum if you choose.\n\nDeposit on Polygon  \n50 USDC\n\nUnified Balance  \n100 USDC\n\nDeposit on Base  \n50 USDC\n\nWithdraw to Arbitrum  \n100 USDC\n\n* * *\n\n## Real-World Applicationsâ€‹\n\n### Payment Applicationsâ€‹\n\n  * **Micropayments** : Pay-per-article, API usage billing, content monetization\n  * **Streaming payments** : Subscription services, hourly billing, real-time payroll\n  * **P2P transfers** : Instant remittances without intermediaries\n\n### Gaming Applicationsâ€‹\n\n  * **Turn-based games** : Chess, poker, strategy games with wagers\n  * **Real-time multiplayer** : In-game economies with instant transactions\n  * **Tournaments** : Prize pools and automated payouts\n\n### DeFi Applicationsâ€‹\n\n  * **High-frequency trading** : Execute trades without MEV concerns\n  * **Prediction markets** : Real-time betting with instant settlement\n  * **Escrow services** : Multi-party coordination with dispute resolution\n\n* * *\n\n## Security Modelâ€‹\n\nYellow Network maintains blockchain-level security despite operating off-chain:\n\nGuarantee| How It's Achieved  \n---|---  \n**Fund Safety**|  All funds locked in audited smart contracts  \n**Dispute Resolution**|  Challenge period allows contesting incorrect states  \n**Cryptographic Proof**|  Every state transition is signed by participants  \n**Recovery Guarantee**|  Users can always recover funds via on-chain contracts  \n  \nIf a Clearnode becomes unresponsive or malicious, you can submit your latest signed state to the blockchain and recover your funds after a challenge period.\n\n* * *\n\n## Next Stepsâ€‹\n\nNow that you understand what Yellow solves, continue to:\n\n  * **[Architecture at a Glance](/docs/learn/introduction/architecture-at-a-glance)** â€” See how the protocol layers work together\n  * **[Quickstart](/docs/learn/getting-started/quickstart)** â€” Create your first state channel in minutes\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/learn/introduction/what-yellow-solves.mdx)\n\n[PreviousLearn](/docs/learn/)[NextArchitecture at a Glance](/docs/learn/introduction/architecture-at-a-glance)\n\n  * The Blockchain Scalability Problem\n  * How Yellow Network Solves This\n    * The Core Insight\n    * What You Get\n  * The Nitrolite Protocol\n  * Chain Abstraction with Clearnode\n  * Real-World Applications\n    * Payment Applications\n    * Gaming Applications\n    * DeFi Applications\n  * Security Model\n  * Next Steps",
    "metadata": {
      "title": "What Yellow Solves | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/what-yellow-solves",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/legacy/about/related-work",
    "text": "# Page Not Found\n\nWe could not find what you were looking for.\n\nPlease contact the owner of the site that linked you to the original URL and let them know their link is broken.",
    "metadata": {
      "title": "Yellow Network",
      "url": "https://docs.yellow.org/docs/legacy/about/related-work",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/legacy/about/the-solution",
    "text": "# Page Not Found\n\nWe could not find what you were looking for.\n\nPlease contact the owner of the site that linked you to the original URL and let them know their link is broken.",
    "metadata": {
      "title": "Yellow Network",
      "url": "https://docs.yellow.org/docs/legacy/about/the-solution",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/legacy/architecture",
    "text": "# Page Not Found\n\nWe could not find what you were looking for.\n\nPlease contact the owner of the site that linked you to the original URL and let them know their link is broken.",
    "metadata": {
      "title": "Yellow Network",
      "url": "https://docs.yellow.org/docs/legacy/architecture",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/legacy/business/market-evaluation",
    "text": "# Page Not Found\n\nWe could not find what you were looking for.\n\nPlease contact the owner of the site that linked you to the original URL and let them know their link is broken.",
    "metadata": {
      "title": "Yellow Network",
      "url": "https://docs.yellow.org/docs/legacy/business/market-evaluation",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/manuals",
    "text": "* [](/)\n  * Manuals\n\n# Manuals\n\nWork in Progress\n\nThis section is currently under development. Comprehensive manuals and documentation will be available soon.\n\nComing soon: Detailed manuals covering all aspects of the platform.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/manuals/index.md)\n\n[NextRequest Asset Support](/docs/manuals/request-asset-support)",
    "metadata": {
      "title": "Manuals | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/manuals/request-asset-support",
    "text": "* [](/)\n  * Request Asset Support\n\nOn this page\n\n# Requesting Asset Support\n\nThis guide is primarily for **project teams, token issuers, and integration partners** who need to add support for new assets or tokens in the Clearnode infrastructure. Following this process will enable Clearnode to recognize and process transfers of your asset across supported blockchain networks.\n\n## What Happens When Support is Addedâ€‹\n\nOnce an asset is supported in Clearnode:\n\n  * Users can deposit and withdraw the asset through Clearnode's state channels\n  * The asset becomes available for instant, off-chain transfers via the Nitrolite protocol\n  * The asset can be used in cross-chain operations (deposit on one chain, withdraw on another) for blockchains it was configured on\n  * Applications built on Yellow Network can integrate the asset for payments and settlements\n  * The asset's unified balance is tracked across all supported blockchains\n\nERC20 Compatibility\n\nAdding support for ERC20 tokens is straightforward and requires only configuration changes. Non-standard token implementations may require additional development work and testing.\n\nLiquidity Requirements for Withdrawals\n\nFor a token to be immediately withdrawable on a specific blockchain, Clearnode must be provided with sufficient liquidity on that chain. Without liquidity, users can deposit tokens but cannot withdraw them until liquidity is available. Please contact our Business team to arrange liquidity provision before requesting asset support.\n\n## Understanding Environmentsâ€‹\n\nClearnode operates in two distinct environments with separate asset configurations:\n\nEnvironment| Purpose| Typical Assets  \n---|---|---  \n**Sandbox**|  Development, testing, and experimentation| Testnet tokens (Sepolia USDC, Amoy ETH, test tokens, etc.)  \n**Production**|  Live operations with real assets| Mainnet tokens (USDC, USDT, DAI, etc.)  \n  \n**Configuration file location:** `clearnode/chart/config/<sandbox_or_prod>/assets.yaml`\n\n**Important Considerations:**\n\n  * **Production will not support test network tokens** \\- mainnet tokens only\n  * **Sandbox will not support mainnet tokens** \\- testnet tokens only\n  * You must decide which environment needs the asset support based on your use case\n  * If you need support in both environments (e.g., testnet token for development, mainnet token for production), you must submit configuration changes to both files\n\n## How to Request Supportâ€‹\n\nAsset support is requested by creating or modifying a configuration file in the [nitrolite](https://github.com/erc7824/nitrolite) repository:\n\n  1. **Fork the repository** : `https://github.com/erc7824/nitrolite`\n  2. **Navigate to the appropriate configuration file** :\n     * For Sandbox: `clearnode/chart/config/sandbox/assets.yaml`\n     * For Production: `clearnode/chart/config/prod/assets.yaml`\n  3. **Add your asset configuration** at the end of the list (see next section for structure)\n  4. **Submit a Pull Request** with a clear description of the asset being added\n  5. **Wait for review** by the development team\n\nThe next section provides detailed guidance on the configuration structure and whether you need to add a new asset or just a token.\n\n## Asset Configuration Structureâ€‹\n\n### Understanding Assets vs Tokensâ€‹\n\nIn Clearnode's configuration model:\n\n  * An **asset** represents a logical currency or token type (e.g., \"USDC\", \"ETH\")\n  * A **token** is a specific implementation of that asset on a particular blockchain\n\n**Example:** USDC is an asset that has different token implementations:\n\n  * USDC on Polygon at address `0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359`\n  * USDC on Base at address `0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913`\n  * USDC on Ethereum at address `0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48`\n\n### Before You Start: Check if the Asset Existsâ€‹\n\nBefore adding a new asset, check if Clearnode already supports the asset on other blockchains. If the asset exists but your target blockchain is not listed, you only need to add a **token entry** to the existing asset. If the asset doesn't exist at all, you need to add both the **asset** and its **token(s)**.\n\n#### Scenario 1: Asset exists, add a token to a new blockchainâ€‹\n    \n    \n    assets:  \n      - name: \"USD Coin\"  \n        symbol: \"usdc\"  \n        tokens:  \n          - blockchain_id: 137  \n            address: \"0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359\"  \n            decimals: 6  \n          # Add your new token here  \n          - blockchain_id: 8453  # Base  \n            address: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\"  \n            decimals: 6  \n    \n\n#### Scenario 2: New asset, add both asset and token(s)â€‹\n    \n    \n    assets:  \n      - name: \"My New Token\"  \n        symbol: \"mnt\"  \n        tokens:  \n          - blockchain_id: 137  \n            address: \"0xYourTokenAddressOnPolygon\"  \n            decimals: 18  \n    \n\n### Configuration Fieldsâ€‹\n\n#### Asset Levelâ€‹\n\nEach asset entry requires the following fields:\n    \n    \n    assets:  \n      - name: \"USD Coin\"    # Human-readable name  \n        symbol: \"usdc\"      # Ticker symbol (lowercase)  \n        disabled: false     # If set to `true`, then it is not loaded into configuration  \n        tokens: [...]       # Array of token implementations  \n    \n\nField| Required| Description  \n---|---|---  \n`name`| No| Human-readable name of the asset (e.g., \"USD Coin\"). If omitted, defaults to the symbol.  \n`symbol`| **Yes**|  Ticker symbol for the asset (must be lowercase, e.g., \"usdc\", \"eth\")  \n`disabled`| No| Set to `true` to temporarily disable processing this asset (default: `false`)  \n`tokens`| **Yes**|  Array of blockchain-specific token implementations  \n  \n#### Token Levelâ€‹\n\nEach token within an asset requires the following fields:\n    \n    \n    tokens:  \n      - name: \"USD Coin on Polygon\"      # Token-specific name  \n        symbol: \"usdc\"                   # Token-specific symbol  \n        blockchain_id: 137               # Chain ID  \n        disabled: false                  # Skip processing (default: false)  \n        address: \"0x3c499c542cEF...\"     # Contract address  \n        decimals: 6                      # Token decimals  \n    \n\nField| Required| Description  \n---|---|---  \n`name`| No| Token name on this blockchain (inherits from asset if not specified)  \n`symbol`| No| Token symbol on this blockchain (inherits from asset if not specified)  \n`blockchain_id`| **Yes**|  Chain ID where this token is deployed (must match a supported blockchain)  \n`disabled`| No| Set to `true` to temporarily disable this token (default: `false`)  \n`address`| **Yes**|  Token's smart contract address (must be a valid address on the specified chain)  \n`decimals`| **Yes**|  Number of decimal places the token uses (e.g., 6 for USDC, 18 for ETH)  \n  \n### Prerequisites for Adding Assetsâ€‹\n\nBefore submitting your configuration:\n\n  1. **Blockchain Support** : Ensure the blockchain (by `blockchain_id`) is already supported in `blockchains.yaml`\n  2. **Token Deployment** : The token contract must be deployed and verified on the target blockchain\n  3. **ERC20 Compliance** : Token should follow the standard ERC20 interface for seamless integration\n  4. **Correct Decimals** : Verify the token's decimal places (commonly 6 or 18, but varies by token)\n  5. **Valid Address** : Double-check the contract address is correct and matches the intended blockchain\n\nBlockchain Must Be Supported First\n\nYou cannot add a token on a blockchain that is not yet supported in Clearnode. If your target blockchain is not in the `blockchains.yaml` configuration, you must first follow the [Request Blockchain Support](/docs/manuals/request-blockchain-support) guide before requesting asset support.\n\n## Need Help?â€‹\n\nIf you have questions about asset support requests, encounter issues during configuration, or need clarification on any part of this process, please don't hesitate to contact the development team.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/manuals/request-asset-support.md)\n\n[PreviousManuals](/docs/manuals/)[NextRequest Blockchain Support](/docs/manuals/request-blockchain-support)\n\n  * What Happens When Support is Added\n  * Understanding Environments\n  * How to Request Support\n  * Asset Configuration Structure\n    * Understanding Assets vs Tokens\n    * Before You Start: Check if the Asset Exists\n    * Configuration Fields\n    * Prerequisites for Adding Assets\n  * Need Help?",
    "metadata": {
      "title": "Requesting Asset Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-asset-support",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/manuals/request-blockchain-support",
    "text": "* [](/)\n  * Request Blockchain Support\n\nOn this page\n\n# Requesting Blockchain Support\n\nThis guide is primarily for **blockchain integrators, infrastructure teams, and project partners** who need to add support for new blockchain networks in the Clearnode infrastructure. Following this process will enable Clearnode to connect to your blockchain and provide off-chain clearing and settlement services.\n\n## What Happens When Support is Addedâ€‹\n\nOnce a blockchain is supported in Clearnode:\n\n  * Clearnode can establish RPC connections to the specified blockchain network\n  * The Nitrolite protocol smart contracts (custody, adjudicator, and balance checker) will be monitored on that chain\n  * Users can deposit and withdraw assets on that blockchain through Clearnode\n  * State channels can leverage that blockchain for on-chain settlement when needed\n  * Assets deployed on the supported blockchain become available for cross-chain clearing\n\nNon-EVM and Limited Infrastructure Support\n\nIf your blockchain support request concerns a **non-EVM blockchain** or a blockchain with **limited infrastructure support** (e.g., scarce RPC providers, incomplete tooling, experimental networks), **you must contact the development team before proceeding** with this guide. These cases require custom development and cannot be handled through standard configuration.\n\nContact the dev team via [GitHub Issues](https://github.com/layer-3/nitrolite/issues).\n\n## Understanding Environmentsâ€‹\n\nClearnode operates in two distinct environments with separate configurations:\n\nEnvironment| Purpose| Typical Networks  \n---|---|---  \n**Sandbox**|  Development, testing, and experimentation| Testnets (Sepolia, Polygon Amoy, etc.)  \n**Production**|  Live operations with real assets| Mainnets (Ethereum, Polygon, Base, Linea, etc.)  \n  \n**Configuration file location:** `clearnode/chart/config/<sandbox_or_prod>/blockchains.yaml`\n\n**Important Considerations:**\n\n  * **Production will not support test networks** \\- mainnet blockchains only\n  * **Sandbox will not support mainnet networks** \\- testnet blockchains only\n  * You must decide which environment needs the blockchain support based on your use case\n  * If you need support in both environments (e.g., testnet for development, mainnet for production), you must submit configuration changes to both files\n\n## How to Request Supportâ€‹\n\nBlockchain support is requested by creating or modifying a configuration file in the [nitrolite](https://github.com/erc7824/nitrolite) repository:\n\n  1. **Fork the repository** : `https://github.com/erc7824/nitrolite`\n  2. **Navigate to the appropriate configuration file** :\n     * For Sandbox: `clearnode/chart/config/sandbox/blockchains.yaml`\n     * For Production: `clearnode/chart/config/prod/blockchains.yaml`\n  3. **Add your blockchain configuration** at the end of the `blockchains` list (see next section for structure)\n  4. **Submit a Pull Request** with a clear description of the blockchain being added\n  5. **Wait for review** by the development team\n\nThe next section provides detailed guidance on the configuration structure.\n\n## Blockchain Configuration Structureâ€‹\n\n### Overviewâ€‹\n\nThe `blockchains.yaml` file contains two main sections:\n\n  * `default_contract_addresses`: Default smart contract addresses applied to all blockchains (unless overridden)\n  * `blockchains`: Array of blockchain configurations\n\n### Configuration Fieldsâ€‹\n\nEach blockchain entry requires the following fields:\n    \n    \n    blockchains:  \n      - name: polygon                 # Blockchain name (lowercase, underscores allowed)  \n        id: 137                       # Chain ID for validation  \n        disabled: false               # Whether to disable (default: false)  \n        block_step: 10000             # Block range for scanning (default: 10000)  \n        contract_addresses:           # Override default contract addresses  \n          custody: \"0x...\"  \n          adjudicator: \"0x...\"  \n          balance_checker: \"0x...\"  \n    \n\n**Field Descriptions:**\n\nField| Required| Description  \n---|---|---  \n`name`| **Yes**|  Unique identifier for the blockchain (lowercase, underscores allowed, e.g., `polygon`, `base`, `arbitrum_one`)  \n`id`| **Yes**|  Chain ID used for validation (must match the blockchain's official chain ID)  \n`disabled`| No| Set to `true` to disable or `false` to enable (default: `false`)  \n`block_step`| No| Number of blocks to scan per query when monitoring events (default: `10000`). Adjust based on blockchain or RPC provider performance.  \n`contract_addresses`| No| Override default contract addresses for this specific blockchain  \n  \n### Contract Deploymentâ€‹\n\nWhen requesting the addition of a new blockchain, addresses of the infrastructure smart contracts must be provided:\n\n  * **Custody Contract** : Manages user deposits and withdrawals\n  * **Adjudicator Contract** : Handles dispute resolution for state channels\n  * **Balance Checker Contract** : Provides efficient balance queries\n\nSmart contract deployment\n\nFor now, you don't need to deploy these contracts yourself. The development team will handle contract deployment on the new blockchain as part of the support process.\n\nYou can submit your request with smart contract addresses set to placeholder values (e.g., `0x0000000000000000000000000000000000000000`). The team will replace them with the actual deployed addresses during integration.\n\nComing Soon: Cross-Chain Contract Deployment Tool\n\nWe are developing a tool to simplify the deployment of Nitrolite protocol smart contracts across multiple blockchains with deterministic addresses. This will enable deploying contracts to the same address on different chains, making configuration management significantly easier.\n\nRead on to learn how to specify contract addresses in the configuration.\n\nYou have two options for providing contract addresses:\n\n#### Option 1: Using Default Contract Addressesâ€‹\n\nIf you deploy contracts at the addresses specified in the `default_contract_addresses`, you don't need to specify `contract_addresses` in each blockchain entry.\n    \n    \n    default_contract_addresses:  \n      custody: \"0x490fb189DdE3a01B00be9BA5F41e3447FbC838b6\"  \n      adjudicator: \"0xcbbc03a873c11beeFA8D99477E830be48d8Ae6D7\"  \n      balance_checker: \"0x2352c63A83f9Fd126af8676146721Fa00924d7e4\"  \n      \n    blockchains:  \n      - name: polygon  \n        id: 137  \n        enabled: true  \n      - name: base  \n        id: 8453  \n        enabled: true  \n    \n\nThis approach is cleaner when contracts are deployed at identical addresses.\n\n#### Option 2: Blockchain-Specific Contract Addressesâ€‹\n\nIf contract addresses differ on your blockchain, specify them individually:\n    \n    \n    blockchains:  \n      - name: polygon  \n        id: 137  \n        enabled: true  \n        contract_addresses:  \n          custody: \"0xPolygonCustodyAddress...\"  \n          adjudicator: \"0xPolygonAdjudicatorAddress...\"  \n          balance_checker: \"0xPolygonBalanceCheckerAddress...\"  \n      - name: base  \n        id: 8453  \n        enabled: true  \n        contract_addresses:  \n          custody: \"0xBaseCustodyAddress...\"  \n          adjudicator: \"0xBaseAdjudicatorAddress...\"  \n          balance_checker: \"0xBaseBalanceCheckerAddress...\"  \n    \n\nContract Address Requirements\n\nEach blockchain **must have all three contract addresses configured** either through `default_contract_addresses` or blockchain-specific `contract_addresses`. If defaults are not provided, every blockchain must explicitly define all three addresses. Missing contract addresses will cause Clearnode to fail on startup.\n\n## Need Help?â€‹\n\nIf you have questions about blockchain support requests, encounter issues during integration, or need clarification on any part of this process, please don't hesitate to contact the development team.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/manuals/request-blockchain-support.md)\n\n[PreviousRequest Asset Support](/docs/manuals/request-asset-support)[NextRunning Clearnode Locally](/docs/manuals/running-clearnode-locally)\n\n  * What Happens When Support is Added\n  * Understanding Environments\n  * How to Request Support\n  * Blockchain Configuration Structure\n    * Overview\n    * Configuration Fields\n    * Contract Deployment\n  * Need Help?",
    "metadata": {
      "title": "Requesting Blockchain Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-blockchain-support",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/manuals/running-clearnode-locally",
    "text": "* [](/)\n  * Running Clearnode Locally\n\nOn this page\n\n# Running Clearnode Locally\n\nThis manual explains how to run a Clearnode locally using Docker Compose for development and testing purposes. Clearnode is an implementation of a message broker node providing ledger services for the Nitrolite protocol, which enables efficient off-chain payment channels with on-chain settlement capabilities.\n\n## Prerequisitesâ€‹\n\n  * Docker and Docker Compose installed on your system\n  * Git (to clone the repository)\n\n## Quick Startâ€‹\n\n### 1\\. Clone the Repositoryâ€‹\n    \n    \n    git clone https://github.com/erc7824/nitrolite.git  \n    cd nitrolite/clearnode  \n    \n\n### 2\\. Configuration Setupâ€‹\n\nCreate a configuration directory:\n    \n    \n    cp -r config/compose/example config/compose/local  \n    \n\n### 3\\. Configure Blockchain Connectionsâ€‹\n\nEdit `config/compose/local/blockchains.yaml` to configure your blockchain connections. Here's an example:\n    \n    \n    default_contract_addresses:  \n      custody: \"0x490fb189DdE3a01B00be9BA5F41e3447FbC838b6\"  \n      adjudicator: \"0xcbbc03a873c11beeFA8D99477E830be48d8Ae6D7\"  \n      balance_checker: \"0x2352c63A83f9Fd126af8676146721Fa00924d7e4\"  \n      \n    blockchains:  \n      - name: polygon  \n        id: 137  \n        disabled: false  \n        block_step: 10000  \n      - name: base  \n        id: 8453  \n        disabled: true  \n    \n\n### 4\\. Configure Assetsâ€‹\n\nEdit `config/compose/local/assets.yaml` to configure supported assets:\n    \n    \n    assets:  \n      - name: \"USD Coin\"  \n        symbol: \"usdc\"  \n        tokens:  \n          - blockchain_id: 137  \n            address: \"0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359\"  \n            decimals: 6  \n      - name: \"Wrapped Ether\"  \n        symbol: \"weth\"  \n        tokens:  \n          - blockchain_id: 137  \n            address: \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\"  \n            decimals: 18  \n    \n\n### 5\\. Environment Variablesâ€‹\n\nCreate a `.env` file in `config/compose/local/.env` with the following:\n    \n    \n    # Required  \n    BROKER_PRIVATE_KEY=your_private_key_here  \n      \n    # Add RPC endpoints for each enabled blockchain  \n    POLYGON_BLOCKCHAIN_RPC=wss://my-polygon-rpc.example.com  \n    # BASE_BLOCKCHAIN_RPC=wss://my-base-rpc.example.com  \n      \n    # Optional configuration  \n    CLEARNODE_LOG_LEVEL=info  \n    \n\n### 6\\. Start Servicesâ€‹\n\nRun the following command to start all services:\n    \n    \n    docker compose up  \n    \n\nThis will start:\n\n  * Clearnode service on port 8000 (WebSocket/HTTP)\n  * PostgreSQL database\n  * Prometheus metrics on port 4242\n\n### 7\\. Stop Servicesâ€‹\n\nTo stop all services:\n    \n    \n    docker compose down  \n    \n\n## Configuration Referenceâ€‹\n\n### Environment Variablesâ€‹\n\nVariable| Description| Required| Default  \n---|---|---|---  \n`BROKER_PRIVATE_KEY`| Private key used for signing broker messages| Yes| -  \n`DATABASE_DRIVER`| Database driver to use (postgres/sqlite)| No| sqlite  \n`CLEARNODE_CONFIG_DIR_PATH`| Path to directory containing configuration files| No| .  \n`CLEARNODE_DATABASE_URL`| Database connection string| No| clearnode.db  \n`CLEARNODE_LOG_LEVEL`| Logging level (debug, info, warn, error)| No| info  \n`HTTP_PORT`| Port for the HTTP/WebSocket server| No| 8000  \n`METRICS_PORT`| Port for Prometheus metrics| No| 4242  \n`MSG_EXPIRY_TIME`| Time in seconds for message timestamp validation| No| 60  \n`<BLOCKCHAIN_NAME>_BLOCKCHAIN_RPC`| RPC endpoint for each enabled blockchain| Yes| -  \n  \n### Blockchain Configuration (blockchains.yaml)â€‹\n\n**Configuration Structure:**\n\n  * **default_contract_addresses** : That's the optional set of default contract addresses applied to all blockchains unless overridden\n\n    * `custody`: Custody contract address\n    * `adjudicator`: Adjudicator contract address\n    * `balance_checker`: Balance checker contract address\n  * **blockchains** : Array of blockchain configurations\n\n    * `name`: Blockchain name (required; lowercase, underscores allowed)\n    * `id`: Chain ID for validation (required)\n    * `disabled`: Whether to disable this blockchain (optional, default: false)\n    * `block_step`: Block range for scanning (optional, default: 10000)\n    * `contract_addresses`: Override default addresses for this specific blockchain (optional)\n      * `custody`: Custody contract address\n      * `adjudicator`: Adjudicator contract address\n      * `balance_checker`: Balance checker contract address\n\nwarning\n\nEven though both `default_contract_addresses` and blockchain-specific `contract_addresses` are described as optional, each blockchain must have all required contract addresses set. If no defaults are provided under `default_contract_addresses`, you must specify `custody`, `adjudicator`, and `balance_checker` addresses for every blockchain in its `contract_addresses` section. Otherwise, Clearnode will fail to start due to missing contract address configuration.\n\nRPC endpoints follow the pattern: `<BLOCKCHAIN_NAME_UPPERCASE>_BLOCKCHAIN_RPC`\n\nExample:\n    \n    \n    MY_NETWORK_BLOCKCHAIN_RPC=wss://my-network-rpc.example.com  \n    \n\n### Asset Configuration (assets.yaml)â€‹\n\n**Configuration Structure:**\n\n  * **assets** : Array of asset configurations\n    * `name`: Human-readable name of the asset (e.g., \"USD Coin\")\n    * `symbol`: Ticker symbol for the asset (required; lowercase, e.g., \"usdc\")\n    * `disabled`: Whether to skip processing this asset (optional, default: false)\n    * `tokens`: Array of blockchain-specific token implementations\n      * `name`: Token name on this blockchain (optional, inherits from asset)\n      * `symbol`: Token symbol on this blockchain (optional, inherits from asset)\n      * `blockchain_id`: Chain ID where this token is deployed (required)\n      * `disabled`: Whether to skip processing this token (optional, default: false)\n      * `address`: Token's contract address (required)\n      * `decimals`: Number of decimal places for the token (required)\n\n**Asset Token Inheritance:**\n\n  * If a token's `name` is not specified, it uses the asset's `name`\n  * If a token's `symbol` is not specified, it uses the asset's `symbol`\n  * If an asset's `name` is not specified, it defaults to the asset's `symbol`\n\n## Key Featuresâ€‹\n\n  * **Multi-Chain Support** : Connect to multiple EVM blockchains simultaneously\n  * **Off-Chain Payments** : Efficient payment channels for high-throughput transactions\n  * **Virtual Applications** : Create multi-participant applications\n  * **Message Forwarding** : Bi-directional message routing between participants\n  * **Flexible Database** : Support for both PostgreSQL and SQLite\n  * **Prometheus Metrics** : Built-in monitoring on port 4242\n  * **Quorum-Based Signatures** : Multi-signature schemes with weight-based quorums\n\n## Troubleshootingâ€‹\n\n### Common Issuesâ€‹\n\n  1. **Port Conflicts** : If you encounter port conflicts, check which services are running on ports 8000 (HTTP/WebSocket) or 4242 (metrics) and either stop them or modify the ports in docker-compose.yml\n\n  2. **RPC Configuration** : Ensure RPC endpoints match the pattern `<BLOCKCHAIN_NAME_UPPERCASE>_BLOCKCHAIN_RPC` and that the chain ID matches your configuration\n\n  3. **Configuration Files** : Make sure `blockchains.yaml` and `assets.yaml` are properly formatted YAML files in your CONFIG_DIR_PATH\n\n  4. **Database Connection** : If using PostgreSQL, ensure the database service is running and accessible\n\n\n### Useful Commandsâ€‹\n\nCheck service status:\n    \n    \n    docker-compose ps  \n    \n\nView logs for a specific service:\n    \n    \n    docker-compose logs -f <service-name>  \n    \n\nRestart a specific service:\n    \n    \n    docker-compose restart <service-name>  \n    \n\nClean up (remove containers, networks, and volumes):\n    \n    \n    docker-compose down -v  \n    \n\n## Development Tipsâ€‹\n\n  1. **Debug Mode** : Set `CLEARNODE_LOG_LEVEL=debug` for verbose logging\n  2. **Database Access** : Use a database client to connect to `localhost:5432` with PostgreSQL credentials\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/manuals/running-clearnode-locally.md)\n\n[PreviousRequest Blockchain Support](/docs/manuals/request-blockchain-support)\n\n  * Prerequisites\n  * Quick Start\n    * 1\\. Clone the Repository\n    * 2\\. Configuration Setup\n    * 3\\. Configure Blockchain Connections\n    * 4\\. Configure Assets\n    * 5\\. Environment Variables\n    * 6\\. Start Services\n    * 7\\. Stop Services\n  * Configuration Reference\n    * Environment Variables\n    * Blockchain Configuration (blockchains.yaml)\n    * Asset Configuration (assets.yaml)\n  * Key Features\n  * Troubleshooting\n    * Common Issues\n    * Useful Commands\n  * Development Tips",
    "metadata": {
      "title": "Running Clearnode Locally | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/running-clearnode-locally",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/architecture",
    "text": "* [](/)\n  * Architecture\n\nOn this page\n\n# Architecture\n\n## System Overviewâ€‹\n\nThe Nitrolite protocol architecture consists of multiple layers working together to enable scalable, secure state channel operations:\n\nBlockchain Layer\n\nOn-Chain Layer  \n(Smart Contracts)\n\nClient SDK\n\nOff-Chain Layer  \n(Fast Updates)\n\nApplication Layer\n\nCommunicate via RPC using NitroRPC protocol\n\nOperate on-chain state channels\n\nObserve events\n\nChess, DEX, Gaming, Payments, Custom Logic\n\nClearnode\n\nClient SDK\n\nCustody, Adjudicator contracts\n\nEthereum, Polygon, etc.\n\n## Communication Patternsâ€‹\n\n### On-Chain Channel Openingâ€‹\n\nThe channel opening process follows a coordinated sequence between client and a clearnode:\n\n  1. Client requests channel creation from a clearnode via Nitro RPC\n  2. The clearnode returns a channel struct and signed initial state (signature at index 1)\n  3. Client signs the initial state (signature at index 0)\n  4. Client calls the `create(...)` method of the Custody Smart Contract on the blockchain, providing the channel and initial state with both signatures\n  5. Contract verifies signatures and emits `Opened` event\n  6. Channel becomes ACTIVE immediately\n  7. The clearnode monitors the `Opened` event and updates its internal state\n\nBlockchainClearnodeClientBlockchainClearnodeClientcreate_channel requestchannel struct + signed initial state (clearnode signature)Add own signaturecreate() with BOTH signaturesVerify signaturesSet status = ACTIVEEmit Opened eventOpened event (monitored)channel_update notification\n\nCooperative Opening\n\nChannel opening requires cooperation between both parties, ensuring mutual agreement before funds are locked.\n\n### Off-Chain Updatesâ€‹\n\n**Off-Chain Updates** :\n\n  1. Participants exchange signed state updates:\n\n     * **For Payment Channels** (User â†” Clearnode): States are exchanged directly via Nitro RPC\n\n     * **For App Sessions** (Multi-party): State exchange is managed by the App itself (peer-to-peer). Once the state has enough signatures to satisfy quorum, a responsible party submits the signed state to the Clearnode\n\n  2. No blockchain transactions required\n\n  3. Latest valid state maintained off-chain\n\n  4. Can be checkpointed on-chain at any time\n\n     * _Current Implementation Note_ : While this is the ideal design goal, the current implementation does not store the state off-chain, so checkpointing is not currently supported. This functionality is under development and will be more enforced in the next version of the protocol.\n\nZero Gas Fees\n\nOff-chain updates are instant (< 1 second) and incur zero gas fees, enabling high-frequency operations.\n\n### On-Chain Channel Closingâ€‹\n\nChannels can be closed in two ways:\n\n**Cooperative Closure** :\n\n  1. All participants negotiate and agree on the final state\n  2. Each participant signs the final state with `intent = FINALIZE`\n  3. Any participant submits the fully-signed final state to the Custody Contract via `close()`\n  4. Contract verifies all signatures and distributes funds according to final allocations\n  5. Channel status becomes FINAL\n\nThis is the preferred closure method. It requires only 1 transaction and is gas-efficient.\n\n**Non-Cooperative Closure** :\n\n  1. A participant submits the latest known state to the Custody Contract via `challenge()`\n  2. Contract verifies signatures and sets channel status to DISPUTE\n  3. A challenge period begins (e.g., 24 hours), allowing the other party to respond\n  4. If participants decides to cooperate again, they may produce a newer valid state, and any of them can submit it via `checkpoint()`, thus stopping the challenge period and moving the channel from DISPUTE back to ACTIVE status\n  5. If not, after the challenge period expires, any participant calls `close()` to finalize with the latest submitted state\n  6. Contract distributes funds according to the final state allocations\n\nThis mechanism resolves disputes when parties cannot cooperate. It requires a waiting period for security and is more expensive due to multiple transactions.\n\nYes\n\nNo\n\nActive Channel\n\nParties Agree?\n\nCooperative Close  \nFast, Cheap\n\nChallenge-Response  \nSlow, Secure\n\n## Fund Flowâ€‹\n\nThe following diagram illustrates how funds flow through the Nitrolite protocol:\n\ndeposit\n\nresize\n\nresize\n\nresize\n\nopen/deposit\n\nwithdraw / close session\n\nresize / close channel\n\nwithdraw\n\nUser Wallet  \n(ERC-20)\n\nAvailable  \n(Custody SC)\n\nUnified Balance  \n(Clearnode)\n\nChannel-Locked  \n(Custody SC)\n\nApp Sessions  \n(Application)\n\n**Flow Explanation** :\n\n  1. **Deposit** : User deposits ERC-20 tokens into the **Available** balance of the Custody Contract.\n  2. **Resize** : Funds can be moved between **Available** balance and **Unified Balance** (managed off-chain by the clearnode).\n  3. **Channel Lock** : Funds can also be moved between **Available** balance and **Channel-Locked** balance via resize operations, or between **Channel-Locked** and **Unified Balance**.\n  4. **App Sessions** : Funds from the **Unified Balance** can be allocated to App Sessions.\n  5. **Release** : When app sessions close or funds are withdrawn, they return to the **Unified Balance**.\n  6. **Unlock/Withdraw** : Funds can be moved back to **Available** balance (via resize/close) and then withdrawn to the **User Wallet**.\n\nSecurity Guarantee\n\nAt every stage, funds remain cryptographically secured. Users can always recover their funds according to the latest valid signed state, even if the clearnode becomes unresponsive.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/architecture.mdx)\n\n[PreviousTerminology](/docs/protocol/terminology)[NextOverview](/docs/protocol/on-chain/overview)\n\n  * System Overview\n  * Communication Patterns\n    * On-Chain Channel Opening\n    * Off-Chain Updates\n    * On-Chain Channel Closing\n  * Fund Flow",
    "metadata": {
      "title": "Architecture | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/architecture",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/communication-flows",
    "text": "* [](/)\n  * Cross-Layer Communication Flows\n\nOn this page\n\n# Cross-Layer Communication Flows\n\nThis section illustrates how the on-chain and off-chain layers interact during typical operations. Each flow shows the sequence of method calls and data exchange between Client, Clearnode, and Smart Contracts.\n\nFlow Navigation\n\nJump to a specific flow:\n\n  * Authentication Flow \\- Establish session with session key delegation\n  * Channel Creation Flow \\- Open payment channel on blockchain\n  * Off-Chain Transfer Flow \\- Instant transfers without gas\n  * App Session Lifecycle \\- Multi-party application flow\n  * Cooperative Closure \\- Fast channel closure\n  * Challenge-Response Closure \\- Dispute resolution\n\n* * *\n\n## Authentication Flowâ€‹\n\n### Purposeâ€‹\n\nEstablish authenticated session with session key delegation.\n\n### Actorsâ€‹\n\n  * **Client** : User application or SDK\n  * **Clearnode** : Off-chain service provider\n\n### Sequence Diagramâ€‹\n\nClearnodeMain WalletClientClearnodeMain WalletClient1\\. Generate Session Keypair2\\. auth_request (public, no signature)3\\. Generate Challenge4\\. Sign Challenge with MAIN wallet (EIP-712)5\\. Validate & Issue SessionSubsequent requests signed with session_keysession_private_key = random()session_address = address(session_public_key)auth_request(address, session_key, allowances, scope, expires_at)Validate params, generate UUIDauth_challenge(challenge_message)Sign Policy typed data (challenge, scope, wallet, session_key, expires_at, allowances)EIP-712 signatureauth_verify(challenge, sig) // or auth_verify(challenge, jwt)Recover main wallet from sig (or validate jwt)Create session + JWT{address, session_key, jwt_token, success}\n\n### Stepsâ€‹\n\n#### Step 1: Client Generates Session Keypairâ€‹\n\nThe session key is generated entirely off-chain and the private key never leaves the client:\n    \n    \n    session_private_key = random()  \n    session_public_key = derive(session_private_key)  \n    session_address = address(session_public_key)  \n    \n\n#### Step 2: Client â†’ Clearnode: `auth_request` (public, no signature)â€‹\n\nThe client sends a public registration request (no signature required):\n    \n    \n    Request:  \n    {  \n      address: user_wallet_address  \n      session_key: session_address  \n      allowances: [{\"asset\": \"usdc\", \"amount\": \"100.0\"}]  \n      scope: \"transfer,app.create\"  \n      expires_at: 1762417328123  // Unix ms  \n    }  \n    \n\n#### Step 3: Clearnode Validates and Generates Challengeâ€‹\n\nThe clearnode performs validation:\n\n  * Validate address/session_key format, optional allowances/scope, expires_at\n  * Generate challenge UUID\n\n#### Step 4: Clearnode â†’ Client: `auth_challenge`â€‹\n\nThe clearnode responds with a challenge:\n    \n    \n    Response:  \n    {  \n      challenge_message: \"550e8400-e29b-41d4-a716-446655440000\"  \n    }  \n    Signature: signed by Clearnode  \n    \n\n#### Step 5: Client Signs Challenge (MAIN wallet, EIP-712)â€‹\n\nThe client signs the challenge using the main wallet over the Policy typed data (includes challenge, wallet, session_key, expires_at, scope, allowances):\n    \n    \n    challenge_signature = signTypedData(policyTypedData, main_wallet_private_key)  \n    \n\n#### Step 6: Client â†’ Clearnode: `auth_verify`â€‹\n\nThe client submits the signed challenge (or a previously issued JWT):\n    \n    \n    Request:  \n    {  \n      challenge: \"550e8400-e29b-41d4-a716-446655440000\",  \n      // alternatively:  \n      // jwt: \"<existing_jwt>\"  \n    }  \n    Signature: EIP-712 signature by main wallet (required if jwt is absent)  \n    \n\n#### Step 7: Clearnode Validates Challengeâ€‹\n\nThe clearnode validates:\n\n  * Signature recovers the wallet used in `auth_request`\n  * Challenge matches pending authentication\n  * Challenge not expired or reused\n\n#### Step 8: Clearnode â†’ Client: `auth_verify` Responseâ€‹\n\nThe clearnode confirms authentication:\n    \n    \n    Response:  \n    {  \n      address: user_wallet_address  \n      session_key: session_address  \n      jwt_token: \"<jwt>\"  \n      success: true  \n    }  \n    \n\n#### Step 9: Session Establishedâ€‹\n\n  * All subsequent requests signed with `session_private_key`\n  * The clearnode enforces allowances and expiration\n  * No main wallet interaction required until session expires\n\n### Key Pointsâ€‹\n\nSession Security\n\n  * Session private key **NEVER** leaves the client\n  * Main wallet only signs once (`auth_request`)\n  * All subsequent operations use session key\n  * Allowances prevent unlimited spending\n  * Challenge-response prevents replay attacks\n\n**Related Methods** : [`auth_request`](/docs/off-chain/authentication#step-1-auth_request), [`auth_challenge`](/docs/off-chain/authentication#step-2-auth_challenge), [`auth_verify`](/docs/off-chain/authentication#step-3-auth_verify)\n\n* * *\n\n## Channel Creation Flowâ€‹\n\n### Purposeâ€‹\n\nOpen a payment channel with zero initial balance; fund it later via `resize_channel`.\n\n### Actorsâ€‹\n\n  * **Client** : User application or SDK\n  * **Clearnode** : Off-chain service provider\n  * **Smart Contract** : Custody Contract\n  * **Blockchain** : Ethereum-compatible network\n\n### Sequence Diagramâ€‹\n\nBlockchainClearnodeClientBlockchainClearnodeClientOff-Chain Preparation2\\. Prepare Channel3\\. Validate & SignOn-Chain ExecutionChannel is now ACTIVEcreate_channel(chain_id, token)Generate unique nonceCreate channel configCreate initial state (intent: INITIALIZE, version: 0, zero allocations)Pack & sign state{channel_id, channel, state, server_signature}Verify Clearnode signatureSign packed state with user keyCustody.create(channel, state, sig_user, sig_clearnode)Verify signaturesCreate channel (zero balance)Set status to OPEN/ACTIVEEmit Opened eventOpened event (monitored)Opened event\n\n### Stepsâ€‹\n\n#### Step 1: Client â†’ Clearnode: `create_channel`â€‹\n\nClient requests channel creation:\n    \n    \n    Request:  \n    {  \n      chain_id: 137  // Polygon  \n      token: \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\"  // USDC  \n    }  \n    Signature: session key signature  \n    \n\n#### Step 2: Clearnode Processes Requestâ€‹\n\nThe clearnode:\n\n  * Validates token is supported on chain\n  * Generates unique nonce\n  * Selects adjudicator (SimpleConsensus for payment channels)\n  * Creates Channel struct\n  * Computes `channelId` = `keccak256(abi.encode(Channel))`\n  * Creates initial State with `intent: INITIALIZE`, `version: 0`, `state_data: \"0x\"`, zero allocations\n  * Packs state (`abi.encode(channelId, intent, version, data, allocations)` in Solidity terms)\n  * Signs packed state with clearnode's participant key\n\n#### Step 3: Clearnode â†’ Client: Responseâ€‹\n    \n    \n    Response:  \n    {  \n      channel: {  \n        participants: [user_address, clearnode_address]  \n        adjudicator: 0xSimpleConsensusAddress  \n        challenge: 86400  \n        nonce: 1699123456789  \n      }  \n      state: {  \n        intent: INITIALIZE  \n        version: 0  \n        data: \"0x\"  \n        allocations: [  \n          {destination: user_address, token: usdc, amount: 0},  \n          {destination: clearnode_address, token: usdc, amount: 0}  \n        ]  \n      }  \n      server_signature: \"0xClearnodeSig...\"  \n      channel_id: \"0xChannelId...\"  \n    }  \n    \n\nClearnode Signs First\n\nThe clearnode provides its signature **BEFORE** the user commits funds on-chain. This ensures both parties have committed before any on-chain transaction occurs.\n\n#### Steps 4-5: Client Validates and Signsâ€‹\n\nClient:\n\n  * Recomputes `channelId` and verifies it matches\n  * Recomputes packed state and verifies clearnode signature\n  * Signs packed state with user's participant key\n\n#### Step 6: Client â†’ Blockchain: `Custody.create()`â€‹\n\nClient submits transaction:\n    \n    \n    Custody.create(channel, state, userSig, serverSig)  \n    \n\n#### Step 7: Blockchain Validates and Creates Channelâ€‹\n\nContract:\n\n  * Verifies user's signature is valid\n  * Verifies clearnode's signature is valid\n  * Stores channel parameters and funding state (zero balances)\n  * Sets channel status to `OPEN`\n  * Emits `Opened` event\n\n#### Step 8: Event Listener Detects Creationâ€‹\n\nThe clearnode's event listener:\n\n  * Detects `Opened` event\n  * Validates channel parameters\n\n#### Steps 9-10: Notificationsâ€‹\n\nThe clearnode:\n\n  * Updates internal database: channel status = open (zero balance)\n  * Sends `channel_update` notification to client\n\n#### Step 11: Channel Activeâ€‹\n\n  * Channel active with zero balance\n  * Use `resize_channel` to fund the channel\n\n### Key Pointsâ€‹\n\nTwo-Phase Process\n\n  * **Off-chain preparation** : Clearnode prepares and signs channel configuration\n  * **On-chain execution** : User submits transaction to lock funds\n  * This ensures clearnode is ready to join before user risks funds\n\n**Related Methods** : [`create_channel`](/docs/off-chain/channel-methods#create_channel)\n\n* * *\n\n## Off-Chain Transfer Flowâ€‹\n\n### Purposeâ€‹\n\nTransfer funds between users instantly without blockchain transaction.\n\n### Actorsâ€‹\n\n  * **Sender (Client A)** : Initiating user\n  * **Clearnode** : Off-chain service provider\n  * **Receiver (Client B)** : Receiving user\n\n### Sequence Diagramâ€‹\n\nClient BClearnodeClient AClient BClearnodeClient A2\\. Validate Request3\\. Update Ledger4\\. Notify ReceiverComplete: < 1 second, zero gastransfer(destination, amount, asset)Check A authenticatedCheck A has sufficient balanceCheck B exists (has channel)Debit entry (A: -50 USDC)Credit entry (B: +50 USDC)Create transaction recordTransfer confirmed âœ“transfer_received eventbalance_update event\n\n### Stepsâ€‹\n\n#### Step 1: Client A â†’ Clearnode: `transfer`â€‹\n\nSender initiates transfer:\n    \n    \n    Request:  \n    {  \n      destination: \"0xClientB_Address\",   // or destination_user_tag: \"UX123D\"  \n      allocations: [{\"asset\": \"usdc\", \"amount\": \"50.0\"}]  \n    }  \n    Signature: Client A's session key  \n    \n\n#### Step 2: Clearnode Validatesâ€‹\n\nThe clearnode validates:\n\n  * Client A is authenticated\n  * Client A has >= 50 USDC available balance\n  * Destination address/tag is valid (account is created if new)\n  * Asset \"usdc\" is supported\n\n#### Step 3: Clearnode Creates Ledger Entriesâ€‹\n\nDouble-entry bookkeeping:\n\n**Entry 1 (Debit from Client A unified account)** :\n    \n    \n    {  \n      account_id: Client A address  \n      asset: \"usdc\"  \n      credit: \"0.0\"  \n      debit: \"50.0\"  \n    }  \n    \n\n**Entry 2 (Credit to Client B unified account)** :\n    \n    \n    {  \n      account_id: Client B address  \n      asset: \"usdc\"  \n      credit: \"50.0\"  \n      debit: \"0.0\"  \n    }  \n    \n\n#### Step 4: Clearnode Creates Transaction Recordâ€‹\n    \n    \n    {  \n      id: 1,  \n      tx_type: \"transfer\",  \n      from_account: Client A address,  \n      from_account_tag: \"NQKO7C\",  \n      to_account: Client B address,  \n      to_account_tag: \"UX123D\",  \n      asset: \"usdc\",  \n      amount: \"50.0\",  \n      created_at: \"2023-05-01T12:00:00Z\"  \n    }  \n    \n\n#### Step 5: Clearnode â†’ Client A: Responseâ€‹\n    \n    \n    Response:  \n    {  \n      transactions: [  \n        {  \n          id: 1,  \n          tx_type: \"transfer\",  \n          from_account: \"0xA...\",  \n          from_account_tag: \"NQKO7C\",  \n          to_account: \"0xB...\",  \n          to_account_tag: \"UX123D\",  \n          asset: \"usdc\",  \n          amount: \"50.0\",  \n          created_at: \"2023-05-01T12:00:00Z\"  \n        }  \n      ]  \n    }  \n    \n\n#### Step 6-7: Clearnode â†’ Clients: Notificationsâ€‹\n\n  * `tr` (transfer) notification to sender/receiver with `transactions` array\n  * `bu` (balance update) notification reflecting new balances\n\n#### Step 9: Transfer Completeâ€‹\n\n  * Instant (< 1 second)\n  * No blockchain transaction\n  * Zero gas fees\n  * Both parties notified\n\n### Key Pointsâ€‹\n\nInstant Settlement\n\n  * **Purely off-chain** : Database transaction, no blockchain\n  * **Instant settlement** : < 1 second typical\n  * **Zero gas fees** : No on-chain transaction required\n  * **Double-entry bookkeeping** : Accounting accuracy guaranteed\n  * **Receiver account auto-created** : Destination tag/address need not have a prior balance\n\n**Related Methods** : [`transfer`](/docs/off-chain/transfers#transfer)\n\n* * *\n\n## App Session Lifecycle Flowâ€‹\n\n### Purposeâ€‹\n\nCreate, update, and close a collaborative app session with multiple participants.\n\n### Actorsâ€‹\n\n  * **Client A** : Participant 1\n  * **Client B** : Participant 2\n  * **Clearnode** : Off-chain service provider\n\n### Scenarioâ€‹\n\nTwo-player chess game with 100 USDC stake each.\n\n### Sequence Diagramâ€‹\n\nClearnodeClient BClient AClearnodeClient BClient ACreate (lock funds)Update (submit_app_state)Closecreate_app_session(definition, allocations, session_data?)co-sign (if non-zero allocation)Validate quorum, balances, allowancesLock allocations from unified balances{app_session_id, status:\"open\", version:1}asu/bu notificationssubmit_app_state(app_session_id, intent, version, allocations, session_data?)co-signs to meet quorumValidate intent rules, version, quorum, allowancesApply operate/deposit/withdraw{app_session_id, status:\"open\", version:n}asu/bu notificationsclose_app_session(app_session_id, allocations, session_data?)co-signs to meet quorumValidate sums and quorum, release to unified balances{app_session_id, status:\"closed\", version:n+1}asu/bu notifications\n\n### Sequence (Create â†’ Update â†’ Close)â€‹\n\n  1. **Create (off-chain):`create_app_session`**\n\n     * Client signs request (all participants with non-zero allocations must sign).\n     * Clearnode validates protocol version (0.2/0.4), quorum, balances, allowances/session keys.\n     * Funds are locked from each signerâ€™s unified balance into the app session account.\n     * **Response (minimal)** : `app_session_id`, `status: \"open\"`, `version: 1`. Full metadata is not echoed; use `get_app_sessions` to read it.\n\n**Example Request** :\n    \n    {  \n      \"req\": [1,\"create_app_session\",{  \n        \"definition\": {  \n          \"protocol\": \"NitroRPC/0.4\",  \n          \"participants\": [\"0xA\",\"0xB\"],  \n          \"weights\": [100,100],  \n          \"quorum\": 200,  \n          \"challenge\": 86400,  \n          \"nonce\": 1699123  \n        },  \n        \"allocations\": [  \n          {\"participant\": \"0xA\",\"asset\": \"usdc\",\"amount\": \"100.0\"},  \n          {\"participant\": \"0xB\",\"asset\": \"usdc\",\"amount\": \"100.0\"}  \n        ],  \n        \"session_data\": \"{\\\"game\\\":\\\"chess\\\"}\"  \n      },1699123456789],  \n      \"sig\": [\"0xUserSig\",\"0xCoSig\"]  \n    }  \n    \n\n  2. **State Updates (off-chain):`submit_app_state`**\n\n     * v0.4 requires `version = current+1`; v0.2 rejects `intent`/`version` and only allows a single update.\n     * Intents:\n       * `operate`: redistribute, sum must stay equal.\n       * `deposit`: sum must increase; depositor must sign and have available unified balance.\n       * `withdraw`: sum must decrease; session must have funds.\n     * Quorum required; session-key allowances enforced.\n     * **Response (minimal)** : `app_session_id`, `status: \"open\"`, `version` (new). No metadata echoed.\n     * Notifications: `asu` (app session update) + `bu` (balance update for deposit/withdraw).\n\n**Example Request (deposit v0.4)** :\n    \n    {  \n      \"req\": [2,\"submit_app_state\",{  \n        \"app_session_id\": \"0xSession\",  \n        \"intent\": \"deposit\",  \n        \"version\": 2,  \n        \"allocations\": [  \n          {\"participant\": \"0xA\",\"asset\": \"usdc\",\"amount\": \"150.0\"},  \n          {\"participant\": \"0xB\",\"asset\": \"usdc\",\"amount\": \"100.0\"}  \n        ]  \n      },1699123456790],  \n      \"sig\": [\"0xUserSig\",\"0xCoSig\"]  \n    }  \n    \n\n  3. **Close (off-chain):`close_app_session`**\n\n     * Requires quorum signatures; final allocations must match total balances.\n     * **Response (minimal)** : `app_session_id`, `status: \"closed\"`, `version` (incremented). No metadata echoed.\n     * Funds are released to participantsâ€™ unified balances; notifications `asu` and `bu` are sent.\n\n**Example Request** :\n    \n    {  \n      \"req\": [3,\"close_app_session\",{  \n        \"app_session_id\": \"0xSession\",  \n        \"allocations\": [  \n          {\"participant\": \"0xA\",\"asset\": \"usdc\",\"amount\": \"180.0\"},  \n          {\"participant\": \"0xB\",\"asset\": \"usdc\",\"amount\": \"20.0\"}  \n        ]  \n      },1699123456795],  \n      \"sig\": [\"0xUserSig\",\"0xCoSig\"]  \n    }  \n    \n\n\n### Key Pointsâ€‹\n\nApp Sessions\n\nApp sessions enable multi-party applications with custom governance rules. Funds are locked from unified balance for the duration of the session.\n\n**Related Methods** : [`create_app_session`](/docs/off-chain/app-sessions#create_app_session), [`submit_app_state`](/docs/off-chain/app-sessions#submit_app_state), [`close_app_session`](/docs/off-chain/app-sessions#close_app_session)\n\n* * *\n\n## Cooperative Closure Flowâ€‹\n\n### Purposeâ€‹\n\nClose channel when all parties agree on final state.\n\n### Actorsâ€‹\n\n  * **Client** : User application\n  * **Clearnode** : Off-chain service provider\n  * **Smart Contract** : Custody Contract\n  * **Blockchain** : Ethereum-compatible network\n\n### Key Pointsâ€‹\n\nPreferred Method\n\nCooperative closure is **fast (1 transaction)** , **cheap (low gas)** , and **immediate (no waiting period)**. Always use this when possible.\n\n### Sequence Diagramâ€‹\n\nBlockchainClearnodeClientBlockchainClearnodeClientclose_channel(channel_id, funds_destination)Validate channel open/resizing and not challengedBuild FINALIZE state (version = current+1, data = \"0x\", allocations){channel_id, state, server_signature}Verify server_signature and sign packed stateCustody.close(channel_id, state, userSig, serverSig)Verify signatures, close channel, emit eventEvent observedUpdate DB and balancescu + bu notifications\n\n### Sequenceâ€‹\n\n  1. **Client â†’ Clearnode** : `close_channel(channel_id, funds_destination)`\n\n     * Authenticated request signed by the user (session key or wallet).\n\n**Example Request** :\n    \n    {  \n      \"req\": [10,\"close_channel\",{  \n        \"channel_id\": \"0xChannel\",  \n        \"funds_destination\": \"0xUser\"  \n      },1699123457000],  \n      \"sig\": [\"0xUserSig\"]  \n    }  \n    \n\n  2. **Clearnode** : validates channel exists and is `open`/`resizing`, checks challenged-channel guard, builds FINALIZE state:\n\n     * `intent: FINALIZE`, `version = current+1`, `state_data: \"0x\"`, allocations split between user and broker based on channel balance.\n     * Signs packed state (`keccak256(abi.encode(channelId, intent, version, data, allocations))`).\n  3. **Clearnode â†’ Client** : response with `channel_id`, `state`, `server_signature`.\n\n  4. **Client** : verifies server signature, signs the same packed state.\n\n  5. **Client â†’ Blockchain** : `Custody.close(channel_id, state, userSig, serverSig)` (one tx).\n\n  6. **Blockchain** : verifies both signatures, closes channel, emits `Closed/Opened`-equivalent event (implementation-specific), releases funds.\n\n  7. **Clearnode** : observes event, updates DB, sends `cu` (channel update) and `bu` (balance update) notifications.\n\n\n**Related Methods** : [`close_channel`](/docs/off-chain/channel-methods#close_channel)\n\n* * *\n\n## Challenge-Response Closure Flowâ€‹\n\n### Purposeâ€‹\n\nClose channel when other party is unresponsive or disputes final state.\n\n### Actorsâ€‹\n\n  * **Client** : User application\n  * **Clearnode** : Off-chain service provider (may be unresponsive)\n  * **Smart Contract** : Custody Contract\n  * **Blockchain** : Ethereum-compatible network\n\n### Key Pointsâ€‹\n\nChallenge Period\n\nThis method requires waiting for the challenge period (typically 24 hours) to elapse. Use only when cooperative closure fails.\n\n### Sequence Diagramâ€‹\n\nOtherPartyClearnodeBlockchainClientOtherPartyClearnodeBlockchainClientHold latest signed statealt[Newer state posted]Wait for challenge period expiryCustody.challenge(channelId, state, sigs)Start challenge timer (challenge period)Custody.checkpoint(channelId, newerState, sigs)Replace pending stateCustody.close(channelId, state, sigs) // after timeout if uncontestedFinalize channel, emit eventEvent observed when back onlineUpdate DB, balancescu + bu notifications\n\n### Sequence (User-initiated, clearnode unresponsive)â€‹\n\n  1. **Prerequisite** : User holds the latest mutually signed state (or clearnode-signed latest) for the channel.\n  2. **Client â†’ Blockchain** : `Custody.challenge(channelId, state, sigs...)`\n     * Submits the latest signed state to start the challenge.\n  3. **Challenge Window** : Other party can respond with a newer valid state before timeout.\n  4. **If no newer state is posted** : After the challenge period, user calls `Custody.close(channelId, state, sigs...)` to finalize.\n  5. **Blockchain** : finalizes channel, releases funds per challenged state, emits closure event.\n  6. **Clearnode** (when responsive again): observes event, updates DB, sends `cu`/`bu` notifications to participants.\n\n**Related Methods** : On-chain `Custody.challenge()` and `Custody.close()`\n\n* * *\n\n## Next Stepsâ€‹\n\nNow that you understand how all protocol layers work together:\n\n  1. **Review Method Details** : Visit Part 2 (Off-Chain RPC Protocol) for complete method specifications\n  2. **Explore Reference** : See [Protocol Reference](/docs/protocol/protocol-reference) for constants and standards\n  3. **Implementation Guide** : Check [Implementation Checklist](/docs/protocol/implementation-checklist) for best practices\n  4. **Quick Start** : Follow the [Quick Start Guide](/docs/protocol/quick-start) to begin building\n\nComplete Flows\n\nThese flows represent the most common operations. For edge cases and error handling, consult the specific method documentation in Part 2.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/communication-flows.mdx)\n\n[PreviousQuery Methods & Notifications](/docs/protocol/off-chain/queries)[NextProtocol Reference](/docs/protocol/protocol-reference)\n\n  * Authentication Flow\n    * Purpose\n    * Actors\n    * Sequence Diagram\n    * Steps\n    * Key Points\n  * Channel Creation Flow\n    * Purpose\n    * Actors\n    * Sequence Diagram\n    * Steps\n    * Key Points\n  * Off-Chain Transfer Flow\n    * Purpose\n    * Actors\n    * Sequence Diagram\n    * Steps\n    * Key Points\n  * App Session Lifecycle Flow\n    * Purpose\n    * Actors\n    * Scenario\n    * Sequence Diagram\n    * Sequence (Create â†’ Update â†’ Close)\n    * Key Points\n  * Cooperative Closure Flow\n    * Purpose\n    * Actors\n    * Key Points\n    * Sequence Diagram\n    * Sequence\n  * Challenge-Response Closure Flow\n    * Purpose\n    * Actors\n    * Key Points\n    * Sequence Diagram\n    * Sequence (User-initiated, clearnode unresponsive)\n  * Next Steps",
    "metadata": {
      "title": "Cross-Layer Communication Flows | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/communication-flows",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/glossary",
    "text": "* [](/)\n  * Glossary\n\nOn this page\n\n# Glossary\n\nComplete alphabetical reference of all protocol terms and concepts.\n\nQuick Reference\n\nThis glossary provides concise definitions of all Nitrolite protocol terms. For detailed explanations with examples and diagrams, see the respective sections in the documentation.\n\n* * *\n\n## Aâ€‹\n\n### Adjudicatorâ€‹\n\nSmart contract that validates state transitions according to application-specific rules. Each channel specifies an adjudicator that determines which state updates are valid.\n\n**Examples** : SimpleConsensus, RemittanceAdjudicator\n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures), [Security Considerations](/docs/protocol/on-chain/security)\n\n* * *\n\n### Allocationâ€‹\n\nSpecification of how funds are distributed, containing destination, token, and amount. Allocations define where funds should be sent when a channel closes or how they're distributed within an app session.\n\n**Structure** :\n    \n    \n    {  \n      destination: address,  // Recipient wallet address  \n      token: address,        // ERC-20 token contract  \n      amount: uint256        // Amount in smallest unit  \n    }  \n    \n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures#allocation)\n\n* * *\n\n### App Sessionâ€‹\n\nOff-chain channels built on top of payment channels, intended to be used by app developers to enable application-specific interactions and transactions without touching the blockchain. Previously known as Virtual Ledger Channels (VLC).\n\n**Features** :\n\n  * Multi-party participation\n  * Custom governance rules (quorum, weights)\n  * Fund locking from unified balance\n  * Application-specific state management\n\n**Related** : [App Sessions Methods](/docs/off-chain/app-sessions), [Communication Flows](/docs/protocol/communication-flows#app-session-lifecycle-flow)\n\n* * *\n\n## Câ€‹\n\n### Challenge Periodâ€‹\n\nDuration (in seconds) that parties have to respond to a dispute. When a channel is challenged, all participants have this amount of time to submit a newer state before the challenged state becomes final.\n\n**Typical Values** :\n\n  * Default: 86400 seconds (24 hours)\n  * Minimum recommended: 3600 seconds (1 hour)\n  * Maximum recommended: 604800 seconds (7 days)\n\n**Related** : [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle#closure---challenge-response)\n\n* * *\n\n### Channelâ€‹\n\nA secure communication pathway between participants that locks funds in an on-chain smart contract while enabling off-chain state updates. Channels are the foundation of the Nitrolite protocol.\n\n**Lifecycle** : VOID â†’ INITIAL â†’ ACTIVE â†’ (DISPUTE) â†’ FINAL\n\n**Related** : [On-Chain Protocol](/docs/protocol/on-chain/overview), [Data Structures](/docs/protocol/on-chain/data-structures#channel)\n\n* * *\n\n### channelIdâ€‹\n\nA unique identifier for a channel, formatted as a 0x-prefixed hex string (32 bytes). Computed deterministically from the channel configuration.\n\n**Computation** :\n    \n    \n    channelId = keccak256(abi.encode(  \n      channel.participants,  \n      channel.adjudicator,  \n      channel.challenge,  \n      channel.nonce  \n    ))  \n    \n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures#channel-identifier)\n\n* * *\n\n### Checkpointâ€‹\n\nRecording a state on-chain without entering dispute mode. Checkpointing creates an on-chain record of the current state but keeps the channel in ACTIVE status.\n\n**Benefits** :\n\n  * Shortens effective challenge history\n  * Provides on-chain proof of state\n  * Doesn't start challenge period\n\n**Related** : [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle#checkpointing)\n\n* * *\n\n### Clearnodeâ€‹\n\nA virtual ledger layer that provides a unified ledger (through Nitro RPC) and coordinates state channels (through Nitrolite), providing chain abstraction for developers and users.\n\n**Responsibilities** :\n\n  * Manage off-chain RPC protocol\n  * Provide unified balance\n  * Join payment channels\n  * Coordinate app sessions\n\n**Related** : [Architecture](/docs/protocol/architecture), [Off-Chain RPC Protocol](/docs/off-chain/overview)\n\n* * *\n\n### Creatorâ€‹\n\nThe participant at index 0 in a channel who initiates channel creation. The Creator constructs the channel configuration, prepares the initial funding state, signs it (signature at position 0), and calls the on-chain `create()` function to lock their funds and establish the channel.\n\n**Typically** : A user or light client opening a payment channel with a clearnode.\n\n**Related** : [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle#creation-phase), [Protocol Reference](/docs/protocol/protocol-reference#participant-indices)\n\n* * *\n\n### Custody Contractâ€‹\n\nThe main on-chain contract implementing channel creation, joining, closure, and resizing. It is an implementation of the Nitrolite protocol.\n\n**Interfaces Implemented** :\n\n  * `IChannel` \\- Core channel operations\n  * `IDeposit` \\- Fund management\n  * `IChannelReader` \\- State queries\n\n**Related** : [On-Chain Overview](/docs/protocol/on-chain/overview), [Data Structures](/docs/protocol/on-chain/data-structures)\n\n* * *\n\n## Iâ€‹\n\n### Intentâ€‹\n\nIn NitroRPC/0.4, specifies the type of app session state update. The intent system enables dynamic fund management within active sessions.\n\n**Types** :\n\n  * **OPERATE** : Redistribute existing funds (sum unchanged)\n  * **DEPOSIT** : Add funds to session from unified balance\n  * **WITHDRAW** : Remove funds from session to unified balance\n\n**Related** : [App Sessions](/docs/off-chain/app-sessions#submit_app_state)\n\n* * *\n\n## Lâ€‹\n\n### Ledger Entryâ€‹\n\nDouble-entry bookkeeping record of a debit or credit. Every financial operation in a clearnode creates two ledger entries to maintain accounting accuracy.\n\n**Fields** :\n\n  * account_id\n  * asset\n  * credit (incoming)\n  * debit (outgoing)\n  * created_at\n\n**Related** : [Transfers](/docs/off-chain/transfers#off-chain-processing), [Query Methods](/docs/off-chain/queries#get_ledger_entries)\n\n* * *\n\n### Ledger Transactionâ€‹\n\nUser-facing transaction record showing transfers, deposits, withdrawals, and app session operations. Provides a simplified view of financial activity.\n\n**Types** :\n\n  * `transfer` \\- Direct transfer between users\n  * `deposit` \\- Funds deposited to unified balance\n  * `withdrawal` \\- Funds withdrawn from unified balance\n  * `app_deposit` \\- Funds locked in app session\n  * `app_withdrawal` \\- Funds released from app session\n\n**Related** : [Query Methods](/docs/off-chain/queries#get_ledger_transactions)\n\n* * *\n\n## Mâ€‹\n\n### Magic Numberâ€‹\n\nConstant in `state.data` signaling special states. Magic numbers enable smart contracts to identify the type of state without complex parsing.\n\n**Values** :\n\n  * **CHANOPEN** = 7877 (0x1EC5) - Initial funding state\n  * **CHANCLOSE** = 7879 (0x1EC7) - Final closing state\n\n**Related** : [Protocol Reference](/docs/protocol/protocol-reference#magic-numbers), [Data Structures](/docs/protocol/on-chain/data-structures)\n\n* * *\n\n## Nâ€‹\n\n### Nonceâ€‹\n\nUnique number ensuring channel identifier uniqueness. Even with identical participants and configuration, different nonces create different channel IDs.\n\n**Typical Value** : Timestamp in milliseconds\n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures#channel), [Channel Creation](/docs/off-chain/channel-methods#create_channel)\n\n* * *\n\n### Nitro RPCâ€‹\n\nThe off-chain communication protocol for state channel operations. A lightweight, RPC-based RPC protocol with compact message format and signature-based authentication.\n\n**Versions** :\n\n  * **NitroRPC/0.2** : Legacy (basic state updates)\n  * **NitroRPC/0.4** : Current (intent system)\n\n**Related** : [Off-Chain RPC Protocol](/docs/off-chain/overview), [Message Format](/docs/off-chain/message-format)\n\n* * *\n\n### Nitroliteâ€‹\n\nThe on-chain smart contract protocol for state channels. Defines the structure of channels, states, and the rules for creation, updates, and closure.\n\n**Version** : 0.5.0 (Mainnet deployments live; not production yet)\n\n**Related** : [On-Chain Protocol](/docs/protocol/on-chain/overview), [Protocol Reference](/docs/protocol/protocol-reference#protocol-versions)\n\n* * *\n\n## Pâ€‹\n\n### Participantâ€‹\n\nAn entity (identified by a wallet address) that is part of a channel. Typically includes a Creator (user) and a Clearnode or Clearnode Operator.\n\n**In Payment Channels** :\n\n  * Index 0: Creator (user)\n  * Index 1: Clearnode\n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures#channel), [Protocol Reference](/docs/protocol/protocol-reference#participant-indices)\n\n* * *\n\n## Qâ€‹\n\n### Quorumâ€‹\n\nMinimum total weight of signatures required to approve app session state updates. The quorum defines the governance threshold for multi-party applications.\n\n**Example** :\n    \n    \n    participants: [Alice, Bob, Judge]  \n    weights: [40, 40, 50]  \n    quorum: 80  \n      \n    // Valid signature combinations:  \n    // - Alice + Bob (40 + 40 = 80) âœ“  \n    // - Alice + Judge (40 + 50 = 90) âœ“  \n    // - Bob + Judge (40 + 50 = 90) âœ“  \n    // - Alice alone (40 < 80) âœ—  \n    \n\n**Related** : [App Sessions](/docs/off-chain/app-sessions#create_app_session), [Governance Examples](/docs/off-chain/app-sessions#governance-examples)\n\n* * *\n\n## Râ€‹\n\n### requestIdâ€‹\n\nA unique identifier for an RPC request, used for correlating requests and responses. Generated by the client for each request.\n\n**Type** : uint64\n\n**Related** : [Message Format](/docs/off-chain/message-format#general-structure)\n\n* * *\n\n## Sâ€‹\n\n### Session Keyâ€‹\n\nA temporary cryptographic key delegated by a user's main wallet that provides a flexible way for the user to manage security of their funds by giving specific permissions and allowances for specific apps.\n\n**Features** :\n\n  * Spending limits (allowances)\n  * Operation scope restrictions\n  * Expiration time\n  * Gasless signing (no wallet prompts)\n\n**Related** : [Authentication](/docs/off-chain/authentication), [Communication Flows](/docs/protocol/communication-flows#authentication-flow)\n\n* * *\n\n### Stateâ€‹\n\nA snapshot of the channel at a point in time, including fund allocations and application-specific data. States are signed by participants to authorize transitions.\n\n**Components** :\n\n  * `intent` \\- Purpose of the state (INITIALIZE, OPERATE, RESIZE, FINALIZE)\n  * `version` \\- Incremental version number for comparison\n  * `data` \\- Application-specific data or magic number\n  * `allocations` \\- Fund distribution\n  * `sigs` \\- Participant signatures\n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures#state)\n\n* * *\n\n### packedStateâ€‹\n\nA specific encoding of a channelId, state.intent, state.version, state.data, state.allocations, used for signing and signature verification.\n\n**Computation** :\n    \n    \n    packedState = abi.encode(  \n      channelId,  \n      state.intent,  \n      state.version,  \n      state.data,  \n      state.allocations  \n    )  \n    \n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures#packed-state)\n\n* * *\n\n## Uâ€‹\n\n### Unified Balanceâ€‹\n\nAn abstraction that aggregates a user's funds across multiple blockchain networks, managed by a clearnode. The unified balance provides a single view of all assets regardless of which chain they're locked on.\n\n**Benefits** :\n\n  * Chain abstraction\n  * Simplified fund management\n  * Cross-chain transfers without bridges\n  * Single balance for all operations\n\n**Related** : [Architecture](/docs/protocol/architecture#fund-flow), [Transfers](/docs/off-chain/transfers#unified-balance-mechanics)\n\n* * *\n\n## Wâ€‹\n\n### Weightâ€‹\n\nVoting power assigned to a participant in an app session. Weights determine how much influence each participant has in governance decisions.\n\n**Usage** : Sum of signer weights must meet quorum for state updates to be valid.\n\n**Related** : [App Sessions](/docs/off-chain/app-sessions#create_app_session)\n\n* * *\n\n## Additional Termsâ€‹\n\n### appSessionIdâ€‹\n\nA unique identifier for an app session, formatted as a 0x-prefixed hex string (32 bytes). Used for all subsequent operations on that specific app session.\n\n* * *\n\n### chainIdâ€‹\n\nA blockchain network identifier (uint64). Examples: 1 (Ethereum Mainnet), 137 (Polygon), 8453 (Base), 42161 (Arbitrum One), 10 (Optimism).\n\n* * *\n\n### assetSymbolâ€‹\n\nA lowercase string identifier for a supported asset (e.g., \"usdc\", \"eth\", \"weth\", \"usdt\", \"dai\", \"wbtc\"). Asset symbols are consistent across chains.\n\n* * *\n\n### walletAddressâ€‹\n\nA user's blockchain address (0x-prefixed hex string, 20 bytes) that identifies their account and owns funds. Used to identify participants in channels and app sessions.\n\n* * *\n\n## Cross-Referencesâ€‹\n\nFor detailed explanations of these terms with examples, diagrams, and use cases, refer to:\n\n  * **Core Concepts** : [Terminology](/docs/protocol/terminology)\n  * **On-Chain Details** : [On-Chain Protocol](/docs/protocol/on-chain/overview)\n  * **Off-Chain Details** : [Off-Chain RPC Protocol](/docs/off-chain/overview)\n  * **Implementation** : [Quick Start Guide](/docs/protocol/quick-start), [Implementation Checklist](/docs/protocol/implementation-checklist)\n\nUsing This Glossary\n\nPress `Ctrl+F` (or `Cmd+F` on Mac) to search for specific terms. Most terms also appear as tooltips throughout the documentation for quick reference.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/glossary.mdx)\n\n[PreviousProtocol Reference](/docs/protocol/protocol-reference)[NextImplementation Checklist](/docs/protocol/implementation-checklist)\n\n  * A\n    * Adjudicator\n    * Allocation\n    * App Session\n  * C\n    * Challenge Period\n    * Channel\n    * channelId\n    * Checkpoint\n    * Clearnode\n    * Creator\n    * Custody Contract\n  * I\n    * Intent\n  * L\n    * Ledger Entry\n    * Ledger Transaction\n  * M\n    * Magic Number\n  * N\n    * Nonce\n    * Nitro RPC\n    * Nitrolite\n  * P\n    * Participant\n  * Q\n    * Quorum\n  * R\n    * requestId\n  * S\n    * Session Key\n    * State\n    * packedState\n  * U\n    * Unified Balance\n  * W\n    * Weight\n  * Additional Terms\n    * appSessionId\n    * chainId\n    * assetSymbol\n    * walletAddress\n  * Cross-References",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/implementation-checklist",
    "text": "* [](/)\n  * Implementation Checklist\n\nOn this page\n\n# Implementation Checklist\n\nComprehensive checklist for building a compliant Nitrolite client with security best practices.\n\nProgressive Implementation\n\nYou don't need to implement everything at once. Start with Core Protocol and On-Chain Integration, then add Off-Chain RPC and advanced features progressively.\n\n* * *\n\n## Core Protocol Supportâ€‹\n\nFoundation requirements for any Nitrolite implementation.\n\n### Identifier Computationâ€‹\n\n  * **Compute channelId from Channel struct**\n\n    * Hash participants, adjudicator, challenge, nonce using keccak256\n    * Verify deterministic computation (same inputs = same output)\n    * Reference: [Data Structures](/docs/protocol/on-chain/data-structures#channel-identifier)\n  * **Compute payload hash (packedState) from channel state**\n\n    * Compute `packedState = keccak256(abi.encode(channelId, state.intent, state.version, state.data, state.allocations))`\n    * Ensure proper ABI encoding\n    * Reference: [Data Structures](/docs/protocol/on-chain/data-structures#packed-state)\n\n### Signature Handlingâ€‹\n\n  * **Generate signatures**\n\n    * Support ECDSA signatures (standard for EOA wallets)\n    * Encode as `bytes` format (65 bytes: r + s + v)\n    * For on-chain: sign raw `packedState` hash\n    * For off-chain RPC: sign EIP-712 typed data structures\n    * Reference: [Signature Standards](/docs/protocol/protocol-reference#signature-standards)\n  * **Verify signatures**\n\n    * Recover signer address from signature\n    * Validate signer matches expected participant\n    * Support EIP-1271 for smart contract wallets\n    * Support EIP-6492 for counterfactual contracts\n    * Handle EIP-191 for personal signatures where applicable\n\nSignature Standards\n\nOn-chain signatures use raw `packedState` hash for chain-agnostic compatibility. Off-chain RPC messages use EIP-712 typed data for user-facing signatures (e.g., authentication). Refer to [Signature Standards](/docs/protocol/protocol-reference#signature-standards) for details.\n\n* * *\n\n## On-Chain Integrationâ€‹\n\nSmart contract interactions for channel lifecycle management.\n\n### Blockchain Connectionâ€‹\n\n  * **Connect to Ethereum-compatible blockchain**\n\n    * Support multiple chains (Ethereum, Polygon, Arbitrum, Optimism, Base)\n    * Use Web3 provider (e.g., Infura, Alchemy)\n    * Handle network switching\n    * Implement retry logic for failed connections\n  * **Load contract ABIs**\n\n    * Custody Contract ABI\n    * Adjudicator contract ABI (application-specific)\n    * ERC-20 token ABI\n\n### Channel Operationsâ€‹\n\n  * **Create channel (`Custody.create`)**\n\n    * Verify state has `intent = INITIALIZE` (1) and `version = 0`\n    * Preferred: include both participant signatures to start in `ACTIVE`\n    * Legacy: single sig â†’ `INITIAL`; wait for `join()` to reach `ACTIVE`\n    * Handle ERC-20 approvals only if depositing at creation (legacy flow)\n    * Reference: [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle#creation-phase)\n  * **Monitor activation / join**\n\n    * Subscribe to `Opened` and `Joined` events\n    * In legacy flow, ensure `join()` transitions `INITIAL` â†’ `ACTIVE`\n  * **Cooperative closure (`Custody.close`)**\n\n    * Build state with `intent = FINALIZE` (3), `version = current+1`, `data = \"0x\"`\n    * Require both participant signatures; submit single tx\n    * Confirm funds destination and allocations match expectations\n    * Reference: [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle#cooperative-closure)\n  * **Dispute / challenge**\n\n    * Persist latest fully signed state for `challenge()`\n    * During `DISPUTE`, accept newer state via `checkpoint()` (on-chain) if available\n    * After challenge timeout, finalize with `close()` using challenged state\n    * Reference: [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle#challenge-phase)\n\n### Event Listeningâ€‹\n\n  * **Listen to contract events**\n\n    * `Opened(channelId, channel, deposits)` \\- Channel created and active\n    * `Challenged(channelId, state, expiration)` \\- Dispute started (expiration = challenge period end)\n    * `Closed(channelId, allocations)` \\- Channel finalized\n    * `Resized(channelId)` \\- Channel capacity changed\n  * **Process events in order**\n\n    * Maintain event log cursor/checkpoint\n    * Handle blockchain reorganizations\n    * Implement event replay for recovery\n  * **Update internal state based on events**\n\n    * Sync channel status (INITIAL â†’ ACTIVE â†’ DISPUTE â†’ FINAL)\n    * Update unified balance when channels open/close\n    * Notify users of status changes\n\nEvent Recovery\n\nImplement event recovery for when your application restarts or loses connection. Replay events from last checkpoint to current block.\n\n* * *\n\n## Off-Chain RPCâ€‹\n\nRPC communication with clearnode.\n\n### Connection Managementâ€‹\n\n  * **Establish RPC connection**\n\n    * Connect to clearnode RPC endpoint\n    * Handle connection timeouts\n    * Implement exponential backoff for reconnection\n    * Reference: [Off-Chain Overview](/docs/off-chain/overview)\n  * **Implement message format**\n\n    * Compact JSON array format: `[requestId, method, params, timestamp]`\n    * Request wrapper: `{req: [...], sig: [...]}`\n    * Response wrapper: `{res: [...], sig: [...]}`\n    * Error format: `{res: [requestId, \"error\", {error: \"message\"}, timestamp], sig: [...]}`\n    * Reference: [Message Format](/docs/off-chain/message-format)\n  * **Handle network outages gracefully**\n\n    * Detect connection loss\n    * Queue pending requests\n    * Reconnect automatically\n    * Resubmit queued requests after reconnection\n\n### Authenticationâ€‹\n\n  * **Implement 3-step flow (auth_request â†’ auth_challenge â†’ auth_verify)**\n\n    * Generate session keypair locally; never transmit the private key\n    * `auth_request`: public, unsigned; send address, session_key, allowances (optional), scope (optional, not enforced), **expires_at (required, ms)**\n    * Store the exact parameters; response method is `auth_challenge` with `challenge_message`\n    * `auth_verify`: sign EIP-712 Policy typed data with **main wallet** (not session key) including challenge, wallet, session_key, expires_at, scope, allowances; or pass `jwt` to reuse without signature\n    * Response returns `{address, session_key, jwt_token, success}`; use session key for all subsequent private calls\n    * Reference: [Authentication](/docs/off-chain/authentication)\n  * **Session key management**\n\n    * Specify allowances per asset (unrestricted if omitted); enforce spending caps on every debit\n    * Set `expires_at`; re-authenticate before expiry; handle â€œsession expiredâ€ errors\n    * Rotate/revoke session keys as needed; avoid reusing keys across applications\n  * **Request signing & verification**\n\n    * Client signs all private RPC requests with session key; validate clearnode signatures on responses\n    * Ensure canonical JSON serialization of `req`/`res` arrays before hashing/signing\n\n### Method Implementationâ€‹\n\n  * **Implement all required methods**\n\n    * **Authentication** : auth_request, auth_verify\n    * **Channel Management** : create_channel, close_channel, resize_channel\n    * **Transfers** : transfer\n    * **App Sessions** : create_app_session, submit_app_state, close_app_session\n    * **Queries** : get_config, get_assets, get_app_definition, get_channels, get_app_sessions, get_ledger_balances, get_ledger_entries, get_ledger_transactions, get_rpc_history, get_user_tag, get_session_keys, ping\n    * Reference: [Queries](/docs/off-chain/queries)\n  * **Handle server notifications**\n\n    * `bu` (Balance Update) - Balance changed\n    * `cu` (Channel Update) - Channel status changed\n    * `tr` (Transfer) - Incoming/outgoing transfer\n    * `asu` (App Session Update) - App session state changed\n    * Reference: [Notifications](/docs/off-chain/queries#notifications)\n\nMethod Prioritization\n\nStart with: authentication â†’ create_channel â†’ transfer â†’ get_ledger_balances. Add other methods as needed for your use case.\n\n* * *\n\n## State Managementâ€‹\n\nOff-chain state tracking and synchronization.\n\n### State Storageâ€‹\n\n  * **Store latest signed states securely**\n\n    * Save complete state struct (data, allocations, sigs)\n    * Include channelId and version\n    * Persist to durable storage (database, filesystem)\n    * Implement atomic updates\n  * **Track state versions**\n\n    * Maintain version counter per channel and app session\n    * Reject states with version â‰¤ current version\n    * Increment version for each new state\n  * **Implement unified balance tracking**\n\n    * Aggregate funds across all chains\n    * Track funds in unified account vs channel escrow vs app session accounts\n    * Update on channel open/close and transfers\n    * Reference: [Transfers](/docs/off-chain/transfers)\n  * **Handle app session state updates**\n\n    * Verify quorum met (sum of weights â‰¥ quorum)\n    * Track locked funds per session\n    * Release funds on session close\n    * Reference: [App Sessions](/docs/off-chain/app-sessions)\n\n### State Validationâ€‹\n\n  * **Verify signatures before accepting states**\n\n    * Check all required signatures present\n    * Validate each signature against expected signer\n    * Ensure quorum met for app sessions\n  * **Validate state transitions**\n\n    * For channels: verify StateIntent (INITIALIZE, RESIZE, FINALIZE)\n    * For app sessions: verify quorum and allocation rules\n    * Verify version increments correctly\n    * For closure: allocations valid and complete\n  * **Maintain state history**\n\n    * Keep N most recent states per channel\n    * Useful for dispute resolution\n    * Implement pruning strategy for old states\n\n* * *\n\n## Securityâ€‹\n\nCritical security practices for production deployments.\n\n### Key Managementâ€‹\n\n  * **Secure key storage**\n\n    * Never log private keys\n    * Use secure key storage (keychain, HSM, encrypted database)\n    * Implement key rotation\n    * Separate signing keys from storage keys\n  * **Implement signature verification**\n\n    * Verify all incoming signatures\n    * Validate signer matches expected participant\n    * Check signature freshness (timestamp)\n  * **Never share private keys or session key private keys**\n\n    * Session keys stay on client\n    * Never transmit private keys over network\n    * Use separate keys for different purposes\n\n### Challenge Monitoringâ€‹\n\n  * **Monitor blockchain for channel events**\n\n    * Subscribe to all channels you participate in\n    * Alert on `Challenged` events\n    * Automated response to challenges\n  * **Respond to challenges within challenge period**\n\n    * Maintain latest valid state\n    * Submit newer state if challenged with old state\n    * Set alerts for challenge expiration\n  * **Implement automated challenge response**\n\n    * Detect challenges automatically\n    * Submit newer state without manual intervention\n    * Fallback to manual response if needed\n\n### Session Key Managementâ€‹\n\n  * **Session key allowance enforcement**\n\n    * Track spending per session key\n    * Reject operations exceeding allowance\n    * Alert user when approaching limit\n  * **Validate spending limits client-side**\n\n    * Check allowance before submitting operations\n    * Provide clear error messages\n    * Offer to re-authenticate with higher allowance\n\n### Best Practicesâ€‹\n\n  * **Never sign two states with same version number**\n\n    * Maintain version counter\n    * Reject duplicate versions\n    * Use atomic version increment\n  * **Keep track of latest state you've signed**\n\n    * Store all signed states\n    * Never sign older version\n    * Use for dispute resolution\n  * **Set appropriate challenge periods**\n\n    * Balance security (longer) vs UX (shorter)\n    * Consider block time and congestion\n    * Minimum: 1 hour (enforced by Custody Contract `MIN_CHALLENGE_PERIOD`)\n  * **Validate all inputs thoroughly**\n\n    * Check address formats\n    * Verify amounts are positive\n    * Validate asset symbols\n    * Sanitize user input\n  * **Log all state transitions for auditing**\n\n    * Timestamp all operations\n    * Record signatures and signers\n    * Maintain audit trail\n    * Implement log rotation\n\n* * *\n\n## Error Handlingâ€‹\n\nRobust error handling for production reliability.\n\n### RPC Errorsâ€‹\n\n  * **Handle error responses**\n    * Error response format: `{res: [requestId, \"error\", {error: \"descriptive message\"}, timestamp], sig: [...]}`\n    * No numeric error codes; errors have descriptive messages only\n    * Common errors: \"authentication required\", \"insufficient balance\", \"channel not found\", \"session expired, please re-authenticate\"\n    * Always check if response method is `\"error\"`\n    * Reference: [Error Handling](/docs/protocol/protocol-reference#error-handling)\n\n### Transaction Errorsâ€‹\n\n  * **Implement retry logic for critical operations**\n\n    * Exponential backoff\n    * Maximum retry attempts\n    * Idempotent operations\n  * **Handle gas estimation failures**\n\n    * Provide manual gas limit option\n    * Retry with higher gas limit\n    * Alert user to potential issues\n  * **Handle transaction reverts**\n\n    * Parse revert reason\n    * Provide helpful error messages\n    * Suggest corrective actions\n\n* * *\n\n## Testingâ€‹\n\nComprehensive testing strategy for confidence in production.\n\n### Unit Testingâ€‹\n\n  * **Test signature generation and verification**\n\n    * Known test vectors\n    * Round-trip signing\n    * Invalid signature rejection\n  * **Test identifier computation**\n\n    * channelId determinism\n    * packedState (payload hash) consistency\n    * Known test vectors\n  * **Test state validation logic**\n\n    * Version ordering\n    * Allocation sum validation\n    * StateIntent validation (INITIALIZE, RESIZE, FINALIZE for channels)\n\n### Integration Testingâ€‹\n\n  * **Test both cooperative and challenge closure paths**\n\n    * Cooperative close (happy path)\n    * Challenge initiation\n    * Challenge response\n    * Challenge timeout\n  * **Test multi-chain operations**\n\n    * Open channels on different chains\n    * Cross-chain transfers (via unified balance)\n    * Chain-specific edge cases\n  * **Test network reconnection**\n\n    * Simulate network interruption\n    * Verify automatic reconnection\n    * Check state synchronization\n\n### End-to-End Testingâ€‹\n\n  * **Test complete user journeys**\n\n    * Authentication â†’ Channel Open â†’ Transfer â†’ Channel Close\n    * App session creation â†’ State updates â†’ Closure\n    * Error scenarios and recovery\n  * **Test with real clearnodes**\n\n    * Testnet deployment\n    * Mainnet staging environment\n    * Monitor performance and errors\n\n* * *\n\n## Performance Optimizationâ€‹\n\nOptimize for production workloads.\n\n### Efficiencyâ€‹\n\n  * **Minimize blockchain queries**\n\n    * Cache contract addresses\n    * Batch event queries\n    * Use multicall for multiple reads\n  * **Implement connection pooling**\n\n    * Reuse RPC connections\n    * Pool blockchain RPC connections\n    * Implement connection limits\n  * **Optimize state storage**\n\n    * Index by channelId and app_session_id\n    * Prune old states\n    * Compress stored states\n\n### Monitoringâ€‹\n\n  * **Implement health checks**\n\n    * RPC connection status\n    * Blockchain connection status\n    * Event listener status\n    * Use `ping` method for clearnode health\n  * **Monitor latency**\n\n    * RPC request/response time\n    * Transaction confirmation time\n    * Event processing delay\n  * **Track error rates**\n\n    * Failed transactions\n    * RPC errors\n    * Signature verification failures\n\n* * *\n\n## Documentationâ€‹\n\nDocumentation for maintainability.\n\n### Code Documentationâ€‹\n\n  * **Document adjudicator-specific requirements clearly**\n\n    * State validation rules\n    * Version comparison logic\n    * Gas cost estimates\n  * **Document custom state formats**\n\n    * Application-specific data structures\n    * Serialization format\n    * Version compatibility\n\n### User Documentationâ€‹\n\n  * **Provide integration guide**\n\n    * Setup instructions\n    * Code examples\n    * Common patterns\n  * **Document error messages**\n\n    * User-friendly descriptions\n    * Suggested actions\n    * Support contact information\n\n* * *\n\n## Deployment Checklistâ€‹\n\nPre-production validation.\n\n### Pre-Productionâ€‹\n\n  * **Audit smart contracts thoroughly before deployment**\n\n    * Use established auditors\n    * Test on testnets first\n    * Gradual mainnet rollout\n  * **Test on testnet extensively**\n\n    * All user flows\n    * Error scenarios\n    * Performance under load\n  * **Implement monitoring and alerting**\n\n    * Error rate alerts\n    * Performance degradation alerts\n    * Challenge event alerts\n\n### Productionâ€‹\n\n  * **Use appropriate challenge periods**\n\n    * Longer for high-value channels\n    * Consider network congestion\n    * Balance security vs UX\n  * **Implement proper key management**\n\n    * Hardware security modules (HSM)\n    * Key rotation policy\n    * Backup and recovery procedures\n  * **Set up incident response procedures**\n\n    * On-call rotation\n    * Escalation procedures\n    * Communication plan\n\n* * *\n\n## Compliance Levelsâ€‹\n\n### Minimal (User Client)â€‹\n\nEssential for basic client functionality:\n\n  * Core Protocol Support âœ“\n  * On-Chain Integration (create, close) âœ“\n  * Off-Chain RPC (auth, transfer, basic queries) âœ“\n  * Basic Security âœ“\n\n### Standard (Production Application)â€‹\n\nAdd:\n\n  * Complete method implementation âœ“\n  * State Management âœ“\n  * Comprehensive Error Handling âœ“\n  * Testing âœ“\n\n### Advanced (Clearnode Implementation)â€‹\n\nAdd:\n\n  * Server-side RPC routing and authentication âœ“\n  * Event-driven architecture âœ“\n  * Unified balance management (double-entry ledger) âœ“\n  * App session coordination âœ“\n  * High availability and fault tolerance âœ“\n\n* * *\n\n## Next Stepsâ€‹\n\n  1. **Start Simple** : Implement Core Protocol + Basic On-Chain integration\n  2. **Add RPC** : Connect to clearnode, implement authentication and basic methods\n  3. **Enhance Security** : Implement all security best practices\n  4. **Test Thoroughly** : Unit, integration, and end-to-end tests\n  5. **Deploy Gradually** : Testnet â†’ Staging â†’ Production\n\nReady to Build\n\nUse this checklist as a guide throughout your implementation. Check off items as you complete them and refer back to detailed documentation for each section.\n\n* * *\n\n## Resourcesâ€‹\n\n  * **Communication Flows** : [Communication Flows](/docs/protocol/communication-flows)\n  * **Reference** : [Protocol Reference](/docs/protocol/protocol-reference)\n  * **Channel Lifecycle** : [Channel Lifecycle](/docs/on-chain/channel-lifecycle)\n  * **RPC Methods** : [Queries](/docs/off-chain/queries)\n  * **Example Code** : [Integration Tests](https://github.com/layer-3/nitrolite/tree/main/integration)\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/implementation-checklist.mdx)\n\n[PreviousGlossary](/docs/protocol/glossary)\n\n  * Core Protocol Support\n    * Identifier Computation\n    * Signature Handling\n  * On-Chain Integration\n    * Blockchain Connection\n    * Channel Operations\n    * Event Listening\n  * Off-Chain RPC\n    * Connection Management\n    * Authentication\n    * Method Implementation\n  * State Management\n    * State Storage\n    * State Validation\n  * Security\n    * Key Management\n    * Challenge Monitoring\n    * Session Key Management\n    * Best Practices\n  * Error Handling\n    * RPC Errors\n    * Transaction Errors\n  * Testing\n    * Unit Testing\n    * Integration Testing\n    * End-to-End Testing\n  * Performance Optimization\n    * Efficiency\n    * Monitoring\n  * Documentation\n    * Code Documentation\n    * User Documentation\n  * Deployment Checklist\n    * Pre-Production\n    * Production\n  * Compliance Levels\n    * Minimal (User Client)\n    * Standard (Production Application)\n    * Advanced (Clearnode Implementation)\n  * Next Steps\n  * Resources",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/introduction",
    "text": "* [](/)\n  * Introduction\n\nOn this page\n\n# Introduction\n\n## What is Nitrolite?â€‹\n\nNitrolite is a state channel protocol that enables off-chain interactions between participants with minimal on-chain operations. The protocol forms a unified virtual ledger (called \"clearnet\") for applications to escrow funds while being fully abstracted from the underlying blockchain.\n\nThe initial version of Nitrolite is EVM-compatible and designed for deployment on Layer 1 and Layer 2 Ethereum networks.\n\n## Design Goalsâ€‹\n\nNitrolite is designed with the following objectives:\n\n  * **Scalability** : Move high-frequency operations off-chain\n  * **Cost Efficiency** : Minimize gas fees by reducing on-chain transactions\n  * **Security** : Maintain blockchain-level security guarantees\n  * **Interoperability** : Support multiple blockchains and assets\n  * **Developer Experience** : Provide clear, implementable specifications\n\n## Protocol Layersâ€‹\n\nNitrolite consists of three interconnected layers:\n\n  1. **On-Chain Layer** : Smart contracts that handle fund custody, dispute resolution, and final settlement\n  2. **Off-Chain Layer** : RPC protocol for fast, gasless state updates between participants\n  3. **Application Layer** : Arbitrary application logic built on top of the protocol\n\nApplication Layer\n\nOff-Chain RPC Layer\n\nOn-Chain Smart Contract Layer\n\nBlockchain\n\n## Specification Scopeâ€‹\n\nThis document defines the Nitrolite protocol in a **programming language-agnostic manner**. Implementers can use these specifications to build compliant implementations in any language (Go, Python, Rust, JavaScript, etc.).\n\nLanguage Independence\n\nImplementation-specific details are referenced but not mandated by this specification. The protocol description is abstract and can be implemented in any programming language.\n\n## RFC 2119 Keywordsâ€‹\n\nThe keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/introduction.mdx)\n\n[NextTerminology](/docs/protocol/terminology)\n\n  * What is Nitrolite?\n  * Design Goals\n  * Protocol Layers\n  * Specification Scope\n  * RFC 2119 Keywords",
    "metadata": {
      "title": "Introduction | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/introduction",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
    "text": "* [](/)\n  * Off-Chain RPC Protocol\n  * App Session Methods\n\nOn this page\n\n# App Session Methods\n\nApp sessions enable multi-party applications with custom governance rules, allowing complex interactions on top of payment channels.\n\n* * *\n\n## Overviewâ€‹\n\nApp sessions are off-chain channels built on top of the unified balance, intended for app developers to create application-specific interactions. They act as a \"box\" or shared account where multiple participants can transfer funds and execute custom logic with governance rules.\n\n### Key Featuresâ€‹\n\n**Multi-Party Governance** : Define custom voting weights and quorum rules for state updates.\n\n**Application-Specific State** : Store arbitrary application data (game state, escrow conditions, etc.).\n\n**Flexible Fund Management** : Transfer, redistribute, add, or withdraw funds during session lifecycle.\n\n**Instant Updates** : All state changes happen off-chain with zero gas fees.\n\nFor App Developers\n\nApp sessions are specifically designed for app developers building trustless multi-party applications like games, prediction markets, escrow, and collaborative finance.\n\n* * *\n\n## Protocol Versionsâ€‹\n\nApp sessions support multiple protocol versions for backward compatibility.\n\n### Version Comparisonâ€‹\n\nFeature| NitroRPC/0.2 (Legacy)| NitroRPC/0.4 (Current)  \n---|---|---  \n**State Updates**|  Basic only| Intent-based (OPERATE, DEPOSIT, WITHDRAW)  \n**Add Funds to Active Session**|  âŒ No| âœ… Yes (DEPOSIT intent)  \n**Remove Funds from Active Session**|  âŒ No| âœ… Yes (WITHDRAW intent)  \n**Fund Redistribution**|  âœ… Yes| âœ… Yes (OPERATE intent)  \n**Error Handling**|  Basic| Enhanced validation  \n**Modify Total Funds**|  Must close & recreate| Can update during session  \n**Recommended For**|  Legacy support only| All new implementations  \n  \nProtocol Version Selection\n\nThe protocol version is specified in the app definition during creation and **cannot be changed** for an existing session. Always use **NitroRPC/0.4** for new app sessions.\n\n* * *\n\n## create_app_sessionâ€‹\n\n### Nameâ€‹\n\n`create_app_session`\n\n### Usageâ€‹\n\nCreates a new virtual application session on top of the unified balance. An app session is a \"box\" or shared account where multiple participants can transfer funds and execute application-specific logic with custom governance rules. The app definition specifies participants, their voting weights, quorum requirements for state updates, and the protocol version. Funds are transferred from participants' unified balance accounts to a dedicated App Session Account for the duration of the session. App sessions enable complex multi-party applications like games, prediction markets, escrow, and collaborative financeâ€”all operating off-chain with instant state updates and zero gas fees.\n\n### When to Useâ€‹\n\nWhen multiple participants need to interact with shared funds and application state in a trustless manner. Examples include turn-based games, betting pools, escrow arrangements, DAOs, prediction markets, and any application requiring multi-signature state management.\n\n### Prerequisitesâ€‹\n\n  * All participants with non-zero initial allocations must be [authenticated](/docs/protocol/off-chain/authentication)\n  * All such participants must have sufficient available balance\n  * All such participants must sign the creation request\n  * Protocol version must be supported (NitroRPC/0.2 or NitroRPC/0.4)\n\n### Requestâ€‹\n\nQuick Reference\n\nCommon structures: AppDefinition â€¢ Allocation\n\nParameter| Type| Required| Description| See Also  \n---|---|---|---|---  \n`definition`| AppDefinition| Yes| Configuration defining the app session rules and participants| â†“ Structure  \n`allocations`| Allocation[]| Yes| Initial funds to transfer from participants' unified balance accounts| â†“ Structure  \n`session_data`| string| No| Application-specific initial state (JSON string, max 64KB recommended)  \nThis is application-specific; protocol doesn't validate content| â€”  \n  \n#### Session Identifierâ€‹\n\n`app_session_id` is derived deterministically from the entire App definition:\n    \n    \n    appSessionId = keccak256(JSON.stringify({  \n      application: \"...\",  \n      protocol: \"NitroRPC/0.4\",  \n      participants: [...],  \n      weights: [...],  \n      quorum: 100,  \n      challenge: 86400,  \n      nonce: 123456  \n    }))  \n    \n\n  * Includes `application`, `protocol`, `participants`, `weights`, `quorum`, `challenge`, and `nonce`\n  * Does **not** include `chainId` because sessions live entirely off-chain\n  * Client can recompute locally to verify clearnode responses\n  * `nonce` uniqueness is critical: same definition â‡’ same ID\n\nImplementation reference: `clearnode/app_session_service.go`.\n\n#### AppDefinitionâ€‹\n\nField| Type| Required| Description| Default| Allowed Values| Notes  \n---|---|---|---|---|---|---  \n`protocol`| string| Yes| Protocol version for this app session| â€”| `\"NitroRPC/0.2\"` | `\"NitroRPC/0.4\"`| Version cannot be changed after creation; use 0.4 for new sessions  \n`participants`| address[]| Yes| Array of all participant wallet addresses| â€”| Min: 2 participants| Order is important - indices used for signatures and weights  \nLast participant often represents the application/judge  \n`weights`| int64[]| Yes| Voting power for each participant| â€”| â€”| Length must match participants array  \nOrder corresponds to participants array  \nAbsolute values matter for quorum; don't need to sum to 100  \n`quorum`| uint64| Yes| Minimum total weight required to approve state updates| â€”| â€”| Sum of signers' weights must be â‰¥ quorum  \n`challenge`| uint64| No| Challenge period in seconds for disputes| 86400 (24 hours)| â€”| Only relevant if app session state is ever checkpointed on-chain  \n`nonce`| uint64| Yes| Unique identifier| â€”| â€”| Typically timestamp; ensures uniqueness  \n  \n**Example** :\n    \n    \n    {  \n      \"protocol\": \"NitroRPC/0.4\",  \n      \"participants\": [\"0x742d35Cc...\", \"0x8B3192f2...\", \"0x456789ab...\"],  \n      \"weights\": [50, 50, 100],  \n      \"quorum\": 100,  \n      \"challenge\": 3600,  \n      \"nonce\": 1699123456789  \n    }  \n    \n\n#### Allocationâ€‹\n\nField| Type| Required| Description  \n---|---|---|---  \n`participant`| address| Yes| Participant wallet address (must be in `definition.participants`)  \n`asset`| string| Yes| Asset identifier (e.g., `\"usdc\"`)  \n`amount`| string| Yes| Amount in human-readable format (e.g., `\"100.0\"`)  \n  \n**Example** :\n    \n    \n    [  \n          {\"participant\": \"0x742d35Cc...\", \"asset\": \"usdc\", \"amount\": \"100.0\"},  \n          {\"participant\": \"0x8B3192f2...\", \"asset\": \"usdc\", \"amount\": \"100.0\"},  \n          {\"participant\": \"0x456789ab...\", \"asset\": \"usdc\", \"amount\": \"0.0\"}  \n        ]  \n    \n\n**Note** : Participants with zero allocation don't need to sign creation.\n\n### Responseâ€‹\n\nParameter| Type| Description| Format/Structure| Example| Notes  \n---|---|---|---|---|---  \n`app_session_id`| string| Unique identifier for the created app session| 0x-prefixed hex string (32 bytes)| `\"0x9876543210fedcba9876543210fedcba9876543210fedcba9876543210fedcba\"`| Use this for all subsequent operations on this session  \n`status`| string| App session status| `\"open\"`| `\"open\"`| Values: `\"open\"` or `\"closed\"`  \n`version`| number| Current state version| `1`| `1`| Always starts at 1  \n  \nThe Go service returns only these fields on creation. To fetch full metadata (application, participants, quorum, weights, session_data, protocol, challenge, nonce, timestamps), call [`get_app_sessions`](/docs/protocol/off-chain/queries#get_app_sessions) after creation.\n\n* * *\n\n## Governance Modelsâ€‹\n\nApp sessions support flexible governance through custom weights and quorum configurations.\n\n### Example 1: Simple Two-Player Gameâ€‹\n    \n    \n    Participants: [Alice, Bob]  \n    Weights: [1, 1]  \n    Quorum: 2  \n      \n    Result: Both players must sign every state update  \n    Use case: Chess, poker, betting between two parties  \n    \n\n**Governance** : Cooperative - both parties must agree to all changes.\n\n### Example 2: Game with Judgeâ€‹\n    \n    \n    Participants: [Alice, Bob, Judge]  \n    Weights: [0, 0, 100]  \n    Quorum: 100  \n      \n    Result: Only judge can update state  \n    Use case: Games where application determines outcome  \n    \n\n**Governance** : Authoritative - application/judge has full control.\n\n### Example 3: Multi-Party Escrowâ€‹\n    \n    \n    Participants: [Buyer, Seller, Arbiter]  \n    Weights: [40, 40, 50]  \n    Quorum: 80  \n      \n    Result: Any 2 parties can approve  \n      - Buyer + Seller (80)  \n      - Buyer + Arbiter (90)  \n      - Seller + Arbiter (90)  \n    Use case: Escrowed transactions with dispute resolution  \n    \n\n**Governance** : Flexible 2-of-3 - any two can proceed, preventing single-party blocking.\n\n### Example 4: DAO-like Votingâ€‹\n    \n    \n    Participants: [User1, User2, User3, User4, Contract]  \n    Weights: [20, 25, 30, 25, 0]  \n    Quorum: 51  \n      \n    Result: Majority of weighted votes required (51 out of 100)  \n    Use case: Collaborative funds management  \n    \n\n**Governance** : Weighted majority - decisions require majority approval by stake.\n\n### Example 5: Watch Towerâ€‹\n    \n    \n    Participants: [Alice, Bob, WatchTower]  \n    Weights: [40, 40, 100]  \n    Quorum: 80  \n      \n    Result:  \n      - Normal operation: Alice + Bob (80)  \n      - Emergency: WatchTower alone (100)  \n    Use case: Automated monitoring and intervention  \n    \n\n**Governance** : Dual-mode - normal requires cooperation, emergency allows automated action.\n\nGovernance Flexibility\n\nBy adjusting weights and quorum, you can implement any governance model from fully cooperative (all must sign) to fully authoritative (single party controls) to complex weighted voting systems.\n\n* * *\n\n## Fund Transfer Mechanicsâ€‹\n\nWhen an app session is created, funds are transferred from the unified balance account to a dedicated App Session Account:\n\ncreate_app_session\n\nAlice's Unified Account  \nBalance: 200 USDC\n\nCreate App Session  \nAlice transfers 100 USDC\n\nAlice's Unified Account  \nBalance: 100 USDC\n\nApp Session Account  \nBalance: 100 USDC  \n(Beneficiary: Alice)\n\n**Balance State Changes** :\n    \n    \n    Before Creation:  \n      Alice's Unified Account:  \n        Balance: 200 USDC  \n      \n    After Creating Session with 100 USDC:  \n      Alice's Unified Account:  \n        Balance: 100 USDC  \n        \n      App Session Account:  \n        Balance: 100 USDC (Beneficiary: Alice)  \n    \n\n### Signature Requirementsâ€‹\n\nAll participants with non-zero initial allocations MUST sign the create_app_session request. The clearnode validates that:\n\n  1. All required signatures are present\n  2. Signatures are valid for respective participants\n  3. Total weight of signers >= quorum (must be met for creation)\n\n* * *\n\n## submit_app_stateâ€‹\n\n### Nameâ€‹\n\n`submit_app_state`\n\n### Usageâ€‹\n\nSubmits a state update for an active app session. State updates can redistribute funds between participants (OPERATE intent), add funds to the session (DEPOSIT intent), or remove funds from the session (WITHDRAW intent). The intent system is only available in NitroRPC/0.4; version 0.2 sessions only support fund redistribution without explicit intent. Each state update increments the version number, and must be signed by participants whose combined weights meet the quorum requirement. The allocations field always represents the FINAL state after the operation, not the delta.\n\n### When to Useâ€‹\n\nDuring app session lifecycle to update the state based on application logic. Examples include recording game moves, updating scores, reallocating funds based on outcomes, adding stakes, or partially withdrawing winnings.\n\n### Prerequisitesâ€‹\n\n  * App session must exist and be in \"open\" status\n  * Signers must meet quorum requirement\n  * For DEPOSIT intent: Depositing participant must sign (in addition to quorum)\n  * For DEPOSIT intent: Depositing participant must have sufficient available balance\n  * For WITHDRAW intent: Session must have sufficient funds to withdraw\n  * NitroRPC/0.4: `version` must be **exactly current_version + 1**\n  * NitroRPC/0.2: **omit** `intent` and `version` (service rejects them); only OPERATE-style redistribution is supported\n  * If using a session key, spending allowances for that key are enforced\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Format| Example| Notes / See Also  \n---|---|---|---|---|---|---  \n`app_session_id`| string| Yes| Identifier of the app session to update| 0x-prefixed hex string (32 bytes)| `\"0x9876543210fedcba...\"`| -  \n`intent`| string| Yes for v0.4, No for v0.2| Type of operation (NitroRPC/0.4 only)| Allowed: `\"operate\"` | `\"deposit\"` | `\"withdraw\"`| `\"operate\"`| Omit for NitroRPC/0.2 sessions (treated as operate)  \n`version`| number| Yes| Expected next version number| -| `2`| Must be exactly currentVersion + 1; prevents conflicts  \n`allocations`| Allocation[]| Yes| **FINAL allocation state after this update**  \n  \nâš ï¸ **IMPORTANT** : This is the target state, NOT the delta| See Allocation above| After operate from [100, 100] where Alice loses 25 to Bob:  \n`[{\"participant\": \"0xAlice\", \"asset\": \"usdc\", \"amount\": \"75.0\"}, {\"participant\": \"0xBob\", \"asset\": \"usdc\", \"amount\": \"125.0\"}]`| Clearnode validates based on intent rules (see below)  \n`session_data`| string| No| Updated application-specific state| JSON string| `\"{\\\"currentMove\\\":\\\"e2e4\\\",\\\"turn\\\":\\\"black\\\"}\"`| Can be updated independently of allocations  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Format/Structure| Example| Notes  \n---|---|---|---|---|---  \n`app_session_id`| string| Session identifier (echoed)| -| -| -  \n`version`| number| Confirmed new version number| -| `2`| -  \n`status`| string| Updated session status| `\"open\"`| `\"open\"`| Minimal response (no metadata echoed)  \n  \nThe Go handler returns an `AppSessionResponse` type, but for state submissions it only includes `app_session_id`, `version`, and `status` (and does not echo session metadata). Use [`get_app_sessions`](/docs/protocol/off-chain/queries#get_app_sessions) to read the full session record.\n\n* * *\n\n## Intent System (NitroRPC/0.4)â€‹\n\nThe intent system defines the type of operation being performed. Each intent has specific validation rules.\n\n### Intent: OPERATE (Redistribute Existing Funds)â€‹\n\n**Purpose** : Move funds between participants without changing total amount in session.\n\n**Rules** :\n\n  * Sum of allocations MUST equal sum before operation\n  * No funds added or removed from session\n  * Quorum requirement MUST be met\n  * Depositing participant signature NOT required\n\n**Example** :\n    \n    \n    Current state (version 1):  \n      Alice: 100 USDC  \n      Bob: 100 USDC  \n      Total: 200 USDC  \n      \n    Update (version 2, intent: \"operate\"):  \n      Allocations: [  \n        {\"participant\": \"0xAlice\", \"asset\": \"usdc\", \"amount\": \"75.0\"},  \n        {\"participant\": \"0xBob\", \"asset\": \"usdc\", \"amount\": \"125.0\"}  \n      ]  \n        \n    Result:  \n      Alice: 75 USDC (-25)  \n      Bob: 125 USDC (+25)  \n      Total: 200 USDC (unchanged) âœ“  \n      \n    Validation: Sum before (200) == Sum after (200) âœ“  \n    \n\n**Use Cases** :\n\n  * Record game outcome (winner gets opponent's stake)\n  * Update prediction market positions\n  * Rebalance shared pool\n  * Penalize or reward participants\n\nOPERATE Intent\n\nUse OPERATE for simple fund redistributions within the session. The total amount remains constantâ€”funds just move between participants.\n\n* * *\n\n### Intent: DEPOSIT (Add Funds to Session)â€‹\n\n**Purpose** : Add funds from a participant's unified balance into the session.\n\n**Rules** :\n\n  * Sum of allocations MUST be greater or equal to sum before operation\n  * Increase MUST come from available balance of depositing participant\n  * Depositing participant MUST sign (even if quorum is met without them)\n  * Quorum requirement MUST still be met\n  * Allocations show FINAL amounts (not delta)\n  * If signed via a session key, spending caps for that key are enforced\n\n**Example** :\n    \n    \n    Current state (version 1):  \n      Alice: 100 USDC  \n      Bob: 100 USDC  \n      Total: 200 USDC  \n      \n    Alice's Unified Balance:  \n      Available: 50 USDC  \n      \n    Update (version 2, intent: \"deposit\"):  \n      Allocations: [  \n        {\"participant\": \"0xAlice\", \"asset\": \"usdc\", \"amount\": \"150.0\"},  \n        {\"participant\": \"0xBob\", \"asset\": \"usdc\", \"amount\": \"100.0\"}  \n      ]  \n      Signatures: [AliceSig, QuorumSigs...]  \n        \n    Calculation:  \n      Alice deposit amount = 150 (new) - 100 (old) = 50 USDC  \n        \n    Result:  \n      Alice: 150 USDC (100 + 50 deposited)  \n      Bob: 100 USDC (unchanged)  \n      Total: 250 USDC (+50) âœ“  \n        \n    Alice's Unified Balance After:  \n      Available: 0 USDC (50 transferred to App Session Account)  \n      \n    App Session Account After:  \n      Balance: 250 USDC (increased by 50)  \n      \n    Validation:  \n      - Sum after (250) > Sum before (200) âœ“  \n      - Alice signed âœ“  \n      - Alice had 50 available âœ“  \n    \n\n**Use Cases** :\n\n  * Top up game stake mid-game\n  * Add collateral to escrow\n  * Increase position in prediction market\n  * Buy into ongoing game\n\nDEPOSIT Intent\n\n**Critical Understanding** : The allocations array shows FINAL amounts, not the deposit amount. The clearnode calculates the deposit by comparing previous and new allocations for each participant.\n\n* * *\n\n### Intent: WITHDRAW (Remove Funds from Session)â€‹\n\n**Purpose** : Remove funds from session back to a participant's unified balance.\n\n**Rules** :\n\n  * Sum of allocations MUST be less or equal to sum before operation\n  * Decrease is returned to participant's available balance\n  * Withdrawing participant signature NOT specifically required (quorum sufficient)\n  * Quorum requirement MUST be met\n  * Allocations show FINAL amounts (not delta)\n\n**Example** :\n    \n    \n    Current state (version 1):  \n      Alice: 150 USDC  \n      Bob: 100 USDC  \n      Total: 250 USDC  \n      \n    Update (version 2, intent: \"withdraw\"):  \n      Allocations: [  \n        {\"participant\": \"0xAlice\", \"asset\": \"usdc\", \"amount\": \"150.0\"},  \n        {\"participant\": \"0xBob\", \"asset\": \"usdc\", \"amount\": \"75.0\"}  \n      ]  \n      Signatures: [QuorumSigs...]  \n        \n    Calculation:  \n      Bob withdrawal amount = 100 (old) - 75 (new) = 25 USDC  \n        \n    Result:  \n      Alice: 150 USDC (unchanged)  \n      Bob: 75 USDC (100 - 25 withdrawn)  \n      Total: 225 USDC (-25) âœ“  \n        \n    Bob's Unified Balance After:  \n      Available: +25 USDC  \n      \n    App Session Account After:  \n      Balance: 225 USDC (decreased by 25)  \n      \n    Validation:  \n      - Sum after (225) < Sum before (250) âœ“  \n      - Quorum met âœ“  \n    \n\n**Use Cases** :\n\n  * Cash out partial winnings mid-game\n  * Remove collateral when no longer needed\n  * Take profits from shared investment\n  * Reduce stake in ongoing game\n\n* * *\n\n## Version Managementâ€‹\n\n  * NitroRPC/0.4: each update MUST be exactly `previous_version + 1`, or it is rejected.\n  * NitroRPC/0.2: omit `intent` and `version`; providing either results in `\"incorrect request: specified parameters are not supported in this protocol\"`.\n\n* * *\n\n## Quorum Validationâ€‹\n\nFor every update, the clearnode validates quorum:\n\nYes\n\nNo\n\nReceive State Update\n\nCalculate Total Weight\n\nSum weights of all signers\n\nTotal Weight >= Quorum?\n\nâœ“ Update Accepted\n\nâœ— Reject: Quorum Not Met\n\n**Validation Logic** :\n    \n    \n    totalWeight = sum of weights for all signers  \n    if (totalWeight >= definition.quorum) {  \n      âœ“ Update accepted  \n    } else {  \n      âœ— Reject: \"Quorum not met\"  \n    }  \n    \n\n**Example** (using Game with Judge scenario):\n    \n    \n    Participants: [Alice, Bob, Judge]  \n    Weights: [0, 0, 100]  \n    Quorum: 100  \n      \n    Valid signature combinations:  \n      - Judge alone: weight = 100 >= 100 âœ“  \n      - Alice + Bob: weight = 0 >= 100 âœ—  \n      - Alice + Bob + Judge: weight = 100 >= 100 âœ“  \n    \n\n* * *\n\n## close_app_sessionâ€‹\n\n### Nameâ€‹\n\n`close_app_session`\n\n### Usageâ€‹\n\nCloses an active app session and distributes all funds from the App Session Account according to the final allocations. Once closed, the app session cannot be reopened; participants must create a new session if they want to continue. The final allocations determine how funds are returned to each participant's unified balance account. Closing requires quorum signatures. The final session_data can record the outcome or final state of the application. All funds in the App Session Account are released immediately.\n\n### When to Useâ€‹\n\nWhen application logic has completed and participants want to finalize the outcome and retrieve their funds. Examples include game ending, escrow condition met, prediction market settled, or any application reaching its natural conclusion.\n\n### Prerequisitesâ€‹\n\n  * App session must exist and be in \"open\" status\n  * Signers must meet quorum requirement\n  * Final allocations must not exceed total funds in session\n  * Sum of final allocations must equal total session funds\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Format/Structure| Example| Notes  \n---|---|---|---|---|---|---  \n`app_session_id`| string| Yes| Identifier of the app session to close| 0x-prefixed hex string (32 bytes)| `\"0x9876543210fedcba...\"`| -  \n`allocations`| Allocation[]| Yes| Final distribution of all funds in the session  \n  \n**IMPORTANT** : Must account for ALL funds; sum must equal session total  \n  \n**Structure (per allocation)** :  \nâ€¢ `participant` (address) - Participant wallet address  \nâ€¢ `asset` (string) - Asset identifier  \nâ€¢ `amount` (string) - Final amount for this participant| See structure| 200 USDC total, winner takes most:  \n`[{\"participant\": \"0xAlice\", \"asset\": \"usdc\", \"amount\": \"180.0\"}, {\"participant\": \"0xBob\", \"asset\": \"usdc\", \"amount\": \"15.0\"}, {\"participant\": \"0xJudge\", \"asset\": \"usdc\", \"amount\": \"5.0\"}]`| Can allocate zero to participants (they get nothing)  \n`session_data`| string| No| Final application state or outcome record| JSON string| `\"{\\\"result\\\":\\\"Alice wins\\\",\\\"finalScore\\\":\\\"3-1\\\"}\"`| Useful for recording outcome for history/analytics  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Format/Structure| Example| Notes  \n---|---|---|---|---|---  \n`app_session_id`| string| Session identifier (echoed)| -| -| -  \n`status`| string| Final status| Value: \"closed\"| `\"closed\"`| Minimal response  \n`version`| number| New session version| -| `2`| Incremented on close  \n  \nclose_app_session response\n\nThe handler returns an `AppSessionResponse` type in Go, but on close it only populates `app_session_id`, `status`, and `version`. For full metadata after closure, query [`get_app_sessions`](/docs/protocol/off-chain/queries#get_app_sessions).\n\n* * *\n\n## Fund Distribution on Closureâ€‹\n\nWhen an app session closes, funds return to participants' unified balances:\n    \n    \n    Before Closure:  \n      Alice's Unified Account:  \n        Balance: 100 USDC  \n      \n    App Session Account 0x98765:  \n      Alice: 100 USDC  \n      Bob: 100 USDC  \n      Total: 200 USDC  \n      \n    Close with final allocations:  \n      Alice: 180 USDC  \n      Bob: 20 USDC  \n      \n    After Closure:  \n      Alice's Unified Account:  \n        Balance: 280 USDC (100 + 180 received from session)  \n          \n      Bob's Unified Account:  \n        Balance: 20 USDC (received from session)  \n        \n      App Session Account 0x98765:  \n        Closed (Balance: 0 USDC)  \n    \n\n### Allocation Rulesâ€‹\n\n  1. **Must Sum to Total** :\n\n     * `sum(final_allocations) MUST equal sum(current_allocations)`\n     * Clearnode validates this; cannot create or destroy funds during close\n  2. **Can Be Zero** :\n\n     * Participants can receive zero in final allocation (lost everything)\n     * Example: Losing player in a winner-takes-all game\n  3. **Accounting for Participants** :\n\n     * It is recommended to include an entry for every participant (use zero for losers).\n     * If you omit a participant, the service treats them as receiving zero, as long as per-asset totals still match the session balance.\n  4. **Can Include Non-Financial Participants** :\n\n     * Example: Judge/application can receive commission\n     * `{\"participant\": \"0xJudge\", \"asset\": \"usdc\", \"amount\": \"5.0\"}`\n\n* * *\n\n## Closure Examplesâ€‹\n\n### Example 1: Chess Gameâ€‹\n    \n    \n    Initial:  \n      White: 100 USDC  \n      Black: 100 USDC  \n      Judge: 0 USDC  \n      Total: 200 USDC  \n      \n    Final (White wins):  \n      White: 190 USDC (won 90)  \n      Black: 0 USDC (lost 100)  \n      Judge: 10 USDC (5% commission)  \n      Total: 200 USDC âœ“  \n    \n\n### Example 2: Escrow (Buyer Satisfied)â€‹\n    \n    \n    Initial:  \n      Buyer: 100 USDC  \n      Seller: 0 USDC  \n      Arbiter: 0 USDC  \n      Total: 100 USDC  \n      \n    Final (Successful delivery):  \n      Buyer: 0 USDC  \n      Seller: 99 USDC (payment)  \n      Arbiter: 1 USDC (fee)  \n      Total: 100 USDC âœ“  \n    \n\n### Example 3: Escrow (Dispute, Buyer Refunded)â€‹\n    \n    \n    Initial:  \n      Buyer: 100 USDC  \n      Seller: 0 USDC  \n      Arbiter: 0 USDC  \n      Total: 100 USDC  \n      \n    Final (Arbiter ruled for buyer):  \n      Buyer: 95 USDC (refund minus fee)  \n      Seller: 0 USDC  \n      Arbiter: 5 USDC (dispute fee)  \n      Total: 100 USDC âœ“  \n    \n\n### Example 4: Prediction Marketâ€‹\n    \n    \n    Initial:  \n      User1: 50 USDC (bet YES)  \n      User2: 50 USDC (bet YES)  \n      User3: 40 USDC (bet NO)  \n      Oracle: 0 USDC  \n      Total: 140 USDC  \n      \n    Final (Outcome: YES):  \n      User1: 68.25 USDC (split pot proportionally)  \n      User2: 68.25 USDC  \n      User3: 0 USDC (lost)  \n      Oracle: 3.50 USDC (2.5% fee)  \n      Total: 140 USDC âœ“  \n    \n\nFinal Distribution\n\nAll participants receive funds according to the final allocations, whether they won, lost, or served as neutral parties (judges, arbiters, oracles). The total is always preserved.\n\n* * *\n\n* * *\n\n## Implementation Notesâ€‹\n\n**State Management** :\n\n  * Always use `intent: \"operate\"` for simple redistributions\n  * Always specify FINAL allocations, never deltas\n  * The clearnode computes deltas internally by comparing with previous state\n  * Version numbers must be strictly sequential\n  * The session_data field can be updated in any intent\n\n**Performance** :\n\n  * Updates are instant (< 1 second) and off-chain\n  * Zero gas fees for all operations\n  * All updates are logged for audit trail\n\n**Notifications** :\n\n  * Participants are notified on all active connections of state changes\n  * Closed sessions remain queryable for history\n\n**Irreversibility** :\n\n  * Closure is instant and atomic\n  * All funds released simultaneously\n  * Once closed, cannot be reopened\n  * To continue, create a new session\n\n* * *\n\n## Next Stepsâ€‹\n\nExplore other protocol features:\n\n  * **[Queries& Notifications](/docs/protocol/off-chain/queries)** \\- Query session history and receive real-time updates\n  * **[Transfers](/docs/protocol/off-chain/transfers)** \\- Move funds between unified balances\n  * **[Channel Methods](/docs/protocol/off-chain/channel-methods)** \\- Manage underlying payment channels\n\nFor foundational concepts:\n\n  * **[Message Format](/docs/protocol/off-chain/message-format)** \\- Understand request/response structure\n  * **[Authentication](/docs/protocol/off-chain/authentication)** \\- Manage session keys and security\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/off-chain/app-sessions.mdx)\n\n[PreviousTransfer Method](/docs/protocol/off-chain/transfers)[NextQuery Methods & Notifications](/docs/protocol/off-chain/queries)\n\n  * Overview\n    * Key Features\n  * Protocol Versions\n    * Version Comparison\n  * create_app_session\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n  * Governance Models\n    * Example 1: Simple Two-Player Game\n    * Example 2: Game with Judge\n    * Example 3: Multi-Party Escrow\n    * Example 4: DAO-like Voting\n    * Example 5: Watch Tower\n  * Fund Transfer Mechanics\n    * Signature Requirements\n  * submit_app_state\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n  * Intent System (NitroRPC/0.4)\n    * Intent: OPERATE (Redistribute Existing Funds)\n    * Intent: DEPOSIT (Add Funds to Session)\n    * Intent: WITHDRAW (Remove Funds from Session)\n  * Version Management\n  * Quorum Validation\n  * close_app_session\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n  * Fund Distribution on Closure\n    * Allocation Rules\n  * Closure Examples\n    * Example 1: Chess Game\n    * Example 2: Escrow (Buyer Satisfied)\n    * Example 3: Escrow (Dispute, Buyer Refunded)\n    * Example 4: Prediction Market\n  * Implementation Notes\n  * Next Steps",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/off-chain/authentication",
    "text": "* [](/)\n  * Off-Chain RPC Protocol\n  * Authentication\n\nOn this page\n\n# Authentication\n\nAuthentication with Clearnode can be done in two ways: using your **main wallet as a root signer** for all requests, or delegating to session keys via a secure 3-step challenge-response protocol.\n\n* * *\n\n## Overviewâ€‹\n\nThere are two authentication approaches:\n\n  1. **Main Wallet (Root Signer)** : Sign every request with your main wallet. Simple but requires user interaction for each operation.\n\n  2. **Session Keys (Delegated)** : Establish an authenticated session once, then use a session key for subsequent operations without repeatedly prompting the main wallet.\n\n\nMain Wallet as Root Signer\n\nYou can **skip the session key flow entirely** and use your main wallet to sign all requests. This provides maximum security but requires wallet interaction for every operation. Simply sign each request with your main wallet's private key instead of creating a session key.\n\n### Why Session Keys?â€‹\n\nSession keys provide **flexible security management** :\n\n  * **Granular Permissions** : Specify which operations the session key can perform\n  * **Spending Allowances** : Set maximum spending limits per asset\n  * **Time-Bounded** : Automatic expiration reduces risk of key compromise\n  * **Application-Scoped** : Different keys for different apps\n  * **User Experience** : No repeated wallet prompts during active session\n\nFlexible Security Management\n\nSession keys give users a flexible way to manage security of their funds by providing specific permissions and allowances for specific apps, balancing convenience with security.\n\n### Choosing Your Approachâ€‹\n\nAspect| Main Wallet (Root Signer)| Session Keys (Delegated)  \n---|---|---  \n**Setup**|  None - use immediately| One-time 3-step flow  \n**UX**|  Wallet prompt for every operation| Sign once, use for duration  \n**Security**|  Maximum - full control always| Balanced - limited by allowances  \n**Use Case**|  Single operations, high-value transactions| Interactive apps, frequent operations  \n**Revocation**|  Not needed| Can be revoked anytime  \n**Best For**|  One-time actions, security-critical operations| Gaming, trading bots, dApps with frequent interactions  \n  \nWhen to Use Each\n\n  * **Use Main Wallet** : For single channel creation, large transfers, or when maximum security is required\n  * **Use Session Keys** : For interactive applications, gaming, automated operations, or when user experience matters\n\n### Session Key Authentication Flowâ€‹\n\nThe 3-step process ensures both security and usability:\n\nClearnodeClientUser WalletClearnodeClientUser WalletClearnodeClientUser WalletStep 1: Register Session KeyStep 2: ChallengeStep 3: Verify Session KeyCompleteAll subsequent requests signed with session keyGenerate session keypair (locally)Prepare auth parameters (address, session_key, application, allowances, expires_at)auth_request (public endpoint, no signature)Validate parametersGenerate challenge UUIDauth_challenge (challenge_message)Create EIP-712 typed data with challengeRequest EIP-712 signatureSign with main walletauth_verify (EIP-712 signature by main wallet)Recover address from EIP-712 signatureValidate signature matches main walletCreate session (with allowances)Generate JWT tokenSession established (address, session_key, jwt_token, success)\n\nChallenge-Response Pattern\n\nThis pattern ensures that:\n\n  1. User owns the main wallet (EIP-712 signature in Step 3)\n  2. Challenge is unique and cannot be replayed\n  3. No private keys are ever transmitted\n  4. Session key is authorized by the main wallet\n\n* * *\n\n## Step 1: auth_requestâ€‹\n\n### Nameâ€‹\n\n`auth_request`\n\n### Usageâ€‹\n\nInitiates authentication with Clearnode by registering a session key. The client sends authentication parameters to register a session key that can act on their behalf. The session key can have restricted permissions including spending limits (allowances), operation scope, and expiration time.\n\n**Important** : `auth_request` is a **public endpoint** and does not require a signature. The client simply needs to prepare and send the authentication parameters.\n\n### When to Useâ€‹\n\n**Optional** : Use this when you want to delegate signing to a session key instead of using your main wallet for every request. This is the first step in establishing an authenticated session with Clearnode.\n\nIf you prefer to use your main wallet as a root signer for all operations, you can skip this entire authentication flow.\n\n### Prerequisitesâ€‹\n\n  * User has a wallet with funds\n  * Client can generate a keypair (e.g., secp256k1)\n  * Client can prepare authentication parameters locally\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example| Notes  \n---|---|---|---|---|---|---  \n`address`| string (wallet address)| Yes| User's main wallet address that owns the funds| -| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`| -  \n`session_key`| string (wallet address)| Yes| Wallet address of the locally-generated session keypair| -| `\"0x9876543210fedcba9876543210fedcba98765432\"`| The private key never leaves the client  \n`application`| string| No| Application identifier for analytics and session management| `\"clearnode\"`| `\"chess-game-app\"`| Helps track which app is using which session  \n`allowances`| Array<Allowance>| No| Spending limits for this session key  \n  \n**Structure (per allowance)** :  \nâ€¢ `asset` (string) - Asset identifier (e.g., \"usdc\", \"eth\")  \nâ€¢ `amount` (string) - Maximum amount this session can spend| Unrestricted if omitted/empty| `[{\"asset\": \"usdc\", \"amount\": \"100.0\"}]`| If empty/omitted, no spending cap is enforced  \n`scope`| string| No| Comma-separated list of permitted operations| All operations permitted| `\"app.create,app.submit,transfer\"`| Future feature, not fully enforced yet  \n`expires_at`| number| Yes| Unix timestamp (milliseconds) when the session key expires| â€”| `1762417328000`| Provide a 13-digit Unix ms timestamp; no server default is applied  \n  \nSpending Allowances\n\nIf you omit `allowances` the session key is unrestricted. Specify explicit allowances to bound risk if a session key is compromised.\n\nAllowances are validated against the brokerâ€™s supported assets. Unsupported symbols will cause authentication to fail.\n\n### Responseâ€‹\n\nParameter| Type| Description| Format| Example| Purpose  \n---|---|---|---|---|---  \n`challenge_message`| string| UUID that client must sign with session key to prove ownership| UUID v4| `\"550e8400-e29b-41d4-a716-446655440000\"`| Proves client controls session key without exposing private key  \n  \n### Signatureâ€‹\n\nRequest **does NOT require a signature** as `auth_request` is a public endpoint.\n\n**Process** :\n\n  1. Client prepares authentication parameters (address, session_key, application, allowances, expires_at)\n  2. Client stores these parameters locally for use in Step 3 (auth_verify)\n  3. Client sends request to Clearnode\n  4. Clearnode validates all parameters before generating a challenge\n\nParameter Storage\n\nKeep the authentication parameters (especially `address`, `session_key`, `application`, `allowances`, `scope`, and `expires_at`) stored locally until Step 3, as you'll need them to create the EIP-712 signature.\n\n### Next Stepâ€‹\n\nUpon receiving the `challenge_message`, client must prepare an EIP-712 signature (or reuse a previously issued `jwt`) and call `auth_verify`.\n\n### Error Casesâ€‹\n\nError Codes\n\nCurrently, the protocol does not use standardized error codes. Errors are returned as descriptive messages.\n\nCommon error scenarios:\n\nError| Description| Recovery  \n---|---|---  \n**Invalid address format**|  Main wallet address is malformed| Verify address format (0x + 40 hex chars)  \n**Invalid session key format**|  Session key address is malformed| Verify session key format  \n**Invalid parameters**|  One or more parameters are invalid or missing| Check all required parameters  \n**Session key already registered**|  This session key is already in use| Generate a new session keypair  \n  \n* * *\n\n## Step 2: auth_challengeâ€‹\n\n### Nameâ€‹\n\n`auth_challenge`\n\n### Usageâ€‹\n\nServer-generated response to `auth_request` containing a challenge that the client must sign to prove control of the session key. This implements a challenge-response authentication pattern to prevent replay attacks and verify the client controls the private key of the session key they registered.\n\n### When to Useâ€‹\n\nAutomatically sent by Clearnode in response to valid `auth_request`. Client does not explicitly call this; it's part of the authentication flow.\n\n### Requestâ€‹\n\nN/A (server-initiated response to `auth_request`)\n\n### Responseâ€‹\n\nParameter| Type| Description| Format| Purpose| Example| Generation| Lifetime  \n---|---|---|---|---|---|---|---  \n`challenge_message`| string| Randomly generated UUID that client must sign| UUID v4| Prevents replay attacks, proves session key ownership| `\"550e8400-e29b-41d4-a716-446655440000\"`| Cryptographically secure random UUID| Single use, expires after 5 minutes if not verified  \n  \n### Signatureâ€‹\n\nThe challenge is returned as a normal RPC response (server signs the envelope like any other RPC response).\n\n### Next Stepâ€‹\n\nClient signs the challenge with session key private key and calls `auth_verify`.\n\nChallenge Uniqueness\n\nEach challenge is unique and single-use. It expires after 5 minutes if not verified. This prevents replay attacks where an attacker might try to reuse a captured challenge signature.\n\n* * *\n\n## Step 3: auth_verifyâ€‹\n\n### Nameâ€‹\n\n`auth_verify`\n\n### Usageâ€‹\n\nCompletes the authentication flow by submitting the signed challenge from `auth_challenge`. If the signature is valid and matches the registered session key, the authentication is complete and the session key can be used to sign subsequent requests. This proves the client controls the private key without ever transmitting it.\n\n### When to Useâ€‹\n\nImmediately after receiving `auth_challenge` response. This is the final step in authentication.\n\n### Prerequisitesâ€‹\n\n  * Completed `auth_request` and received `auth_challenge`\n  * Have the challenge_message\n  * Have the session key private key (client-side only)\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Example| Notes  \n---|---|---|---|---|---  \n`challenge`| string| Yes| The challenge_message received from auth_challenge| `\"550e8400-e29b-41d4-a716-446655440000\"`| Must be the exact challenge from Step 2  \n`jwt`| string| No| Existing JWT for re-login without signature| `\"eyJhbGciOi...\"`| If provided, signature is not required  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Example| Notes  \n---|---|---|---|---  \n`address`| string (wallet address)| Authenticated user's main wallet address| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`| Confirms which account is authenticated  \n`session_key`| string (wallet address)| Confirmed session key wallet address| `\"0x9876543210fedcba9876543210fedcba98765432\"`| The authorized session key  \n`jwt_token`| string| JWT token for authenticated API calls| `\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"`| Store securely; validity follows the provided `expires_at`  \n`success`| boolean| Authentication success indicator| `true`| Indicates if authentication completed successfully  \n  \n### Signatureâ€‹\n\nIf `jwt` is omitted, the request **MUST** include an EIP-712 signature signed by the **main wallet** (NOT the session key). If `jwt` is present, no signature is required.\n\n**EIP-712 Typed Data Structure** :\n    \n    \n    {  \n      types: {  \n        EIP712Domain: [  \n          { name: \"name\", type: \"string\" }  \n        ],  \n        Policy: [  \n          { name: \"challenge\", type: \"string\" },  \n          { name: \"scope\", type: \"string\" },  \n          { name: \"wallet\", type: \"address\" },  \n          { name: \"session_key\", type: \"address\" },  \n          { name: \"expires_at\", type: \"uint64\" },  \n          { name: \"allowances\", type: \"Allowance[]\" }  \n        ],  \n        Allowance: [  \n          { name: \"asset\", type: \"string\" },  \n          { name: \"amount\", type: \"string\" }  \n        ]  \n      },  \n      primaryType: \"Policy\",  \n      domain: {  \n        name: <application_name>  // From auth_request  \n      },  \n      message: {  \n        challenge: <challenge_message>,  // From auth_challenge  \n        scope: <scope>,                  // From auth_request  \n        wallet: <address>,               // From auth_request  \n        session_key: <session_key>,      // From auth_request  \n        expires_at: <expires_at>,        // From auth_request (13-digit Unix ms)  \n        allowances: <allowances>         // From auth_request  \n      }  \n    }  \n    \n\n**Signing Process** :\n\n  1. Client creates EIP-712 typed data with challenge and all parameters from Step 1\n  2. User's wallet signs the typed data: `signature = signTypedData(typedData, mainWalletPrivateKey)`\n  3. Client sends request with EIP-712 signature in `sig` array\n\nCritical Security Requirement\n\nThe `auth_verify` signature MUST be an **EIP-712 signature signed by the main wallet** , not the session key. This proves the main wallet owner authorizes the session key to act on their behalf. The signature binds the challenge to the session key authorization.\n\n### Next Stepâ€‹\n\nSession is authenticated. All subsequent private method calls should be signed with the session key. You may also re-authenticate later by sending `auth_verify` with the previously issued `jwt` (no signature required).\n\n### Error Casesâ€‹\n\nError Codes\n\nCurrently, the protocol does not use standardized error codes. Errors are returned as descriptive messages.\n\nCommon error scenarios:\n\nError| Description| Recovery  \n---|---|---  \n**Invalid signature**|  EIP-712 signature doesn't match main wallet or is malformed| Verify main wallet private key used for signing, check EIP-712 structure  \n**Challenge expired**|  Challenge older than 5 minutes| Restart auth flow from `auth_request`  \n**Challenge already used**|  Challenge has been verified already| Generate new session or use existing if still valid  \n**Invalid challenge**|  Challenge not found in pending auths| Ensure `auth_request` succeeded first  \n**Challenge mismatch**|  Challenge doesn't match pending auth| Use exact challenge from `auth_challenge`  \n  \n* * *\n\n## Complete Authentication Flow Exampleâ€‹\n\nPutting it all together:\n\nGenerate session keypair\n\nauth_request  \n(public, no signature)\n\nReceive challenge_message\n\nCreate EIP-712 typed data\n\nauth_verify  \n(EIP-712 sig by main wallet)\n\nSession + JWT established\n\nUse session key for requests\n\nTimeout (expires_at reached)\n\nSpending limit exceeded\n\nManual revocation\n\nMust re-authenticate\n\nMust re-authenticate\n\nMust re-authenticate\n\nError (retry)\n\nTimeout (5 min)\n\nError (retry)\n\nError (retry)\n\nUnauthenticated\n\nPreparingAuth\n\nWaitingForChallenge\n\nCreatingEIP712\n\nSigningWithWallet\n\nWaitingForConfirmation\n\nAuthenticated\n\nSessionExpired\n\nSessionInvalidated\n\nSessionRevoked\n\n* * *\n\n## Session Managementâ€‹\n\n### Session Lifecycleâ€‹\n\n  1. **Creation** : After successful `auth_verify`\n  2. **Active** : Can perform operations until expiration or allowance exceeded\n  3. **Expiration** : Automatic after specified duration\n  4. **Invalidation** : When spending allowances exhausted\n  5. **Revocation** : User or the clearnode can revoke manually\n\n### Checking Session Statusâ€‹\n\nUse `get_session_keys` to view active sessions and their remaining allowances. The response includes session details with current allowance usage and respects the `expires_at` provided during `auth_request`.\n\n### Session Expiration Handlingâ€‹\n\nWhen a session expires according to the `expires_at` you provided, the clearnode will return an error response:\n    \n    \n    {  \n      \"res\": [  \n        <requestId>,  \n        \"error\",  \n        {  \n          \"error\": \"session expired, please re-authenticate\"  \n        },  \n        <timestamp>  \n      ],  \n      \"sig\": [<clearnode_signature>]  \n    }  \n    \n\nError Format\n\nThe protocol does not use numeric error codes. Errors are returned as method `\"error\"` with a descriptive message in the params.\n\n**Recovery** : Re-authenticate by running the 3-step flow again.\n\n### Spending Allowance Trackingâ€‹\n\nThe clearnode tracks spending by monitoring all ledger debit operations:\n    \n    \n    Initial state:  \n      allowance = specified_limit  \n      used = 0  \n      remaining = specified_limit  \n      \n    After operations:  \n      allowance = specified_limit (unchanged)  \n      used = sum_of_all_debits  \n      remaining = allowance - used  \n      \n    When operation exceeds remaining (for assets with an allowance):  \n      Error: \"Session key allowance exceeded: amount_required, remaining_available\"  \n    \n\nAllowance Enforcement\n\nWhen a session key reaches its spending cap, all further operations are rejected. The user must create a new session with fresh allowances or use their main wallet directly.\n\n* * *\n\n## Security Best Practicesâ€‹\n\n### For Usersâ€‹\n\n  1. **Set Spending Limits** : Always specify `allowances` when creating sessions\n  2. **Short Expirations** : Use shorter expiration times for sensitive operations\n  3. **Application Scoping** : Use different session keys for different applications\n  4. **Monitor Usage** : Regularly check session key spending via `get_session_keys`\n  5. **Revoke When Done** : Revoke sessions when application use is complete\n\n### For Developersâ€‹\n\n  1. **Secure Storage** : Store session key private keys securely (encrypted storage, secure enclaves)\n  2. **Never Transmit** : Never send session key private keys over network\n  3. **Handle Expiration** : Implement automatic re-authentication on session expiry\n  4. **Clear on Logout** : Delete session keys when user logs out\n  5. **Verify Signatures** : Always verify the clearnode's signatures on responses\n\n* * *\n\n## Next Stepsâ€‹\n\nNow that you're authenticated, you can:\n\n  * **[Create Channels](/docs/protocol/off-chain/channel-methods)** \\- Open payment channels and deposit funds\n  * **[Transfer Funds](/docs/protocol/off-chain/transfers)** \\- Send instant off-chain payments\n  * **[Manage App Sessions](/docs/protocol/off-chain/app-sessions)** \\- Create multi-party application channels\n  * **[Query Data](/docs/protocol/off-chain/queries)** \\- Check balances, transactions, and channel status\n\nFor protocol fundamentals, see:\n\n  * **[Message Format](/docs/protocol/off-chain/message-format)** \\- Understand request/response structure\n  * **[Off-Chain RPC Overview](/docs/protocol/off-chain/overview)** \\- High-level protocol overview\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/off-chain/authentication.mdx)\n\n[PreviousMessage Format](/docs/protocol/off-chain/message-format)[NextChannel Management Methods](/docs/protocol/off-chain/channel-methods)\n\n  * Overview\n    * Why Session Keys?\n    * Choosing Your Approach\n    * Session Key Authentication Flow\n  * Step 1: auth_request\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n    * Signature\n    * Next Step\n    * Error Cases\n  * Step 2: auth_challenge\n    * Name\n    * Usage\n    * When to Use\n    * Request\n    * Response\n    * Signature\n    * Next Step\n  * Step 3: auth_verify\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n    * Signature\n    * Next Step\n    * Error Cases\n  * Complete Authentication Flow Example\n  * Session Management\n    * Session Lifecycle\n    * Checking Session Status\n    * Session Expiration Handling\n    * Spending Allowance Tracking\n  * Security Best Practices\n    * For Users\n    * For Developers\n  * Next Steps",
    "metadata": {
      "title": "Authentication | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/authentication",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/off-chain/channel-methods",
    "text": "* [](/)\n  * Off-Chain RPC Protocol\n  * Channel Management Methods\n\nOn this page\n\n# Channel Management Methods\n\nChannel management methods enable clients to create, modify, and close payment channels with a clearnode on various blockchain networks.\n\n* * *\n\n## Overviewâ€‹\n\nPayment channels are the foundation of the Nitrolite protocol. They lock funds on-chain while enabling instant off-chain operations within a unified balance.\n\n### Channel Lifecycle Summaryâ€‹\n\ncreate_channel (off-chain)\n\nUser submits create() transaction\n\nContract locks user funds (status = open)\n\nresize_channel (optional)\n\nUser submits resize() transaction\n\nclose_channel (cooperative)\n\nFunds distributed\n\nchallenge() (non-cooperative)\n\nChallenge period then close()\n\nRequesting\n\nOnChain\n\nACTIVE\n\nResizing\n\nClosing\n\nDisputing\n\n* * *\n\n## create_channelâ€‹\n\n### Nameâ€‹\n\n`create_channel`\n\n### Usageâ€‹\n\nInitiates the creation of a payment channel between user and a clearnode on a specific blockchain. The clearnode validates the request, generates a channel configuration with a unique nonce, prepares the initial funding state, and signs it. The user receives the complete channel data and the clearnode's signature, which they must then submit to the blockchain's Custody contract via the `create()` function to finalize channel creation and lock funds on-chain. This two-step process (off-chain preparation, on-chain execution) ensures the clearnode has agreed on channel creation and received an on-chain confirmation that it was created.\n\n### When to Useâ€‹\n\nWhen a user wants to establish a payment channel on a specific blockchain network. This is the first operation after authentication if the user doesn't have an open channel yet. On subsequent connections, users won't need to create a channel again unless they closed it.\n\nTwo-Step Process\n\nChannel creation is intentionally split into two steps:\n\n  1. **Off-chain preparation** : The clearnode prepares and signs the initial state\n  2. **On-chain execution** : User submits transaction to create the channel\n\nThis ensures the clearnode has committed to the channel before the user submits the on-chain transaction.\n\n### Prerequisitesâ€‹\n\n  * User must be [authenticated](/docs/protocol/off-chain/authentication)\n  * Target blockchain and token must be supported by the clearnode\n  * User must have native currency for gas fees\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example| Notes  \n---|---|---|---|---|---|---  \n`chain_id`| uint32| Yes| Blockchain network identifier  \n  \n**Examples** :  \nâ€¢ 1: Ethereum Mainnet  \nâ€¢ 137: Polygon  \nâ€¢ 8453: Base  \nâ€¢ 42161: Arbitrum One  \nâ€¢ 10: Optimism| â€”| `137`| Use `get_config` to see supported chains  \n`token`| string (wallet address)| Yes| ERC-20 token contract address on the specified chain  \n  \nFormat: 0x-prefixed hex (20 bytes)| â€”| `\"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\"`| Must be supported; see `get_assets`  \n  \nInitial Channel State\n\nChannels are created with **zero initial balance** for both participants. To add funds to the channel, use the `resize_channel` method after creation. The challenge period is set to 1 hour (3600 seconds) by default.\n\n### Responseâ€‹\n\nQuick Reference\n\nStructures: Channel â€¢ State â€¢ StateAllocation\n\nParameter| Type| Description| See Also  \n---|---|---|---  \n`channel_id`| string| Computed channel identifier (0x-prefixed hex, 32 bytes)| â€”  \n`channel`| Channel| On-chain channel params| â†“ Structure  \n`state`| State| Initial state (intent INITIALIZE, version 0, empty data, zero allocations)| â†“ Structure  \n`server_signature`| string| Clearnode signature over packed state (hex string)| â€”  \n  \n#### Channel Structureâ€‹\n\nField| Type| Description| Notes  \n---|---|---|---  \n`participants`| wallet address[]| Array of two wallet addresses: [User, Clearnode]| Order: Index 0 = User, Index 1 = Clearnode  \nOrder is critical for signature verification  \n`adjudicator`| wallet address| Adjudicator contract address for this channel| Typically SimpleConsensus for payment channels  \nValidates state transitions during disputes  \n`challenge`| uint64| Challenge period in seconds| Default: 3600 seconds (1 hour)  \n`nonce`| uint64| Unique identifier for this channel| Ensures channelId uniqueness even with same participants  \nServer-generated timestamp or counter  \n  \n**Example** :\n    \n    \n    {  \n      \"participants\": [\"0x742d35Cc...\", \"0x123456Cc...\"],  \n      \"adjudicator\": \"0xAdjudicator123...\",  \n      \"challenge\": 86400,  \n      \"nonce\": 1699123456  \n    }  \n    \n\n#### State Structureâ€‹\n\nField| Type| Description| Notes  \n---|---|---|---  \n`intent`| StateIntent| State purpose indicator| For creation: `INITIALIZE` (1)  \n`version`| uint64| State sequence number| For creation: `0`  \n`state_data`| string| State data (hex)| For creation: `\"0x\"`  \n`allocations`| StateAllocation[]| Fund allocations (raw units)| Order matches participants array; both `0` on creation  \n  \n**Example** :\n    \n    \n    {  \n      \"intent\": 1,  \n      \"version\": 0,  \n      \"state_data\": \"0x\",  \n      \"allocations\": [  \n        {\"participant\": \"0x742d35Cc...\", \"token\": \"0x2791Bca1...\", \"amount\": \"0\"},  \n        {\"participant\": \"0x123456Cc...\", \"token\": \"0x2791Bca1...\", \"amount\": \"0\"}  \n      ]  \n    }  \n    \n\n#### StateAllocation Structureâ€‹\n\nField| Type| Description  \n---|---|---  \n`participant`| string (wallet address)| Participant's wallet address  \n`token`| string (wallet address)| Token contract address  \n`amount`| string| Amount in smallest unit (e.g., `\"100000000\"` for 100 USDC with 6 decimals)  \n  \nClearnode Signature First\n\nThe clearnode provides its signature BEFORE the user commits funds on-chain. This ensures both parties have committed to the channel before any on-chain transaction occurs.\n\n### Next Steps After Receiving Responseâ€‹\n\n  1. **Verify Channel Data**\n\n     * Recompute `channelId` = `keccak256(abi.encode(channel))`\n     * Verify computed ID matches response `channel_id`\n     * Check participants[0] is your wallet address\n     * Verify token matches your request\n  2. **Verify the Clearnode's Signature**\n\n     * Compute `packedState` = `abi.encode(channelId, state.intent, state.version, state.data, state.allocations)`\n     * Recover signer from `server_signature`\n     * Verify signer is the clearnode's known wallet address\n  3. **Sign State with Your Key**\n\n     * Sign `packedState` with your participant key\n     * Include your signature when submitting to blockchain\n  4. **Submit On-Chain Transaction**\n\n     * Call `Custody.create(channel, state, yourSignature, clearnodeSignature)`\n     * Wait for transaction confirmation\n  5. **Monitor for Channel Creation**\n\n     * Listen for `Opened` event (emitted right after transaction is mined)\n     * Or poll `get_channels` until channel appears with status \"open\"\n  6. **Channel Active**\n\n     * Channel appears in `get_channels` with status \"open\"\n     * Channel starts with zero balance\n     * Use `resize_channel` to add funds to the channel\n\n### Error Casesâ€‹\n\nError Format\n\nThe protocol does not use numeric error codes. Errors are returned as method `\"error\"` with descriptive messages.\n\nCommon error scenarios:\n\nError| Description| Recovery  \n---|---|---  \n**Authentication required**|  Not authenticated| Complete [authentication flow](/docs/protocol/off-chain/authentication)  \n**Unsupported chain**| `chain_id` not supported| Use `get_config`  \n**Token not supported**|  Token not in asset config for chain| Use `get_assets`  \n**Invalid signature**|  Caller did not sign request| Sign with channel participant wallet  \n**Channel already exists**|  Open channel with broker already exists| Use existing channel or close it first  \n**Failed to prepare state**|  Internal packing/signing issue| Retry or contact support  \n  \n### Implementation Notesâ€‹\n\n  * The nonce is generated by the clearnode to ensure uniqueness\n  * The channelId can be computed client-side: `keccak256(abi.encode(channel))`\n  * The packedState should be verified: `abi.encode(channelId, state.intent, state.version, state.data, state.allocations)`\n  * Users should verify the clearnode's signature before proceeding\n  * The challenge period can be customized but most users should use defaults\n\n### Sequence Diagramâ€‹\n\nBlockchainClearnodeUserBlockchainClearnodeUser1\\. Request Channel Creation2\\. Prepare Channel3\\. Verify & Sign4\\. Submit On-Chain5\\. Create Channel (Status: ACTIVE)Use resize_channel to add fundscreate_channel(chain_id, token)Generate unique nonceCreate channel configCreate initial state (intent: INITIALIZE, version: 0)Sign state{channel, state, server_signature, channel_id}Verify Clearnode signatureSign state with participant keyCustody.create(channel, state, signatures)Verify signaturesCreate channel with status ACTIVEEmit Opened eventChannel Active (zero balance)Channel Active (zero balance)\n\n* * *\n\n## close_channelâ€‹\n\n### Nameâ€‹\n\n`close_channel`\n\n### Usageâ€‹\n\nInitiates cooperative closure of an active payment channel. The clearnode signs a final state with StateIntent.FINALIZE reflecting the current balance distribution. The user receives this clearnode-signed final state which they must submit to the blockchain's Custody contract via the `close()` function. This is the preferred and most efficient way to close a channel as it requires only one on-chain transaction and completes immediately without a challenge period. Both parties must agree on the final allocation for cooperative closure to work.\n\n### When to Useâ€‹\n\nWhen a user wants to withdraw funds from an active channel and both user and the clearnode agree on the final balance distribution. This should be the default closure method when both parties are online and cooperative.\n\nPreferred Closure Method\n\nCooperative closure is **fast (1 transaction)** , **cheap (low gas)** , and **immediate (no waiting period)**. Always use this method when possible. Challenge-response closure should only be used when the clearnode is unresponsive or disputes the final state.\n\n### Prerequisitesâ€‹\n\n  * Channel must exist and be in ACTIVE status\n  * User must be authenticated\n  * User must have native currency for gas fees\n  * Both parties must agree on final allocations (implicitly, by the clearnode signing)\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example| Notes  \n---|---|---|---|---|---|---  \n`channel_id`| string| Yes| Identifier of the channel to close| -| `\"0xabcdef1234567890...\"`| From get_channels or stored after creation  \n`funds_destination`| string (wallet address)| Yes| Address where your share of channel funds should be sent| -| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`| Typically your wallet address  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Example| Notes  \n---|---|---|---|---  \n`channel_id`| string| Channel identifier| `\"0xabcdef1234...\"`| â€”  \n`state`| State| Final state with intent FINALIZE and version = current+1  \n`state_data`: `\"0x\"`  \n`allocations`: final fund distribution (raw units)| See State structure| `channel` field is omitted in close responses  \n`server_signature`| string| Clearnode signature over packed state| `\"0xabcdef987654...\"`| Hex string  \n  \n### Next Steps After Receiving Responseâ€‹\n\n  1. **Verify Final Allocations**\n\n     * Check allocations match expectations\n     * Verify total matches total locked funds\n     * Ensure your allocation is correct\n  2. **Verify the Clearnode's Signature**\n\n     * Compute `packedState` = `abi.encode(channelId, state.intent, state.version, state.data, state.allocations)`\n     * Verify signature is from the clearnode\n  3. **Sign Final State**\n\n     * Sign `packedState` with your participant key\n     * Include your signature when submitting to blockchain\n  4. **Submit On-Chain**\n\n     * Call `Custody.close(channelId, state, yourSignature, clearnodeSignature)` on blockchain\n     * Both signatures must be present\n  5. **Wait for Confirmation**\n\n     * Transaction confirms\n     * Funds distributed according to allocations\n  6. **Channel Closed**\n\n     * Channel deleted from chain\n     * Funds in your wallet or custody available balance\n  7. **Withdraw if Needed**\n\n     * If funds in custody, call `withdraw()` to move to wallet\n\n### Error Casesâ€‹\n\nError Format\n\nThe protocol does not use numeric error codes. Errors are returned as method `\"error\"` with descriptive messages.\n\nCommon error scenarios:\n\nError| Description| Recovery  \n---|---|---  \n**Authentication required**|  Not authenticated| Re-authenticate  \n**Channel not found**|  Invalid `channel_id`| Verify with `get_channels`  \n**Channel challenged**|  Participant has challenged channels| Resolve challenges first  \n**Channel not open/resizing**|  Status not `open` or `resizing`| Only open/resizing channels can close  \n**Invalid signature**|  Caller did not sign request| Sign with channel participant wallet  \n**Token/asset not found**|  Asset config missing| Ensure channel token is supported  \n**Insufficient/negative balance**|  Ledger balance retrieval or negative balance| Ensure balances are non-negative; retry  \n**Failed to pack/sign state**|  Internal packing/signing issue| Retry or contact support  \n  \n### Comparison: Cooperative vs Challenge Closureâ€‹\n\nAspect| Cooperative (this method)| Challenge  \n---|---|---  \n**Speed**|  Fast (1 transaction)| Slow (challenge period + 1 transaction)  \n**Gas Cost**|  Low (~100k gas)| High (~200k+ gas, 2+ transactions)  \n**Requirements**|  Both parties online & agree| Works if other party unresponsive  \n**Waiting Period**|  None (immediate)| 24+ hours (challenge duration)  \n**Use When**|  Normal operations| Disputes or unresponsiveness  \n  \nWhen to Use Challenge Closure\n\nOnly use challenge closure (on-chain `challenge()` function) when:\n\n  * Clearnode is unresponsive\n  * Clearnode disputes the final allocation\n  * Cooperative closure fails repeatedly\n\nChallenge closure requires waiting for the challenge period to expire before funds are released.\n\n### Implementation Notesâ€‹\n\n  * The StateIntent.FINALIZE (3) signals this is a final state\n  * All participants must sign the final state for it to be accepted on-chain\n  * The allocations determine where funds go when channel closes\n  * Clearnode will only sign if the allocations match the current state of the unified balance\n  * After closing, funds are distributed according to the allocations specified\n  * Users may need to call `withdraw()` separately to move funds from custody ledger to their wallet\n\n* * *\n\n## resize_channelâ€‹\n\n### Nameâ€‹\n\n`resize_channel`\n\n### Usageâ€‹\n\nAdjusts the allocations of an existing channel by locking or unlocking funds **without closing the channel**. Unlike older implementations, this uses the `resize()` function on the Custody contract to perform an **in-place update** of the channel's allocations. The same channelId persists throughout the operation, and the channel remains in ACTIVE status. Clearnode prepares a resize state with delta amounts (positive for deposit, negative for withdrawal) that all participants must sign before submitting on-chain.\n\n### When to Useâ€‹\n\nWhen a user wants to adjust channel allocations while keeping the same channel active. This is more efficient than closing and reopening, and maintains the channel's history and state version continuity.\n\nIn-Place Update\n\nThe resize operation updates the channel **in place**. The channelId **stays the same** , and the channel remains ACTIVE throughout. This is the current implementation of channel allocation adjustment.\n\n### Prerequisitesâ€‹\n\n  * Channel must exist and be in ACTIVE status\n  * User must be authenticated\n  * Positive deltas require enough available unified balance\n  * Negative deltas require sufficient channel balance\n  * All participants must sign the resize state (consensus required)\n  * User must have native currency for gas fees\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example| Notes  \n---|---|---|---|---|---|---  \n`channel_id`| string| Yes| Identifier of the channel to resize (stays the same)| -| `\"0xabcdef1234567890...\"`| 0x-prefixed hex string (32 bytes)  \nThis channel_id will NOT change after resize  \n`allocate_amount`| string (decimal)| No| Amount to add/remove between unified balance and the channel before resize| `0`| `\"50.0\"`| Decimal string; can be used together with `resize_amount`; at least one of the two must be non-zero  \n`resize_amount`| string (decimal)| No| Delta to apply to the channel: positive to deposit, negative to withdraw| `0`| `\"75.0\"` or `\"-100.0\"`| Decimal string; can be used together with `allocate_amount`; at least one of the two must be non-zero  \n`funds_destination`| string (wallet address)| Yes| Destination for the user's allocation in the resize state| -| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`| 0x-prefixed hex string (20 bytes)  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Example| Notes  \n---|---|---|---|---  \n`channel_id`| string| Same channel identifier (unchanged)| `\"0xabcdef1234567890...\"`| This does NOT change (in-place update)  \n`state`| State| Resize state to be submitted on-chain  \nâ€¢ `intent` = RESIZE (2)  \nâ€¢ `version` = current+1  \nâ€¢ `state_data` = ABI-encoded `int256[2]` of `[resize_amount, allocate_amount]` (raw units)  \nâ€¢ `allocations` = final absolute allocations after resize| See State structure| `channel` field is omitted in resize responses  \n`server_signature`| string| Clearnode signature over packed state| `\"0x9876fedcba...\"`| Hex string  \n  \n### Next Steps After Receiving Responseâ€‹\n\nThe client must submit the resize state to the blockchain:\n\n  1. **Verify the resize state**\n\n     * Check channel_id matches (should be unchanged)\n     * Verify intent is RESIZE (2)\n     * Confirm version is current + 1\n     * Check allocations reflect the requested change\n  2. **Sign the resize state**\n         \n         packedState = abi.encode(  \n           channel_id,  \n           state.intent,      // StateIntent.RESIZE (2)  \n           state.version,     // Incremented version  \n           state.data,        // ABI-encoded int256[] deltas  \n           state.allocations  // Final allocations  \n         )  \n         user_signature = sign(packedState, participant_private_key)  \n         \n\n  3. **Ensure sufficient balance**\n\n     * Positive deltas require enough available unified balance to cover `allocate_amount + resize_amount` (after decimals conversion)\n     * Negative deltas require the channel to have sufficient funds being deallocated\n  4. **Call`Custody.resize()` on-chain**\n         \n         custody.resize(  \n           channel_id,    // Same channel_id  \n           state,         // Resize state  \n           yourSignature,  \n           clearnodeSignature  \n         )  \n         \n\n  5. **Wait for transaction confirmation**\n\n     * Channel remains ACTIVE (no status change)\n     * Funds locked or unlocked based on delta\n     * Expected deposits updated to new amounts\n  6. **Monitor for`Resized` event**\n         \n         event Resized(bytes32 indexed channelId, int256[] deltaAllocations)  \n         \n\n     * Emitted when resize completes\n     * Contains the delta amounts applied\n     * Confirms operation success\n  7. **Update local state**\n\n     * Channel_id remains the same (no replacement needed)\n     * Unified balance automatically updated\n     * Version incremented\n\n### Error Casesâ€‹\n\nError| Cause| Resolution  \n---|---|---  \nAuthentication required| Not authenticated| Complete authentication flow  \nChannel not found| Invalid channel_id| Verify with `get_channels`  \nChannel challenged| Participant has challenged channels| Resolve challenged channels first  \nOperation denied: resize already ongoing| Channel status is `resizing`| Wait for existing resize to complete  \nOperation denied: channel is not open| Status not `open`| Only open channels can resize  \nInvalid signature| Caller not among channel signers| Sign request with channel participant  \nToken/asset not found for channel| Asset config missing for channel token/chain| Ensure channel token is supported  \nResize operation requires non-zero amounts| Both `resize_amount` and `allocate_amount` are zero| Provide a non-zero value  \nInsufficient unified balance| New channel amount would exceed available balance| Reduce amounts or add funds  \nNew channel amount must be positive| Resize would make channel balance negative| Reduce withdrawal  \nFailed to pack resize amounts/state| Internal packing/signing error| Retry; contact support if persistent  \n  \n### Resize Scenariosâ€‹\n\n#### Scenario 1: Depositing Additional Fundsâ€‹\n\n**Initial State** :\n    \n    \n    Channel (on Polygon): 20 USDC  \n    Channel (on Celo): 5 USDC  \n    Unified balance: 25 USDC total  \n    \n\n**Operation** :\n    \n    \n    resize_channel({  \n      channel_id: \"0xCelo_Channel_Id\",  // Resize Celo channel  \n      allocate_amount: \"0\",  \n      resize_amount: \"75.0\",  // Deposit 75 USDC  \n      funds_destination: \"0x742d35Cc...\"  // Required, even for deposits  \n    })  \n    \n\n**Result** :\n    \n    \n    Channel (on Polygon): 20 USDC (unchanged)  \n    Channel (on Celo): 80 USDC (5 + 75 = 80)  \n    Unified balance: 100 USDC total (reduced available balance to fund deposit)  \n    Same channel_id on Celo (unchanged)  \n    \n\n* * *\n\n#### Scenario 2: Withdrawing Fundsâ€‹\n\n**Initial State** :\n    \n    \n    Channel (on Polygon): 100 USDC  \n    Unified balance: 100 USDC total (all locked in channel)  \n    \n\n**Operation** :\n    \n    \n    resize_channel({  \n      channel_id: \"0xPolygon_Channel_Id\",  \n      allocate_amount: \"0\",  \n      resize_amount: \"-100.0\",  // Withdraw all 100 USDC  \n      funds_destination: \"0x742d35Cc...\"  // User's wallet  \n    })  \n    \n\n**Result** :\n    \n    \n    Channel (on Polygon): 0 USDC (100 - 100 = 0)  \n    Unified balance: 0 USDC  \n    100 USDC returned to available balance (unified)  \n    Same channel_id (unchanged)  \n    Channel still ACTIVE (can be used again or closed)  \n    \n\n* * *\n\n#### Scenario 3: Complex Multi-Chain Rebalancingâ€‹\n\n**Initial State** :\n    \n    \n    Channel (on Polygon): 20 USDC  \n    Channel (on Celo): 80 USDC  \n    Unified balance: 100 USDC total  \n    Want to withdraw all on Polygon (100 USDC)  \n    \n\n**Operation** :\n    \n    \n    // First, allocate Celo funds to Polygon channel  \n    resize_channel({  \n      channel_id: \"0xPolygon_Channel_Id\",  \n      allocate_amount: \"80.0\",  // Allocate from Celo  \n      resize_amount: \"-100.0\",  // Withdraw 100 total  \n      funds_destination: \"0x742d35Cc...\"  \n    })  \n    \n\n**Result** :\n    \n    \n    Channel (on Polygon): 0 USDC  \n    Channel (on Celo): 0 USDC (deallocated)  \n    100 USDC withdrawn to user's wallet  \n    \n\nComplex Rebalancing\n\nMulti-chain rebalancing with `allocate_amount` is an advanced feature. For simple deposit/withdrawal on a single channel, use only `resize_amount` with `allocate_amount` = \"0\".\n\n### Implementation Notesâ€‹\n\n  * The `resize()` function operates **in place** on the same channel\n  * channelId **never changes** (no new channel created)\n  * Channel remains in **ACTIVE** status throughout\n  * State **version increments** like any state update\n  * Delta amounts are encoded as **int256[]** in state.data\n  * Positive deltas increase channel balance (and reduce available unified balance)\n  * Negative deltas decrease channel balance (and increase available unified balance)\n  * **All participants must sign** the resize state (consensus required)\n  * More gas-efficient than close + reopen\n  * Unified balance automatically updated by clearnode\n  * Channel history and state continuity preserved\n\n* * *\n\n## Next Stepsâ€‹\n\nExplore other off-chain operations:\n\n  * **[Transfers](/docs/protocol/off-chain/transfers)** \\- Send instant off-chain payments using unified balance\n  * **[App Sessions](/docs/protocol/off-chain/app-sessions)** \\- Create multi-party application channels\n  * **[Queries](/docs/protocol/off-chain/queries)** \\- Check channel status, balances, and history\n\nFor protocol fundamentals:\n\n  * **[Authentication](/docs/protocol/off-chain/authentication)** \\- Understand authorization and session management\n  * **[Message Format](/docs/protocol/off-chain/message-format)** \\- Learn request/response structure\n  * **[On-Chain Protocol](/docs/protocol/on-chain/overview)** \\- Deep dive into smart contracts\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/off-chain/channel-methods.mdx)\n\n[PreviousAuthentication](/docs/protocol/off-chain/authentication)[NextTransfer Method](/docs/protocol/off-chain/transfers)\n\n  * Overview\n    * Channel Lifecycle Summary\n  * create_channel\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n    * Next Steps After Receiving Response\n    * Error Cases\n    * Implementation Notes\n    * Sequence Diagram\n  * close_channel\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n    * Next Steps After Receiving Response\n    * Error Cases\n    * Comparison: Cooperative vs Challenge Closure\n    * Implementation Notes\n  * resize_channel\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n    * Next Steps After Receiving Response\n    * Error Cases\n    * Resize Scenarios\n    * Implementation Notes\n  * Next Steps",
    "metadata": {
      "title": "Channel Management Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/channel-methods",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/off-chain/message-format",
    "text": "* [](/)\n  * Off-Chain RPC Protocol\n  * Message Format\n\nOn this page\n\n# Message Format\n\nThe Nitro RPC protocol uses a compact, efficient message format for all communication between clients and a clearnode.\n\n* * *\n\n## General Structureâ€‹\n\nEvery Nitro RPC message consists of a compact JSON array format:\n    \n    \n    [requestId, method, params, timestamp]  \n    \n\nCompact Format\n\nThis array-based format reduces message overhead by approximately 30% compared to traditional JSON-RPC, making it ideal for high-frequency state channel operations.\n\n### Componentsâ€‹\n\nComponent| Type| Description  \n---|---|---  \n**requestId**|  uint64| Unique identifier for the request, used to correlate responses  \n**method**|  string| Remote method name to be invoked  \n**params**|  object| Method-specific parameters as a JSON object  \n**timestamp**|  uint64| Server-provided timestamp in milliseconds  \n  \n#### requestIdâ€‹\n\n  * **Purpose** : Correlate requests with their responses\n  * **Type** : Unsigned 64-bit integer\n  * **Generation** : Client-generated, must be unique per connection\n  * **Range** : 0 to 2^64-1\n  * **Example** : `1`, `42`, `9876543210`\n\n#### methodâ€‹\n\n  * **Purpose** : Specify which RPC method to invoke\n  * **Type** : String\n  * **Format** : snake_case (e.g., `create_channel`, not `createChannel`)\n  * **Examples** : `auth_request`, `transfer`, `create_app_session`\n\n#### paramsâ€‹\n\n  * **Purpose** : Provide method-specific parameters\n  * **Type** : JSON object\n  * **Content** : Varies by method\n  * **Example** : `{\"chain_id\": 137, \"token\": \"0x...\", \"amount\": \"100000000\"}`\n  * **Reference** : See [Authentication](/docs/protocol/off-chain/authentication), [Channel Methods](/docs/protocol/off-chain/channel-methods), [Transfers](/docs/protocol/off-chain/transfers), [App Sessions](/docs/protocol/off-chain/app-sessions), and [Queries](/docs/protocol/off-chain/queries) for parameter specifications\n\n#### timestampâ€‹\n\n  * **Purpose** : Request ordering and replay attack prevention\n  * **Type** : Unsigned 64-bit integer (Unix milliseconds)\n  * **Generation** : Client-provided on requests; server-provided on responses\n  * **Example** : `1699123456789` (November 5, 2023, 01:57:36 UTC)\n\n* * *\n\n## Request Messageâ€‹\n\nA complete request message wraps the payload array and includes signatures.\n\n### Structureâ€‹\n    \n    \n    {  \n      \"req\": [requestId, method, params, timestamp],  \n      \"sig\": [signature1, signature2, ...]  \n    }  \n    \n\n### Fieldsâ€‹\n\n#### reqâ€‹\n\nThe request payload as a 4-element array containing:\n\n  * Request ID\n  * Method name\n  * Parameters object\n  * Timestamp\n\n#### sigâ€‹\n\nArray of ECDSA signatures, one or more depending on the operation:\n\n  * **Single signature** : Most operations (signed by client's session key)\n  * **Multiple signatures** : Multi-party operations (e.g., app session creation)\n\n### Signature Formatâ€‹\n\nEach signature is:\n\n  * **Format** : 0x-prefixed hex string\n  * **Length** : 65 bytes (130 hex characters + \"0x\" prefix)\n  * **Components** : r (32 bytes) + s (32 bytes) + v (1 byte)\n  * **Algorithm** : ECDSA over secp256k1 curve\n  * **Hash** : keccak256 of the exact `req` array bytes\n\n**Example Signature** :\n    \n    \n    0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef01  \n    \n\nEVM-Specific Format\n\nThis signature format (ECDSA over secp256k1 with keccak256 hashing) is specific to EVM-compatible chains. If the protocol extends to support non-EVM chains in the future, signature formats may need to be adapted to match those chains' native cryptographic primitives.\n\nSignature Security\n\nSignatures are computed over the keccak256 hash of the JSON-encoded `req` array. The JSON encoding MUST be consistent (same key ordering, no extra whitespace) to ensure signature validity.\n\n### Complete Exampleâ€‹\n    \n    \n    {  \n      \"req\": [  \n        1,  \n        \"auth_request\",  \n        {  \n          \"address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\",  \n          \"session_key\": \"0x9876543210fedcba9876543210fedcba98765432\",  \n          \"application\": \"trading-dex\",  \n          \"allowances\": [  \n            {\"asset\": \"usdc\", \"amount\": \"1000.0\"},  \n            {\"asset\": \"eth\", \"amount\": \"0.5\"}  \n          ],  \n          \"scope\": \"transfer,app.create\",  \n          \"expires_at\": 1762417328123  \n        },  \n        1699123456789  \n      ],  \n      \"sig\": [  \n        \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef01\"  \n      ]  \n    }  \n    \n\n* * *\n\n## Response Messageâ€‹\n\nThe clearnode sends response messages with the same structure, replacing `params` with `result`.\n\n### Structureâ€‹\n    \n    \n    {  \n      \"res\": [requestId, method, result, timestamp],  \n      \"sig\": [signature1, ...]  \n    }  \n    \n\n### Fieldsâ€‹\n\n#### resâ€‹\n\nThe response payload as a 4-element array:\n\n  * Same **requestId** (to correlate with request)\n  * **method** (response method name)\n    * Usually matches the request method\n    * **Exception** : `auth_request` â†’ response has `auth_challenge` method\n    * **Exception** : Errors â†’ response has `error` method\n  * **result** (method-specific response data, replaces params)\n  * **timestamp** (server response time)\n\n#### sigâ€‹\n\nThe clearnode's signature(s) over the response:\n\n  * Proves response authenticity\n  * Verifies response hasn't been tampered with\n  * Enables non-repudiation\n\n### Complete Exampleâ€‹\n    \n    \n    {  \n      \"res\": [  \n        1,  \n        \"auth_challenge\",  \n        {  \n          \"challenge_message\": \"550e8400-e29b-41d4-a716-446655440000\"  \n        },  \n        1699123457000  \n      ],  \n      \"sig\": [  \n        \"0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890ab\"  \n      ]  \n    }  \n    \n\n* * *\n\n## Error Responseâ€‹\n\nWhen an error occurs, the clearnode sends an error response with method set to `\"error\"`.\n\n### Structureâ€‹\n    \n    \n    {  \n      \"res\": [  \n        requestId,  \n        \"error\",  \n        {  \n          \"error\": \"Error description message\"  \n        },  \n        timestamp  \n      ],  \n      \"sig\": [\"0xServerSignature...\"]  \n    }  \n    \n\nThe result object at position 2 contains a single `\"error\"` field with a descriptive error message string.\n\n### Error Examplesâ€‹\n\n**Authentication Required** :\n    \n    \n    {  \n      \"res\": [  \n        5,  \n        \"error\",  \n        {  \n          \"error\": \"Authentication required: session not established\"  \n        },  \n        1699123456789  \n      ],  \n      \"sig\": [\"0xServerSignature...\"]  \n    }  \n    \n\n**Insufficient Balance** :\n    \n    \n    {  \n      \"res\": [  \n        12,  \n        \"error\",  \n        {  \n          \"error\": \"Insufficient balance: required 100 USDC, available 75 USDC\"  \n        },  \n        1699123456790  \n      ],  \n      \"sig\": [\"0xServerSignature...\"]  \n    }  \n    \n\n**Method Not Found** :\n    \n    \n    {  \n      \"res\": [  \n        8,  \n        \"error\",  \n        {  \n          \"error\": \"Method not found: 'invalid_method'\"  \n        },  \n        1699123456791  \n      ],  \n      \"sig\": [\"0xServerSignature...\"]  \n    }  \n    \n\nError Handling\n\nCheck the response method field (position 1 in `res` array). If it equals `\"error\"`, extract the error message from the result object's `error` field. The error message provides human-readable context about what went wrong.\n\n* * *\n\n## Payload Hash Computationâ€‹\n\nEvery RPC message (request or response) is signed over the exact serialized `req` or `res` array bytes.\n\n### What is Signedâ€‹\n\n  * **Requests** : The `req` array `[requestId, method, params, timestamp]` exactly as sent\n  * **Responses** : The `res` array `[requestId, method, result, timestamp]` exactly as received\n\n### Hash Formulaâ€‹\n    \n    \n    payloadHash = keccak256(<exact JSON bytes of req or res>)  \n    \n\nUse the same bytes you transmit (or receive) when computing/verifying the hash; do not re-serialize with different spacing or key ordering.\n\n### Exampleâ€‹\n\n**Request Payload** :\n    \n    \n    [42,\"create_app_session\",{\"definition\":{...},\"allocations\":[...]},1699123456789]  \n    \n\nHash that exact byte string, then sign it (client for requests, clearnode for responses).\n\n* * *\n\n## Message Flow Diagramâ€‹\n\nThe following diagram illustrates the complete request-response cycle:\n\nClearnodeClientClearnodeClientClearnodeClientGenerate RequestProcess RequestGenerate ResponseProcess ResponseCreate payload: [request_id, method, params, 0]Sign payload with session keySend Request {req, sig}Verify signatureValidate parametersExecute method logicGenerate resultCreate response: [request_id, method, result, timestamp]Sign responseSend Response {res, sig}Verify Clearnode signatureCorrelate by request_idHandle result\n\n* * *\n\n## Signature Verification Processâ€‹\n\nBoth clients and a clearnode MUST verify signatures on all messages.\n\n### Client Verifying a Clearnode Responseâ€‹\n\n  1. **Extract Response** : Get `res` array from response\n  2. **Compute Hash** : `hash = keccak256(<exact res bytes>)`\n  3. **Recover Address** : Use `sig` to recover signer address\n  4. **Verify** : Confirm recovered address matches the clearnode's known address\n\n### A Clearnode Verifying Client Requestâ€‹\n\n  1. **Extract Request** : Get `req` array from request\n  2. **Compute Hash** : `hash = keccak256(<exact req bytes>)`\n  3. **Recover Address** : Use `sig` to recover signer address\n  4. **Verify** : Confirm recovered address matches authenticated user or registered session key\n\nSignature Verification Requirements\n\n**Most** messages MUST be cryptographically signed and verified. All state-changing operations (channel creation/closure, transfers, app sessions) and authenticated methods require valid signatures. However, **some query methods** (such as `get_config`) may be accessed without signatures. Refer to individual method specifications for signature requirements.\n\n* * *\n\n## JSON Encoding Consistencyâ€‹\n\nTo ensure signature validity, JSON encoding MUST be consistent across all implementations.\n\n### Requirementsâ€‹\n\n  1. **Key Ordering** : Object keys MUST be in a deterministic order\n  2. **No Whitespace** : Remove all unnecessary whitespace\n  3. **No Trailing Commas** : Standard JSON (no trailing commas)\n  4. **UTF-8 Encoding** : Use UTF-8 character encoding\n  5. **Number Format** : Numbers as strings for large integers (avoid precision loss)\n\n### Canonical Exampleâ€‹\n\n**Consistent** (valid for signing):\n    \n    \n    [1,\"transfer\",{\"amount\":\"100\",\"asset\":\"usdc\",\"destination\":\"0x...\"},1699123456]  \n    \n\n**Inconsistent** (would produce different hash):\n    \n    \n    [  1,  \"transfer\",  { \"destination\": \"0x...\", \"amount\": \"100\", \"asset\": \"usdc\" },  1699123456  ]  \n    \n\nImplementation Note\n\nUse a JSON library that supports canonical JSON serialization, or implement strict key ordering and whitespace removal before computing hashes.\n\n* * *\n\n## Next Stepsâ€‹\n\nNow that you understand the message format, explore how it's used in practice:\n\n  * **[Authentication](/docs/protocol/off-chain/authentication)** \\- Learn the 3-step authentication flow\n  * **[Channel Methods](/docs/protocol/off-chain/channel-methods)** \\- See request/response examples for channel operations\n  * **[Transfers](/docs/protocol/off-chain/transfers)** \\- Understand transfer message structure\n  * **[App Sessions](/docs/protocol/off-chain/app-sessions)** \\- Explore multi-signature app session messages\n\nFor a high-level overview, return to **[Off-Chain RPC Overview](/docs/protocol/off-chain/overview)**.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/off-chain/message-format.mdx)\n\n[PreviousOff-Chain RPC Overview](/docs/protocol/off-chain/overview)[NextAuthentication](/docs/protocol/off-chain/authentication)\n\n  * General Structure\n    * Components\n  * Request Message\n    * Structure\n    * Fields\n    * Signature Format\n    * Complete Example\n  * Response Message\n    * Structure\n    * Fields\n    * Complete Example\n  * Error Response\n    * Structure\n    * Error Examples\n  * Payload Hash Computation\n    * What is Signed\n    * Hash Formula\n    * Example\n  * Message Flow Diagram\n  * Signature Verification Process\n    * Client Verifying a Clearnode Response\n    * A Clearnode Verifying Client Request\n  * JSON Encoding Consistency\n    * Requirements\n    * Canonical Example\n  * Next Steps",
    "metadata": {
      "title": "Message Format | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/message-format",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/off-chain/overview",
    "text": "* [](/)\n  * Off-Chain RPC Protocol\n  * Off-Chain RPC Overview\n\nOn this page\n\n# Off-Chain RPC Protocol Overview\n\nThe Off-Chain RPC Protocol defines how clients communicate with a clearnode to perform state channel operations without touching the blockchain.\n\n* * *\n\n## What is Nitro RPC?â€‹\n\n**Nitro RPC** is a lightweight RPC protocol designed for state channel communication. It uses a compact JSON array format for efficiency and includes signature-based authentication.\n\nProtocol Purpose\n\nNitro RPC enables clients to interact with a clearnode for channel management, fund transfers, and application-specific operationsâ€”all happening off-chain with instant finality and zero gas costs.\n\n* * *\n\n## Key Featuresâ€‹\n\n### 1\\. Compact Message Formatâ€‹\n\nNitro RPC uses a streamlined JSON array format instead of verbose JSON objects, reducing message size and improving network efficiency.\n    \n    \n    // Compact format: [requestId, method, params, timestamp]  \n    [1, \"create_channel\", {\"chain_id\": 137, \"token\": \"0x...\", \"amount\": \"1000000\"}, 1699123456789]  \n    \n\nEfficiency Benefit\n\nThe compact array format reduces bandwidth usage by approximately 30% compared to traditional JSON-RPC, crucial for high-frequency state channel updates.\n\n### 2\\. Signature-Based Authenticationâ€‹\n\nEvery request and response is cryptographically signed, ensuring:\n\n  * **Message authenticity** : Verify sender identity\n  * **Message integrity** : Detect tampering\n  * **Non-repudiation** : Proof of communication\n\n### 3\\. Multi-Signature Supportâ€‹\n\nSupports operations requiring multiple participants' signatures:\n\n  * Channel creation (user + a clearnode)\n  * App session state updates (multiple participants based on quorum)\n  * Cooperative channel closure\n\n### 4\\. Timestamp-Based Request Orderingâ€‹\n\nAll messages include timestamps (client-provided on requests, server-provided on responses) enabling:\n\n  * Request ordering\n  * Replay attack prevention\n  * Audit trail for debugging\n\n### 5\\. Channel-Aware Message Structureâ€‹\n\nThe protocol understands channel concepts natively:\n\n  * Packed states\n  * Multi-party signatures\n  * State versioning\n\n* * *\n\n## Protocol Versionsâ€‹\n\nNitro RPC has evolved to support advanced features while maintaining backward compatibility.\n\n### Version Comparisonâ€‹\n\nFeature| NitroRPC/0.2| NitroRPC/0.4  \n---|---|---  \n**Status**|  Legacy| **Current**  \n**Basic State Updates**|  âœ…| âœ…  \n**Intent System**|  âŒ| âœ…  \n**DEPOSIT Intent**|  âŒ| âœ… (add funds to app sessions)  \n**WITHDRAW Intent**|  âŒ| âœ… (remove funds from app sessions)  \n**OPERATE Intent**|  Implicit only| âœ… Explicit  \n**Recommended**|  No| **Yes**  \n  \nVersion Recommendation\n\n**Always use NitroRPC/0.4** for new implementations. Version 0.2 is maintained for backward compatibility only and lacks the intent system required for flexible app session management.\n\n### NitroRPC/0.2 (Legacy)â€‹\n\n**Features** :\n\n  * Basic state updates for app sessions\n  * All updates redistribute existing funds\n  * Cannot add or remove funds from active sessions\n  * Must close and recreate sessions to change total funds\n\n**Use Case** : Maintained for existing applications, not recommended for new development.\n\n### NitroRPC/0.4 (Current)â€‹\n\n**Features** :\n\n  * Intent-based state updates: **OPERATE** , **DEPOSIT** , **WITHDRAW**\n  * Add funds to active app sessions (DEPOSIT)\n  * Remove funds from active sessions (WITHDRAW)\n  * Better error handling and validation\n  * Enhanced security checks\n\n**Use Case** : All new implementations should use this version.\n\n* * *\n\n## Communication Architectureâ€‹\n\nNitro RPC enables bidirectional real-time communication between clients and a clearnode.\n\nRPC Connection\n\nEvent Monitoring\n\nState Management\n\n1\\. RPC Request  \n(signed)\n\n2\\. Process & Validate\n\n3\\. RPC Response  \n(signed)\n\nAsync Notifications\n\nBlockchain Events\n\nClient Application\n\nClearnode\n\nBlockchain\n\nDatabase\n\n### Connection Flowâ€‹\n\n  1. **Client Establishes Connection** : Open persistent connection to a clearnode\n  2. **Authentication** : Complete 3-step auth flow (auth_request â†’ auth_challenge â†’ auth_verify)\n  3. **RPC Communication** : Send requests, receive responses\n  4. **Notifications** : Receive real-time updates (balance changes, channel events)\n  5. **Keep-Alive** : Periodic ping/pong to maintain connection (optional, depends upon the implementation chosen)\n\n* * *\n\n## Message Categoriesâ€‹\n\nNitro RPC methods are organized into functional categories:\n\n### 1\\. Authentication Methodsâ€‹\n\nEstablish and manage authenticated sessions:\n\n  * `auth_request` \\- Initiate authentication (response: `auth_challenge`)\n  * `auth_verify` \\- Complete authentication with challenge response\n\n### 2\\. Channel Management Methodsâ€‹\n\nCreate and manage payment channels:\n\n  * `create_channel` \\- Open new channel\n  * `close_channel` \\- Cooperatively close channel\n  * `resize_channel` \\- Adjust channel allocations\n\n### 3\\. Transfer Methodsâ€‹\n\nMove funds between users:\n\n  * `transfer` \\- Send funds off-chain with instant settlement\n\n### 4\\. App Session Methodsâ€‹\n\nManage multi-party application channels:\n\n  * `create_app_session` \\- Create new app session\n  * `submit_app_state` \\- Update session state (with intents)\n  * `close_app_session` \\- Finalize and distribute funds\n\n### 5\\. Query Methodsâ€‹\n\nRead state and configuration:\n\n  * Public: `get_config`, `get_assets`, `get_app_definition`, `get_channels`, `get_app_sessions`, `get_ledger_entries`, `get_ledger_transactions`, `ping`\n  * Private (auth required): `get_ledger_balances`, `get_rpc_history`, `get_user_tag`, `get_session_keys`\n\n### 6\\. Notifications (Server-to-Client)â€‹\n\nReal-time updates:\n\n  * `bu` (balance update) - Balance changed\n  * `cu` (channel update) - Channel status changed\n  * `tr` (transfer) - Incoming/outgoing transfer\n  * `asu` (app session update) - App session state changed\n\n* * *\n\n## Security Modelâ€‹\n\nThe Off-Chain RPC Protocol provides multiple layers of security:\n\n### Cryptographic Securityâ€‹\n\n  * **ECDSA Signatures** : Every message signed with secp256k1\n  * **Keccak256 Hashing** : Message integrity verification\n  * **Challenge-Response Auth** : Prove key ownership without exposing private keys\n\n### Protocol-Level Securityâ€‹\n\n  * **Request Ordering** : Timestamps prevent replay attacks\n  * **Session Expiration** : Session keys have time limits\n  * **Spending Allowances** : Limit session key spending power\n  * **Signature Verification** : All operations require valid signatures\n\n### Network Securityâ€‹\n\n  * **TLS Encrypted Communication** : Encrypted communication channel\n  * **Origin Validation** : Prevent unauthorized connections\n\nStrong Security Model\n\nThe combination of cryptographic signatures, challenge-response authentication, and spending allowances ensures that even if a session key is compromised, damage is limited by spending caps and expiration times.\n\n* * *\n\n## Next Stepsâ€‹\n\nExplore the detailed specifications for each part of the protocol:\n\n  * **[Message Format](/docs/protocol/off-chain/message-format)** \\- Learn the request/response structure\n  * **[Authentication](/docs/protocol/off-chain/authentication)** \\- Implement secure session management\n  * **[Channel Methods](/docs/protocol/off-chain/channel-methods)** \\- Create and manage payment channels\n  * **[Transfers](/docs/protocol/off-chain/transfers)** \\- Enable instant off-chain payments\n  * **[App Sessions](/docs/protocol/off-chain/app-sessions)** \\- Build multi-party applications\n  * **[Queries& Notifications](/docs/protocol/off-chain/queries)** \\- Read state and receive updates\n\n* * *\n\n## Key Conceptsâ€‹\n\nBefore diving into specific methods, ensure you understand these core concepts from the protocol foundation:\n\n  * **Channel** \\- Payment channel locking funds on-chain\n  * **State** \\- Snapshot of channel at a point in time\n  * **Participant** \\- Entity in a channel (user, a clearnode)\n  * **Unified Balance** \\- Aggregated balance across chains\n  * **Session Key** \\- Temporary key with spending limits\n\nRefer to the **[Terminology](/docs/protocol/terminology)** page for complete definitions.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/off-chain/overview.mdx)\n\n[PreviousSecurity Considerations](/docs/protocol/on-chain/security)[NextMessage Format](/docs/protocol/off-chain/message-format)\n\n  * What is Nitro RPC?\n  * Key Features\n    * 1\\. Compact Message Format\n    * 2\\. Signature-Based Authentication\n    * 3\\. Multi-Signature Support\n    * 4\\. Timestamp-Based Request Ordering\n    * 5\\. Channel-Aware Message Structure\n  * Protocol Versions\n    * Version Comparison\n    * NitroRPC/0.2 (Legacy)\n    * NitroRPC/0.4 (Current)\n  * Communication Architecture\n    * Connection Flow\n  * Message Categories\n    * 1\\. Authentication Methods\n    * 2\\. Channel Management Methods\n    * 3\\. Transfer Methods\n    * 4\\. App Session Methods\n    * 5\\. Query Methods\n    * 6\\. Notifications (Server-to-Client)\n  * Security Model\n    * Cryptographic Security\n    * Protocol-Level Security\n    * Network Security\n  * Next Steps\n  * Key Concepts",
    "metadata": {
      "title": "Off-Chain RPC Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/overview",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/off-chain/queries",
    "text": "* [](/)\n  * Off-Chain RPC Protocol\n  * Query Methods & Notifications\n\nOn this page\n\n# Query Methods & Notifications\n\nQuery methods retrieve information from a clearnode, while notifications provide real-time updates about state changes.\n\n* * *\n\n## Overviewâ€‹\n\nThe Nitro RPC protocol provides two types of information retrieval:\n\n**Query Methods** : Client-initiated requests to retrieve current state information (balances, channels, sessions, transactions).\n\n**Notifications** : Server-initiated messages sent to all relevant active connections when events occur (balance changes, channel updates, incoming transfers).\n\nReal-Time Updates\n\nCombine query methods for initial state retrieval with notifications for ongoing monitoring. This pattern ensures your application always reflects the latest state without constant polling.\n\n* * *\n\n## Query Methods Summaryâ€‹\n\nMethod| Authentication| Purpose| Pagination  \n---|---|---|---  \n`get_config`| Public| Retrieve clearnode configuration| No  \n`get_assets`| Public| List supported assets| No  \n`get_app_definition`| Public| Fetch the definition for a specific app session| No  \n`get_channels`| Public| List payment channels| Yes  \n`get_app_sessions`| Public| List app sessions| Yes  \n`get_ledger_balances`| Private| Query current balances| No  \n`get_ledger_entries`| Public| Detailed accounting entries| Yes  \n`get_ledger_transactions`| Public| User-facing transaction history| Yes  \n`get_rpc_history`| Private| Fetch recent RPC invocations| Yes  \n`get_user_tag`| Private| Retrieve user's alphanumeric tag| No  \n`get_session_keys`| Private| List active session keys| Yes  \n`ping`| Public| Connection health check| No  \n  \nAuthentication\n\n**Public methods** can be called without authentication. **Private methods** require completing the [authentication flow](/docs/protocol/off-chain/authentication) first.\n\nPagination defaults\n\nUnless explicitly provided, paginated methods default to `limit = 10` (maximum 100) and `offset = 0`, matching the brokerâ€™s `ListOptions`.\n\n* * *\n\n## get_configâ€‹\n\n### Nameâ€‹\n\n`get_config`\n\n### Usageâ€‹\n\nRetrieves the clearnode's configuration: broker address plus supported blockchains and their custody/adjudicator contracts.\n\n### Requestâ€‹\n\nNo parameters.\n\n### Responseâ€‹\n\nParameter| Type| Description| Example  \n---|---|---|---  \n`broker_address`| string| Clearnode's wallet address| `\"0xbbbb567890abcdef...\"`  \n`networks`| array<BlockchainInfo>| List of supported blockchain networks| See structure below  \n  \n#### BlockchainInfo Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`chain_id`| uint32| Network identifier| `137` (Polygon)  \n`name`| string| Human-readable blockchain name| `\"Polygon\"`  \n`custody_address`| string| Custody contract address on this chain| `\"0xCustodyContractAddress...\"`  \n`adjudicator_address`| string| Adjudicator contract address on this chain| `\"0xAdjudicatorAddress...\"`  \n  \n**Use Cases** :\n\n  * Discover supported chains and contract addresses\n  * Verify clearnode wallet address\n\n* * *\n\n## get_assetsâ€‹\n\n### Nameâ€‹\n\n`get_assets`\n\n### Usageâ€‹\n\nRetrieves all supported assets and their configurations across supported blockchains.\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Example| Notes  \n---|---|---|---|---|---  \n`chain_id`| uint32| No| Filter by specific chain| `137`| If omitted, returns assets for all chains  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Example  \n---|---|---|---  \n`assets`| array<Asset>| List of supported assets| See structure below  \n  \n#### Asset Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`token`| string| Token contract address| `\"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\"`  \n`chain_id`| uint32| Blockchain network identifier| `137`  \n`symbol`| string| Token symbol| `\"usdc\"`  \n`decimals`| uint8| Number of decimal places| `6`  \n  \n**Use Cases** :\n\n  * Display supported assets in UI\n  * Validate asset identifiers before transfers\n  * Get contract addresses for specific chains\n\n* * *\n\n## get_app_definitionâ€‹\n\n### Nameâ€‹\n\n`get_app_definition`\n\n### Usageâ€‹\n\nRetrieves the immutable definition for a given app session so clients can verify governance parameters and participants.\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Example  \n---|---|---|---|---  \n`app_session_id`| string| Yes| Target app session identifier| `\"0x9876543210fedcba...\"`  \n  \n### Responseâ€‹\n\nReturns the [AppDefinition](/docs/protocol/off-chain/app-sessions#appdefinition) structure:\n\nField| Type| Description  \n---|---|---  \n`protocol`| string| Protocol version (`\"NitroRPC/0.2\"` or `\"NitroRPC/0.4\"`)  \n`participants`| array<address>| Wallet addresses authorized for this session  \n`weights`| array<int64>| Voting weight per participant (aligned with `participants` order)  \n`quorum`| uint64| Minimum combined weight required for updates  \n`challenge`| uint64| Dispute timeout (seconds)  \n`nonce`| uint64| Unique instance identifier  \n  \n**Use Cases** :\n\n  * Validate session metadata before signing states\n  * Display governance rules in UI\n  * Confirm protocol version compatibility\n\n* * *\n\n## get_channelsâ€‹\n\n### Nameâ€‹\n\n`get_channels`\n\n### Usageâ€‹\n\nLists all channels for a specific participant address across all supported chains.\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example  \n---|---|---|---|---|---  \n`participant`| string| No| Participant wallet address to query| (empty = all channels)| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`  \n`status`| string| No| Filter by status| -| `\"open\"`  \n`offset`| number| No| Pagination offset| `0`| `42`  \n`limit`| number| No| Number of channels to return| `10` (max 100)| `10`  \n`sort`| string| No| Sort order by created_at| `\"desc\"`| `\"desc\"`  \n  \n**Allowed status values** : `\"open\"` | `\"closed\"` | `\"challenged\"` | `\"resizing\"`\n\n### Responseâ€‹\n\nParameter| Type| Description| Example  \n---|---|---|---  \n`channels`| array<Channel>| List of channels| See structure below  \n  \n#### Channel Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`channel_id`| string| Unique channel identifier| `\"0xabcdef...\"`  \n`participant`| string| User's wallet address| `\"0x742d35Cc...\"`  \n`status`| string| Channel status| `\"open\"`  \n`token`| string| Asset contract address| `\"0x2791Bca1...\"`  \n`wallet`| string| Participant's wallet address| `\"0x742d35Cc...\"`  \n`amount`| string| Total channel capacity (human-readable)| `\"100.0\"`  \n`chain_id`| uint32| Blockchain network identifier| `137`  \n`adjudicator`| string| Dispute resolution contract address| `\"0xAdjudicator...\"`  \n`challenge`| uint64| Dispute timeout period (seconds)| `3600`  \n`nonce`| uint64| Unique nonce ensuring channel uniqueness| `1699123456789`  \n`version`| uint64| Current state version| `5`  \n`created_at`| string| Channel creation timestamp (ISO 8601)| `\"2023-05-01T12:00:00Z\"`  \n`updated_at`| string| Last modification timestamp (ISO 8601)| `\"2023-05-01T14:30:00Z\"`  \n  \n**Use Cases** :\n\n  * Display user's open channels\n  * Check channel status before operations\n  * Monitor multi-chain channel distribution\n\n* * *\n\n## get_app_sessionsâ€‹\n\n### Nameâ€‹\n\n`get_app_sessions`\n\n### Usageâ€‹\n\nLists all app sessions for a participant, sorted by creation date (newest first by default). Optionally filter by status (open/closed). Returns complete session information including participants, voting weights, quorum, protocol version, and current state. Supports pagination for large result sets.\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Allowed Values| Example  \n---|---|---|---|---|---|---  \n`participant`| string (address)| No| Filter by participant wallet address| (empty = all sessions)| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`|   \n`status`| string| No| Filter by status| -| `\"open\"`|   \n`offset`| number| No| Pagination offset| 0| -| `42`  \n`limit`| number| No| Number of sessions to return| 10 (max 100)| -| `10`  \n`sort`| string| No| Sort order by created_at| \"desc\"| `\"desc\"`|   \n  \n**Allowed status values** : `\"open\"` | `\"closed\"`\n\n### Responseâ€‹\n\nParameter| Type| Description| See Also  \n---|---|---|---  \n`app_sessions`| array<AppSessionInfo>| List of app sessions| See structure below  \n  \n#### AppSessionInfoâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`app_session_id`| string| Unique identifier| `\"0x9876543210fedcba...\"`  \n`application`| string| Application identifier| `\"NitroliteChess\"`  \n`status`| string| Current status| `\"open\"` | `\"closed\"`  \n`participants`| array<address>| All participant wallet addresses| `[\"0x742d35Cc...\", \"0x8B3192f2...\"]`  \n`weights`| array<int64>| Voting weights per participant| `[50, 50, 100]`  \n`quorum`| uint64| Required weight for state updates| `100`  \n`protocol`| string| Protocol version| `\"NitroRPC/0.4\"`  \n`challenge`| uint64| Challenge period in seconds| `86400`  \n`version`| number| Current state version| `5`  \n`nonce`| uint64| Unique session identifier| `1699123456789`  \n`session_data`| string| Current application state| `\"{\\\"gameType\\\":\\\"chess\\\",\\\"turn\\\":\\\"white\\\"}\"`  \n`created_at`| string (timestamp)| Creation timestamp| `\"2023-05-01T12:00:00Z\"`  \n`updated_at`| string (timestamp)| Last update timestamp| `\"2023-05-01T14:30:00Z\"`  \n  \n**Use Cases** :\n\n  * Display user's active games or escrows\n  * Monitor session history\n  * Paginate through large session lists\n\nPagination Best Practice\n\nWhen dealing with users who have many app sessions, use pagination with reasonable `limit` values (10-50) to improve performance and user experience.\n\n* * *\n\n## get_ledger_balancesâ€‹\n\n### Nameâ€‹\n\n`get_ledger_balances`\n\n### Usageâ€‹\n\nRetrieves the ledger balances for an account. If no parameters are provided, returns the authenticated user's unified balance across all assets. Can also query balance within a specific app session by providing the app_session_id. Returns all tracked assets (including those that currently evaluate to zero).\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Format| Example  \n---|---|---|---|---|---  \n`account_id`| string| No| Account or app session identifier| 0x-prefixed hex string or wallet address| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`  \n  \nApp Session Balances\n\nTo query balance within a specific app session, provide the `app_session_id` as the `account_id`.\n\n### Responseâ€‹\n\nParameter| Type| Description| Example  \n---|---|---|---  \n`ledger_balances`| array<Balance>| Balance per asset| See structure below  \n  \n#### Balance Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`asset`| string| Asset identifier| `\"usdc\"`  \n`amount`| string| Balance in human-readable format| `\"100.0\"`  \n  \n**Use Cases** :\n\n  * Display user's current balances\n  * Check available funds before operations\n  * Monitor balance changes in real-time\n\n* * *\n\n## get_ledger_entriesâ€‹\n\n### Nameâ€‹\n\n`get_ledger_entries`\n\n### Usageâ€‹\n\nRetrieves detailed ledger entries for an account, providing a complete audit trail of all debits and credits. Each entry represents one side of a double-entry bookkeeping transaction. Used for detailed financial reconciliation and accounting. Supports filtering by account, asset, and pagination. Sorted by creation date (newest first by default).\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Allowed Values| Example  \n---|---|---|---|---|---|---  \n`account_id`| string| No| Filter by account identifier| -| -| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`  \n`wallet`| string (address)| No| Filter by wallet address| -| -| `\"0x742d35Cc...\"`  \n`asset`| string| No| Filter by asset| -| -| `\"usdc\"`  \n`offset`| number| No| Pagination offset| 0| -| -  \n`limit`| number| No| Number of entries to return| 10 (max 100)| -| -  \n`sort`| string| No| Sort order by created_at| \"desc\"| \"asc\" | \"desc\"| -  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Structure| Example  \n---|---|---|---|---  \n`ledger_entries`| array<LedgerEntry>| List of ledger entries| See structure below|   \n  \n#### LedgerEntry Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`id`| number| Unique entry identifier| `123`  \n`account_id`| string| Account this entry belongs to| `\"0x742d35Cc...\"`  \n`account_type`| number| Ledger account classification (`1000`=asset, `2000`=liability, etc.)| `1000`  \n`asset`| string| Asset symbol| `\"usdc\"`  \n`participant`| string| Participant wallet address| `\"0x742d35Cc...\"`  \n`credit`| string| Credit amount (incoming funds, \"0.0\" if debit)| `\"100.0\"`  \n`debit`| string| Debit amount (outgoing funds, \"0.0\" if credit)| `\"25.0\"`  \n`created_at`| string| Entry creation timestamp (ISO 8601)| `\"2023-05-01T12:00:00Z\"`  \n  \nAccount types follow the brokerâ€™s GAAP-style codes: `1000` series for assets, `2000` liabilities, `3000` equity, `4000` revenue, and `5000` expenses.\n\n### Double-Entry Bookkeepingâ€‹\n\nEvery transaction creates two entries:\n    \n    \n    Transfer: Alice sends 50 USDC to Bob  \n      \n    Entry 1 (Alice's ledger):  \n      account_id: Alice's address  \n      asset: usdc  \n      credit: 0.0  \n      debit: 50.0  \n        \n    Entry 2 (Bob's ledger):  \n      account_id: Bob's address  \n      asset: usdc  \n      credit: 50.0  \n      debit: 0.0  \n    \n\nAccounting Principle\n\nThe double-entry system ensures that the total of all debits always equals the total of all credits, providing mathematical proof of accounting accuracy. This is the same principle used by traditional financial institutions.\n\n**Use Cases** :\n\n  * Detailed financial reconciliation\n  * Audit trail generation\n  * Accounting system integration\n  * Verify balance calculations\n\n* * *\n\n## get_ledger_transactionsâ€‹\n\n### Nameâ€‹\n\n`get_ledger_transactions`\n\n### Usageâ€‹\n\nRetrieves user-facing transaction history showing transfers, deposits, withdrawals, and app session operations. Unlike ledger entries (which show accounting details), this provides a simplified view of financial activity with sender, receiver, amount, and transaction type. Supports filtering by asset and transaction type. Sorted by creation date (newest first by default).\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Allowed Values| Example  \n---|---|---|---|---|---|---  \n`account_id`| string| No| Filter by account identifier| -| -| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`  \n`asset`| string| No| Filter by asset| -| -| `\"usdc\"`  \n`tx_type`| string| No| Filter by transaction type| -| \"transfer\" | \"deposit\" | \"withdrawal\" | \"app_deposit\" | \"app_withdrawal\" | \"escrow_lock\" | \"escrow_unlock\"| `\"transfer\"`  \n`offset`| number| No| Pagination offset| 0| -| -  \n`limit`| number| No| Number of transactions to return| 10 (max 100)| -| -  \n`sort`| string| No| Sort order by created_at| \"desc\"| \"asc\" | \"desc\"| -  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Example  \n---|---|---|---  \n`ledger_transactions`| array<LedgerTransaction>| List of transactions| See structure below  \n  \n#### LedgerTransaction Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`id`| number| Unique transaction identifier| `1`  \n`tx_type`| string| Transaction type| `\"transfer\"`  \n`from_account`| string| Sender account identifier (wallet, channel, or app session)| `\"0x742d35Cc...\"`  \n`from_account_tag`| string| Sender's user tag (empty if none)| `\"NQKO7C\"`  \n`to_account`| string| Receiver account identifier (wallet, channel, or app session)| `\"0x8B3192f2...\"`  \n`to_account_tag`| string| Receiver's user tag (empty if none)| `\"UX123D\"`  \n`asset`| string| Asset symbol| `\"usdc\"`  \n`amount`| string| Transaction amount| `\"50.0\"`  \n`created_at`| string| Transaction timestamp (ISO 8601)| `\"2023-05-01T12:00:00Z\"`  \n  \n`from_account` and `to_account` mirror the brokerâ€™s internal `AccountID` values, so they can reference wallets, app session escrow accounts, or channel escrows.\n\n### Transaction Typesâ€‹\n\nType| Description| Direction  \n---|---|---  \n**transfer**|  Direct transfer between unified balances| Off-chain â†” Off-chain  \n**deposit**|  Funds deposited from channel to unified balance| On-chain â†’ Off-chain  \n**withdrawal**|  Funds withdrawn from unified balance to channel| Off-chain â†’ On-chain  \n**app_deposit**|  Funds moved from unified balance into app session| Unified â†’ App Session  \n**app_withdrawal**|  Funds released from app session to unified balance| App Session â†’ Unified  \n**escrow_lock**|  Funds temporarily locked for blockchain operations| Unified â†’ Escrow  \n**escrow_unlock**|  Funds released from escrow after blockchain confirmation| Escrow â†’ Unified  \n  \n**Use Cases** :\n\n  * Display transaction history in UI\n  * Export transaction records\n  * Monitor specific transaction types\n  * Track payment flows\n\n* * *\n\n## get_rpc_historyâ€‹\n\n### Nameâ€‹\n\n`get_rpc_history`\n\n### Usageâ€‹\n\nReturns the authenticated user's recent RPC invocations, including signed request and response payloads. Useful for audit trails and debugging client integrations.\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example  \n---|---|---|---|---|---  \n`offset`| number| No| Pagination offset| `0`| `20`  \n`limit`| number| No| Maximum entries to return| `10` (max 100)| `25`  \n`sort`| string| No| Sort order by timestamp| `\"desc\"`| `\"asc\"`  \n  \n### Responseâ€‹\n\nParameter| Type| Description| See Also  \n---|---|---|---  \n`rpc_entries`| array<RPCEntry>| Recorded invocations| See structure below  \n  \n#### RPCEntry Structureâ€‹\n\nField| Type| Description  \n---|---|---  \n`id`| number| Internal history identifier  \n`sender`| string| Wallet that issued the call  \n`req_id`| number| Request sequence number  \n`method`| string| RPC method name  \n`params`| string| JSON-encoded request parameters  \n`timestamp`| number| Unix timestamp (seconds)  \n`req_sig`| array<Signature>| Signatures attached to the request  \n`response`| string| JSON-encoded response payload  \n`res_sig`| array<Signature>| Response signatures  \n  \n**Use Cases** :\n\n  * Debug client/server mismatches\n  * Provide user-facing audit logs\n  * Verify signed payloads during dispute resolution\n\n* * *\n\n## get_user_tagâ€‹\n\n### Nameâ€‹\n\n`get_user_tag`\n\n### Usageâ€‹\n\nRetrieves the authenticated user's unique alphanumeric tag. User tags provide a human-readable alternative to addresses for [transfer](/docs/protocol/off-chain/transfers) operations, similar to username systems. Tags are automatically generated upon first interaction with a clearnode and remain constant. This is a convenience feature for improving user experience.\n\n### Requestâ€‹\n\nNo parameters.\n\n### Responseâ€‹\n\nParameter| Type| Description| Format| Example| Notes  \n---|---|---|---|---|---  \n`tag`| string| User's unique alphanumeric tag| 6 uppercase alphanumeric characters| `\"UX123D\"`| Can be used in transfer operations as destination_user_tag  \n  \n### Usage in Transfersâ€‹\n\nInstead of using full address:\n    \n    \n    transfer({destination: \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\", ...})  \n    \n\nUsers can use the tag:\n    \n    \n    transfer({destination_user_tag: \"UX123D\", ...})  \n    \n\nHuman-Readable Addresses\n\nUser tags make it easier for users to share their \"address\" verbally or in non-technical contexts, similar to payment apps like Venmo or Cash App usernames.\n\n* * *\n\n## get_session_keysâ€‹\n\n### Nameâ€‹\n\n`get_session_keys`\n\n### Usageâ€‹\n\nRetrieves all active (non-expired) session keys for the authenticated user. Shows each session key's address, application name, spending allowances, current usage, expiration, and permissions. Used for managing delegated keys and monitoring spending caps. Only returns session keys (not custody signers).\n\n### Authenticationâ€‹\n\nRequired (private method)\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example  \n---|---|---|---|---|---  \n`offset`| number| No| Pagination offset| `0`| `20`  \n`limit`| number| No| Results per page| `10` (max 100)| `25`  \n`sort`| string| No| Sort order by created_at| `\"desc\"`| `\"asc\"`  \n  \n### Responseâ€‹\n\nParameter| Type| Description| See Also  \n---|---|---|---  \n`session_keys`| array<SessionKeyInfo>| List of active session keys| See structure below  \n  \n#### SessionKeyInfo Structureâ€‹\n\nField| Type| Description| Default| Notes  \n---|---|---|---|---  \n`id`| number| Internal identifier| â€”| â€”  \n`session_key`| string (address)| Session key address| â€”| â€”  \n`application`| string| Application name for this session| `\"clearnode\"`| â€”  \n`allowances`| array<AllowanceUsage>| Spending limits and usage| â€”| See structure below  \n`scope`| string| Permission scope| â€”| Future feature, not fully enforced yet  \n`expires_at`| string (timestamp)| Session expiration time (ISO 8601 format)| â€”| â€”  \n`created_at`| string (timestamp)| Session creation time (ISO 8601 format)| â€”| â€”  \n  \n**Example** :\n    \n    \n    {  \n      \"id\": 1,  \n      \"session_key\": \"0x9876543210fedcba...\",  \n      \"application\": \"Chess Game\",  \n      \"allowances\": [  \n        {\"asset\": \"usdc\", \"allowance\": \"100.0\", \"used\": \"45.0\"}  \n      ],  \n      \"scope\": \"app.create,transfer\",  \n      \"expires_at\": \"2023-05-02T12:00:00Z\",  \n      \"created_at\": \"2023-05-01T12:00:00Z\"  \n    }  \n    \n\n#### AllowanceUsageâ€‹\n\nField| Type| Description  \n---|---|---  \n`asset`| string| Asset identifier (e.g., `\"usdc\"`)  \n`allowance`| string| Total spending limit  \n`used`| string| Amount already spent  \n  \n### Spending Trackingâ€‹\n\nThe clearnode tracks session key spending by monitoring all ledger debit operations:\n    \n    \n    Initial: allowance = 100 USDC, used = 0 USDC  \n    After transfer of 45 USDC: allowance = 100 USDC, used = 45 USDC  \n    Remaining = 55 USDC available for future operations  \n    \n\nWhen a session key reaches its spending cap, further operations are rejected:\n    \n    \n    Error: \"operation denied: insufficient session key allowance: 60 required, 55 available\"  \n    \n\nSpending Caps\n\nSession key allowances provide important security: even if a session key is compromised, the maximum loss is limited to the allowance amount.\n\n**Use Cases** :\n\n  * Display active sessions in UI\n  * Monitor spending against caps\n  * Manage session lifecycles\n  * Security auditing\n\n* * *\n\n## pingâ€‹\n\n### Nameâ€‹\n\n`ping`\n\n### Usageâ€‹\n\nSimple connectivity check to verify the clearnode is responsive and the RPC connection is alive. Returns immediately with success. Used for heartbeat, connection testing, and latency measurement.\n\n### Authenticationâ€‹\n\nNot required (public method)\n\n### Requestâ€‹\n\nNo parameters required (empty object `{}`).\n\n### Responseâ€‹\n\nThe response method should be `\"pong\"`.\n\nParameter| Type| Description| Value/Example| Notes  \n---|---|---|---|---  \n(empty)| object| Empty object or confirmation data| `{}`| Response indicates successful connection  \n  \n### Use Casesâ€‹\n\n**Heartbeat** : Periodic ping to keep RPC connection alive\n    \n    \n    setInterval(() => clearnode.call(\"ping\"), 30000)  // Every 30 seconds  \n    \n\n**Latency Measurement** : Measure round-trip time\n    \n    \n    const start = Date.now()  \n    await clearnode.call(\"ping\")  \n    const latency = Date.now() - start  \n    console.log(`Latency: ${latency}ms`)  \n    \n\n**Health Check** : Verify connection before critical operations\n    \n    \n    try {  \n      await clearnode.call(\"ping\")  \n      // Connection healthy, proceed with operation  \n    } catch (error) {  \n      // Connection lost, reconnect  \n    }  \n    \n\n**Authentication Status** : Test if session is still valid\n    \n    \n    const response = await clearnode.call(\"ping\")  \n    // If no auth error, session is active  \n    \n\n* * *\n\n## Notifications (Server-to-Client)â€‹\n\nThe clearnode sends unsolicited notifications to clients via RPC when certain events occur. These are not responses to requests, but asynchronous messages initiated by the server.\n\nEventsClearnodeClientEvent SourceClearnodeClientEvent SourceClearnodeClientRPC Connection EstablishedTransfer (incoming/outgoing)tr (transfer) notificationBalance changedbu (balance update) notificationChannel openedcu (channel update) notificationApp session updatedasu (app session update) notification\n\n### Notification Typesâ€‹\n\nMethod| Description| Data Structure  \n---|---|---  \n`bu`| Balance update| `balance_updates` array with updated balances  \n`cu`| Channel update| Full `Channel` object  \n`tr`| Transfer (incoming/outgoing)| `transactions` array with transfer details  \n`asu`| App session update| `app_session` object and `participant_allocations`  \n  \n* * *\n\n## bu (Balance Update)â€‹\n\n### Methodâ€‹\n\n`bu`\n\n### When Sentâ€‹\n\nWhenever account balances change due to transfers, app session operations, or channel operations.\n\n### Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`balance_updates`| array<LedgerBalance>| Updated balances for affected accounts| See structure below  \n  \n#### LedgerBalance Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`asset`| string| Asset symbol| `\"usdc\"`  \n`amount`| string| New balance amount| `\"150.0\"`  \n  \n**Use Cases** :\n\n  * Update balance display in real-time\n  * Trigger UI animations for balance changes\n  * Log balance history for analytics\n\n* * *\n\n## cu (Channel Update)â€‹\n\n### Methodâ€‹\n\n`cu`\n\n### When Sentâ€‹\n\nWhen a channel's state changes (opened, resized, challenged, closed).\n\n### Structureâ€‹\n\nThe notification contains the complete updated `Channel` object. See Channel Structure in the `get_channels` section for the full field list.\n\n**Use Cases** :\n\n  * Update channel status in UI\n  * Alert user when channel becomes active\n  * Monitor for unexpected channel closures\n\n* * *\n\n## tr (Transfer)â€‹\n\n### Methodâ€‹\n\n`tr`\n\n### When Sentâ€‹\n\nWhen a transfer affects the user's account (both incoming and outgoing transfers).\n\n### Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`transactions`| array<LedgerTransaction>| Array of transaction objects for the transfer| See structure below  \n  \nThe `LedgerTransaction` structure is identical to the one returned by `get_ledger_transactions`. See LedgerTransaction Structure for the full field list.\n\n**Use Cases** :\n\n  * Display incoming/outgoing payment notifications\n  * Play sound/show toast for transfers\n  * Update transaction history in real-time\n\nReal-Time Payments\n\nCombine `tr` notifications with `bu` (balance update) to provide immediate feedback when users send or receive funds.\n\n* * *\n\n## asu (App Session Update)â€‹\n\n### Methodâ€‹\n\n`asu`\n\n### When Sentâ€‹\n\nWhen an app session state changes (new state submitted, session closed, deposits/withdrawals).\n\n### Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`app_session`| AppSession| Complete app session object| See `get_app_sessions` for structure  \n`participant_allocations`| array<AppAllocation>| Current allocations for each participant| See structure below  \n  \n#### AppAllocation Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`participant`| string| Participant wallet address| `\"0x742d35Cc...\"`  \n`asset`| string| Asset symbol| `\"usdc\"`  \n`amount`| string| Allocated amount| `\"50.0\"`  \n  \n**Use Cases** :\n\n  * Update game UI when opponent makes a move\n  * Refresh session state in real-time\n  * Alert when session is closed\n  * Sync multi-participant applications\n\n* * *\n\n## Implementation Notesâ€‹\n\n**Connection Management** :\n\n  * Maintain persistent connection for notifications\n  * Implement automatic reconnection on disconnect\n  * Re-fetch current state after reconnection\n\n**Notification Handling** :\n\n  * All notifications are asynchronous\n  * No response required from client\n  * Multiple notifications may arrive rapidly (batch if needed)\n\n**Best Practices** :\n\n  * Use query methods for initial state retrieval\n  * Use notifications for ongoing monitoring\n  * Don't rely solely on notifications (could be missed during disconnect)\n  * Implement periodic state refresh as backup\n\n**Pagination** :\n\n  * For methods with pagination, use reasonable `limit` values\n\n* * *\n\n## Next Stepsâ€‹\n\nExplore other protocol features:\n\n  * **[App Sessions](/docs/protocol/off-chain/app-sessions)** \\- Create and manage multi-party applications\n  * **[Transfers](/docs/protocol/off-chain/transfers)** \\- Send funds between users\n  * **[Channel Methods](/docs/protocol/off-chain/channel-methods)** \\- Manage payment channels\n\nFor protocol fundamentals:\n\n  * **[Authentication](/docs/protocol/off-chain/authentication)** \\- Manage session keys\n  * **[Message Format](/docs/protocol/off-chain/message-format)** \\- Understand request/response structure\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/off-chain/queries.mdx)\n\n[PreviousApp Session Methods](/docs/protocol/off-chain/app-sessions)[NextCross-Layer Communication Flows](/docs/protocol/communication-flows)\n\n  * Overview\n  * Query Methods Summary\n  * get_config\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_assets\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_app_definition\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_channels\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_app_sessions\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_ledger_balances\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_ledger_entries\n    * Name\n    * Usage\n    * Request\n    * Response\n    * Double-Entry Bookkeeping\n  * get_ledger_transactions\n    * Name\n    * Usage\n    * Request\n    * Response\n    * Transaction Types\n  * get_rpc_history\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_user_tag\n    * Name\n    * Usage\n    * Request\n    * Response\n    * Usage in Transfers\n  * get_session_keys\n    * Name\n    * Usage\n    * Authentication\n    * Request\n    * Response\n    * Spending Tracking\n  * ping\n    * Name\n    * Usage\n    * Authentication\n    * Request\n    * Response\n    * Use Cases\n  * Notifications (Server-to-Client)\n    * Notification Types\n  * bu (Balance Update)\n    * Method\n    * When Sent\n    * Structure\n  * cu (Channel Update)\n    * Method\n    * When Sent\n    * Structure\n  * tr (Transfer)\n    * Method\n    * When Sent\n    * Structure\n  * asu (App Session Update)\n    * Method\n    * When Sent\n    * Structure\n  * Implementation Notes\n  * Next Steps",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/off-chain/transfers",
    "text": "* [](/)\n  * Off-Chain RPC Protocol\n  * Transfer Method\n\nOn this page\n\n# Transfer Method\n\nTransfer method enable instant, off-chain fund movement between users.\n\n* * *\n\n## Overviewâ€‹\n\nThe transfer system allows users to send funds to each other instantly using their unified balance, without any on-chain transactions. Transfers are backed by the security of underlying payment channels and use double-entry bookkeeping for accounting accuracy.\n\n### Why Use Transfer?â€‹\n\n**Instant Settlement** : Transfers complete immediately with instant finality.\n\n**No Blockchain Fees** : No blockchain transactions means no gas costs for both sender and recipient.\n\n**Cross-Chain Unified** : Send from your unified balance across multiple chains.\n\n**Auditable** : Complete transaction history with double-entry ledger tracking.\n\nInstant Off-Chain Payments\n\nTransfers provide the speed and convenience of traditional payment networks while maintaining the security guarantees of blockchain-backed channels.\n\n* * *\n\n## transferâ€‹\n\n### Nameâ€‹\n\n`transfer`\n\n### Usageâ€‹\n\nTransfer funds from the authenticated user's unified balance to another user's unified balance within the Yellow Network. This is a purely off-chain operation, which results in instant settlement. The transfer updates internal ledger entries using double-entry bookkeeping principles and creates a transaction record for both parties. The security guarantee comes from the underlying on-chain channels that back the unified balance.\n\n### When to Useâ€‹\n\nWhen sending funds to another Yellow Network user. Common use cases include peer-to-peer payments, merchant payments, tipping.\n\n### Prerequisitesâ€‹\n\n  * Sender must be [authenticated](/docs/protocol/off-chain/authentication)\n  * Sender must have sufficient available balance in unified account\n  * Recipient must be identified by valid wallet address or user tag\n\nRecipient Requirements\n\nThe recipient does not need to have an existing balance or account on the clearnode. Transfers can be sent to any valid wallet address, and the recipient's account will be created automatically on the first login if it doesn't exist.\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Format| Example| Notes  \n---|---|---|---|---|---|---  \n`destination`| string (wallet address)| Yes (if `destination_user_tag` not provided)| Recipient's wallet address| 0x-prefixed hex string (20 bytes)| `\"0x8B3192f2F7b1b34f2e4e7B8C9D1E0F2A3B4C5D6E\"`| -  \n`destination_user_tag`| string| Yes (if destination not provided)| Recipient's randomly generated user identifier| Alphanumeric string| `\"UX123D\"`| Alternative to address; internal feature, may change  \n`allocations`| TransferAllocation[]| Yes (minimum: 1)| Assets and amounts to transfer| Array of allocation objects| `[{\"asset\": \"usdc\", \"amount\": \"50.0\"}]`| See structure below  \n  \n#### TransferAllocation Structureâ€‹\n\nEach allocation in the `allocations` array specifies an asset and amount to transfer:\n\nField| Type| Required| Description| Format| Example  \n---|---|---|---|---|---  \n`asset`| string| Yes| Asset symbol identifier| Lowercase string| `\"usdc\"`, `\"eth\"`, `\"weth\"`, `\"btc\"`  \n`amount`| string| Yes| Amount to transfer in human-readable format| Decimal string| `\"50.0\"`, `\"0.01\"`  \n  \n**Notes** :\n\n  * Asset symbols must be lowercase\n  * Use `get_assets` method to see all supported assets\n  * Amounts are in human-readable format (e.g., \"50.0\" for 50 USDC)\n  * Clearnode handles conversion to smallest unit internally\n  * Multiple assets can be transferred in a single operation\n\n**Example** :\n    \n    \n    {  \n      \"allocations\": [  \n        {  \n          \"asset\": \"usdc\",  \n          \"amount\": \"50.0\"  \n        },  \n        {  \n          \"asset\": \"eth\",  \n          \"amount\": \"0.01\"  \n        }  \n      ]  \n    }  \n    \n\n### Responseâ€‹\n\nThe response contains an array of transactions, with one transaction for each asset being transferred:\n\nParameter| Type| Description| Example| Notes  \n---|---|---|---|---  \n`transactions`| LedgerTransaction[]| Array of transaction objects for each asset| See below| One transaction per asset transferred  \n  \n**LedgerTransaction Structure** (per transaction):\n\nField| Type| Description| Example  \n---|---|---|---  \n`id`| number| Numeric transaction identifier| `1`  \n`tx_type`| string| Transaction type| `\"transfer\"`  \n`from_account`| string| Sender account identifier (wallet/app session/channel)| `\"0x1234567890abcdef...\"`  \n`from_account_tag`| string| Sender's user tag (if exists)| `\"NQKO7C\"`  \n`to_account`| string| Recipient account identifier| `\"0x9876543210abcdef...\"`  \n`to_account_tag`| string| Recipient's user tag (if exists)| `\"UX123D\"`  \n`asset`| string| Asset symbol that was transferred| `\"usdc\"`  \n`amount`| string| Amount transferred for this asset (decimal string)| `\"50.0\"`  \n`created_at`| string| ISO 8601 timestamp| `\"2023-05-01T12:00:00Z\"`  \n  \n**Example Response** :\n    \n    \n    {  \n      \"transactions\": [  \n        {  \n          \"id\": 1,  \n          \"tx_type\": \"transfer\",  \n          \"from_account\": \"0x1234567890abcdef...\",  \n          \"from_account_tag\": \"NQKO7C\",  \n          \"to_account\": \"0x9876543210abcdef...\",  \n          \"to_account_tag\": \"UX123D\",  \n          \"asset\": \"usdc\",  \n          \"amount\": \"50.0\",  \n          \"created_at\": \"2023-05-01T12:00:00Z\"  \n        },  \n        {  \n          \"id\": 2,  \n          \"tx_type\": \"transfer\",  \n          \"from_account\": \"0x1234567890abcdef...\",  \n          \"from_account_tag\": \"NQKO7C\",  \n          \"to_account\": \"0x9876543210abcdef...\",  \n          \"to_account_tag\": \"UX123D\",  \n          \"asset\": \"eth\",  \n          \"amount\": \"0.1\",  \n          \"created_at\": \"2023-05-01T12:00:00Z\"  \n        }  \n      ]  \n    }  \n    \n\n* * *\n\n## Off-Chain Processingâ€‹\n\nWhen a transfer is executed, the clearnode performs the following operations:\n\nClient BServiceClient AClient B (Recipient)ClearnodeClient A (Sender)Client B (Recipient)ClearnodeClient A (Sender)1\\. Send Transfer Request2\\. Validate3\\. Update Ledger4\\. Send Responses & Notifications5\\. Balance Updatedtransfer({ destination, allocations })Verify authenticationCheck available balanceValidate allocationsCreate debit entry (Alice -50 USDC)Create credit entry (Bob +50 USDC)Record transactionBalance +50 USDCtr (transfer) notificationbu (balance update) notificationtr (transfer) notificationbu (balance update) notificationresponse\n\n### Step-by-Step Processâ€‹\n\n#### 1\\. Validates Requestâ€‹\n\nThe clearnode performs comprehensive validation:\n\n  * Verifies authentication and signature\n  * Checks sender has sufficient available balance in unified account\n  * Validates allocations format and asset support\n\n#### 2\\. Updates Ledger (Double-Entry Bookkeeping)â€‹\n\nEvery transfer creates two ledger entries - one for the sender and one for the recipient. The ledger uses double-entry bookkeeping principles where each entry has both `credit` and `debit` fields, with amounts always recorded as positive values.\n\nDouble-Entry Bookkeeping\n\nThe double-entry system ensures that the total of all debits always equals the total of all credits, providing mathematical proof of accounting accuracy. Every transfer is recorded twice - once as a debit to the sender's account and once as a credit to the recipient's account.\n\n#### 3\\. Records Transactionâ€‹\n\nA user-facing transaction record is created for each asset being transferred, containing information about the sender, recipient, asset, and amount.\n\n#### 4\\. Sends Notificationsâ€‹\n\n  * **Both parties** receive `tr` (transfer) notification with transaction details\n  * **Both parties** receive `bu` (balance update) notification with updated balances\n\n#### 5\\. Responseâ€‹\n\n  * **Sender** receives response with transaction details\n\n* * *\n\n## Unified Balance Mechanicsâ€‹\n\nThe unified balance aggregates funds from all chains.\n\n### Example: Multi-Chain Aggregationâ€‹\n    \n    \n    User deposited:  \n      $10 USDC on Ethereum  \n      $5 USDC on Polygon  \n      $3 USDC on Base  \n        \n    Unified Balance: $18 USDC total  \n      \n    User can transfer: Any amount up to $18 USDC  \n    \n\n### Account Typesâ€‹\n\nThe ledger system maintains three types of accounts:\n\n  1. **Unified Account** : Main account identified by wallet address. This is where user funds are stored and can be transferred or withdrawn.\n\n  2. **App Session Account** : Identified by app session ID. Participant wallets are beneficiaries of this account. Funds in app sessions are locked for the duration of the session.\n\n  3. **Channel Escrow Account** : Temporary account that locks funds when user requests blockchain operations like resize. Funds remain in this account until the transaction is confirmed on-chain.\n\n\n* * *\n\n## Transaction History Query Methodsâ€‹\n\nUsers can query their transfer history using two methods for different levels of detail.\n\n* * *\n\n### get_ledger_transactionsâ€‹\n\nRetrieves user-facing transaction log with sender, recipient, amount, and type. This endpoint provides a view of transactions where the specified account appears as either the sender or receiver.\n\nPublic Endpoint\n\nThis is a public endpoint - authentication is not required.\n\n#### Requestâ€‹\n\nParameter| Type| Required| Description| Format| Example| Notes  \n---|---|---|---|---|---|---  \n`account_id`| string| No| Filter by account ID (wallet, app session, or channel)| Hex string or ID| `\"0x1234567890abcdef...\"`| Returns transactions for this account  \n`asset`| string| No| Filter by asset symbol| Lowercase string| `\"usdc\"`| Returns transactions for this asset only  \n`tx_type`| string| No| Filter by transaction type| `transfer`, `deposit`, `withdrawal`, `app_deposit`, `app_withdrawal`, `escrow_lock`, `escrow_unlock`| `\"transfer\"`| Returns only this type of transaction  \n`offset`| number| No| Pagination offset| `0`| `42`| Defaults to `0`  \n`limit`| number| No| Number of transactions to return| `10` (max 100)| `10`| Defaults to 10 if omitted  \n`sort`| string| No| Sort order by created_at| `\"asc\"` or `\"desc\"`| `\"desc\"`| Default: `\"desc\"`  \n  \n#### Responseâ€‹\n\nParameter| Type| Description  \n---|---|---  \n`ledger_transactions`| LedgerTransaction[]| Array of transaction objects  \n  \n**LedgerTransaction Structure** :\n\nField| Type| Description  \n---|---|---  \n`id`| number| Unique transaction reference  \n`tx_type`| string| Transaction type  \n`from_account`| string| Sender account identifier  \n`from_account_tag`| string| Sender's user tag (empty if none)  \n`to_account`| string| Recipient account identifier  \n`to_account_tag`| string| Recipient's user tag (empty if none)  \n`asset`| string| Asset symbol  \n`amount`| string| Transaction amount (decimal string)  \n`created_at`| string| ISO 8601 timestamp  \n  \n* * *\n\n### get_ledger_entriesâ€‹\n\nRetrieves detailed accounting entries showing all debits and credits. This endpoint provides double-entry bookkeeping records for detailed reconciliation and audit trails.\n\nPublic Endpoint\n\nThis is a public endpoint - authentication is not required.\n\n#### Requestâ€‹\n\nParameter| Type| Required| Description| Format| Example| Notes  \n---|---|---|---|---|---|---  \n`account_id`| string| No| Filter by account ID (wallet/app session/channel)| Hex string or ID| `\"0x1234567890abcdef...\"`| Returns entries for this account  \n`wallet`| string| No| Filter by participant wallet| 0x-prefixed hex string (20 bytes)| `\"0x1234567890abcdef...\"`| Returns entries for this participant  \n`asset`| string| No| Filter by asset symbol| Lowercase string| `\"usdc\"`| Returns entries for this asset only  \n`offset`| number| No| Pagination offset| `0`| `42`| Defaults to `0`  \n`limit`| number| No| Number of entries to return| `10` (max 100)| `10`| Defaults to 10 if omitted  \n`sort`| string| No| Sort order by created_at| `\"asc\"` or `\"desc\"`| `\"desc\"`| Default: `\"desc\"`  \n  \n#### Responseâ€‹\n\nParameter| Type| Description  \n---|---|---  \n`ledger_entries`| LedgerEntry[]| Array of ledger entry objects  \n  \n**LedgerEntry Structure** :\n\nField| Type| Description  \n---|---|---  \n`id`| number| Unique entry ID  \n`account_id`| string| Account identifier  \n`account_type`| number| Account type (`1000`=asset, `2000`=liability, etc.)  \n`asset`| string| Asset symbol  \n`participant`| string| Participant wallet address  \n`credit`| string| Credit amount (positive value or \"0.0\")  \n`debit`| string| Debit amount (positive value or \"0.0\")  \n`created_at`| string| ISO 8601 timestamp  \n  \n* * *\n\n## Implementation Notesâ€‹\n\n**Performance** :\n\n  * Transfers are instant (< 1 second) and atomic\n  * No blockchain transaction required\n  * No blockchain fees\n\n**Features** :\n\n  * Unified balance is updated immediately\n  * Transfer can include multiple assets in one operation\n  * Transaction IDs can be used to track and query transfer status via `get_ledger_transactions`\n\n**Audit Trail** :\n\n  * Clearnode maintains complete audit trail of all transfers\n  * Double-entry bookkeeping ensures mathematical accuracy\n  * All records queryable via `get_ledger_*` methods\n\n* * *\n\n## Next Stepsâ€‹\n\nExplore other off-chain operations:\n\n  * **[App Sessions](/docs/protocol/off-chain/app-sessions)** \\- Create multi-party application channels\n  * **[Queries& Notifications](/docs/protocol/off-chain/queries)** \\- Check balances, transactions, and receive updates\n  * **[Channel Methods](/docs/protocol/off-chain/channel-methods)** \\- Manage payment channels\n\nFor protocol fundamentals:\n\n  * **[Authentication](/docs/protocol/off-chain/authentication)** \\- Understand authorization and session management\n  * **[Message Format](/docs/protocol/off-chain/message-format)** \\- Learn request/response structure\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/off-chain/transfers.mdx)\n\n[PreviousChannel Management Methods](/docs/protocol/off-chain/channel-methods)[NextApp Session Methods](/docs/protocol/off-chain/app-sessions)\n\n  * Overview\n    * Why Use Transfer?\n  * transfer\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n  * Off-Chain Processing\n    * Step-by-Step Process\n  * Unified Balance Mechanics\n    * Example: Multi-Chain Aggregation\n    * Account Types\n  * Transaction History Query Methods\n    * get_ledger_transactions\n    * get_ledger_entries\n  * Implementation Notes\n  * Next Steps",
    "metadata": {
      "title": "Transfer Method | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/transfers",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/on-chain/channel-lifecycle",
    "text": "* [](/)\n  * On-Chain Protocol\n  * Channel Lifecycle\n\nOn this page\n\n# Channel Lifecycle\n\n## State Transitions Overviewâ€‹\n\nThe lifecycle of a channel moves through well-defined states depending on how participants interact with the custody contract.\n\ncreate()\n\ncreate() (sigs from all participants)\n\njoin() (all participants)\n\ncheckpoint()\n\nchallenge()\n\nclose() (cooperative)\n\ncheckpoint() (newer state)\n\nchallenge period expires\n\nVOID\n\nINITIAL\n\nACTIVE\n\nDISPUTE\n\nFINAL\n\nOperational state  \nOff-chain updates occur here\n\nChallenge period active  \nParties can submit newer states\n\nUse the sections below for details on each phase.\n\n## Creation Phaseâ€‹\n\n**Purpose** : Initiate a new channel with specified participants and initial funding.\n\n**Process** :\n\n  1. The Creator:\n     * Constructs a Channel configuration with participants, adjudicator, challenge period, and nonce\n     * Prepares an initial State with application-specific app data\n     * Defines expected token deposits for all participants in `state.allocations`\n     * Signs the computed packedState of this initial state\n     * Includes Creator's signature in `state.sigs` at position 0\n     * Calls either `create(...)` or `depositAndCreate(...)` function with the channel configuration and initial signed state\n\nImplicit Join (Immediate Activation)\n\nIf the Creator obtains the second participant's signature on the initial state **before** calling `create()`, they can supply both signatures in `state.sigs` (positions 0 and 1). When the contract detects `sigs.length == 2`:\n\n  * It verifies both signatures\n  * Locks funds from both participants\n  * Transitions directly to `ACTIVE` status (skipping `INITIAL`)\n  * Emits both `Joined` and `Opened` events\n\nThis \"implicit join\" is the **recommended approach** for faster channel activation and reduced gas costs (single transaction instead of two).\n\n  2. The contract:\n     * Verifies the Creator's signature on the funding packedState\n     * Verifies Creator has sufficient balance to fund their allocation\n     * Locks the Creator's funds according to the allocation\n     * Sets the channel status to `INITIAL`\n     * Emits a `Created` event with channelId, channel configuration, and expected deposits\n\nContractCreatorContractCreatorStatus = VOIDStatus = INITIALConstruct Channel configCreate initial StateSign packedStatecreate(channel, state)Verify signatureLock Creator fundsSet status to INITIALEmit Created event\n\nParticipant versus Caller address\n\nThe first participant address is usually different from the caller (EOA or contract), thus enabling channel operation delegation. This can be fruitful as users can fund channels for other ones.\n\n## Joining Phaseâ€‹\n\nTwo Channel Opening Flows\n\nThere are two ways to open a channel:\n\n  1. **Modern/Recommended** : Provide ALL signatures in `create()` â†’ channel immediately ACTIVE (see [Architecture](/docs/protocol/architecture#channel-opening))\n  2. **Legacy/Manual** : Provide only creator's signature in `create()` â†’ status INITIAL â†’ separate `join()` calls â†’ ACTIVE\n\nThis section documents flow #2. Most implementations use flow #1.\n\n**Purpose** : Allow other participants to join and fund the channel (when using separate join flow).\n\n**Process** :\n\n  1. Each non-Creator participant:\n\n     * Verifies the channelId and expected allocations\n     * Signs the same funding packedState\n     * Calls the `join` function with channelId, their participant index, and signature\n  2. The contract:\n\n     * Verifies the participant's signature against the funding packedState\n     * Confirms the signer matches the expected participant at the given index\n     * Locks the participant's funds according to the allocation\n     * Tracks the actual deposit in the channel metadata\n     * Emits a `Joined` event with channelId and participant index\n  3. When all participants have joined, the contract:\n\n     * Verifies that all expected deposits are fulfilled\n     * Sets the channel status to `ACTIVE`\n     * Emits an `Opened` event with channelId\n\nSystemContractParticipantSystemContractParticipantStatus INITIALStatus ACTIVEalt[All participants joined]Sign funding packedStatejoin(channelId, index, signature)Verify signatureLock participant fundsEmit Joined eventSet status to ACTIVEEmit Opened event\n\nChannel Activation\n\nThe channel becomes operational only when ALL participants have successfully joined and funded their allocations.\n\n## Active Phaseâ€‹\n\n**Purpose** : Enable off-chain state updates while channel is operational.\n\n### Off-Chain Updatesâ€‹\n\nParticipants:\n\n  * Exchange and sign state updates off-chain via the Nitro RPC protocol\n  * Maintain a record of the latest valid state\n  * Use application-specific data in the `state.data` field\n\nEach new state:\n\n  * May update allocations when assets are transferred (though allocations can remain unchanged between states, e.g., game moves without fund transfers)\n  * MUST be signed by the necessary participants according to adjudicator rules\n  * MUST comply with the validation rules of the channel's adjudicator\n\nThe on-chain contract remains unchanged during the active phase unless participants choose to checkpoint a state.\n\nOff-Chain Efficiency\n\nDuring the active phase, state updates occur entirely off-chain with zero gas costs and sub-second latency.\n\n## Checkpointingâ€‹\n\n**Purpose** : Record a state on-chain without entering dispute mode.\n\n**Process** :\n\n  1. Any participant:\n\n     * Calls the `checkpoint` function with a valid state and required proofs\n  2. The contract:\n\n     * Verifies the submitted state via the adjudicator\n     * If valid and more recent than the previously checkpointed state, stores it\n     * Emits a `Checkpointed` event with channelId\n\ncheckpoint\n\nValid\n\nActive Channel  \nStatus: ACTIVE\n\nVerify State\n\nStore State\n\nEmit Event\n\nRemain Active  \nStatus: ACTIVE\n\nOptional Operation\n\nCheckpointing is optional but recommended for long-lived channels or after significant value transfers.\n\n## Closure - Cooperativeâ€‹\n\n**Purpose** : Close channel to distribute locked funds, after all participants have agreed on the final state.\n\n**Process** :\n\n  1. Any participant:\n\n     * Prepare a final State with `intent` equal to `FINALIZE`.\n     * Collects signatures from all participants on this final state\n     * Calls the `close` function with channelId, final state, and any required proofs\n  2. The contract:\n\n     * Verifies all participant signatures on the closing packedState\n     * Verifies the state has `intent` equal to `FINALIZE`.\n     * Distributes funds according to the final state's allocations\n     * Sets the channel status to `FINAL`\n     * Deletes the channel metadata\n     * Emits a `Closed` event\n\nContractUserContractUserStatus = ACTIVEStatus = FINALCreate final State (intent=FINALIZE)Collect all signaturesclose(channelId, state, proofs)Verify all signaturesVerify intent = FINALIZEDistribute fundsSet status to FINALDelete metadataEmit Closed event\n\nPreferred Method\n\n**This is the preferred closure method as it is fast and gas-efficient.** It requires only one transaction and completes immediately without a challenge period.\n\n## Closure - Challenge-Responseâ€‹\n\n**Purpose** : Handle closure when participants disagree or one party is unresponsive.\n\n### Challenge Processâ€‹\n\n  1. To initiate a challenge, a participant:\n     * Calls the `challenge` function with their latest valid state and required proofs\n\nLatest State Location\n\nThe participant's latest state may only exist off-chain and not be known on-chain yet. The challenge process brings this off-chain state on-chain for validation.\n\n  2. The contract:\n     * Verifies the submitted state via the adjudicator\n     * If valid, stores the state and starts the challenge period\n     * Sets a challenge expiration timestamp (current time + challenge duration)\n     * Sets the channel status to `DISPUTE`\n     * Emits a `Challenged` event with channelId and expiration time\n\nTimerContractUserTimerContractUserStatus = ACTIVEStatus = DISPUTEchallenge(channelId, state, proofs)Verify stateStore stateSet status to DISPUTEStart challenge periodEmit Challenged event\n\n### Resolving Challenge with Checkpointâ€‹\n\nDuring the challenge period, any participant:\n\n  * Submits a more recent valid state by calling `checkpoint()`\n  * If the new state is valid and more recent (as determined by the adjudicator or IComparable interface), the contract updates the stored state, resets the challenge period, and returns the channel to `ACTIVE` status\n\n### Challenge Period Elapseâ€‹\n\nAfter the challenge period expires, any participant:\n\n  * Call `close` with an empty candidate and proof to distribute funds according to the last valid challenged state\n\nThe contract:\n\n  * Verifies the challenge period has elapsed\n  * Distributes funds according to the challenged state's allocations\n  * Sets channel status to `FINAL`\n  * Deletes the channel metadata\n  * Emits a `Closed` event\n\nKey Principle\n\nThe challenge mechanism gives parties time to prove they have a newer state. If no one responds with a newer state, the challenged state is assumed correct.\n\n**Complete Challenge-Response Flow** :\n\nchallenge()\n\ncheckpoint() with newer state\n\nclose() after timeout\n\nActive\n\nDispute\n\nFinal\n\nChallenge period active  \nParties can submit  \nnewer states\n\n## Resize Protocolâ€‹\n\n**Purpose** : Adjust funds locked in the channel by locking or unlocking funds **without closing the channel**.\n\n**Process** :\n\n  1. Any participant:\n     * Calls the `resize` function with:\n       * The channelId (remains unchanged)\n       * A candidate State with:\n         * `intent` = `StateIntent.RESIZE`\n         * `version` = precedingState.version + 1\n         * `data` = ABI-encoded `int256[]` containing delta amounts (positive for deposit, negative for withdrawal) respectively for participants\n         * `allocations` = Allocation[] after resize (absolute amounts)\n         * Signatures from **ALL participants** (consensus required)\n       * An array of proof states containing the previous state (`version-1`) first and its proof later in the array\n\nDeposit Requirement\n\nThe participant depositing must have at least the corresponding amount in their Custody ledger account (available balance) to lock additional funds to the channel.\n\n  2. The contract:\n\n     * Verifies the channel is in ACTIVE status\n     * Verifies all participants have signed the resize state\n     * Decodes delta amounts from `candidate.data`\n     * Validates adjudicator approves the preceding state\n     * For positive deltas: Locks additional funds from custody account\n     * For negative deltas: Unlocks funds back to custody account\n     * Updates expected deposits to match new allocations\n     * Emits `Resized(channelId, deltaAllocations)` event\n  3. The channel:\n\n     * **channelId remains UNCHANGED** (same channel persists)\n     * Status remains **ACTIVE** throughout\n     * Version increments by 1\n     * No new channel is created\n\nContractUserContractUserStatus = ACTIVESame channelIdState version + 1Intent = RESIZEStatus = ACTIVESame channelIdChannel still ACTIVEresize(channelId, resizeState, proofs)Verify signatures (all participants)Decode delta amounts from state.dataLock funds (positive deltas)Unlock funds (negative deltas)Update expected depositsResized(channelId, deltas)\n\n**Use Cases** :\n\n  * Increasing funds locked in the channel (positive delta: adding funds)\n  * Decreasing funds locked in the channel (negative delta: removing funds)\n  * Adjusting fund distribution while maintaining channel continuity\n\nIn-Place Update\n\nThe resize operation updates the channel **in place**. The channelId stays the same, and the channel remains ACTIVE throughout. This differs from closing and reopening, which would create a new channel.\n\nImplicit Transfer with Resize\n\nIt is possible to combine a transfer (change of allocations among participants) with a resize operation. For example:\n\n  * Previous state allocations: `[5, 10]`\n  * Desired transfer: 2 tokens from second to first participant â†’ `[7, 8]`\n  * Additional changes: first participant withdraws all 7, second participant deposits 6\n  * Delta amounts: `[-7, 6]`\n  * Resize state allocations: `[0, 14]`\n\n**Rule** : `sum(allocations_resize_state) = sum(allocations_prev_state) + sum(delta_amounts)`  \nFor this example: `14 = 15 + (-1)` âœ“\n\n## State Transition Summaryâ€‹\n\nThe complete channel lifecycle state machine:\n\nInitial\n\ncreate()\n\ncreate() with all sigs\n\njoin() all\n\nresize()\n\nchallenge()\n\nclose() cooperative\n\ncheckpoint() newer\n\nclose() after timeout\n\nDeleted\n\nVOID\n\nINITIAL\n\nACTIVE\n\nDISPUTE\n\nFINAL\n\nChannel does not exist\n\nAwaiting participants\n\nOperational  \nOff-chain updates\n\nChallenge active  \nResponse period\n\nFunds distributed  \nReady for deletion\n\n**Valid Transitions** :\n\nFrom| To| Trigger| Requirements  \n---|---|---|---  \nVOID| INITIAL| `create()`| Creator signature, sufficient balance, INITIALIZE intent  \nINITIAL| ACTIVE| `join()`| All participants joined and funded  \nACTIVE| ACTIVE| `checkpoint()`| Valid newer state  \nACTIVE| ACTIVE| `resize()`| All signatures, valid deltas, sufficient balance  \nACTIVE| DISPUTE| `challenge()`| Valid state newer than latest known on-chain  \nACTIVE| FINAL| `close()`| All signatures, FINALIZE intent  \nDISPUTE| ACTIVE| `checkpoint()`| Valid newer state  \nDISPUTE| FINAL| `close()`| Challenge period expired  \nFINAL| VOID| Automatic| Metadata deleted  \n  \nChannel Deletion\n\nWhen a channel reaches FINAL status, the channel metadata is deleted from the chain and funds are distributed according to the final state allocations.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/on-chain/channel-lifecycle.mdx)\n\n[PreviousData Structures](/docs/protocol/on-chain/data-structures)[NextSignature Formats](/docs/protocol/on-chain/signature-formats)\n\n  * State Transitions Overview\n  * Creation Phase\n  * Joining Phase\n  * Active Phase\n    * Off-Chain Updates\n  * Checkpointing\n  * Closure - Cooperative\n  * Closure - Challenge-Response\n    * Challenge Process\n    * Resolving Challenge with Checkpoint\n    * Challenge Period Elapse\n  * Resize Protocol\n  * State Transition Summary",
    "metadata": {
      "title": "Channel Lifecycle | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/channel-lifecycle",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/on-chain/data-structures",
    "text": "* [](/)\n  * On-Chain Protocol\n  * Data Structures\n\nOn this page\n\n# Data Structures\n\n## Channelâ€‹\n\nRepresents the configuration of a state channel.\n    \n    \n    struct Channel {  \n        address[] participants;  // List of participants in the channel  \n        address adjudicator;     // Contract that validates state transitions  \n        uint64 challenge;        // Duration in seconds for dispute resolution  \n        uint64 nonce;           // Unique identifier for the channel  \n    }  \n    \n\n**Fields** :\n\n  * `participants`: An ordered array of participant addresses. Index 0 is typically the Creator, index 1 is the clearnode.\n  * `adjudicator`: Address of the adjudicator contract responsible for validating state transitions.\n  * `challenge`: Challenge period duration in seconds. Determines a time window when a challenge can be resolved by a counterparty. Otherwise, a channel is considered closed and funds can be withdrawn.\n  * `nonce`: A unique number that, combined with other fields, creates a unique channel identifier.\n\nParticipant versus Caller Address\n\nThe first participant address is usually different from the caller (EOA or contract), thus enabling channel operation delegation. This can be fruitful as users can fund channels for other ones.\n\n## Stateâ€‹\n\nRepresents a snapshot of channel state at a point in time.\n    \n    \n    struct State {  \n        StateIntent intent;       // Intent of the state (INITIALIZE, OPERATE, RESIZE, FINALIZE)  \n        uint256 version;          // State version incremental number to compare most recent  \n        bytes data;               // Application-specific data  \n        Allocation[] allocations; // Asset allocation for each participant  \n        bytes[] sigs;             // Participant signatures authorizing the packed state payload  \n    }  \n    \n\n**Fields** :\n\n  * `intent`: The intent of this state, indicating its purpose (see StateIntent enum).\n  * `version`: Incremental version number used to compare and validate state freshness. Higher versions supersede lower versions.\n  * `data`: Application-specific data which adjudicators can operate on. For a `resize(...)` state must contain `allocationDeltas`. For more information, please check the [resize operation docs](/docs/protocol/on-chain/channel-lifecycle#resize-protocol).\n  * `allocations`: Array of allocations defining how funds are distributed.\n  * `sigs`: Array of participant signatures over the canonical packed state payload. Order corresponds to the Channel's participants array.\n\n## Allocationâ€‹\n\nSpecifies how a particular amount of a token should be allocated.\n    \n    \n    struct Allocation {  \n        address destination;  // Recipient of funds  \n        address token;        // ERC-20 token address  \n        uint256 amount;       // Token amount in smallest unit  \n    }  \n    \n\n**Fields** :\n\n  * `destination`: Address that will receive the funds when channel closes.\n  * `token`: Contract address of the ERC-20 token (or zero address for native currency).\n  * `amount`: Amount in the token's smallest unit (wei for ETH, considering decimals for ERC-20).\n\n## Signaturesâ€‹\n\nSignatures in Nitrolite are stored as raw `bytes` so the protocol can validate multiple scheme formats.\n    \n    \n    struct Signature {  \n        uint8 v;      // Recovery identifier  \n        bytes32 r;    // First 32 bytes of signature  \n        bytes32 s;    // Second 32 bytes of signature  \n    }  \n    \n\nAt a minimum Nitrolite currently recognizes the following signature families (see the [Signature Formats](/docs/protocol/on-chain/signature-formats) reference for the full specification):\n\n  * **Raw/Pre-EIP-191 ECDSA** â€“ Signs `keccak256(packedState)` without any prefix.\n  * **EIP-191 (version`0x45`)** â€“ Signs a structured message that prefixes the packed state with the Ethereum signed message header and length.\n  * **EIP-712 Typed Data** â€“ Signs `keccak256(abi.encode(domainSeparator, hashStruct(state)))`.\n  * **EIP-1271 Smart-Contract Signatures** â€“ Arbitrary bytes validated via `isValidSignature` on the signer contract.\n  * **EIP-6492 Counterfactual Signatures** â€“ Wraps deployment data to prove a not-yet-deployed ERC-4337 wallet authorized the state.\n\nRefer to the dedicated page for verification order, payload layouts, and implementation guidance.\n\n## Amountâ€‹\n\nRepresents a quantity of a specific token.\n    \n    \n    struct Amount {  \n        address token;    // ERC-20 token address  \n        uint256 amount;   // Token amount  \n    }  \n    \n\n## Channel Statusâ€‹\n\nEnum representing the lifecycle stage of a channel.\n    \n    \n    enum Status {  \n        VOID,      // Channel does not exist  \n        INITIAL,   // Creation in progress, awaiting all participants  \n        ACTIVE,    // Fully funded and operational  \n        DISPUTE,   // Challenge period active  \n        FINAL      // Ready to be closed and deleted  \n    }  \n    \n\n## Protocol Constantsâ€‹\n\n### Participant Indicesâ€‹\n    \n    \n    constant uint256 CLIENT_IDX = 0;   // Client/Creator participant index  \n    constant uint256 SERVER_IDX = 1;   // Server/Clearnode participant index  \n    constant uint256 PART_NUM = 2;     // Number of participants (always 2)  \n    \n\n### Challenge Periodâ€‹\n    \n    \n    uint256 public constant MIN_CHALLENGE_PERIOD = 1 hours;  \n    \n\nThe minimum challenge period enforced by the Custody Contract. Channel configurations must specify a challenge period of at least 1 hour.\n\n### EIP-712 Type Hashesâ€‹\n\nThe protocol uses EIP-712 structured data signing with the following domain parameters:\n    \n    \n    // EIP-712 Domain  \n    name: \"Nitrolite:Custody\"  \n    version: \"0.3.0\"  \n    \n\nType hashes for state validation:\n    \n    \n    // State hash computation for signatures  \n    bytes32 constant STATE_TYPEHASH = keccak256(  \n        \"AllowStateHash(bytes32 channelId,uint8 intent,uint256 version,bytes data,Allocation[] allocations)Allocation(address destination,address token,uint256 amount)\"  \n    );  \n      \n    // Challenge state hash computation  \n    bytes32 public constant CHALLENGE_STATE_TYPEHASH = keccak256(  \n        \"AllowChallengeStateHash(bytes32 channelId,uint8 intent,uint256 version,bytes data,Allocation[] allocations)Allocation(address destination,address token,uint256 amount)\"  \n    );  \n    \n\nThese type hashes enable human-readable signature prompts in wallets and improve security by preventing signature replay attacks across different contexts.\n\n## Identifier Computationâ€‹\n\n### Channel Identifierâ€‹\n\nThe channelId MUST be computed as:\n    \n    \n    channelId = keccak256(  \n        abi.encode(  \n            channel.participants,  \n            channel.adjudicator,  \n            channel.challenge,  \n            channel.nonce,  \n            chainId  \n        )  \n    )  \n    \n\nThis creates a deterministic, unique identifier for each channel.\n\nApp Session Identifiers\n\nApp sessions use a different computation: `keccak256(JSON.stringify(definition))` where definition includes the app configuration but **not** `chainId`, since sessions are entirely off-chain. See [Off-chain â€º App Sessions â€º Session Identifier](/docs/protocol/off-chain/app-sessions#session-identifier) for details.\n\nDeterministic IDs\n\nChannel IDs are deterministically computed from the channel configuration, ensuring the same configuration always produces the same identifier.\n\n### Packed Stateâ€‹\n\nThe legacy state hash concept was removed in v0.3.0 when non-ECDSA signatures were introduced. Instead, participants use the **packed state** payload for signing:\n    \n    \n    packedState = abi.encode(  \n        channelId,  \n        state.intent,  \n        state.version,  \n        state.data,  \n        state.allocations  \n    )  \n    \n\nThe packed state is simply `abi.encode(channelId, state.intent, state.version, state.data, state.allocations)`. This byte array is fed into the selected signing scheme (EIP-712 hashing, ERC-1271 contract checks, NO_EIP712 fallback, etc.). Each scheme may wrap or hash `packedState` as needed, but the canonical payload MUST be the input.\n\nSignature Verification\n\nAll state updates MUST be verified by checking signatures against the canonical `packedState` payload (after the signing method applies its required hashing/wrapping) before accepting them on-chain.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/on-chain/data-structures.mdx)\n\n[PreviousOverview](/docs/protocol/on-chain/overview)[NextChannel Lifecycle](/docs/protocol/on-chain/channel-lifecycle)\n\n  * Channel\n  * State\n  * Allocation\n  * Signatures\n  * Amount\n  * Channel Status\n  * Protocol Constants\n    * Participant Indices\n    * Challenge Period\n    * EIP-712 Type Hashes\n  * Identifier Computation\n    * Channel Identifier\n    * Packed State",
    "metadata": {
      "title": "Data Structures | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/data-structures",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/on-chain/overview",
    "text": "* [](/)\n  * On-Chain Protocol\n  * Overview\n\nOn this page\n\n# On-Chain Protocol Overview\n\nThe on-chain protocol defines the smart contract interfaces and data structures that form the foundation of Nitrolite's security guarantees. This layer operates on the blockchain and handles:\n\n  * **Fund Custody** : Secure locking and unlocking of participant assets\n  * **Dispute Resolution** : Challenge-response mechanism for disagreements\n  * **Final Settlement** : Distribution of funds according to validated states\n  * **Channel Lifecycle**: State transitions from creation to closure\n\n## Key Responsibilitiesâ€‹\n\nThe on-chain layer MUST provide:\n\n  1. **Deterministic channel identifiers** computed from channel configuration\n  2. **Signature verification** to authenticate state updates\n  3. **State validation** through adjudicator contracts\n  4. **Challenge periods** to ensure fair dispute resolution\n  5. **Fund safety** guaranteeing users can always recover their assets\n\nEVM Compatibility\n\nThe initial version of Nitrolite is designed for EVM-compatible blockchains including Ethereum, Polygon, Base, and other EVM chains. Support for additional networks is continuously expanding.\n\n## Contract Interfacesâ€‹\n\nThe protocol defines three primary contract interfaces:\n\n  * **IChannel** : Core channel lifecycle operations (create, join, challenge, close)\n  * **IDeposit** : Token deposit and withdrawal management\n  * **IChannelReader** : Read-only queries for channel state and status\n\nThese interfaces are implemented by the **Custody Contract** , which serves as the main entry point for on-chain operations.\n\n## Next Stepsâ€‹\n\nThe following sections detail:\n\n  * [Data Structures](/docs/protocol/on-chain/data-structures): Core types and identifier computation\n  * [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle): Complete state machine and operations\n  * [Security Considerations](/docs/protocol/on-chain/security): Threat model and best practices\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/on-chain/overview.mdx)\n\n[PreviousArchitecture](/docs/protocol/architecture)[NextData Structures](/docs/protocol/on-chain/data-structures)\n\n  * Key Responsibilities\n  * Contract Interfaces\n  * Next Steps",
    "metadata": {
      "title": "Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/overview",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/on-chain/security",
    "text": "* [](/)\n  * On-Chain Protocol\n  * Security Considerations\n\nOn this page\n\n# Security Considerations\n\n## Current Limitationsâ€‹\n\nThe current Custody contract implementation has the following limitations:\n\n  * **Two-participant channels only** : Channels support exactly 2 participants\n  * **Participant role constraint** : First participant must always be a client, while second must be a Clearnode\n  * **Single allocation per participant** : Each participant can have only 1 allocation\n  * **Same-token allocations** : Both allocations must be for the same token\n  * **Minimum challenge duration** : Challenge duration is set to be no less than 1 hour\n  * **No re-challenge** : It is not possible to challenge an already challenged channel\n  * **No direct EOA resize** : It is not possible to resize directly from or to your EOA; you must deposit to or withdraw funds from the Custody contract first\n  * **Channel required for withdrawal** : It is not possible to withdraw your funds from the Unified Balance on a chain with no open channel without opening a channel first. In a future major release, we plan to merge these steps in one operation\n  * **Separate resize and balance operations** : It is not possible to top-up a Unified Balance from or withdraw to your EOA balance in the same `resize(...)` operation. You must deposit your funds prior to or withdraw after the `resize(...)` operation. In a future major release, we plan to merge these steps in one operation\n\nFuture Improvements\n\nMany of these limitations are implementation-specific and are planned to be addressed in future major releases. They do not represent fundamental protocol constraints.\n\n## Threat Modelâ€‹\n\n### Assumptionsâ€‹\n\nThe protocol operates under the following security assumptions:\n\n  * **At least one honest party per channel** willing to enforce their rights\n  * **Blockchain is secure and censorship-resistant** within reasonable bounds\n  * **Cryptographic primitives are secure** (ECDSA, keccak256)\n  * **Participants have access to the blockchain** to submit challenges within the challenge period\n\nTrust Model\n\nNitrolite is designed as a **trustless protocol** \\- no single party can steal funds or prevent others from recovering their legitimate share.\n\n### Protected Againstâ€‹\n\nThe protocol provides protection against:\n\n  * **Replay attacks** via version number checking in Custody contract\n  * **State withholding** via challenge mechanism\n  * **Unauthorized state transitions** via signature verification\n  * **Funds theft** \\- all transitions require valid signatures from appropriate parties\n\n### Not Protected Againstâ€‹\n\nThe protocol cannot protect against:\n\n  * **All participants colluding** to violate application rules\n  * **Blockchain -level attacks** (51% attacks, MEV exploitation, etc.)\n  * **Denial of service by blockchain congestion** \\- may affect ability to respond to challenges\n\nBlockchain Dependency\n\nThe security of Nitrolite channels depends on the underlying blockchain's liveness and security. Extended blockchain downtime during a challenge period could prevent parties from responding.\n\n## Security Propertiesâ€‹\n\n### Funds Safetyâ€‹\n\n**Property** : Participants can always recover their funds according to the latest valid signed state, even if other participants become unresponsive.\n\n**Mechanism** : The challenge-response system ensures that:\n\n  1. Any party can initiate closure unilaterally\n  2. Challenge period allows time for others to respond with newer states\n  3. Newest valid state always wins\n  4. Funds are distributed according to the final accepted state\n\nYes\n\nNo\n\nNo\n\nYes\n\nUser has latest  \nsigned state\n\nOther participant responsive?\n\nCooperative close  \nFast & cheap\n\nChallenge with  \nlatest state\n\nWait challenge  \nperiod\n\nCommunication continuation suggested?\n\nClose & recover funds\n\nCreate and submit a  \nnewer state via checkpoint(...)\n\n### State Validityâ€‹\n\n**Property** : Only states signed by the required participants (as determined by the adjudicator) can be accepted.\n\n**Mechanism** :\n\n  * Every state update requires cryptographic signatures\n  * Signatures are verified against the packedState\n  * Adjudicator validates state transitions according to application rules\n  * Invalid states are rejected on-chain\n\nCryptographic Security\n\nState validity is enforced through [supported signatures](/docs/protocol/on-chain/signature-formats), all of which are supported by Ethereum itself.\n\n#### EIP-712 Signature Supportâ€‹\n\nNitrolite supports **EIP-712 (Typed Structured Data)** signatures in addition to raw ECDSA and EIP-191. This provides significant security and user experience advantages:\n\n**Security Benefits** :\n\n  * **Domain Separation** : Signatures are bound to a specific contract and chain, preventing replay attacks across different applications or networks\n  * **Type Safety** : Structured data hashing ensures only valid state structures can be signed, preventing malformed data injection\n  * **Semantic Clarity** : Each field's type and purpose is cryptographically enforced, reducing ambiguity attacks\n\n**User Experience Benefits** :\n\n  * **Human-Readable** : Modern wallets (MetaMask, Ledger, etc.) display EIP-712 signatures as structured fields instead of opaque hex strings\n  * **Transparency** : Users see exactly what `channelId`, `intent`, `version`, `allocations`, and `data` they're signing\n  * **Trust** : Clear presentation reduces phishing risks and increases user confidence\n\n**Example Wallet Display** :\n    \n    \n    Sign Typed Data:  \n      channelId: 0xabcd1234...  \n      intent: OPERATE (1)  \n      version: 5  \n      allocations:  \n        [0] destination: 0x742d35Cc..., token: USDC, amount: 100.00  \n        [1] destination: 0x123456Cc..., token: USDC, amount: 0.00  \n    \n\nCompared to EIP-191 which would show:\n    \n    \n    Sign Message:  \n    0x1ec5000000000000000000000000000000000000000000000000000000001234abcd...  \n    [500+ more hex characters]  \n    \n\n**Implementation Note** : The protocol accepts **all three formats** (raw ECDSA, EIP-191, EIP-712) for maximum compatibility, but EIP-712 is **strongly recommended** for production applications due to its superior security and UX properties.\n\nSupporting EIP-712 signatures also differentiates Nitrolite by keeping state channel operations wallet-friendly and lowering integration friction compared to protocols limited to raw message signing.\n\n### Livenessâ€‹\n\n**Property** : As long as the blockchain is live and accepts transactions within the challenge period, honest participants can enforce their rights.\n\n**Requirements** :\n\n  * Blockchain must be operational\n  * Participant must be able to submit transactions\n  * Challenge period must be sufficient for transaction confirmation\n\n**Recommended Challenge Periods** :\n\n  * **High-value channels**: 24-48 hours (default: 24 hours / 86400 seconds)\n  * **Medium-value channels** : 12-24 hours\n  * **Low-value rapid channels** : 6-12 hours\n\nChallenge Period Trade-offs\n\nLonger challenge periods provide more security but slower dispute resolution. Shorter periods enable faster closure but require more vigilant monitoring.\n\n### Censorship Resistanceâ€‹\n\n**Property** : Since anyone can submit challenges and responses, censorship of a single participant does not prevent channel closure.\n\n**Mechanism** :\n\n  * Any participant can initiate challenge\n  * Any participant can respond to challenge\n  * Multiple participants can attempt the same operation\n  * As long as one honest party can transact, the channel can be resolved\n\n## Attack Vectors and Mitigationsâ€‹\n\n### Replay Attacksâ€‹\n\n**Attack** : Resubmitting old signed states to revert channel to a previous favorable allocation.\n\n**Mitigation** :\n\n  * Adjudicators MUST implement version checking to verify that a supplied \"candidate\" is indeed supported by a supplied \"proof\".\n  * Higher version numbers supersede lower versions\n  * On-chain contract tracks the highest version seen\n  * Old states are automatically rejected\n\nv10 > v5\n\nv10 < v20\n\nState v10 submitted\n\nCompare versions\n\nAccept new state\n\nReject old state\n\nVersion Monotonicity\n\nAlways ensure state versions increase monotonically. Never sign two different states with the same version number.\n\n### State Withholdingâ€‹\n\n**Attack** : Refusing to cooperate in closing channel, holding funds hostage.\n\n**Mitigation** :\n\n  * Challenge mechanism allows unilateral closure\n  * Challenge period ensures fair dispute resolution\n  * Latest signed state always prevails\n\n**Example Scenario** :\n    \n    \n    1. Alice and Bob have channel with $1000 each  \n    2. After trading, valid state shows Alice: $1500, Bob: $500  \n    3. Bob refuses to cooperate in cooperative close  \n    4. Alice initiates challenge with latest signed state  \n    5. Bob has access only to an older state, meaning he is unable to resolve the challenge  \n    6. After challenge period elapses, Alice's state becomes the final one  \n    7. Alice recovers her $1500  \n    \n\n### Challenge Griefingâ€‹\n\n**Attack** : Repeatedly challenging with old states to delay closure and grief the counterparty.\n\n**Mitigation** :\n\n  * Each valid newer state resets the challenge period\n  * Attacker must pay gas for each challenge attempt\n  * Eventually attacker runs out of old states\n  * Newest state always wins regardless of challenge count\n  * The party being griefed can checkpoint with the latest valid state, impeding the griefer from challenging with any intermediate state\n\nEconomic Disincentive\n\nChallenge griefing is economically costly for the attacker (gas fees) while only causing time delay, not fund loss, for the victim.\n\n### Front-Runningâ€‹\n\n**Attack** : Observing pending challenge transaction and front-running with a newer state.\n\n**Mitigation** :\n\n  * **This is actually desired behavior** in Nitrolite\n  * The newest state should always win\n  * Front-running helps ensure the most recent state is used\n  * Both parties benefit from accurate state resolution\n\n## Best Practicesâ€‹\n\n### For Usersâ€‹\n\n**Essential Practices** :\n\n  1. **Never sign duplicate versions** : Never sign two different states with the same version number\n  2. **Keep records** : Maintain a record of the latest state you've signed\n  3. **Monitor events** : Watch the blockchain for channel events (Challenged, Closed)\n  4. **Respond promptly** : React to challenges within the challenge period\n  5. **Verify adjudicators** : Only use adjudicator contracts from trusted sources\n\nCritical Rule\n\n**NEVER sign two different states with the same version number.** This creates ambiguity about the true latest state and can lead to disputes.\n\n### For Implementersâ€‹\n\n**Implementation Requirements** :\n\n  1. **Validate thoroughly** : Check all inputs before submitting transactions\n  2. **Use adjudicators wisely** : Leverage adjudicators to enforce application rules\n  3. **Set appropriate challenge periods** : Balance security needs with user experience\n  4. **Implement proper key management** : Secure storage for participant private keys\n  5. **Log state transitions** : Maintain audit trail of all state updates\n\n**Sample Validation Checklist** :\n    \n    \n    Before submitting state on-chain:  \n    â˜ Verify all required signatures present  \n    â˜ Verify signatures are valid for expected participants  \n    â˜ Verify state version is sequential  \n    â˜ Verify allocations sum correctly  \n    â˜ Verify magic numbers (CHANOPEN/CHANCLOSE) if applicable  \n    â˜ Verify channelId matches expected value  \n    â˜ Test with small amounts first  \n    \n\n### For Adjudicator Developersâ€‹\n\n**Critical Requirements** :\n\n  1. **Implement strict version comparison** : Ensure newer states always supersede older ones\n  2. **Validate state transitions** : Enforce application-specific rules correctly\n  3. **Optimize for gas efficiency** : Validation happens on-chain during disputes\n  4. **Consider edge cases** : Handle all possible state transition scenarios\n  5. **Audit thoroughly** : Security review before deployment is essential\n\nAdjudicator Responsibility\n\nAdjudicators are critical to channel security. A flawed adjudicator can undermine the entire channel's safety guarantees.\n\nBefore Implementing Your Own Adjudicator\n\nThe Adjudicator is an incredibly important part of the Nitrolite protocol. Yellow Network is built on top of a specific adjudicator, which if changed, will render interoperability and security guarantees impossible. Before starting to implement your own Adjudicator, please be sure to advise the Nitrolite developer team, so that your work is not left out.\n\n## Security Guarantees Summaryâ€‹\n\nProperty| Guarantee| Mechanism  \n---|---|---  \n**Funds Safety**|  Cannot lose funds with valid signed state| Challenge-response + signatures  \n**State Validity**|  Only properly signed states accepted| Signature verification  \n**Liveness**|  Can always close if blockchain is live| Unilateral challenge mechanism  \n**Censorship Resistance**|  Any party can enforce closure| Multiple submission paths  \n**No Replay**|  Old states cannot be reused| Version number validation  \n  \nStrong Security Model\n\nNitrolite provides **strong security guarantees** built on top of Layer 1 blockchain security, while enabling Layer 2 scalability and efficiency.\n\n## Emergency Proceduresâ€‹\n\n### If a Clearnode Becomes Unresponsiveâ€‹\n\n  1. **Retrieve latest signed state** from local storage\n  2. **Initiate challenge** on-chain with latest state\n  3. **Close the channel** after challenge period expires\n  4. **Funds are recovered** according to latest valid state\n\n### If You Have Been Challengedâ€‹\n\n  1. **Check for the latest state** \\- make sure the channel was challenged with the latest state. If not, you should checkpoint it with one to avoid funds loss\n  2. **Ensure blockchain access** \\- check network connectivity\n  3. **Use appropriate gas prices** \\- ensure timely confirmation\n  4. **Have backup RPC endpoints** \\- don't rely on single provider\n\nMonitoring Best Practice\n\nSet up automated monitoring with alerts for channel events. This ensures you can respond quickly to challenges even if you're not actively watching.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/on-chain/security.mdx)\n\n[PreviousSignature Formats](/docs/protocol/on-chain/signature-formats)[NextOff-Chain RPC Overview](/docs/protocol/off-chain/overview)\n\n  * Current Limitations\n  * Threat Model\n    * Assumptions\n    * Protected Against\n    * Not Protected Against\n  * Security Properties\n    * Funds Safety\n    * State Validity\n    * Liveness\n    * Censorship Resistance\n  * Attack Vectors and Mitigations\n    * Replay Attacks\n    * State Withholding\n    * Challenge Griefing\n    * Front-Running\n  * Best Practices\n    * For Users\n    * For Implementers\n    * For Adjudicator Developers\n  * Security Guarantees Summary\n  * Emergency Procedures\n    * If a Clearnode Becomes Unresponsive\n    * If You Have Been Challenged",
    "metadata": {
      "title": "Security Considerations | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/security",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/on-chain/signature-formats",
    "text": "* [](/)\n  * On-Chain Protocol\n  * Signature Formats\n\nOn this page\n\n# Signature Formats\n\nNitrolite treats each signature inside `State.sigs` as an opaque `bytes` value. At verification time the Custody contract inspects that payload to detect which validation flow to run. This page captures the current formats the protocol accepts and how they are evaluated.\n\n## Supported Formatsâ€‹\n\n### Raw / Pre-EIP-191 ECDSAâ€‹\n\n  * Signs the raw packedState with no prefix.\n  * Produces the canonical `(v, r, s)` tuple encoded as 65 bytes.\n  * Recommended for chain-agnostic clients or when hardware-wallet compatibility is required.\n\n### EIP-191 (`0x45`) Ethereum Signed Messageâ€‹\n\n  * Payload: `keccak256(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" + len(packedState) + packedState)`.\n  * Matches the UX most wallets expose when calling `eth_sign`.\n  * Nitrolite stores the resulting `(v, r, s)` so adjudicators can re-create the prefixed hash for verification.\n\n### EIP-712 Typed Dataâ€‹\n\n  * Payload: `keccak256(\\\"\\\\x19\\\\x01\\\" ++ domainSeparator ++ hashStruct(state))`.\n  * Domain separator includes chain ID, verifying contract, and an application-specific salt to prevent replay.\n  * Provides the strongest replay protection when both parties agree on the domain definition.\n\n### EIP-1271 Smart-Contract Signaturesâ€‹\n\n  * Supports smart contract wallets (multi-sigs, modules, account abstraction).\n  * The `bytes` payload is passed to the signer's `isValidSignature(hash, bytes signature)` function.\n  * Implementations can encode arbitrary metadata (e.g., batched approvals, guardians).\n\n### EIP-6492 Counterfactual Signaturesâ€‹\n\n  * Wraps an EIP-1271 signature with deployment bytecode and a detection suffix `0x6492649264926492649264926492649264926492649264926492649264926492`.\n  * Allows a not-yet-deployed ERC-4337 smart wallet to attest to a state.\n  * During verification Nitrolite simulates or deploys the wallet, then forwards the inner signature to the regular EIP-1271 flow.\n\n## Verification Orderâ€‹\n\nThe Custody contract attempts the following strategies in order:\n\n  1. **EIP-6492** â€“ If the detection suffix is present, unwrap and validate as counterfactual.\n  2. **EIP-1271** â€“ If the signer currently has contract code, call `isValidSignature`.\n  3. **ECDSA / EIP-191 / EIP-712** â€“ Otherwise treat it as an externally owned account signature and recover the signer using the appropriate hash for the advertised format.\n\nImplementations should persist metadata about which scheme was used so that adjudicators and monitoring services can reproduce the expected hash locally.\n\n## Implementation Notesâ€‹\n\n  * `bytes[] sigs` preserves the ordering of channel participants, but each entry may come from a different signature family.\n  * Wallets should expose the format they used when signing to aid debugging.\n  * Future versions may extend this list; storing opaque bytes ensures backward compatibility.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/on-chain/signature-formats.mdx)\n\n[PreviousChannel Lifecycle](/docs/protocol/on-chain/channel-lifecycle)[NextSecurity Considerations](/docs/protocol/on-chain/security)\n\n  * Supported Formats\n    * Raw / Pre-EIP-191 ECDSA\n    * EIP-191 (`0x45`) Ethereum Signed Message\n    * EIP-712 Typed Data\n    * EIP-1271 Smart-Contract Signatures\n    * EIP-6492 Counterfactual Signatures\n  * Verification Order\n  * Implementation Notes",
    "metadata": {
      "title": "Signature Formats | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/signature-formats",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/protocol-reference",
    "text": "* [](/)\n  * Protocol Reference\n\nOn this page\n\n# Protocol Reference\n\nQuick reference guide for protocol versions, constants, standards, and specifications.\n\nQuick Navigation\n\nJump to a section:\n\n  * Protocol Versions \\- Nitrolite & Nitro RPC versions\n  * State Intent System \\- Channel state classification\n  * Participant Indices \\- Creator & Clearnode positions\n  * Channel Status \\- Status transitions\n  * Signature Standards \\- On-chain & off-chain formats\n  * EIP References \\- Ethereum standards used\n  * Protocol Constants \\- Core constants\n\n* * *\n\n## Protocol Versionsâ€‹\n\n### Nitrolite Protocolâ€‹\n\nProperty| Value  \n---|---  \n**Version**|  0.5.0  \n**Status**|  Mainnet deployments live; not production yet  \n**Compatibility**|  EVM-compatible chains  \n  \n**Supported Chains** : Ethereum, Polygon, Arbitrum One, Optimism, Base, and other EVM-compatible networks.\n\n### Nitro RPC Protocolâ€‹\n\nVersion| Status| Features  \n---|---|---  \n**0.2**|  Legacy| Basic state updates only  \n**0.4**|  Current| Intent system (OPERATE, DEPOSIT, WITHDRAW)  \n  \nVersion Recommendation\n\n**Always use NitroRPC/0.4** for new implementations. Version 0.4 adds the intent system for app sessions, enabling dynamic fund management (deposits and withdrawals) within active sessions.\n\n**Breaking Changes** :\n\n  * NitroRPC/0.4 introduces the `intent` parameter in `submit_app_state`\n  * NitroRPC/0.2 sessions cannot use DEPOSIT or WITHDRAW intents\n  * Protocol version is set during app session creation and cannot be changed\n\n* * *\n\n## State Intent Systemâ€‹\n\nChannel states are classified by `state.intent` (uint8) to signal their purpose. The Solidity enum defines:\n\n### StateIntent Enumerationâ€‹\n    \n    \n    enum StateIntent {  \n        OPERATE,     // 0: Normal updates (challenge/checkpoint)  \n        INITIALIZE,  // 1: Channel funding/creation  \n        RESIZE,      // 2: In-place capacity change  \n        FINALIZE     // 3: Cooperative closure  \n    }  \n    \n\n### Intent Usageâ€‹\n\nIntent| Value| When Used| Method  \n---|---|---|---  \n`INITIALIZE`| 1| Channel creation| `Custody.create()`  \n`RESIZE`| 2| Channel resize| `Custody.resize()`  \n`FINALIZE`| 3| Cooperative closure| `Custody.close()`  \n`OPERATE`| 0| Challenge/checkpoint| `Custody.challenge()`, `Custody.checkpoint()`  \n  \n**Example** :\n    \n    \n    // Creation state  \n    state.intent = 1  // INITIALIZE  \n    state.version = 0  \n    state.data = \"0x\"  // Empty for basic channels  \n      \n    // Closing state  \n    state.intent = 3  // FINALIZE  \n    state.version = currentVersion + 1  \n    state.data = \"0x\"  \n    \n\nIntent Validation\n\nSmart contracts validate the `intent` field to ensure proper channel lifecycle. Incorrect intent values will cause transactions to revert.\n\n* * *\n\n## Participant Indicesâ€‹\n\nIn a standard payment channel, participants are identified by their array index.\n\n### Index 0: Creator (User)â€‹\n\n**Role** : Creator\n\n**Responsibilities** :\n\n  * Initiates channel creation\n  * Typically the one depositing funds\n  * First to sign states (`state.sigs[0]`)\n  * Calls `Custody.create()` on-chain\n\n**Example** :\n    \n    \n    channel.participants[0] = \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\" // User  \n    \n\n### Index 1: Clearnodeâ€‹\n\n**Role** : Service provider\n\n**Responsibilities** :\n\n  * Co-signs the initial state before on-chain `create()`; there is no separate `join()` call\n  * Provides off-chain services (Nitro RPC, unified balance management)\n  * Second to sign states (`state.sigs[1]`)\n\n**Example** :\n    \n    \n    channel.participants[1] = \"0x123456789abcdef0123456789abcdef012345678\" // Clearnode  \n    \n\nSignature Order Critical\n\nSignatures array order **MUST** match participants array order. Mismatched signatures will cause transaction failures.\n    \n    \n    state.sigs[0] = creator_signature   // Must be from participants[0]  \n    state.sigs[1] = clearnode_signature // Must be from participants[1]  \n    \n\n* * *\n\n## Channel Status State Machineâ€‹\n\nChannel lifecycle is governed by status transitions.\n\n### Status Enumerationâ€‹\n    \n    \n    enum Status {  \n        VOID,      // 0: Channel does not exist  \n        INITIAL,   // 1: Creation in progress, awaiting all participants  \n        ACTIVE,    // 2: Fully funded and operational  \n        DISPUTE,   // 3: Challenge period active  \n        FINAL      // 4: Ready to be closed and deleted  \n    }  \n    \n\n### State Transition Diagramâ€‹\n\ncreate() (creator only)\n\ncreate() (all sigs present)\n\njoin() (remaining participants)\n\nchallenge()\n\nclose() (cooperative)\n\ncheckpoint() (newer state)\n\nclose() (after timeout)\n\nVOID\n\nINITIAL\n\nACTIVE\n\nDISPUTE\n\nFINAL\n\nChannel does not exist  \non blockchain\n\nCreator has joined,  \nawaiting other participants\n\nOperational state,  \ncan perform off-chain updates\n\nChallenge active,  \nparties can submit newer states\n\nReady for deletion,  \nfunds distributed\n\n### Valid Transitionsâ€‹\n\nFrom| To| Trigger| Notes  \n---|---|---|---  \n`VOID`| `INITIAL`| `create()` (creator only)| Legacy flow; awaiting other participants  \n`VOID`| `ACTIVE`| `create()` (all sigs present)| Current flow; both participants co-sign initial state  \n`INITIAL`| `ACTIVE`| `join()`| Remaining participants join  \n`ACTIVE`| `DISPUTE`| `challenge()`| Dispute initiated  \n`ACTIVE`| `FINAL`| `close()`| Cooperative closure  \n`DISPUTE`| `ACTIVE`| `checkpoint()`| Newer state accepted  \n`DISPUTE`| `FINAL`| `close()`| Challenge timeout  \n  \nQuick Closure\n\nThe fastest way to close a channel is **ACTIVE â†’ FINAL** via cooperative `close()`. This skips the challenge period entirely.\n\n* * *\n\n## Signature Standardsâ€‹\n\n### On-Chain Signatures (Solidity)â€‹\n\nUsed in smart contract transactions (`create`, `join`, `close`, `challenge`, `resize`).\n\n**Format** : Variable-length byte arrays supporting multiple signature types (since v0.3.0)\n\n**Structure** :\n    \n    \n    struct State {  \n        // ... other fields ...  \n        bytes[] sigs;  // Array of signatures from participants  \n    }  \n    \n\n**Supported Types** :\n\n  * **ECDSA** (65 bytes): Standard signatures from EOA wallets\n  * **ERC-1271** : Smart contract wallet signatures\n  * **ERC-6492** : Counterfactual contract signatures (not yet deployed)\n\n**Hash** : Raw `packedState` (no EIP-191 prefix for chain-agnostic compatibility)\n\n**Example** :\n    \n    \n    packedState = keccak256(abi.encode(channelId, state.intent, state.version, state.data, state.allocations))  \n    signature = sign(packedState, participantPrivateKey) // Raw hash, no prefix  \n    \n\n### Off-Chain Signatures (Nitro RPC)â€‹\n\nUsed in RPC requests and responses over RPC.\n\n**Format** : 0x-prefixed hex string (typically ECDSA from session keys)\n\n**Typical Length** : 65 bytes for ECDSA\n\n  * `r`: 32 bytes\n  * `s`: 32 bytes\n  * `v`: 1 byte\n\n**Representation** : 130 hex characters + `0x` prefix\n\n**Example** :\n    \n    \n    signature = \"0x1234567890abcdef...xyz\" // 132 characters total (ECDSA)  \n    \n\n**Computed Over** :\n    \n    \n    rpcHash = keccak256(JSON.stringify(req))  \n    signature = sign(rpcHash, sessionPrivateKey)  \n    \n\nSession Key Signatures\n\nOff-chain RPC signatures are typically ECDSA from session keys (EOA wallets), but the protocol supports other signature types for future flexibility.\n\nChain-Agnostic Signatures\n\nOn-chain signatures do NOT use EIP-191 or EIP-712 prefixes to maintain chain-agnostic compatibility. This differs from typical Ethereum signing patterns. Off-chain RPC signatures (e.g., authentication) DO use EIP-712 for better wallet UX.\n\n* * *\n\n## EIP Referencesâ€‹\n\nEthereum Improvement Proposals referenced or used by the protocol.\n\n### EIP-191: Signed Data Standardâ€‹\n\n**Status** : Not used in on-chain signatures (chain-agnostic design)  \n**Link** : <https://eips.ethereum.org/EIPS/eip-191>\n\n**Why not used for on-chain** : On-chain signatures are computed over raw `packedState` hash without EIP-191 prefix to maintain compatibility across different EVM chains and potential non-EVM implementations.\n\n### EIP-712: Typed Structured Data Hashingâ€‹\n\n**Status** : Used for off-chain RPC authentication  \n**Link** : <https://eips.ethereum.org/EIPS/eip-712>\n\n**Usage** : Authentication flow uses EIP-712 typed data for signing the Policy structure (challenge, wallet, session_key, expires_at, scope, allowances) with the main wallet. This provides better wallet UX by displaying human-readable signing data.\n\n### EIP-1271: Contract Signature Validationâ€‹\n\n**Status** : Supported by adjudicators  \n**Link** : <https://eips.ethereum.org/EIPS/eip-1271>\n\n**Usage** : Enables smart contract wallets to sign state updates as participants.\n\n### EIP-20 (ERC-20): Token Standardâ€‹\n\n**Status** : Required for all assets  \n**Link** : <https://eips.ethereum.org/EIPS/eip-20>\n\n**Usage** : All assets must be ERC-20 compliant tokens. The Custody Contract uses `transferFrom` and `transfer` methods.\n\nStandards Compliance\n\nWhile the protocol references these EIPs, implementation details may vary. Always consult the specific smart contract code for authoritative behavior.\n\n* * *\n\n## Protocol Constantsâ€‹\n\nThe only protocol-wide constants defined in code are:\n    \n    \n    uint256 constant PART_NUM   = 2; // Channels are always 2-party  \n    uint256 constant CLIENT_IDX = 0; // Client/creator participant index  \n    uint256 constant SERVER_IDX = 1; // Server/clearnode participant index  \n    \n\nAll channel arrays (participants, allocations, sigs) and state validation logic rely on these indices and fixed participant count.\n\n* * *\n\n## Next Stepsâ€‹\n\nNow that you have the complete protocol reference:\n\n  1. **Terminology** : Review [Terminology](/docs/protocol/terminology) for all term definitions\n  2. **Communication Flows** : See [Communication Flows](/docs/protocol/communication-flows) for sequence diagrams\n  3. **Implementation Guide** : Follow [Implementation Checklist](/docs/protocol/implementation-checklist) to build compliant clients\n  4. **Channel Lifecycle** : See [Channel Lifecycle](/docs/on-chain/channel-lifecycle) for detailed state transitions\n\nReference Updates\n\nThis reference reflects protocol version 0.5.0. For the latest updates, check the [Nitrolite repository](https://github.com/layer-3/nitrolite) or use `get_config` to query clearnode capabilities dynamically.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/protocol-reference.mdx)\n\n[PreviousCross-Layer Communication Flows](/docs/protocol/communication-flows)[NextGlossary](/docs/protocol/glossary)\n\n  * Protocol Versions\n    * Nitrolite Protocol\n    * Nitro RPC Protocol\n  * State Intent System\n    * StateIntent Enumeration\n    * Intent Usage\n  * Participant Indices\n    * Index 0: Creator (User)\n    * Index 1: Clearnode\n  * Channel Status State Machine\n    * Status Enumeration\n    * State Transition Diagram\n    * Valid Transitions\n  * Signature Standards\n    * On-Chain Signatures (Solidity)\n    * Off-Chain Signatures (Nitro RPC)\n  * EIP References\n    * EIP-191: Signed Data Standard\n    * EIP-712: Typed Structured Data Hashing\n    * EIP-1271: Contract Signature Validation\n    * EIP-20 (ERC-20): Token Standard\n  * Protocol Constants\n  * Next Steps",
    "metadata": {
      "title": "Protocol Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/protocol-reference",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/protocol/terminology",
    "text": "* [](/)\n  * Terminology\n\nOn this page\n\n# Terminology\n\n## Core Conceptsâ€‹\n\n**Channel** : A secure communication pathway between participants that locks funds in an on-chain smart contract while enabling off-chain state updates.\n\n**State** : A snapshot of the channel at any point in time, including fund allocations and application-specific data.\n\n**Participant** : An entity (identified by a wallet address) that is part of a channel.\n\n**Clearnode** : A server implementing a virtual ledger layer that provides a unified ledger (through Nitro RPC), coordinates state channels (through Nitrolite), and enables chain abstraction for developers and users\n\n**Creator** : The participant at index 0 in a channel who initiates channel creation.\n\n**App Sessions** : Off-chain channels built on top of payment channels, intended to be used by app developers to enable application-specific interactions and transactions without touching the blockchain.\n\n**Unified Balance** : An abstraction that aggregates users' funds across multiple blockchain networks, managed by a clearnode.\n\n**Session Key** : A temporary cryptographic key delegated by a user's main wallet that provides a flexible way for the user to manage security of their funds by giving specific permissions and allowances for specific apps.\n\n## Identifiersâ€‹\n\n**channelId** : A unique identifier for a channel, computed as the hash of the channel configuration, formatted as a 0x-prefixed hex string (32 bytes).\n\n**packedState** : A specific encoding of a channelId, state.intent, state.version, state.data, state.allocations, used for signing and signature verification.\n\n**requestId** : A unique identifier for an RPC request, used for correlating requests and responses formatted as a 0x-prefixed hex string (32 bytes).\n\n**appSessionId** : A unique identifier for an app session, formatted as a 0x-prefixed hex string (32 bytes). Used for all subsequent operations on that specific app session.\n\n**accountId** : An identifier for an account or app session within the unified ledger. Can be either a 0x-prefixed hex string or a wallet address.\n\n**chainId** : A blockchain network identifier (uint64). Examples: 1 (Ethereum Mainnet), 137 (Polygon), 8453 (Base), 42161 (Arbitrum One), 10 (Optimism).\n\n**assetSymbol** : A lowercase string identifier for a supported asset. Asset symbols are consistent across chains.\n\n**walletAddress** : A user's blockchain address (0x-prefixed hex string, 20 bytes) that identifies their account and owns funds. Used to identify participants in channels and app sessions.\n\n**userId** : Identifies a user after authentication to the Clearnode. Currently, this is always equivalent to the user's walletAddress.\n\n## On-Chain Contractsâ€‹\n\n**Custody Contract** : The main on-chain contract implementing the Nitrolite protocol. It provides the functionality to lock and unlock funds; create, close and challenge a channel; track channel state, and coordinate with adjudicators to validate state transitions on state updates.\n\n**Adjudicator** : A smart contract that defines the rules for validating state transitions during all channel lifecycle operations. The adjudicator's `adjudicate(...)` function is called by the Custody contract to verify whether a new state is valid based on previous states and application-specific logic. Examples include SimpleConsensus (requires both signatures) and Remittance (only sender must sign).\n\n## Protocol Componentsâ€‹\n\n**Nitrolite** : The on-chain smart contract protocol.\n\n**Nitro RPC** : The off-chain communication protocol.\n\nQuick Reference\n\nThese terms are used throughout the protocol specification. Bookmark this page for easy reference while reading other sections.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/protocol/terminology.mdx)\n\n[PreviousIntroduction](/docs/protocol/introduction)[NextArchitecture](/docs/protocol/architecture)\n\n  * Core Concepts\n  * Identifiers\n  * On-Chain Contracts\n  * Protocol Components",
    "metadata": {
      "title": "Terminology | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/terminology",
      "source": "yellow-docs"
    }
  },
  {
    "id": "https://docs.yellow.org/docs/tutorials",
    "text": "* [](/)\n  * Tutorials\n\n# Tutorials\n\nWork in Progress\n\nThis section is currently under development. Step-by-step tutorials and comprehensive guides will be available soon.\n\nComing soon: Interactive tutorials covering various development scenarios and use cases.\n\n[Edit this page](https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorials/index.md)",
    "metadata": {
      "title": "Tutorials | Yellow Network",
      "url": "https://docs.yellow.org/docs/tutorials",
      "source": "yellow-docs"
    }
  }
]