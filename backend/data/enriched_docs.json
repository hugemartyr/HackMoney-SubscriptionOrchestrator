[
  {
    "page_content": "* API Reference\n\n\n\n# API Reference\n\nComplete reference for all Yellow SDK methods, types, and utilities.\n\nSummary: Provides a comprehensive index and entry point for the Yellow SDK's technical documentation, covering all available methods, data types, and utility functions.\n\nRelated terms: API reference, SDK documentation, Yellow Network, methods, types, utilities, developer guide, function list, technical specs, API docs, library reference, programming interface, YellowSDK\n\nUse cases: Technical integration planning, Method signature lookup, Data type definition reference",
    "metadata": {
      "title": "API Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/api-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a comprehensive index and entry point for the Yellow SDK's technical documentation, covering all available methods, data types, and utility functions.",
      "keywords": [
        "API reference",
        "SDK documentation",
        "Yellow Network",
        "methods",
        "types",
        "utilities",
        "developer guide",
        "function list",
        "technical specs",
        "API docs",
        "library reference",
        "programming interface",
        "YellowSDK"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "Technical integration planning",
        "Method signature lookup",
        "Data type definition reference"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## NitroliteRPC Functionsâ€‹\n\n\n### Message Creationâ€‹\n\n#### `createAppSessionMessage(signer: MessageSigner, sessions: AppSession[]): Promise<string>`â€‹\n\nCreates a signed application session message.\n\n**Parameters:**\n    \n    \n    type MessageSigner = (payload: any) => Promise<Hex>;  \n      \n    interface AppSession {  \n      definition: AppDefinition;  \n      allocations: AppAllocation[];  \n    }  \n      \n    interface AppDefinition {  \n      protocol: string;  \n      participants: Address[];  \n      weights: number[];  \n      quorum: number;  \n      challenge: number;  \n      nonce: number;  \n    }  \n      \n    interface AppAllocation {  \n      participant: Address;  \n      asset: string;  \n      amount: string;  \n    }  \n    \n\n#### `createStateUpdateMessage(signer: MessageSigner, update: StateUpdate): Promise<string>`â€‹\n\nCreates a signed state update message.\n\n#### `parseRPCResponse(data: string): RPCMessage`â€‹\n\nParses ClearNode response messages.\n\n**Returns:**\n    \n    \n    interface RPCMessage {  \n      id?: number;  \n      method?: string;  \n      params?: any;  \n      result?: any;  \n      error?: RPCError;  \n    }  \n    \n\n### Utilitiesâ€‹\n\n#### `computeChannelId(channel: Channel): ChannelId`â€‹\n\nCalculates deterministic channel identifier.\n\n#### `computeStateHash(state: State, channelId: ChannelId): Hash`â€‹\n\nCalculates state hash for signatures.\n\n#### `validateSignature(state: State, signature: Hex, signer: Address): Promise<boolean>`â€‹\n\nVerifies state signature.\n\nSummary: Provides a suite of RPC utility functions for the Nitrolite protocol to handle secure message creation, state hashing, and signature validation within payment channels.\n\nRelated terms: NitroliteRPC, message signing, state update, channel ID, signature verification, app session, RPC response, crypto payment, off-chain state, deterministic hashing, ClearNode, multi-party channel, state hash, validate signature\n\nUse cases: initiating a payment channel session, updating off-chain state, verifying participant signatures, parsing node responses",
    "metadata": {
      "title": "API Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/api-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a suite of RPC utility functions for the Nitrolite protocol to handle secure message creation, state hashing, and signature validation within payment channels.",
      "keywords": [
        "NitroliteRPC",
        "message signing",
        "state update",
        "channel ID",
        "signature verification",
        "app session",
        "RPC response",
        "crypto payment",
        "off-chain state",
        "deterministic hashing",
        "ClearNode",
        "multi-party channel",
        "state hash",
        "validate signature"
      ],
      "function_name": "createAppSessionMessage",
      "intent": "api_reference",
      "use_cases": [
        "initiating a payment channel session",
        "updating off-chain state",
        "verifying participant signatures",
        "parsing node responses"
      ],
      "function_names": [
        "createStateUpdateMessage",
        "AppSessionMessage",
        "StateUpdateMessage",
        "computeStateHash",
        "computeChannelId"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Type Definitionsâ€‹\n\n\n### Core Typesâ€‹\n    \n    \n    type Address = `0x${string}`;  \n    type Hash = `0x${string}`;  \n    type Hex = `0x${string}`;  \n    type ChannelId = Hash;  \n      \n    interface Channel {  \n      participants: Address[];  \n      adjudicator: Address;  \n      challenge: bigint;  \n      nonce: bigint;  \n    }  \n      \n    interface State {  \n      intent: StateIntent;  \n      version: bigint;  \n      data: Hex;  \n      allocations: Allocation[];  \n      sigs: Hex[];  \n    }  \n      \n    interface Allocation {  \n      destination: Address;  \n      token: Address;  \n      amount: bigint;  \n    }  \n      \n    enum StateIntent {  \n      OPERATE = 0,  \n      INITIALIZE = 1,  \n      RESIZE = 2,  \n      FINALIZE = 3  \n    }  \n      \n    enum ChannelStatus {  \n      VOID = 0,  \n      INITIAL = 1,  \n      ACTIVE = 2,  \n      DISPUTE = 3,  \n      FINAL = 4  \n    }  \n    \n\n### Connection Configurationâ€‹\n    \n    \n    interface ClearNodeConfig {  \n      endpoint: string;          // WebSocket endpoint  \n      apiKey?: string;          // Optional authentication  \n      timeout: number;          // Connection timeout  \n      retryAttempts: number;    // Reconnection attempts  \n    }  \n      \n    const config = {  \n      endpoint: 'wss://clearnet-sandbox.yellow.com/ws', // or wss://clearnet.yellow.com/ws for production  \n      timeout: 30000,  \n      retryAttempts: 3  \n    };  \n    \n\n### RPC Typesâ€‹\n    \n    \n    interface RPCRequest {  \n      id: number;  \n      method: string;  \n      params: any[];  \n      timestamp?: number;  \n    }  \n      \n    interface RPCResponse {  \n      id: number;  \n      result?: any;  \n      error?: RPCError;  \n      timestamp: number;  \n    }  \n      \n    interface RPCError {  \n      code: number;  \n      message: string;  \n      data?: any;  \n    }\n\nSummary: Defines the foundational data structures and types for managing state channels, connection settings, and RPC communication within the Yellow Network. It provides the schema for channel states, participant allocations, and node connectivity.\n\nRelated terms: state channel, RPC, WebSocket, allocation, hex address, nonce, adjudicator, channel setup, connection settings, payment status, node config, dispute resolution, multi-party, signing, state transition\n\nUse cases: Defining the structure of a state channel for off-chain transactions, Configuring a client connection to a ClearNode via WebSockets, Handling RPC request and response formats for protocol communication, Managing channel lifecycle states such as initialization and dispute resolution",
    "metadata": {
      "title": "API Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/api-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the foundational data structures and types for managing state channels, connection settings, and RPC communication within the Yellow Network. It provides the schema for channel states, participant allocations, and node connectivity.",
      "keywords": [
        "state channel",
        "RPC",
        "WebSocket",
        "allocation",
        "hex address",
        "nonce",
        "adjudicator",
        "channel setup",
        "connection settings",
        "payment status",
        "node config",
        "dispute resolution",
        "multi-party",
        "signing",
        "state transition"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "Defining the structure of a state channel for off-chain transactions",
        "Configuring a client connection to a ClearNode via WebSockets",
        "Handling RPC request and response formats for protocol communication",
        "Managing channel lifecycle states such as initialization and dispute resolution"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Error Typesâ€‹\n\n\n### Client Errorsâ€‹\n    \n    \n    class YellowSDKError extends Error {  \n      constructor(message: string, public code: string, public context?: any) {  \n        super(message);  \n        this.name = 'YellowSDKError';  \n      }  \n    }  \n      \n    class NetworkError extends YellowSDKError {  \n      constructor(message: string, context?: any) {  \n        super(message, 'NETWORK_ERROR', context);  \n      }  \n    }  \n      \n    class ContractError extends YellowSDKError {  \n      constructor(message: string, context?: any) {  \n        super(message, 'CONTRACT_ERROR', context);  \n      }  \n    }  \n      \n    class ValidationError extends YellowSDKError {  \n      constructor(message: string, context?: any) {  \n        super(message, 'VALIDATION_ERROR', context);  \n      }  \n    }  \n    \n\n### Error Handlingâ€‹\n    \n    \n    try {  \n      const sessionMessage = await createAppSessionMessage(messageSigner, sessionData);  \n      ws.send(sessionMessage);  \n    } catch (error) {  \n      if (error instanceof NetworkError) {  \n        // Handle network connectivity issues  \n        await this.reconnectToClearNode();  \n      } else if (error instanceof ValidationError) {  \n        // Handle input validation errors  \n        console.error('Invalid session parameters:', error.context);  \n      } else if (error instanceof SigningError) {  \n        // Handle wallet signing errors  \n        console.error('Message signing failed:', error.message);  \n      } else {  \n        // Handle unexpected errors  \n        console.error('Unexpected error:', error);  \n      }  \n    }\n\nSummary: Defines a standardized error hierarchy and handling mechanism for the Yellow Network SDK, enabling robust fault tolerance across network, contract, and validation layers.\n\nRelated terms: error handling, exception, YellowSDKError, NetworkError, ContractError, ValidationError, SigningError, troubleshooting, debugging, retry logic, connection failure, input validation, wallet error, sdk errors\n\nUse cases: reconnecting to nodes after network failure, validating session parameters, handling wallet signing rejections, intercepting smart contract execution errors",
    "metadata": {
      "title": "API Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/api-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines a standardized error hierarchy and handling mechanism for the Yellow Network SDK, enabling robust fault tolerance across network, contract, and validation layers.",
      "keywords": [
        "error handling",
        "exception",
        "YellowSDKError",
        "NetworkError",
        "ContractError",
        "ValidationError",
        "SigningError",
        "troubleshooting",
        "debugging",
        "retry logic",
        "connection failure",
        "input validation",
        "wallet error",
        "sdk errors"
      ],
      "function_name": "createAppSessionMessage",
      "intent": "error_handling",
      "use_cases": [
        "reconnecting to nodes after network failure",
        "validating session parameters",
        "handling wallet signing rejections",
        "intercepting smart contract execution errors"
      ],
      "function_names": [
        "AppSessionMessage"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Constantsâ€‹\n\n\n### Network Endpointsâ€‹\n    \n    \n    const CLEARNODE_ENDPOINTS = {  \n      PRODUCTION: 'wss://clearnet.yellow.com/ws',  \n      SANDBOX: 'wss://clearnet-sandbox.yellow.com/ws',  \n      LOCAL: 'ws://localhost:8080/ws'  \n    };  \n      \n    const PROTOCOLS = {  \n      PAYMENT: 'payment-app-v1',  \n      GAMING: 'gaming-app-v1',  \n      ESCROW: 'escrow-app-v1',  \n      TOURNAMENT: 'tournament-v1',  \n      SUBSCRIPTION: 'subscription-v1'  \n    };  \n    \n\n### Message Typesâ€‹\n    \n    \n    const MESSAGE_TYPES = {  \n      SESSION_CREATE: 'session_create',  \n      SESSION_MESSAGE: 'session_message',  \n      PAYMENT: 'payment',  \n      STATE_UPDATE: 'state_update',  \n      PARTICIPANT_JOIN: 'participant_join',  \n      SESSION_CLOSE: 'session_close',  \n      ERROR: 'error'  \n    };  \n      \n    const SESSION_STATUS = {  \n      PENDING: 'pending',  \n      ACTIVE: 'active',  \n      CLOSING: 'closing',  \n      CLOSED: 'closed',  \n      ERROR: 'error'  \n    };  \n    \n\nThis API reference provides everything you need to integrate NitroliteRPC into your applications with confidence and precision.\n\n\n\n[PreviousApp Sessions](/docs/api-reference/app-sessions)\n\n  * NitroliteRPC Functions\n    * Message Creation\n    * Utilities\n  * Type Definitions\n    * Core Types\n    * Connection Configuration\n    * RPC Types\n  * Error Types\n    * Client Errors\n    * Error Handling\n  * Constants\n    * Network Endpoints\n    * Message Types\n\nSummary: Defines the foundational constants for the NitroliteRPC framework, including environment-specific WebSocket endpoints, supported application protocols, and standardized message types for session lifecycle management.\n\nRelated terms: network endpoints, websocket, clearnode, session status, message types, payment protocol, state update, sandbox, production, nitrolite, rpc, session management, ws, wss, participant join\n\nUse cases: Configuring environment-specific network connections, Initializing multi-party application sessions, Handling state updates in payment or gaming protocols, Monitoring session lifecycle transitions",
    "metadata": {
      "title": "API Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/api-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the foundational constants for the NitroliteRPC framework, including environment-specific WebSocket endpoints, supported application protocols, and standardized message types for session lifecycle management.",
      "keywords": [
        "network endpoints",
        "websocket",
        "clearnode",
        "session status",
        "message types",
        "payment protocol",
        "state update",
        "sandbox",
        "production",
        "nitrolite",
        "rpc",
        "session management",
        "ws",
        "wss",
        "participant join"
      ],
      "function_name": "session_create",
      "intent": "api_reference",
      "use_cases": [
        "Configuring environment-specific network connections",
        "Initializing multi-party application sessions",
        "Handling state updates in payment or gaming protocols",
        "Monitoring session lifecycle transitions"
      ],
      "function_names": [
        "state_update",
        "participant_join",
        "session_message",
        "session_create",
        "session_close"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "* App Sessions\n\n\n\n# App Sessions\n\nAPI methods for managing virtual application sessions.\n\n## create_app_sessionâ€‹\n\nCreates a virtual application session between participants.\n\n**Request:**\n    \n    \n    {  \n      \"req\": [1, \"create_app_session\", {  \n        \"definition\": {  \n          \"protocol\": \"NitroRPC/0.2\" | \"NitroRPC/0.4\",  \n          \"participants\": Address[],  \n          \"weights\": number[],  \n          \"quorum\": number,  \n          \"challenge\": number,  \n          \"nonce\": number  \n        },  \n        \"allocations\": AppAllocation[],  \n        \"session_data\": string // Optional  \n      }, timestamp],  \n      \"sig\": Hex[]  \n    }  \n    \n\n**Response:**\n    \n    \n    {  \n      \"res\": [1, \"create_app_session\", {  \n        \"app_session_id\": Hex,  \n        \"version\": string,  \n        \"status\": \"open\"  \n      }, timestamp],  \n      \"sig\": [Hex]  \n    }  \n    \n\n## submit_app_stateâ€‹\n\nUpdates session state and redistributes funds.\n\n### NitroRPC/0.2â€‹\n\n**Request:**\n    \n    \n    {  \n      \"req\": [1, \"submit_app_state\", {  \n        \"app_session_id\": Hex,  \n        \"allocations\": AppAllocation[],  \n        \"session_data\": string // Optional  \n      }, timestamp],  \n      \"sig\": Hex[]  \n    }  \n    \n\n### NitroRPC/0.4â€‹\n\n**Request:**\n    \n    \n    {  \n      \"req\": [1, \"submit_app_state\", {  \n        \"app_session_id\": Hex,  \n        \"intent\": \"operate\" | \"deposit\" | \"withdraw\",  \n        \"version\": number,  \n        \"allocations\": AppAllocation[],  \n        \"session_data\": string // Optional  \n      }, timestamp],  \n      \"sig\": Hex[]  \n    }  \n    \n\n**Response:**\n    \n    \n    {  \n      \"res\": [1, \"submit_app_state\", {  \n        \"app_session_id\": Hex,  \n        \"version\": string,  \n        \"status\": \"open\"  \n      }, timestamp],  \n      \"sig\": [Hex]  \n    }  \n    \n\n## close_app_sessionâ€‹\n\nCloses session and finalizes fund distribution.\n\n**Request:**\n    \n    \n    {  \n      \"req\": [1, \"close_app_session\", {  \n        \"app_session_id\": Hex,  \n        \"allocations\": AppAllocation[],  \n        \"session_data\": string // Optional  \n      }, timestamp],  \n      \"sig\": Hex[]  \n    }  \n    \n\n**Response:**\n    \n    \n    {  \n      \"res\": [1, \"close_app_session\", {  \n        \"app_session_id\": Hex,  \n        \"version\": string,  \n        \"status\": \"closed\"  \n      }, timestamp],  \n      \"sig\": [Hex]  \n    }  \n    \n\n## Typesâ€‹\n\n### AppAllocationâ€‹\n    \n    \n    interface AppAllocation {  \n      participant: Address;  \n      asset: string;  \n      amount: string;  \n    }  \n    \n\n### AppDefinitionâ€‹\n    \n    \n    interface AppDefinition {  \n      protocol: \"NitroRPC/0.2\" | \"NitroRPC/0.4\";  \n      participants: Address[];  \n      weights: number[];  \n      quorum: number;  \n      challenge: number;  \n      nonce: number;  \n    }  \n    \n\n## Intent Types (NitroRPC/0.4)â€‹\n\n  * `operate`: Redistribute existing session funds\n  * `deposit`: Add funds from participants' unified balances\n  * `withdraw`: Remove funds to participants' unified balances\n\n## Session Statusâ€‹\n\n  * `open`: Session is active and accepting state updates\n  * `closed`: Session is finalized, no further updates allowed\n\n\n\n[NextAPI Reference](/docs/api-reference/)\n\n  * create_app_session\n  * submit_app_state\n    * NitroRPC/0.2\n    * NitroRPC/0.4\n  * close_app_session\n  * Types\n    * AppAllocation\n    * AppDefinition\n  * Intent Types (NitroRPC/0.4)\n  * Session Status\n\nSummary: This component provides API methods to manage the lifecycle of virtual application sessions, enabling secure off-chain state transitions and fund redistribution between multiple participants.\n\nRelated terms: create_app_session, submit_app_state, close_app_session, state channel, NitroRPC, off-chain payments, multi-party signing, fund redistribution, session management, app session id, quorum, nonce, appsession, start session, update balance\n\nUse cases: multi-party state synchronization, off-chain fund redistribution, real-time payment channel updates, decentralized application session management",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/api-reference/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "api_function",
      "summary": "This component provides API methods to manage the lifecycle of virtual application sessions, enabling secure off-chain state transitions and fund redistribution between multiple participants.",
      "keywords": [
        "create_app_session",
        "submit_app_state",
        "close_app_session",
        "state channel",
        "NitroRPC",
        "off-chain payments",
        "multi-party signing",
        "fund redistribution",
        "session management",
        "app session id",
        "quorum",
        "nonce",
        "appsession",
        "start session",
        "update balance"
      ],
      "function_name": "create_app_session",
      "intent": "api_reference",
      "use_cases": [
        "multi-party state synchronization",
        "off-chain fund redistribution",
        "real-time payment channel updates",
        "decentralized application session management"
      ],
      "function_names": [
        "submit_app_state",
        "session_data",
        "app_session_id",
        "create_app_session",
        "close_app_session"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "* Quick Start\n\n\n\n# Quick Start Guide\n\nBuild your first Yellow App in 5 minutes! This guide walks you through creating a simple payment application using state channels.\n\nSummary: This guide provides a high-level entry point for developers to rapidly build and deploy a basic payment application using Yellow Network's state channel infrastructure.\n\nRelated terms: quick start, onboarding, state channels, payment application, Yellow Network, SDK setup, first app, layer 2, off-chain payments, crypto checkout, yellownetwork, statechannel, developer guide\n\nUse cases: initial SDK integration, building a basic payment app, learning state channel implementation, rapid prototyping",
    "metadata": {
      "title": "Quick Start | Yellow Network",
      "url": "https://docs.yellow.org/docs/build/quick-start",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This guide provides a high-level entry point for developers to rapidly build and deploy a basic payment application using Yellow Network's state channel infrastructure.",
      "keywords": [
        "quick start",
        "onboarding",
        "state channels",
        "payment application",
        "Yellow Network",
        "SDK setup",
        "first app",
        "layer 2",
        "off-chain payments",
        "crypto checkout",
        "yellownetwork",
        "statechannel",
        "developer guide"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "initial SDK integration",
        "building a basic payment app",
        "learning state channel implementation",
        "rapid prototyping"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## What You'll Buildâ€‹\n\n\nA basic payment app where users can:\n\n  * Deposit funds into a state channel\n  * Send instant payments to another user\n  * Withdraw remaining funds\n\nNo blockchain knowledge required - we'll handle the complexity for you!\n\nSummary: This guide introduces the core workflow for building a payment application that leverages state channels for instant off-chain transactions, including fund deposits and withdrawals.\n\nRelated terms: start payment, deposit, withdraw, instant payment, state channel, off-chain, peer-to-peer, p2p, yellow network, checkout, micro-transactions, statechannel, payment app\n\nUse cases: peer-to-peer payment, instant micro-transactions, off-chain fund management",
    "metadata": {
      "title": "Quick Start | Yellow Network",
      "url": "https://docs.yellow.org/docs/build/quick-start",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This guide introduces the core workflow for building a payment application that leverages state channels for instant off-chain transactions, including fund deposits and withdrawals.",
      "keywords": [
        "start payment",
        "deposit",
        "withdraw",
        "instant payment",
        "state channel",
        "off-chain",
        "peer-to-peer",
        "p2p",
        "yellow network",
        "checkout",
        "micro-transactions",
        "statechannel",
        "payment app"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "peer-to-peer payment",
        "instant micro-transactions",
        "off-chain fund management"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Prerequisitesâ€‹\n\n\n  * **Node.js 16+** installed on your computer\n  * **A wallet** (MetaMask recommended)\n  * **Basic JavaScript/TypeScript** knowledge\n\nSummary: Outlines the necessary software, tools, and technical knowledge required to begin developing with the Yellow Network SDK.\n\nRelated terms: prerequisites, requirements, setup, installation, Node.js, MetaMask, wallet, JavaScript, TypeScript, environment, getting started, pre-requisites, SDK setup, web3 provider\n\nUse cases: Initial environment configuration, Preparing for SDK integration, Setting up a development workspace",
    "metadata": {
      "title": "Quick Start | Yellow Network",
      "url": "https://docs.yellow.org/docs/build/quick-start",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Outlines the necessary software, tools, and technical knowledge required to begin developing with the Yellow Network SDK.",
      "keywords": [
        "prerequisites",
        "requirements",
        "setup",
        "installation",
        "Node.js",
        "MetaMask",
        "wallet",
        "JavaScript",
        "TypeScript",
        "environment",
        "getting started",
        "pre-requisites",
        "SDK setup",
        "web3 provider"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "Initial environment configuration",
        "Preparing for SDK integration",
        "Setting up a development workspace"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 1: Installationâ€‹\n\n\nCreate a new project and install the Yellow SDK:\n\n  * npm\n  * yarn\n  * pnpm\n    \n    \n    mkdir my-yellow-app  \n    cd my-yellow-app  \n    npm init -y  \n    npm install @erc7824/nitrolite  \n    \n    \n    \n    mkdir my-yellow-app  \n    cd my-yellow-app  \n    yarn init -y  \n    yarn add @erc7824/nitrolite  \n    \n    \n    \n    mkdir my-yellow-app  \n    cd my-yellow-app  \n    pnpm init  \n    pnpm add @erc7824/nitrolite\n\nSummary: Provides the initial setup instructions for integrating the Yellow Network SDK into a project, covering environment initialization and package installation via common JavaScript package managers.\n\nRelated terms: installation, setup, quick start, yellow sdk, nitrolite, npm install, yarn add, pnpm add, @erc7824/nitrolite, project initialization, crypto sdk setup, package manager, getting started, yellow network\n\nUse cases: initial project setup, integrating yellow network sdk, setting up a crypto payment environment",
    "metadata": {
      "title": "Quick Start | Yellow Network",
      "url": "https://docs.yellow.org/docs/build/quick-start",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides the initial setup instructions for integrating the Yellow Network SDK into a project, covering environment initialization and package installation via common JavaScript package managers.",
      "keywords": [
        "installation",
        "setup",
        "quick start",
        "yellow sdk",
        "nitrolite",
        "npm install",
        "yarn add",
        "pnpm add",
        "@erc7824/nitrolite",
        "project initialization",
        "crypto sdk setup",
        "package manager",
        "getting started",
        "yellow network"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "initial project setup",
        "integrating yellow network sdk",
        "setting up a crypto payment environment"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 2: Connect to ClearNodeâ€‹\n\n\nCreate a file `app.js` and connect to the Yellow Network.\n\nClearnode Endpoints\n\n  * **Production** : `wss://clearnet.yellow.com/ws`\n  * **Sandbox** : `wss://clearnet-sandbox.yellow.com/ws` (recommended for testing)\n\napp.js\n    \n    \n    import { createAppSessionMessage, parseRPCResponse } from '@erc7824/nitrolite';  \n      \n    // Connect to Yellow Network (using sandbox for testing)  \n    const ws = new WebSocket('wss://clearnet-sandbox.yellow.com/ws');  \n      \n    ws.onopen = () => {  \n      console.log('âœ… Connected to Yellow Network!');  \n    };  \n      \n    ws.onmessage = (event) => {  \n      const message = parseRPCResponse(event.data);  \n      console.log('ðŸ“¨ Received:', message);  \n    };  \n      \n    ws.onerror = (error) => {  \n      console.error('Connection error:', error);  \n    };  \n      \n    console.log('Connecting to Yellow Network...');\n\nSummary: Establishes a real-time WebSocket connection to the Yellow Network ClearNode infrastructure, enabling the client to send and receive protocol messages via the Nitrolite SDK.\n\nRelated terms: connect to network, websocket connection, clearnode, sandbox environment, rpc response, nitrolite sdk, real-time communication, ws endpoint, yellow network setup, node connection, blockchain gateway, message handling, ws connection, clearnet\n\nUse cases: initial network handshake, real-time transaction monitoring, establishing a secure communication channel, testing in a sandbox environment",
    "metadata": {
      "title": "Quick Start | Yellow Network",
      "url": "https://docs.yellow.org/docs/build/quick-start",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Establishes a real-time WebSocket connection to the Yellow Network ClearNode infrastructure, enabling the client to send and receive protocol messages via the Nitrolite SDK.",
      "keywords": [
        "connect to network",
        "websocket connection",
        "clearnode",
        "sandbox environment",
        "rpc response",
        "nitrolite sdk",
        "real-time communication",
        "ws endpoint",
        "yellow network setup",
        "node connection",
        "blockchain gateway",
        "message handling",
        "ws connection",
        "clearnet"
      ],
      "function_name": "createAppSessionMessage",
      "intent": "tutorial",
      "use_cases": [
        "initial network handshake",
        "real-time transaction monitoring",
        "establishing a secure communication channel",
        "testing in a sandbox environment"
      ],
      "function_names": [
        "AppSessionMessage"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 3: Create Application Sessionâ€‹\n\n\nSet up your wallet for signing messages:\n    \n    \n    // Set up message signer for your wallet  \n    async function setupMessageSigner() {  \n      if (!window.ethereum) {  \n        throw new Error('Please install MetaMask');  \n      }  \n      \n      // Request wallet connection  \n      const accounts = await window.ethereum.request({  \n        method: 'eth_requestAccounts'  \n      });  \n        \n      const userAddress = accounts[0];  \n        \n      // Create message signer function  \n      const messageSigner = async (message) => {  \n        return await window.ethereum.request({  \n          method: 'personal_sign',  \n          params: [message, userAddress]  \n        });  \n      };  \n      \n      console.log('âœ… Wallet connected:', userAddress);  \n      return { userAddress, messageSigner };  \n    }\n\nSummary: Initializes a wallet connection and defines a cryptographic signing function to authenticate the user's identity for an application session.\n\nRelated terms: wallet connection, MetaMask, message signing, authentication, digital signature, eth_requestAccounts, personal_sign, web3 provider, crypto wallet, session setup, user identity, signing, metamask, eth request\n\nUse cases: wallet authentication, signing session messages, connecting to decentralized applications",
    "metadata": {
      "title": "Quick Start | Yellow Network",
      "url": "https://docs.yellow.org/docs/build/quick-start",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Initializes a wallet connection and defines a cryptographic signing function to authenticate the user's identity for an application session.",
      "keywords": [
        "wallet connection",
        "MetaMask",
        "message signing",
        "authentication",
        "digital signature",
        "eth_requestAccounts",
        "personal_sign",
        "web3 provider",
        "crypto wallet",
        "session setup",
        "user identity",
        "signing",
        "metamask",
        "eth request"
      ],
      "function_name": "setupMessageSigner",
      "intent": "tutorial",
      "use_cases": [
        "wallet authentication",
        "signing session messages",
        "connecting to decentralized applications"
      ],
      "function_names": [
        "personal_sign",
        "eth_request"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 4: Create Application Sessionâ€‹\n\n\nCreate a session for your payment app:\n    \n    \n    async function createPaymentSession(messageSigner, userAddress, partnerAddress) {  \n      // Define your payment application  \n      const appDefinition = {  \n        protocol: 'payment-app-v1',  \n        participants: [userAddress, partnerAddress],  \n        weights: [50, 50], // Equal participation  \n        quorum: 100, // Both participants must agree  \n        challenge: 0,  \n        nonce: Date.now()  \n      };  \n      \n      // Initial balances (1 USDC = 1,000,000 units with 6 decimals)  \n      const allocations = [  \n        { participant: userAddress, asset: 'usdc', amount: '800000' }, // 0.8 USDC  \n        { participant: partnerAddress, asset: 'usdc', amount: '200000' } // 0.2 USDC  \n      ];  \n      \n      // Create signed session message  \n      const sessionMessage = await createAppSessionMessage(  \n        messageSigner,  \n        [{ definition: appDefinition, allocations }]  \n      );  \n      \n      // Send to ClearNode  \n      ws.send(sessionMessage);  \n      console.log('âœ… Payment session created!');  \n        \n      return { appDefinition, allocations };  \n    }\n\nSummary: This component initializes a secure multi-party payment session by defining application rules, participant roles, and initial asset allocations before broadcasting the signed state to the network.\n\nRelated terms: create session, payment channel, asset allocation, app definition, multi-party agreement, state initialization, ClearNode, message signing, quorum, participant weights, session message, crypto payment, off-chain state, payment-app-v1, session creation\n\nUse cases: peer-to-peer payment channel initialization, multi-signature escrow setup, defining initial liquidity for trading sessions",
    "metadata": {
      "title": "Quick Start | Yellow Network",
      "url": "https://docs.yellow.org/docs/build/quick-start",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component initializes a secure multi-party payment session by defining application rules, participant roles, and initial asset allocations before broadcasting the signed state to the network.",
      "keywords": [
        "create session",
        "payment channel",
        "asset allocation",
        "app definition",
        "multi-party agreement",
        "state initialization",
        "ClearNode",
        "message signing",
        "quorum",
        "participant weights",
        "session message",
        "crypto payment",
        "off-chain state",
        "payment-app-v1",
        "session creation"
      ],
      "function_name": "createAppSessionMessage",
      "intent": "tutorial",
      "use_cases": [
        "peer-to-peer payment channel initialization",
        "multi-signature escrow setup",
        "defining initial liquidity for trading sessions"
      ],
      "function_names": [
        "AppSessionMessage",
        "PaymentSession"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 5: Send Instant Paymentsâ€‹\n\n    \n    \n    async function sendPayment(ws, messageSigner, amount, recipient) {  \n      // Create payment message  \n      const paymentData = {  \n        type: 'payment',  \n        amount: amount.toString(),  \n        recipient,  \n        timestamp: Date.now()  \n      };  \n      \n      // Sign the payment  \n      const signature = await messageSigner(JSON.stringify(paymentData));  \n        \n      const signedPayment = {  \n        ...paymentData,  \n        signature,  \n        sender: await getCurrentUserAddress()  \n      };  \n      \n      // Send instantly through ClearNode  \n      ws.send(JSON.stringify(signedPayment));  \n      console.log('ðŸ’¸ Payment sent instantly!');  \n    }  \n      \n    // Usage  \n    await sendPayment(ws, messageSigner, 100000n, partnerAddress); // Send 0.1 USDC\n\nSummary: This component demonstrates how to execute instant, cryptographically signed off-chain payments between peers via a ClearNode to ensure transaction integrity and real-time settlement.\n\nRelated terms: send payment, instant transfer, ClearNode, message signing, WebSocket, off-chain, digital signature, peer-to-peer, USDC, real-time settlement, transaction integrity, crypto payment, sendPayment, checkout\n\nUse cases: Peer-to-peer instant transfers, Real-time settlement between trading partners, Micro-payments for digital services",
    "metadata": {
      "title": "Quick Start | Yellow Network",
      "url": "https://docs.yellow.org/docs/build/quick-start",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component demonstrates how to execute instant, cryptographically signed off-chain payments between peers via a ClearNode to ensure transaction integrity and real-time settlement.",
      "keywords": [
        "send payment",
        "instant transfer",
        "ClearNode",
        "message signing",
        "WebSocket",
        "off-chain",
        "digital signature",
        "peer-to-peer",
        "USDC",
        "real-time settlement",
        "transaction integrity",
        "crypto payment",
        "sendPayment",
        "checkout"
      ],
      "function_name": "sendPayment",
      "intent": "tutorial",
      "use_cases": [
        "Peer-to-peer instant transfers",
        "Real-time settlement between trading partners",
        "Micro-payments for digital services"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 6: Handle Incoming Messagesâ€‹\n\n    \n    \n    // Enhanced message handling  \n    ws.onmessage = (event) => {  \n      const message = parseRPCResponse(event.data);  \n        \n      switch (message.type) {  \n        case 'session_created':  \n          console.log('âœ… Session confirmed:', message.sessionId);  \n          break;  \n            \n        case 'payment':  \n          console.log('ðŸ’° Payment received:', message.amount);  \n          // Update your app's UI  \n          updateBalance(message.amount, message.sender);  \n          break;  \n            \n        case 'session_message':  \n          console.log('ðŸ“¨ App message:', message.data);  \n          handleAppMessage(message);  \n          break;  \n            \n        case 'error':  \n          console.error('âŒ Error:', message.error);  \n          break;  \n      }  \n    };  \n      \n    function updateBalance(amount, sender) {  \n      console.log(`Received ${amount} from ${sender}`);  \n      // Update your application state  \n    }\n\nSummary: This component implements a WebSocket message listener to handle real-time protocol events such as session confirmations, incoming payments, and application-specific messages. It serves as the primary mechanism for an application to react to asynchronous state updates and peer communications within the Yellow Network.\n\nRelated terms: WebSocket, message handler, event listener, incoming payment, session confirmation, RPC response, real-time updates, payment notification, state management, session_message, session_created, async communication, onmessage, crypto payment\n\nUse cases: Real-time payment notifications, Session lifecycle management, Peer-to-peer state synchronization",
    "metadata": {
      "title": "Quick Start | Yellow Network",
      "url": "https://docs.yellow.org/docs/build/quick-start",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component implements a WebSocket message listener to handle real-time protocol events such as session confirmations, incoming payments, and application-specific messages. It serves as the primary mechanism for an application to react to asynchronous state updates and peer communications within the Yellow Network.",
      "keywords": [
        "WebSocket",
        "message handler",
        "event listener",
        "incoming payment",
        "session confirmation",
        "RPC response",
        "real-time updates",
        "payment notification",
        "state management",
        "session_message",
        "session_created",
        "async communication",
        "onmessage",
        "crypto payment"
      ],
      "function_name": "onmessage",
      "intent": "tutorial",
      "use_cases": [
        "Real-time payment notifications",
        "Session lifecycle management",
        "Peer-to-peer state synchronization"
      ],
      "function_names": [
        "session_message",
        "session_created"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Complete Exampleâ€‹\n\n\nHere's a complete working example you can copy and run:\n\nSimplePaymentApp.js\n    \n    \n    import { createAppSessionMessage, parseRPCResponse } from '@erc7824/nitrolite';  \n      \n    class SimplePaymentApp {  \n      constructor() {  \n        this.ws = null;  \n        this.messageSigner = null;  \n        this.userAddress = null;  \n        this.sessionId = null;  \n      }  \n      \n      async init() {  \n        // Step 1: Set up wallet  \n        const { userAddress, messageSigner } = await this.setupWallet();  \n        this.userAddress = userAddress;  \n        this.messageSigner = messageSigner;  \n          \n        // Step 2: Connect to ClearNode (sandbox for testing)  \n        this.ws = new WebSocket('wss://clearnet-sandbox.yellow.com/ws');  \n          \n        this.ws.onopen = () => {  \n          console.log('ðŸŸ¢ Connected to Yellow Network!');  \n        };  \n          \n        this.ws.onmessage = (event) => {  \n          this.handleMessage(parseRPCResponse(event.data));  \n        };  \n          \n        return userAddress;  \n      }  \n      \n      async setupWallet() {  \n        const accounts = await window.ethereum.request({  \n          method: 'eth_requestAccounts'  \n        });  \n          \n        const userAddress = accounts[0];  \n        const messageSigner = async (message) => {  \n          return await window.ethereum.request({  \n            method: 'personal_sign',  \n            params: [message, userAddress]  \n          });  \n        };  \n      \n        return { userAddress, messageSigner };  \n      }  \n      \n      async createSession(partnerAddress) {  \n        const appDefinition = {  \n          protocol: 'payment-app-v1',  \n          participants: [this.userAddress, partnerAddress],  \n          weights: [50, 50],  \n          quorum: 100,  \n          challenge: 0,  \n          nonce: Date.now()  \n        };  \n      \n        const allocations = [  \n          { participant: this.userAddress, asset: 'usdc', amount: '800000' },  \n          { participant: partnerAddress, asset: 'usdc', amount: '200000' }  \n        ];  \n      \n        const sessionMessage = await createAppSessionMessage(  \n          this.messageSigner,  \n          [{ definition: appDefinition, allocations }]  \n        );  \n      \n        this.ws.send(sessionMessage);  \n        console.log('âœ… Payment session created!');  \n      }  \n      \n      async sendPayment(amount, recipient) {  \n        const paymentData = {  \n          type: 'payment',  \n          amount: amount.toString(),  \n          recipient,  \n          timestamp: Date.now()  \n        };  \n      \n        const signature = await this.messageSigner(JSON.stringify(paymentData));  \n          \n        this.ws.send(JSON.stringify({  \n          ...paymentData,  \n          signature,  \n          sender: this.userAddress  \n        }));  \n          \n        console.log(`ðŸ’¸ Sent ${amount} instantly!`);  \n      }  \n      \n      handleMessage(message) {  \n        switch (message.type) {  \n          case 'session_created':  \n            this.sessionId = message.sessionId;  \n            console.log('âœ… Session ready:', this.sessionId);  \n            break;  \n          case 'payment':  \n            console.log('ðŸ’° Payment received:', message.amount);  \n            break;  \n        }  \n      }  \n    }  \n      \n    // Usage  \n    const app = new SimplePaymentApp();  \n    await app.init();  \n    await app.createSession('0xPartnerAddress');  \n    await app.sendPayment('100000', '0xPartnerAddress'); // Send 0.1 USDC\n\nSummary: Provides a reference implementation for integrating the Yellow Network SDK, demonstrating wallet authentication, WebSocket connectivity to ClearNodes, and the lifecycle of creating a payment session.\n\nRelated terms: start payment, checkout, connect wallet, WebSocket, ClearNode, session creation, state channel, ERC-7824, nitrolite, multi-party, peer-to-peer, personal_sign, YellowNetwork, eth_requestAccounts\n\nUse cases: peer-to-peer payment, state channel initialization, Web3 wallet integration, ClearNode connectivity",
    "metadata": {
      "title": "Quick Start | Yellow Network",
      "url": "https://docs.yellow.org/docs/build/quick-start",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a reference implementation for integrating the Yellow Network SDK, demonstrating wallet authentication, WebSocket connectivity to ClearNodes, and the lifecycle of creating a payment session.",
      "keywords": [
        "start payment",
        "checkout",
        "connect wallet",
        "WebSocket",
        "ClearNode",
        "session creation",
        "state channel",
        "ERC-7824",
        "nitrolite",
        "multi-party",
        "peer-to-peer",
        "personal_sign",
        "YellowNetwork",
        "eth_requestAccounts"
      ],
      "function_name": "createAppSessionMessage",
      "intent": "tutorial",
      "use_cases": [
        "peer-to-peer payment",
        "state channel initialization",
        "Web3 wallet integration",
        "ClearNode connectivity"
      ],
      "function_names": [
        "AppSessionMessage",
        "eth_request",
        "session_created",
        "personal_sign",
        "Session"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## What's Next?â€‹\n\n\nCongratulations! You've built your first Yellow App. Here's what to explore next:\n\n  * **[Advanced Topics](/docs/learn/advanced/architecture)** : Learn about architecture, multi-party applications, and production deployment\n  * **[API Reference](/docs/api-reference)** : Explore all available SDK methods and options\n\nSummary: This section provides a roadmap for developers who have completed the initial setup, directing them toward advanced architectural concepts, multi-party application development, and production-ready deployment strategies.\n\nRelated terms: yellow network, sdk guide, next steps, developer roadmap, multi-party apps, production deployment, architecture, api reference, getting started, yellow app, crypto protocol, blockchain development, sdk tutorial\n\nUse cases: transitioning from sandbox to production, learning advanced protocol architecture, exploring multi-party payment logic",
    "metadata": {
      "title": "Quick Start | Yellow Network",
      "url": "https://docs.yellow.org/docs/build/quick-start",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section provides a roadmap for developers who have completed the initial setup, directing them toward advanced architectural concepts, multi-party application development, and production-ready deployment strategies.",
      "keywords": [
        "yellow network",
        "sdk guide",
        "next steps",
        "developer roadmap",
        "multi-party apps",
        "production deployment",
        "architecture",
        "api reference",
        "getting started",
        "yellow app",
        "crypto protocol",
        "blockchain development",
        "sdk tutorial"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "transitioning from sandbox to production",
        "learning advanced protocol architecture",
        "exploring multi-party payment logic"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Need Help?â€‹\n\n\n  * **Documentation** : Continue reading the guides for in-depth explanations\n  * **Community** : Join our developer community for support\n  * **Examples** : Check out our GitHub repository for sample applications\n\nYou're now ready to build fast, scalable apps with Yellow SDK!\n\n\n\n  * What You'll Build\n  * Prerequisites\n  * Step 1: Installation\n  * Step 2: Connect to ClearNode\n  * Step 3: Create Application Session\n  * Step 4: Create Application Session\n  * Step 5: Send Instant Payments\n  * Step 6: Handle Incoming Messages\n  * Complete Example\n  * What's Next?\n  * Need Help?\n\nSummary: This section provides a high-level roadmap and support resources for developers to begin integrating the Yellow SDK, covering the end-to-end process from installation to sending instant payments.\n\nRelated terms: quick start, getting started, Yellow SDK, ClearNode connection, application session, instant payments, message handling, developer guide, installation, crypto payments, state channel, SDK setup, Yellow Network, tutorial, sample code\n\nUse cases: Initial SDK integration and setup, Establishing a connection to the ClearNode infrastructure, Implementing basic peer-to-peer instant payment flows",
    "metadata": {
      "title": "Quick Start | Yellow Network",
      "url": "https://docs.yellow.org/docs/build/quick-start",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section provides a high-level roadmap and support resources for developers to begin integrating the Yellow SDK, covering the end-to-end process from installation to sending instant payments.",
      "keywords": [
        "quick start",
        "getting started",
        "Yellow SDK",
        "ClearNode connection",
        "application session",
        "instant payments",
        "message handling",
        "developer guide",
        "installation",
        "crypto payments",
        "state channel",
        "SDK setup",
        "Yellow Network",
        "tutorial",
        "sample code"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "Initial SDK integration and setup",
        "Establishing a connection to the ClearNode infrastructure",
        "Implementing basic peer-to-peer instant payment flows"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Guides\n\n# Guides\n\n**[Migration Guide](/docs/guides/migration-guide)** \\- Guide for migrating from previous versions of the Yellow SDK.\n\n**[Multi-Party App Sessions](/docs/guides/multi-party-app-sessions)** \\- Learn how to create, manage, and close multi-party application sessions using the Yellow Network and Nitrolite protocol.\n\n\n\n[NextMigration Guide](/docs/guides/migration-guide)\n\nSummary: Provides a directory of guides for migrating between SDK versions and managing multi-party application sessions using the Nitrolite protocol.\n\nRelated terms: migration, upgrade, multi-party, app sessions, Nitrolite, session management, state channel, payment protocol, yellow network, sdk update, multi-sig, p2p, session lifecycle\n\nUse cases: upgrading SDK versions, implementing multi-party state channels, managing application session lifecycles",
    "metadata": {
      "title": "Guides | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a directory of guides for migrating between SDK versions and managing multi-party application sessions using the Nitrolite protocol.",
      "keywords": [
        "migration",
        "upgrade",
        "multi-party",
        "app sessions",
        "Nitrolite",
        "session management",
        "state channel",
        "payment protocol",
        "yellow network",
        "sdk update",
        "multi-sig",
        "p2p",
        "session lifecycle"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "upgrading SDK versions",
        "implementing multi-party state channels",
        "managing application session lifecycles"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Migration Guide\n\n\n\n# Migration Guide\n\nIf you are coming from an earlier version of Nitrolite, you will need to account for the following breaking changes.\n\nSummary: Provides guidance and identifies breaking changes for developers transitioning from legacy Nitrolite versions to the current Yellow Network SDK.\n\nRelated terms: migration, upgrade, breaking changes, Nitrolite, versioning, update, legacy, compatibility, deprecation, transition, Yellow Network, SDK update, Nitrolite migration, Nitrolite upgrade\n\nUse cases: upgrading from Nitrolite to Yellow Network, handling breaking changes in SDK updates, maintaining legacy payment integrations",
    "metadata": {
      "title": "Migration Guide | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/migration-guide",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides guidance and identifies breaking changes for developers transitioning from legacy Nitrolite versions to the current Yellow Network SDK.",
      "keywords": [
        "migration",
        "upgrade",
        "breaking changes",
        "Nitrolite",
        "versioning",
        "update",
        "legacy",
        "compatibility",
        "deprecation",
        "transition",
        "Yellow Network",
        "SDK update",
        "Nitrolite migration",
        "Nitrolite upgrade"
      ],
      "function_name": null,
      "intent": "migration",
      "use_cases": [
        "upgrading from Nitrolite to Yellow Network",
        "handling breaking changes in SDK updates",
        "maintaining legacy payment integrations"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## 0.5.x Breaking changesâ€‹\n\n\nThe 0.5.x release includes fundamental protocol changes affecting session keys, channel operations, state signatures, and channel resize rules. The main objective of these changes is to enhance security, and provide better experience for developers and users by ability to limit allowances for specific applications.\n\n**Not ready to migrate?** Unfortunately, at this time Yellow Network does not provide ClearNodes running the previous version of the protocol, so you will need to migrate to the latest version to continue using the Network.\n\n### Protocol Changesâ€‹\n\nThese protocol-level changes affect all implementations and integrations with the Yellow Network.\n\n#### Session Keys: Applications, Allowances, and Expirationâ€‹\n\nSession keys now have enhanced properties that define their access levels and capabilities:\n\n  * **Application field** : Determines the scope of session key permissions. Setting this to an application name (e.g., \"My Trading App\") grants application-scoped access with enforced allowances. Setting it to \"clearnode\" grants root access equivalent to the wallet itself.\n\n  * **Allowances field** : Defines spending limits for application-scoped session keys. These limits are tracked cumulatively across all operations and are enforced by the protocol.\n\n  * **Expires_at field** : Uses a bigint timestamp (seconds since epoch). Once expired, session keys are permanently frozen and cannot be reactivated. This is particularly critical for root access keys (application set to \"clearnode\") - if they expire, you lose the ability to perform channel operations.\n\n\n#### Channel Creation: Separate Create and Fund Stepsâ€‹\n\nClearnode no longer supports creating channels with an initial deposit. All channels must be created with zero balance and funded separately through a resize operation. This two-step process ensures cleaner state management and prevents edge cases in channel initialization.\n\n#### State Signatures: Wallet vs Session Key Signingâ€‹\n\nA fundamental change in how channel states are signed:\n\n  * **Channels created before v0.5.0** : The participant address is the session key, and all states must be signed by that session key.\n\n  * **Channels created after v0.5.0** : The participant address is the wallet address, and all states must be signed by the wallet.\n\n\nThis change improves security and aligns with standard practices, but requires careful handling during the transition period.\n\n#### Resize Operations: Strict Channel Balance Rulesâ€‹\n\nThe protocol now enforces strict rules about channel balances and their impact on other operations:\n\n  * **Blocked operations** : Users with any channel containing non-zero amounts cannot perform transfers, submit app states with deposit intent, or create app sessions with non-zero allocations.\n\n  * **Resizing state** : After a resize request, channels enter a \"resizing\" state with locked funds until the on-chain transaction is confirmed. If a channel remains stuck in this state for an extended period, the recommended action is to close the channel and create a new one.\n\n  * **Allocate amount semantics** : The resize operation uses `allocate_amount` where negative values withdraw from the channel to unified balance, and positive values deposit to the channel.\n\n\nwarning\n\n**Legacy channel migration** : Users with existing channels containing non-zero amounts must either resize them to zero (by providing \"resize_amount\" as 0 and \"allocate_amount\" as your **negative** on-chain balance) or close them to enable full protocol functionality. If you are unsure how to adjust resize parameters, the safe option is to close the old on-chain channel entirely, and open a new one.\n\n#### Non-Zero Channel Allocations: Operation Restrictionsâ€‹\n\nThe following operations will return errors if the user has any channel with non-zero amount:\n\n  * **Transfer** : Returns error code indicating blocked due to non-zero channel balance\n  * **Submit App State** (with deposit intent): Rejected if attempting to deposit\n  * **Create App Session** (with allocations): Rejected if attempting to allocate\n\nThe returned error has the following format: `operation denied: non-zero allocation in <count> channel(s) detected owned by wallet <address>\"`\n\n### Nitrolite SDKâ€‹\n\nYou should definitely read this section if you are using the Nitrolite SDK.\n\n#### Update Authenticationâ€‹\n\nImplementing the new session key protocol changes:\n\n  * Application Session Key\n  * Root Access (Clearnode)\n    \n    \n    const authRequest = {  \n      address: '0x...',  \n      session_key: '0x...',  \n      application: 'My Trading App', // Application name for confined access  \n      allowances: [  \n        { asset: 'usdc', amount: '1000.0' },  \n        { asset: 'eth', amount: '0.5' }  \n      ],  \n      scope: 'app.create',  \n      expires_at: BigInt(Math.floor(Date.now() / 1000) + 7 * 24 * 60 * 60) // 7 days  \n    };  \n    \n    \n    \n    const authRequest = {  \n      address: '0x...',  \n      session_key: '0x...',  \n      application: 'clearnode', // Special value for root access  \n      allowances: [], // Not enforced for root access  \n      scope: 'app.create',  \n      expires_at: BigInt(Math.floor(Date.now() / 1000) + 365 * 24 * 60 * 60) // Long expiration recommended  \n    };  \n    \n\n**Important considerations:**\n\n  * Root access keys (application: \"clearnode\") cannot perform channel operations after expiration\n  * Plan expiration times based on your operational needs\n  * Application-scoped keys track cumulative spending against allowances\n\n#### Auth Verify Changesâ€‹\n\nThe `createEIP712AuthMessageSigner` function signature has changed to align with the new session key structure.\n    \n    \n    const eip712SigningFunction = createEIP712AuthMessageSigner(  \n        walletClient,  \n        {  \n            scope: authMessage.scope,  \n            application: authMessage.application,  \n            participant: authMessage.session_key,  \n            expire: authMessage.expire,  \n            session_key: authMessage.session_key,  \n            expires_at: authMessage.expires_at,  \n            allowances: authMessage.allowances,  \n        },  \n        getAuthDomain(),  \n    );  \n    \n\n#### Migrate Channel Creationâ€‹\n\nChannels must now be created with zero initial deposit and funded separately via the `resizeChannel` method:\n    \n    \n    const { channelId } = await client.createChannel({  \n      chain_id: 1,  \n      token: tokenAddress,  \n      amount: BigInt(1000000), // Initial deposit  \n      session_key: '0x...' // Optional  \n    });  \n      \n    // Step 2: Fund the channel separately  \n    await client.resizeChannel({  \n      channel_id: channelId,  \n      amount: BigInt(1000000),  \n    });  \n    \n\n#### Resize correctlyâ€‹\n\nChannel resizing must be negotiated with the ClearNode through WebSocket. Use `resize_amount` and `allocate_amount` with correct sign convention (`resize_amount = -allocate_amount`) and help users with non-zero channel balances migrate by resizing to zero or reopening channels.\n\nChannel resize can be requested as follows:\n    \n    \n    const resizeMessage = await createResizeChannelMessage(messageSigner, {  \n      channel_id: channelId,  \n      resize_amount: BigInt(50), // Positive = deposit to channel, negative = withdraw from channel to custody ledger  \n      allocate_amount: BigInt(-50), // Negative = deposit to unified balance, negative = withdraw from unified balance to channel  \n      funds_destination: walletAddress,  \n    });  \n      \n    const resizeResponse = {}; // send the message and wait for Clearnode's response  \n      \n    const { params: resizeResponseParams } = parseResizeChannelResponse(resizeResponse);  \n    const resizeParams = {  \n      resizeState: {  \n          channelId,  \n          ...resizeResponseParams.state,  \n          serverSignature: resizeResponseParams.serverSignature,  \n          data: resizeResponseParams.state.stateData as Hex,  \n          version: BigInt(resizeResponseParams.state.version),  \n      },  \n      // `previousState` is either initial or previous resizing state, depending on which has higher version number  \n      // can be obtained with `await (client.getChannelData(channelId)).lastValidState`  \n      proofStates: [previousState],  \n    }  \n      \n    const {txHash} = await client.resizeChannel(resizeParams);  \n    \n\nHere is how you can migrate your channels:\n    \n    \n    // Check and migrate channels with non-zero amounts  \n    const channels = await client.getOpenChannels();  \n      \n    for (const channel of channels) {  \n      if (channel.amount > 0) {  \n        // Must empty channel to enable transfers/app operations  \n        const resizeMessage = await createResizeChannelMessage(messageSigner, {  \n          channel_id: channel.channelId,  \n          resize_amount: BigInt(0),  \n          allocate_amount: -BigInt(channel.amount),  \n          funds_destination: walletAddress,  \n        });  \n          \n        // perform the resize as shown above  \n      }  \n    }  \n    \n\n**Critical:** Operations blocked when any channel has non-zero amount:\n\n  * Off-chain transfers\n  * App state submissions with deposit intent\n  * Creating app sessions with allocations\n\n#### Test State Signaturesâ€‹\n\nIf you plan to work with on-chain channels opened PRIOR to v0.5.0, then on NitroliteClient initialization the `stateSigner` you specify must be based on a Session Key used in the channel as participant. Even if this session key is or will expire, you still need to provide a `stateSigner` based on it.\n\nOn the other hand, if you plan to work with channels created SINCE v0.5.0, you can specify the `stateSigner` based on the `walletClient` you have specified.\n\n#### Manage Session Keysâ€‹\n\nNew methods have been added for comprehensive session key management, including retrieval and revocation.\n    \n    \n    // Get all active session keys  \n    const sessionKeys = await client.getSessionKeys();  \n      \n    // Revoke a specific session key  \n    await client.revokeSessionKey({  \n      session_key: '0x...'  \n    });  \n      \n    // Session key data structure  \n    interface RPCSessionKey {  \n      id: string;  \n      sessionKey: Address;  \n      application: string;  \n      allowances: RPCAllowanceUsage[]; // Includes usage tracking  \n      scope: string;  \n      expiresAt: bigint;  \n      createdAt: bigint;  \n    }  \n    \n\n#### EIP-712 Signatures: String-based Amountsâ€‹\n\nEIP-712 signature types now use string values for amounts instead of numeric types to support better precision with decimal values.\n    \n    \n    const types = {  \n      Allowance: [  \n        { name: 'asset', type: 'string' },  \n        { name: 'amount', type: 'uint256' },  \n        { name: 'amount', type: 'string' },  \n      ]  \n    };  \n    \n\n### ClearNode APIâ€‹\n\nYou should read this section only if you are using the ClearNode API directly.\n\n#### Update Authenticationâ€‹\n\nUse the new session key parameters with proper `application`, `allowances`, and `expires_at` fields:\n\n  * Application Auth\n  * Root Auth (Clearnode)\n    \n    \n    {  \n      \"req\": [1, \"auth_request\", {  \n        \"address\": \"0x1234567890abcdef...\",  \n        \"session_key\": \"0x9876543210fedcba...\",  \n        \"application\": \"My Trading App\",  \n        \"allowances\": [  \n          { \"asset\": \"usdc\", \"amount\": \"1000.0\" },  \n          { \"asset\": \"eth\", \"amount\": \"0.5\" }  \n        ],  \n        \"scope\": \"app.create\",  \n        \"expires_at\": 1719123456789  \n      }, 1619123456789],  \n      \"sig\": [\"0x...\"]  \n    }  \n    \n    \n    \n    {  \n      \"req\": [1, \"auth_request\", {  \n        \"address\": \"0x1234567890abcdef...\",  \n        \"session_key\": \"0x9876543210fedcba...\",  \n        \"application\": \"clearnode\",  \n        \"allowances\": [],  \n        \"scope\": \"app.create\",  \n        \"expires_at\": 1750659456789  \n      }, 1619123456789],  \n      \"sig\": [\"0x...\"]  \n    }  \n    \n\n#### Migrate Channel Creationâ€‹\n\nImplement the two-step process (create empty, then resize to fund)\n\nThe `create_channel` method no longer accepts `amount` and `session_key` parameters:\n    \n    \n    {  \n      \"req\": [1, \"create_channel\", {  \n        \"chain_id\": 137,  \n        \"token\": \"0xeeee567890abcdef...\",  \n        \"amount\": \"100000000\",  \n        \"session_key\": \"0x1234567890abcdef...\"  \n      }, 1619123456789],  \n      \"sig\": [\"0x9876fedcba...\"]  \n    }  \n    \n\n#### Manage Session Keysâ€‹\n\nNew methods for session key operations have been added.\n\n##### Get Session Keysâ€‹\n\nRequest:\n    \n    \n    {  \n      \"req\": [1, \"get_session_keys\", {}, 1619123456789],  \n      \"sig\": [\"0x...\"]  \n    }  \n    \n\nResponse:\n    \n    \n    {  \n      \"res\": [1, \"get_session_keys\", {  \n        \"session_keys\": [{  \n          \"id\": \"sk_123\",  \n          \"session_key\": \"0x9876543210fedcba...\",  \n          \"application\": \"My Trading App\",  \n          \"allowances\": [  \n            { \"asset\": \"usdc\", \"amount\": \"1000.0\", \"used\": \"250.0\" }  \n          ],  \n          \"scope\": \"app.create\",  \n          \"expires_at\": 1719123456789,  \n          \"created_at\": 1619123456789  \n        }]  \n      }, 1619123456789],  \n      \"sig\": [\"0x...\"]  \n    }  \n    \n\n##### Revoke Session Key Requestâ€‹\n\nRequest:\n    \n    \n    {  \n      \"req\": [1, \"revoke_session_key\", {  \n        \"session_key\": \"0x1234567890abcdef...\"  \n      }, 1619123456789],  \n      \"sig\": [\"0x...\"]  \n    }  \n    \n\nResponse:\n    \n    \n    {  \n      \"res\": [1, \"revoke_session_key\", {  \n        \"session_key\": \"0x1234567890abcdef...\"  \n      }, 1619123456789],  \n      \"sig\": [\"0x...\"]  \n    }\n\nSummary: This guide details breaking protocol changes in version 0.5.x, introducing granular session key permissions, mandatory two-step channel funding, and updated state signature requirements to improve security and developer experience.\n\nRelated terms: migration, breaking changes, session keys, channel creation, allowances, expiration, clearnode, state signatures, funding, resize operation, EIP-712, wallet signing, root access, security update, 0.5.x\n\nUse cases: Upgrading SDK to version 0.5.x, Implementing application-specific spending limits, Refactoring channel initialization workflows, Managing session key expiration and security",
    "metadata": {
      "title": "Migration Guide | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/migration-guide",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This guide details breaking protocol changes in version 0.5.x, introducing granular session key permissions, mandatory two-step channel funding, and updated state signature requirements to improve security and developer experience.",
      "keywords": [
        "migration",
        "breaking changes",
        "session keys",
        "channel creation",
        "allowances",
        "expiration",
        "clearnode",
        "state signatures",
        "funding",
        "resize operation",
        "EIP-712",
        "wallet signing",
        "root access",
        "security update",
        "0.5.x"
      ],
      "function_name": "create_channel",
      "intent": "migration",
      "use_cases": [
        "Upgrading SDK to version 0.5.x",
        "Implementing application-specific spending limits",
        "Refactoring channel initialization workflows",
        "Managing session key expiration and security"
      ],
      "function_names": [
        "EIP712AuthMessageSigner",
        "xpires_at",
        "create_channel",
        "get_session_keys",
        "resize_amount"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## 0.3.x Breaking changesâ€‹\n\n\nThe 0.3.x release includes breaking changes to the SDK architecture, smart contract interfaces, and Clearnode API enhancements listed below.\n\n**Not ready to migrate?** Unfortunately, at this time Yellow Network does not provide ClearNodes running the previous version of the protocol, so you will need to migrate to the latest version to continue using the Network.\n\n### Nitrolite SDKâ€‹\n\nYou should definitely read this section if you are using the Nitrolite SDK.\n\n#### Client: Replaced `stateWalletClient` with `StateSigner`â€‹\n\nThe `stateWalletClient` parameter of `NitroliteClient` has been replaced with a required `stateSigner` parameter that implements the `StateSigner` interface.\n\nWhen initializing the client, you should use either `WalletStateSigner` or `SessionKeyStateSigner` to handle state signing.\n    \n    \n    import { createNitroliteClient } from '@erc7824/nitrolite';  \n    import {   \n      createNitroliteClient,  \n      WalletStateSigner  \n    } from '@erc7824/nitrolite';  \n      \n    const client = createNitroliteClient({  \n      publicClient,  \n      walletClient,  \n      stateWalletClient: sessionWalletClient,  \n      stateSigner: new WalletStateSigner(walletClient),  \n      addresses,  \n    });  \n    \n\n**For session key signing:**\n    \n    \n    import { SessionKeyStateSigner } from '@erc7824/nitrolite';  \n      \n    const stateSigner = new SessionKeyStateSigner('0x...' as Hex);  \n    \n\n#### Actions: Modified `createChannel` Parametersâ€‹\n\nThe `CreateChannelParams` interface has been fully restructured for better clarity.\n\nYou should use the new `CreateChannel` ClearNode API endpoint to get the response, that fully resembles the channel creation parameters.\n    \n    \n    const { channelId, initialState, txHash } = await client.createChannel(  \n      tokenAddress,  \n      {  \n        initialAllocationAmounts: [amount1, amount2],  \n        stateData: '0x...',  \n      }  \n    );  \n    const { channelId, initialState, txHash } = await client.createChannel({  \n      channel: {  \n        participants: [address1, address2],  \n        adjudicator: adjudicatorAddress,  \n        challenge: 86400n,  \n        nonce: 42n,  \n      },  \n      unsignedInitialState: {  \n        intent: StateIntent.Initialize,  \n        version: 0n,  \n        data: '0x',  \n        allocations: [  \n          { destination: address1, token: tokenAddress, amount: amount1 },  \n          { destination: address2, token: tokenAddress, amount: amount2 },  \n        ],  \n      },  \n      serverSignature: '0x...',  \n    });  \n    \n\n#### Actions: Structured Typed RPC Request Parametersâ€‹\n\nRPC requests now use endpoint-specific object-based parameters instead of untyped arrays for improved type safety.\n\nYou should update your RPC request creation code to use the new structured format and RPC types.\n    \n    \n    const request = NitroliteRPC.createRequest(  \n      requestId,  \n      RPCMethod.GetChannels,  \n      [participant, status],  \n      timestamp  \n    );  \n    const request = NitroliteRPC.createRequest({  \n      method: RPCMethod.GetChannels,  \n      params: {  \n        participant,  \n        status,  \n      },  \n      requestId,  \n      timestamp,  \n    });  \n    \n\n#### Actions: Standardized Channel Operations Responsesâ€‹\n\nThe responses for `CloseChannel` and `ResizeChannel` methods have been aligned with newly added `CreateChannel` endpoint for consistency.\n\nUpdate your response handling code to use the new `RPCChannelOperation` type.\n    \n    \n    export interface ResizeChannelResponseParams {  \n      channelId: Hex;  \n      stateData: Hex;  \n      intent: number;  \n      version: number;  \n      allocations: RPCAllocation[];  \n      stateHash: Hex;  \n      serverSignature: ServerSignature;  \n    }  \n      \n    export interface CloseChannelResponseParams {  \n      channelId: Hex;  \n      intent: number;  \n      version: number;  \n      stateData: Hex;  \n      allocations: RPCAllocation[];  \n      stateHash: Hex;  \n      serverSignature: ServerSignature;  \n    }  \n    export interface RPCChannelOperation {  \n      channelId: Hex;  \n      state: RPCChannelOperationState;  \n      serverSignature: Hex;  \n    }  \n      \n    export interface CreateChannelResponse extends GenericRPCMessage {  \n      method: RPCMethod.CreateChannel;  \n      params: RPCChannelOperation & {  \n        channel: RPCChannel;  \n      };  \n    }  \n      \n    export interface ResizeChannelResponse extends GenericRPCMessage {  \n      method: RPCMethod.ResizeChannel;  \n      params: RPCChannelOperation;  \n    }  \n      \n    export interface CloseChannelResponse extends GenericRPCMessage {  \n      method: RPCMethod.CloseChannel;  \n      params: RPCChannelOperation;  \n    }  \n    \n\n#### Actions: Modified `Signature` Typeâ€‹\n\nThe `Signature` struct has been replaced with a simple `Hex` type to support EIP-1271 and EIP-6492 signatures.\n\nUpdate your signature-handling code to use the new `Hex` type. Still, if using Nitrolite utils correctly, you will not need to change anything, as the utils will handle the conversion for you.\n    \n    \n    interface Signature {  \n      v: number;  \n      r: Hex;  \n      s: Hex;  \n    }  \n      \n    const sig: Signature = {  \n      v: 27,  \n      r: '0x...',  \n      s: '0x...'  \n    };  \n    type Signature = Hex;  \n      \n    const sig: Signature = '0x...';  \n    \n\n#### Added: Pagination Types and Parametersâ€‹\n\nTo support pagination in ClearNode API requests, new types and parameters have been added.\n\nFor now, only `GetLedgerTransactions` request has been updated to include pagination.\n    \n    \n    export interface PaginationFilters {  \n        /** Pagination offset. */  \n        offset?: number;  \n        /** Number of transactions to return. */  \n        limit?: number;  \n        /** Sort order by created_at. */  \n        sort?: 'asc' | 'desc';  \n    }  \n    \n\n### Clearnode APIâ€‹\n\nYou should read this section only if you are using the ClearNode API directly, or if you are using the Nitrolite SDK with custom ClearNode API requests.\n\n#### Actions: Structured Request Parametersâ€‹\n\nClearNode API requests have migrated from array-based parameters to structured object parameters for improved type safety and API clarity.\n\nUpdate all your ClearNode API requests to use object-based parameters instead of arrays.\n    \n    \n    {  \n      \"req\": [1, \"auth_request\", [{  \n      \"req\": [1, \"auth_request\", {  \n        \"address\": \"0x1234567890abcdef...\",  \n        \"session_key\": \"0x9876543210fedcba...\",  \n        \"app_name\": \"Example App\",  \n        \"allowances\": [ \"usdc\", \"100.0\" ],  \n        \"allowances\": [  \n          {  \n            \"asset\": \"usdc\",  \n            \"amount\": \"100.0\"  \n          }  \n        ],  \n        \"scope\": \"app.create\",  \n        \"expire\": \"3600\",  \n        \"application\": \"0xApp1234567890abcdef...\"  \n      }], 1619123456789],  \n      }, 1619123456789],  \n      \"sig\": [\"0x5432abcdef...\"]  \n    }  \n    \n\n#### Added: `create_channel` Methodâ€‹\n\nA new `create_channel` method has been added to facilitate the improved single-transaction channel opening flow.\n\nUse this method to request channel creation parameters from the broker, then submit the returned data to the smart contract via Nitrolite SDK or directly.\n\n**Request:**\n    \n    \n    {  \n      \"req\": [1, \"create_channel\", {  \n        \"chain_id\": 137,  \n        \"token\": \"0xeeee567890abcdef...\",  \n        \"amount\": \"100000000\",  \n        \"session_key\": \"0x1234567890abcdef...\" // Optional  \n      }, 1619123456789],  \n      \"sig\": [\"0x9876fedcba...\"]  \n    }  \n    \n\n**Response:**\n    \n    \n    {  \n      \"res\": [1, \"create_channel\", {  \n        \"channel_id\": \"0x4567890123abcdef...\",  \n        \"channel\": {  \n          \"participants\": [\"0x1234567890abcdef...\", \"0xbbbb567890abcdef...\"],  \n          \"adjudicator\": \"0xAdjudicatorContractAddress...\",  \n          \"challenge\": 3600,  \n          \"nonce\": 1619123456789  \n        },  \n        \"state\": {  \n          \"intent\": 1,  \n          \"version\": 0,  \n          \"state_data\": \"0xc0ffee\",  \n          \"allocations\": [  \n            {  \n              \"destination\": \"0x1234567890abcdef...\",  \n              \"token\": \"0xeeee567890abcdef...\",  \n              \"amount\": \"100000000\"  \n            },  \n            {  \n              \"destination\": \"0xbbbb567890abcdef...\",  \n              \"token\": \"0xeeee567890abcdef...\",  \n              \"amount\": \"0\"  \n            }  \n          ]  \n        },  \n        \"server_signature\": \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1c\"  \n      }, 1619123456789],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    \n\n#### API: Standardized Channel Operation Responsesâ€‹\n\nThe responses for `create_channel`, `close_channel`, and `resize_channel` methods have been unified for consistency.\n\nUpdate your response parsing to handle the new unified structure with `channel_id`, `state`, and `server_signature` fields.\n    \n    \n    {  \n      \"res\": [1, \"close_channel\", {  \n        \"channelId\": \"0x4567890123abcdef...\",  \n        \"intent\": 3,  \n        \"version\": 123,  \n        \"stateData\": \"0x0000000000000000000000000000000000000000000000000000000000001ec7\",  \n        \"allocations\": [...],  \n        \"stateHash\": \"0x...\",  \n        \"serverSignature\": \"0x...\"  \n      }, 1619123456789],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    {  \n      \"res\": [1, \"close_channel\", {  \n        \"channel_id\": \"0x4567890123abcdef...\",  \n        \"state\": {  \n          \"intent\": 3,  \n          \"version\": 123,  \n          \"state_data\": \"0xc0ffee\",  \n          \"allocations\": [  \n            {  \n              \"destination\": \"0x1234567890abcdef...\",  \n              \"token\": \"0xeeee567890abcdef...\",  \n              \"amount\": \"50000\"  \n            }  \n          ]  \n        },  \n        \"server_signature\": \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1c\"  \n      }, 1619123456789],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    \n\n#### Added: Pagination Metadataâ€‹\n\nPagination-supporting endpoints now include a `metadata` struct in their responses with pagination information.\n\nUpdate your response handling for `get_channels`, `get_app_sessions`, `get_ledger_entries`, and `get_ledger_transactions` to use the new metadata structure.\n    \n    \n    {  \n      \"res\": [1, \"get_channels\", [  \n        [  \n          {  \n            \"channel_id\": \"0xfedcba9876543210...\",  \n            \"status\": \"open\",  \n            // ... channel data  \n          }  \n        ]  \n      ], 1619123456789],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    {  \n      \"res\": [1, \"get_channels\", {  \n        \"channels\": [  \n          {  \n            \"channel_id\": \"0xfedcba9876543210...\",  \n            \"status\": \"open\",  \n            // ... channel data  \n          }  \n        ],  \n        \"metadata\": {  \n          \"page\": 1,  \n          \"per_page\": 10,  \n          \"total_count\": 56,  \n          \"page_count\": 6  \n        }  \n      }, 1619123456789],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    \n\nThe metadata fields provide:\n\n  * `page`: Current page number\n  * `per_page`: Number of items per page\n  * `total_count`: Total number of items available\n  * `page_count`: Total number of pages\n\n### Contractsâ€‹\n\nYou should read this section only if you are using the Nitrolite smart contracts directly.\n\n#### Action: Replaced `Signature` Struct with `bytes`â€‹\n\nThe `Signature` struct has been removed and replaced with `bytes` type to support EIP-1271, EIP-6492, and other signature formats.\n\nUpdate all contract interactions that use signatures to pass `bytes` instead of the struct.\n    \n    \n    struct Signature {  \n      uint8 v;  \n      bytes32 r;  \n      bytes32 s;  \n    }  \n      \n    function join(  \n      bytes32 channelId,  \n      uint256 index,  \n      Signature calldata sig  \n    ) external returns (bytes32);  \n      \n    function challenge(  \n      bytes32 channelId,  \n      State calldata candidate,  \n      State[] calldata proofs,  \n      Signature calldata challengerSig  \n    ) external;  \n    // Signature struct is removed  \n      \n    function join(  \n      bytes32 channelId,  \n      uint256 index,  \n      bytes calldata sig  \n    ) external returns (bytes32);  \n      \n    function challenge(  \n      bytes32 channelId,  \n      State calldata candidate,  \n      State[] calldata proofs,  \n      bytes calldata challengerSig  \n    ) external;  \n    \n\n#### Actions: Updated `State` Signature Arrayâ€‹\n\nThe `State` struct now uses `bytes[]` for signatures instead of `Signature[]`.\n    \n    \n    struct State {  \n      uint8 intent;  \n      uint256 version;  \n      bytes data;  \n      Allocation[] allocations;  \n      Signature[] sigs;  \n      bytes[] sigs;  \n    }  \n    \n\n#### Added: Auto-Join Channel Creation Flowâ€‹\n\nChannels can now become operational immediately after the `create()` call if all participant signatures are provided.\n\nWhen calling `create()` with complete signatures from all participants, the channel automatically becomes active without requiring a separate `join()` call.\n\n**Single signature (requires join):**\n    \n    \n    // Create channel with only creator's signature  \n    State memory initialState = State({  \n        intent: StateIntent.Fund,  \n        version: 0,  \n        data: \"0x\",  \n        allocations: allocations,  \n        sigs: [creatorSignature] // Only one signature  \n    });  \n      \n    bytes32 channelId = custody.create(channel, initialState);  \n    // Channel status: JOINING - requires server to call join()  \n    \n\n**Complete signatures (auto-active):**\n    \n    \n    // Create channel with all participants' signatures  \n    State memory initialState = State({  \n        intent: StateIntent.Fund,  \n        version: 0,  \n        data: \"0x\",  \n        allocations: allocations,  \n        sigs: [creatorSignature, serverSignature] // All signatures  \n    });  \n      \n    bytes32 channelId = custody.create(channel, initialState);  \n    // Channel status: ACTIVE - ready for use immediately  \n    \n\n#### Actions: Update Adjudicator Contracts for EIP-712 Supportâ€‹\n\nA new `EIP712AdjudicatorBase` base contract has been added to support EIP-712 typed structured data signatures in adjudicator implementations.\n\nThe `EIP712AdjudicatorBase` provides:\n\n  * **Domain separator retrieval** : Gets EIP-712 domain separator from the channel implementation contract\n  * **ERC-5267 compliance** : Automatically handles EIP-712 domain data retrieval\n  * **Ownership management** : Built-in access control for updating channel implementation address\n  * **Graceful fallbacks** : Returns `NO_EIP712_SUPPORT` constant when EIP-712 is not available\n\nIf you have custom adjudicator contracts, inherit from `EIP712AdjudicatorBase` to enable EIP-712 signature verification.\n    \n    \n    import {IAdjudicator} from \"../interfaces/IAdjudicator.sol\";  \n    import {Channel, State, Allocation, StateIntent} from \"../interfaces/Types.sol\";  \n      \n    contract MyAdjudicator is IAdjudicator {  \n        function adjudicate(  \n            Channel calldata chan,   \n            State calldata candidate,   \n            State[] calldata proofs  \n        ) external view override returns (bool valid) {  \n            return candidate.validateUnanimousSignatures(chan);  \n        }  \n    }  \n    import {IAdjudicator} from \"../interfaces/IAdjudicator.sol\";  \n    import {Channel, State, Allocation, StateIntent} from \"../interfaces/Types.sol\";  \n    import {EIP712AdjudicatorBase} from \"./EIP712AdjudicatorBase.sol\";  \n      \n    contract MyAdjudicator is IAdjudicator, EIP712AdjudicatorBase {  \n        constructor(address owner, address channelImpl)   \n            EIP712AdjudicatorBase(owner, channelImpl) {}  \n      \n        function adjudicate(  \n            Channel calldata chan,   \n            State calldata candidate,   \n            State[] calldata proofs  \n        ) external override returns (bool valid) {  \n            bytes32 domainSeparator = getChannelImplDomainSeparator();  \n            return candidate.validateUnanimousStateSignatures(chan, domainSeparator);  \n        }  \n    }  \n    \n\n#### Added: Enhanced Signature Supportâ€‹\n\nSmart contracts now support EIP-191, EIP-712, EIP-1271, and EIP-6492 signature formats for greater compatibility.\n\nThe contracts automatically detect and verify the appropriate signature format:\n\n  * **Raw ECDSA** : Traditional `(r, s, v)` signatures\n  * **EIP-191** : Personal message signatures (`\\x19Ethereum Signed Message:\\n`)\n  * **EIP-712** : Typed structured data signatures\n  * **EIP-1271** : Smart contract wallet signatures\n  * **EIP-6492** : Signatures for undeployed contracts\n\nNo changes are needed in your contract calls - the signature verification is handled automatically by the contract.\n\n\n\n[PreviousGuides](/docs/guides/)[NextMulti-Party Application Sessions](/docs/guides/multi-party-app-sessions)\n\n  * 0.5.x Breaking changes\n    * Protocol Changes\n    * Nitrolite SDK\n    * ClearNode API\n  * 0.3.x Breaking changes\n    * Nitrolite SDK\n    * Clearnode API\n    * Contracts\n\nSummary: This migration guide outlines breaking architectural changes in version 0.3.x of the Nitrolite SDK, specifically focusing on the transition to a dedicated state signing interface and restructured channel creation parameters.\n\nRelated terms: migration, breaking changes, Nitrolite SDK, state signing, channel creation, WalletStateSigner, SessionKeyStateSigner, createChannel, upgrade guide, Yellow Network, state update, session keys, NitroliteClient, version 0.3.x\n\nUse cases: Upgrading SDK to version 0.3.x, Implementing session key signing for state updates, Refactoring channel creation parameters for ClearNode API compatibility",
    "metadata": {
      "title": "Migration Guide | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/migration-guide",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This migration guide outlines breaking architectural changes in version 0.3.x of the Nitrolite SDK, specifically focusing on the transition to a dedicated state signing interface and restructured channel creation parameters.",
      "keywords": [
        "migration",
        "breaking changes",
        "Nitrolite SDK",
        "state signing",
        "channel creation",
        "WalletStateSigner",
        "SessionKeyStateSigner",
        "createChannel",
        "upgrade guide",
        "Yellow Network",
        "state update",
        "session keys",
        "NitroliteClient",
        "version 0.3.x"
      ],
      "function_name": "createNitroliteClient",
      "intent": "migration",
      "use_cases": [
        "Upgrading SDK to version 0.3.x",
        "Implementing session key signing for state updates",
        "Refactoring channel creation parameters for ClearNode API compatibility"
      ],
      "function_names": [
        "create_channel",
        "NitroliteClient",
        "Request",
        "close_channel",
        "per_page"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "* Multi-Party Application Sessions\n\n\n\n# Multi-Party Application Sessions Tutorial\n\nSummary: This tutorial provides a guide for establishing and managing off-chain application sessions involving multiple participants to ensure synchronized state updates and collaborative protocol interactions.\n\nRelated terms: multi-party, application session, state channel, off-chain, consensus, collaborative payment, group session, multi-sig, session management, yellow network, multiparty, state update, channel synchronization\n\nUse cases: collaborative trading, multi-party escrow, group payment channels, shared state applications",
    "metadata": {
      "title": "Multi-Party Application Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This tutorial provides a guide for establishing and managing off-chain application sessions involving multiple participants to ensure synchronized state updates and collaborative protocol interactions.",
      "keywords": [
        "multi-party",
        "application session",
        "state channel",
        "off-chain",
        "consensus",
        "collaborative payment",
        "group session",
        "multi-sig",
        "session management",
        "yellow network",
        "multiparty",
        "state update",
        "channel synchronization"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "collaborative trading",
        "multi-party escrow",
        "group payment channels",
        "shared state applications"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Overviewâ€‹\n\n\nApplication sessions in Nitrolite enable multiple participants to interact within a shared off-chain state channel. This is particularly powerful for use cases requiring coordinated actions between parties without on-chain overhead.\n\nThis tutorial demonstrates how to create, manage, and close a multi-party application session using the Yellow Network and Nitrolite protocol.\n\nRun the Full Example\n\nThe complete runnable script for this tutorial is available at: [`scripts/app_sessions/app_session_two_signers.ts`](https://github.com/stevenzeiler/yellow-sdk-tutorials/blob/main/scripts/app_sessions/app_session_two_signers.ts)\n    \n    \n    npx tsx scripts/app_sessions/app_session_two_signers.ts\n\nSummary: This component facilitates the creation and management of off-chain state channels for multiple participants, enabling coordinated multi-party interactions without on-chain overhead. It provides a framework for shared state updates and session lifecycle management within the Nitrolite protocol.\n\nRelated terms: multi-party session, state channel, off-chain state, Nitrolite, session management, multi-signer, shared state, scalability, peer-to-peer, multiparty, statechannel, app session\n\nUse cases: multi-party games, coordinated asset swaps, collaborative off-chain computations, multi-signature payment flows",
    "metadata": {
      "title": "Multi-Party Application Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component facilitates the creation and management of off-chain state channels for multiple participants, enabling coordinated multi-party interactions without on-chain overhead. It provides a framework for shared state updates and session lifecycle management within the Nitrolite protocol.",
      "keywords": [
        "multi-party session",
        "state channel",
        "off-chain state",
        "Nitrolite",
        "session management",
        "multi-signer",
        "shared state",
        "scalability",
        "peer-to-peer",
        "multiparty",
        "statechannel",
        "app session"
      ],
      "function_name": "app_session_two_signers",
      "intent": "tutorial",
      "use_cases": [
        "multi-party games",
        "coordinated asset swaps",
        "collaborative off-chain computations",
        "multi-signature payment flows"
      ],
      "function_names": [
        "app_session_two_signers",
        "app_sessions"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## What is an Application Session?â€‹\n\n\nAn **application session** is a multi-party state channel that allows participants to:\n\n  * **Execute off-chain logic** without blockchain transactions\n  * **Update shared state** with cryptographic signatures\n  * **Transfer value** between participants instantly\n\nUnlike simple payment channels (1-to-1), application sessions support:\n\n  * Multiple participants (2+)\n  * Complex state logic\n  * Voting mechanisms (weights and quorum)\n  * Flexible allocation rules\n\nSummary: A multi-party state channel framework that enables off-chain execution of complex logic and instant value transfers among multiple participants using cryptographic signatures. It supports advanced features like voting mechanisms, quorum-based updates, and flexible state allocation rules.\n\nRelated terms: state channel, multi-party, off-chain, layer 2, quorum, voting, cryptographic signatures, instant settlement, shared state, application session, yellow network, multi-sig, p2p payments, state update\n\nUse cases: multi-party escrow, decentralized governance voting, real-time collaborative gaming, complex supply chain settlements",
    "metadata": {
      "title": "Multi-Party Application Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "A multi-party state channel framework that enables off-chain execution of complex logic and instant value transfers among multiple participants using cryptographic signatures. It supports advanced features like voting mechanisms, quorum-based updates, and flexible state allocation rules.",
      "keywords": [
        "state channel",
        "multi-party",
        "off-chain",
        "layer 2",
        "quorum",
        "voting",
        "cryptographic signatures",
        "instant settlement",
        "shared state",
        "application session",
        "yellow network",
        "multi-sig",
        "p2p payments",
        "state update"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "multi-party escrow",
        "decentralized governance voting",
        "real-time collaborative gaming",
        "complex supply chain settlements"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Prerequisitesâ€‹\n\n\n### Environment Setupâ€‹\n\nYou'll need two wallet seed phrases in your `.env` file:\n    \n    \n    WALLET_1_SEED_PHRASE=\"first wallet 12 or 24 word mnemonic here\"  \n    WALLET_2_SEED_PHRASE=\"second wallet 12 or 24 word mnemonic here\"  \n    \n\n### Funded Walletsâ€‹\n\nBoth wallets should have:\n\n  1. **Funds in Yellow ledger** (deposited via custody contract)\n\n### Install Dependenciesâ€‹\n    \n    \n    npm install  \n    \n\n* * *\n\nSummary: Defines the foundational environment requirements and wallet configurations necessary to establish and participate in multi-party application sessions on the Yellow Network.\n\nRelated terms: multi-party session, wallet setup, seed phrase, mnemonic, environment variables, ledger funding, custody contract, npm install, prerequisites, wallet configuration, Yellow ledger, crypto wallet, .env file, wallet funding\n\nUse cases: Setting up a local development environment for multi-party sessions, Configuring wallet credentials for automated payment testing, Preparing ledger balances for state channel participation",
    "metadata": {
      "title": "Multi-Party Application Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the foundational environment requirements and wallet configurations necessary to establish and participate in multi-party application sessions on the Yellow Network.",
      "keywords": [
        "multi-party session",
        "wallet setup",
        "seed phrase",
        "mnemonic",
        "environment variables",
        "ledger funding",
        "custody contract",
        "npm install",
        "prerequisites",
        "wallet configuration",
        "Yellow ledger",
        "crypto wallet",
        ".env file",
        "wallet funding"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Setting up a local development environment for multi-party sessions",
        "Configuring wallet credentials for automated payment testing",
        "Preparing ledger balances for state channel participation"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Key Conceptsâ€‹\n\n\n### 1\\. App Definitionâ€‹\n\nThe application definition specifies the rules of the session:\n    \n    \n    const appDefinition: RPCAppDefinition = {  \n        protocol: RPCProtocolVersion.NitroRPC_0_5,  \n        participants: [address1, address2],  \n        weights: [50, 50],        // Voting power distribution  \n        quorum: 100,              // Percentage needed for decisions (100 = unanimous)  \n        challenge: 0,             // Challenge period in seconds  \n        nonce: Date.now(),        // Unique session ID  \n        application: 'Test app',  \n    };  \n    \n\n**Key parameters:**\n\nParameter| Description  \n---|---  \n`participants`| Array of wallet addresses involved  \n`weights`| Voting power for each participant (must sum to 100 or appropriate total)  \n`quorum`| Required percentage of votes for actions (50 = majority, 100 = unanimous)  \n`challenge`| Time window for disputing state changes  \n`nonce`| Unique identifier to prevent replay attacks  \n  \n### 2\\. Allocationsâ€‹\n\nAllocations define how assets are distributed among participants:\n\n  * Sandbox\n  * Production\n    \n    \n    const allocations: RPCAppSessionAllocation[] = [  \n        { participant: address1, asset: 'ytest.usd', amount: '0.01' },  \n        { participant: address2, asset: 'ytest.usd', amount: '0.00' }  \n    ];  \n    \n    \n    \n    const allocations: RPCAppSessionAllocation[] = [  \n        { participant: address1, asset: 'usdc', amount: '0.01' },  \n        { participant: address2, asset: 'usdc', amount: '0.00' }  \n    ];  \n    \n\n**Rules:**\n\n  * Total allocations cannot exceed session funding\n  * Amounts are strings (to maintain precision)\n  * Must account for all participants\n\n### 3\\. Multi-Party Signaturesâ€‹\n\nFor actions requiring consensus (closing, etc.), signatures from multiple participants are collected:\n    \n    \n    // First participant signs  \n    const closeMessage = await createCloseAppSessionMessage(  \n        messageSigner1,  \n        { app_session_id: sessionId, allocations: finalAllocations }  \n    );  \n      \n    // Second participant signs  \n    const signature2 = await messageSigner2(closeMessage.req);  \n      \n    // Add second signature  \n    closeMessage.sig.push(signature2);  \n      \n    // Submit with all signatures  \n    await yellow.sendMessage(JSON.stringify(closeMessage));  \n    \n\n* * *\n\nSummary: Defines the governance structure, voting logic, and financial distribution rules for multi-party state channel sessions within the Yellow Network.\n\nRelated terms: multi-party session, app definition, asset allocation, quorum, voting power, challenge period, nonce, consensus, multi-sig, state channel, governance, replay protection, participant weights, session setup\n\nUse cases: collaborative asset management, decentralized governance, multi-party payment channels, dispute resolution configuration",
    "metadata": {
      "title": "Multi-Party Application Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the governance structure, voting logic, and financial distribution rules for multi-party state channel sessions within the Yellow Network.",
      "keywords": [
        "multi-party session",
        "app definition",
        "asset allocation",
        "quorum",
        "voting power",
        "challenge period",
        "nonce",
        "consensus",
        "multi-sig",
        "state channel",
        "governance",
        "replay protection",
        "participant weights",
        "session setup"
      ],
      "function_name": "createCloseAppSessionMessage",
      "intent": "concept",
      "use_cases": [
        "collaborative asset management",
        "decentralized governance",
        "multi-party payment channels",
        "dispute resolution configuration"
      ],
      "function_names": [
        "CloseAppSessionMessage",
        "app_session_id"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Step-by-Step Walkthroughâ€‹\n\n\n### Step 1: Connect to Yellow Networkâ€‹\n\n  * Sandbox\n  * Production\n    \n    \n    const yellow = new Client({  \n        url: 'wss://clearnet-sandbox.yellow.com/ws',  \n    });  \n      \n    await yellow.connect();  \n    console.log('Connected to Yellow clearnet (Sandbox)');  \n    \n    \n    \n    const yellow = new Client({  \n        url: 'wss://clearnet.yellow.com/ws',  \n    });  \n      \n    await yellow.connect();  \n    console.log('Connected to Yellow clearnet (Production)');  \n    \n\n### Step 2: Set Up Participant Walletsâ€‹\n    \n    \n    // Create wallet clients for both participants  \n    const wallet1Client = createWalletClient({  \n        account: mnemonicToAccount(process.env.WALLET_1_SEED_PHRASE as string),  \n        chain: base,  \n        transport: http(),  \n    });  \n      \n    const wallet2Client = createWalletClient({  \n        account: mnemonicToAccount(process.env.WALLET_2_SEED_PHRASE as string),  \n        chain: base,  \n        transport: http(),  \n    });  \n    \n\n### Step 3: Authenticate Both Participantsâ€‹\n\nEach participant needs their own session key:\n    \n    \n    // Authenticate first participant  \n    const sessionKey1 = await authenticateWallet(yellow, wallet1Client);  \n    const messageSigner1 = createECDSAMessageSigner(sessionKey1.privateKey);  \n      \n    // Authenticate second participant  \n    const sessionKey2 = await authenticateWallet(yellow, wallet2Client);  \n    const messageSigner2 = createECDSAMessageSigner(sessionKey2.privateKey);  \n    \n\n### Step 4: Define Application Configurationâ€‹\n    \n    \n    const appDefinition: RPCAppDefinition = {  \n        protocol: RPCProtocolVersion.NitroRPC_0_5,  \n        participants: [wallet1Client.account.address, wallet2Client.account.address],  \n        weights: [50, 50],  \n        quorum: 100,  \n        challenge: 0,  \n        nonce: Date.now(),  \n        application: 'Test app',  \n    };  \n    \n\n### Step 5: Create Session with Initial Allocationsâ€‹\n\n  * Sandbox\n  * Production\n    \n    \n    const allocations = [  \n        { participant: wallet1Client.account.address, asset: 'ytest.usd', amount: '0.01' },  \n        { participant: wallet2Client.account.address, asset: 'ytest.usd', amount: '0.00' }  \n    ];  \n      \n    const sessionMessage = await createAppSessionMessage(  \n        messageSigner1,  \n        { definition: appDefinition, allocations }  \n    );  \n      \n    const sessionResponse = await yellow.sendMessage(sessionMessage);  \n    const sessionId = sessionResponse.params.appSessionId;  \n    \n    \n    \n    const allocations = [  \n        { participant: wallet1Client.account.address, asset: 'usdc', amount: '0.01' },  \n        { participant: wallet2Client.account.address, asset: 'usdc', amount: '0.00' }  \n    ];  \n      \n    const sessionMessage = await createAppSessionMessage(  \n        messageSigner1,  \n        { definition: appDefinition, allocations }  \n    );  \n      \n    const sessionResponse = await yellow.sendMessage(sessionMessage);  \n    const sessionId = sessionResponse.params.appSessionId;  \n    \n\n### Step 6: Update Session Stateâ€‹\n\nYou can update allocations to reflect state changes (e.g., a transfer). Since the quorum is 100%, both participants must sign:\n\n  * Sandbox\n  * Production\n    \n    \n    const newAllocations = [  \n        { participant: wallet1Client.account.address, asset: 'ytest.usd', amount: '0.00' },  \n        { participant: wallet2Client.account.address, asset: 'ytest.usd', amount: '0.01' }  \n    ];  \n      \n    // Create update message signed by first participant  \n    const updateMessage = await createSubmitAppStateMessage(  \n        messageSigner1,  \n        { app_session_id: sessionId, allocations: newAllocations }  \n    );  \n      \n    const updateMessageJson = JSON.parse(updateMessage);  \n      \n    // Second participant signs the same state update  \n    const signature2 = await messageSigner2(updateMessageJson.req as RPCData);  \n      \n    // Append second signature to meet quorum requirement  \n    updateMessageJson.sig.push(signature2);  \n      \n    // Submit with all required signatures  \n    await yellow.sendMessage(JSON.stringify(updateMessageJson));  \n    \n    \n    \n    const newAllocations = [  \n        { participant: wallet1Client.account.address, asset: 'usdc', amount: '0.00' },  \n        { participant: wallet2Client.account.address, asset: 'usdc', amount: '0.01' }  \n    ];  \n      \n    // Create update message signed by first participant  \n    const updateMessage = await createSubmitAppStateMessage(  \n        messageSigner1,  \n        { app_session_id: sessionId, allocations: newAllocations }  \n    );  \n      \n    const updateMessageJson = JSON.parse(updateMessage);  \n      \n    // Second participant signs the same state update  \n    const signature2 = await messageSigner2(updateMessageJson.req as RPCData);  \n      \n    // Append second signature to meet quorum requirement  \n    updateMessageJson.sig.push(signature2);  \n      \n    // Submit with all required signatures  \n    await yellow.sendMessage(JSON.stringify(updateMessageJson));  \n    \n\n### Step 7: Close Session with Multi-Party Signaturesâ€‹\n    \n    \n    // Create close message (signed by participant 1)  \n    const closeMessage = await createCloseAppSessionMessage(  \n        messageSigner1,  \n        { app_session_id: sessionId, allocations: finalAllocations }  \n    );  \n      \n    const closeMessageJson = JSON.parse(closeMessage);  \n      \n    // Participant 2 signs  \n    const signature2 = await messageSigner2(closeMessageJson.req as RPCData);  \n    closeMessageJson.sig.push(signature2);  \n      \n    // Submit with all signatures  \n    const closeResponse = await yellow.sendMessage(JSON.stringify(closeMessageJson));  \n    \n\n* * *\n\nSummary: This component provides a structured workflow for initializing multi-party application sessions, covering network connectivity, participant wallet authentication via session keys, and the definition of state channel configurations.\n\nRelated terms: multi-party session, state channel, wallet authentication, session key, ECDSA signing, NitroRPC, participant setup, peer-to-peer, clearnet, app definition, quorum, crypto payment, yellow network, sandbox, session management\n\nUse cases: multi-party state channels, collaborative dApps, secure peer-to-peer transactions, decentralized session management",
    "metadata": {
      "title": "Multi-Party Application Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component provides a structured workflow for initializing multi-party application sessions, covering network connectivity, participant wallet authentication via session keys, and the definition of state channel configurations.",
      "keywords": [
        "multi-party session",
        "state channel",
        "wallet authentication",
        "session key",
        "ECDSA signing",
        "NitroRPC",
        "participant setup",
        "peer-to-peer",
        "clearnet",
        "app definition",
        "quorum",
        "crypto payment",
        "yellow network",
        "sandbox",
        "session management"
      ],
      "function_name": "authenticateWallet",
      "intent": "tutorial",
      "use_cases": [
        "multi-party state channels",
        "collaborative dApps",
        "secure peer-to-peer transactions",
        "decentralized session management"
      ],
      "function_names": [
        "WalletClient",
        "AppSessionMessage",
        "app_session_id",
        "CloseAppSessionMessage",
        "SubmitAppStateMessage"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Running the Exampleâ€‹\n\n    \n    \n    npx tsx scripts/app_session_two_signers.ts  \n    \n\n### Expected Outputâ€‹\n    \n    \n    Connected to Yellow clearnet  \n    Wallet address: 0x1234...  \n    Wallet address: 0x5678...  \n    Session message created: {...}  \n    Session message sent  \n    Session response: { appSessionId: '0xabc...' }  \n    Submit app state message: {...}  \n    Wallet 2 signed close session message: 0xdef...  \n    Close session message (with all signatures): {...}  \n    Close session message sent  \n    Close session response: { success: true }  \n    \n\n* * *\n\nSummary: Demonstrates the end-to-end lifecycle of a multi-party application session, covering session initialization, state submission, and collaborative closing through multi-signature verification.\n\nRelated terms: multi-party session, state channel, joint signature, session lifecycle, multi-sig, collaborative signing, off-chain state, session management, state update, close session, yellow network, multi party, multiparity\n\nUse cases: multi-party escrow, collaborative state updates, joint account settlement, off-chain agreement",
    "metadata": {
      "title": "Multi-Party Application Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Demonstrates the end-to-end lifecycle of a multi-party application session, covering session initialization, state submission, and collaborative closing through multi-signature verification.",
      "keywords": [
        "multi-party session",
        "state channel",
        "joint signature",
        "session lifecycle",
        "multi-sig",
        "collaborative signing",
        "off-chain state",
        "session management",
        "state update",
        "close session",
        "yellow network",
        "multi party",
        "multiparity"
      ],
      "function_name": "app_session_two_signers",
      "intent": "tutorial",
      "use_cases": [
        "multi-party escrow",
        "collaborative state updates",
        "joint account settlement",
        "off-chain agreement"
      ],
      "function_names": [
        "app_session_two_signers"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Use Casesâ€‹\n\n\nAsset Names in Examples\n\nThe examples below use `usdc` for production scenarios. When testing on Sandbox, replace `usdc` with `ytest.usd`.\n\n### 1\\. Peer-to-Peer Escrowâ€‹\n    \n    \n    // Buyer and seller agree on terms  \n    const appDefinition = {  \n        participants: [buyer, seller],  \n        weights: [50, 50],  \n        quorum: 100,  // Both must agree to release funds  \n        // ...  \n    };  \n      \n    // Buyer funds escrow  \n    const allocations = [  \n        { participant: buyer, asset: 'usdc', amount: '0' },  \n        { participant: seller, asset: 'usdc', amount: '100' }  // Released to seller  \n    ];  \n    \n\n### 2\\. Multi-Player Gamingâ€‹\n    \n    \n    const appDefinition = {  \n        participants: [player1, player2, player3, player4],  \n        weights: [25, 25, 25, 25],  \n        quorum: 75,  // 3 out of 4 players must agree  \n        challenge: 3600,  // 1 hour challenge period  \n        application: 'poker-game',  \n    };  \n    \n\n### 3\\. DAO Treasury Managementâ€‹\n    \n    \n    const appDefinition = {  \n        participants: [member1, member2, member3, member4, member5],  \n        weights: [20, 20, 20, 20, 20],  \n        quorum: 60,  // 60% approval needed  \n        application: 'dao-treasury',  \n    };  \n    \n\n### 4\\. Atomic Swapsâ€‹\n    \n    \n    // Party A has USDC, wants ETH  \n    // Party B has ETH, wants USDC  \n    const allocations = [  \n        { participant: partyA, asset: 'usdc', amount: '100' },  \n        { participant: partyA, asset: 'eth', amount: '0' },  \n        { participant: partyB, asset: 'usdc', amount: '0' },  \n        { participant: partyB, asset: 'eth', amount: '0.05' }  \n    ];  \n      \n    // After swap  \n    const finalAllocations = [  \n        { participant: partyA, asset: 'usdc', amount: '0' },  \n        { participant: partyA, asset: 'eth', amount: '0.05' },  \n        { participant: partyB, asset: 'usdc', amount: '100' },  \n        { participant: partyB, asset: 'eth', amount: '0' }  \n    ];  \n    \n\n* * *\n\nSummary: This component illustrates the practical application of Multi-Party Application Sessions, demonstrating how to configure participant weights, quorum thresholds, and asset allocations for complex state-channel interactions.\n\nRelated terms: multi-party session, state channel, quorum, escrow, atomic swap, DAO treasury, participant weights, asset allocation, consensus, gaming, ytest.usd, usdc, multi-sig, state update\n\nUse cases: peer-to-peer escrow, multi-player gaming, DAO treasury management, atomic swaps",
    "metadata": {
      "title": "Multi-Party Application Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component illustrates the practical application of Multi-Party Application Sessions, demonstrating how to configure participant weights, quorum thresholds, and asset allocations for complex state-channel interactions.",
      "keywords": [
        "multi-party session",
        "state channel",
        "quorum",
        "escrow",
        "atomic swap",
        "DAO treasury",
        "participant weights",
        "asset allocation",
        "consensus",
        "gaming",
        "ytest.usd",
        "usdc",
        "multi-sig",
        "state update"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "peer-to-peer escrow",
        "multi-player gaming",
        "DAO treasury management",
        "atomic swaps"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Advanced Topicsâ€‹\n\n\n### Dynamic Participantsâ€‹\n\nFor applications requiring flexible participation:\n    \n    \n    // Start with 2 participants  \n    let participants = [user1, user2];  \n      \n    // Add a third participant (requires re-creating session)  \n    participants.push(user3);  \n      \n    const newAppDefinition = {  \n        participants,  \n        weights: [33, 33, 34],  \n        // ...  \n    };  \n    \n\n### Weighted Votingâ€‹\n\nDifferent participants can have different voting power:\n    \n    \n    const appDefinition = {  \n        participants: [founder, investor1, investor2],  \n        weights: [50, 30, 20],  // Founder has 50% voting power  \n        quorum: 60,  // Founder + one investor = 60%  \n        // ...  \n    };  \n    \n\n### Challenge Periodsâ€‹\n\nAdd time for participants to dispute state changes:\n    \n    \n    const appDefinition = {  \n        // ...  \n        challenge: 86400,  // 24 hours in seconds  \n    };  \n      \n    // Participants have 24 hours to challenge a close request before finalization  \n    \n\n### State Validationâ€‹\n\nImplement custom logic to validate state transitions:\n    \n    \n    function validateStateTransition(  \n        oldAllocations: RPCAppSessionAllocation[],  \n        newAllocations: RPCAppSessionAllocation[]  \n    ): boolean {  \n        // Ensure total amounts are preserved  \n        const oldTotal = oldAllocations.reduce((sum, a) => sum + parseFloat(a.amount), 0);  \n        const newTotal = newAllocations.reduce((sum, a) => sum + parseFloat(a.amount), 0);  \n          \n        return Math.abs(oldTotal - newTotal) < 0.000001;  \n    }  \n    \n\n* * *\n\nSummary: This section outlines advanced configuration for multi-party application sessions, covering dynamic participant management, weighted voting power, dispute challenge periods, and custom state transition validation logic.\n\nRelated terms: multi-party session, weighted voting, quorum, challenge period, state validation, dynamic participants, dispute resolution, app definition, governance, state transition, consensus, multi-sig, voting power, session recreation\n\nUse cases: DAO governance and weighted decision making, Escrow services with dispute resolution windows, Dynamic group payment sessions with changing members, Custom business logic for validating asset transfers",
    "metadata": {
      "title": "Multi-Party Application Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines advanced configuration for multi-party application sessions, covering dynamic participant management, weighted voting power, dispute challenge periods, and custom state transition validation logic.",
      "keywords": [
        "multi-party session",
        "weighted voting",
        "quorum",
        "challenge period",
        "state validation",
        "dynamic participants",
        "dispute resolution",
        "app definition",
        "governance",
        "state transition",
        "consensus",
        "multi-sig",
        "voting power",
        "session recreation"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "DAO governance and weighted decision making",
        "Escrow services with dispute resolution windows",
        "Dynamic group payment sessions with changing members",
        "Custom business logic for validating asset transfers"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Troubleshootingâ€‹\n\n\n### \"Authentication failed for participant\"â€‹\n\n**Cause** : Session key authentication failed\n\n**Solution** :\n\n  * Ensure both `WALLET_1_SEED_PHRASE` and `WALLET_2_SEED_PHRASE` are set in `.env`\n  * Verify wallets have been authenticated on Yellow network before\n\n### \"Unsupported token\"â€‹\n\n**Cause** : Using the wrong asset for your environment (e.g., `usdc` on Sandbox or `ytest.usd` on Production)\n\n**Solution** :\n\n  * **Sandbox** (`wss://clearnet-sandbox.yellow.com/ws`): Use `ytest.usd`\n  * **Production** (`wss://clearnet.yellow.com/ws`): Use `usdc`\n\nEnsure the asset in your allocations matches the connected network.\n\n### \"Insufficient balance\"â€‹\n\n**Cause** : Participant doesn't have enough funds in Yellow ledger\n\n**Solution** :\n\nDeposit sufficient funds into the yellow network account unified balance for each wallet\n\n### \"Invalid signatures\"â€‹\n\n**Cause** : Not all required signatures were collected\n\n**Solution** :\n\n  * Ensure quorum is met (if quorum is 100, need all signatures)\n  * Check that signatures are added in correct order\n  * Verify message signers correspond to participants\n\n### \"Session already closed\"â€‹\n\n**Cause** : Trying to update or close an already-finalized session\n\n**Solution** :\n\n  * Create a new session\n  * Check session status before operations\n\n### \"Quorum not reached\"â€‹\n\n**Cause** : Insufficient voting weight for action\n\n**Solution** :\n    \n    \n    // Example: quorum is 60, weights are [30, 30, 40]  \n    // Need at least 2 participants to sign  \n      \n    // Check current signature weight  \n    const signatureWeight = signatures.reduce((sum, sig) => {  \n        const participantIndex = findParticipantIndex(sig);  \n        return sum + weights[participantIndex];  \n    }, 0);  \n      \n    console.log(`Current weight: ${signatureWeight}, Required: ${quorum}`);  \n    \n\n* * *\n\nSummary: This component provides a diagnostic guide for resolving common operational errors encountered during multi-party session management, including authentication failures, asset mismatches, and signature quorum issues.\n\nRelated terms: troubleshooting, error handling, authentication failed, unsupported token, insufficient balance, invalid signatures, quorum not reached, session management, state channel, ledger deposit, sandbox vs production, signature weight, multi-party session\n\nUse cases: Debugging session authentication failures, Resolving asset configuration mismatches between environments, Validating multi-party signature quorums, Managing ledger balance requirements for participants",
    "metadata": {
      "title": "Multi-Party Application Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component provides a diagnostic guide for resolving common operational errors encountered during multi-party session management, including authentication failures, asset mismatches, and signature quorum issues.",
      "keywords": [
        "troubleshooting",
        "error handling",
        "authentication failed",
        "unsupported token",
        "insufficient balance",
        "invalid signatures",
        "quorum not reached",
        "session management",
        "state channel",
        "ledger deposit",
        "sandbox vs production",
        "signature weight",
        "multi-party session"
      ],
      "function_name": null,
      "intent": "error_handling",
      "use_cases": [
        "Debugging session authentication failures",
        "Resolving asset configuration mismatches between environments",
        "Validating multi-party signature quorums",
        "Managing ledger balance requirements for participants"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Best Practicesâ€‹\n\n\n  1. **Always validate allocations** before submitting state updates\n  2. **Store session IDs** for future reference and auditing\n  3. **Implement timeout handling** for multi-party signatures\n  4. **Use appropriate quorum settings** based on trust model\n  5. **Test with small amounts** before production use\n  6. **Keep participants informed** of state changes\n  7. **Handle disconnections gracefully** (participants may come back)\n  8. **Document application logic** for all participants\n\n* * *\n\nSummary: This section outlines operational guidelines and safety measures for managing multi-party application sessions, focusing on state integrity, participant coordination, and risk mitigation.\n\nRelated terms: multi-party session, best practices, state update, session ID, quorum, timeout handling, allocation validation, participant management, disconnection handling, trust model, auditing, multi-sig, state channel, yellow network\n\nUse cases: Designing a multi-signature payment flow, Implementing fault-tolerant state channel applications, Managing participant lifecycle in a decentralized exchange, Auditing and logging multi-party transaction history",
    "metadata": {
      "title": "Multi-Party Application Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines operational guidelines and safety measures for managing multi-party application sessions, focusing on state integrity, participant coordination, and risk mitigation.",
      "keywords": [
        "multi-party session",
        "best practices",
        "state update",
        "session ID",
        "quorum",
        "timeout handling",
        "allocation validation",
        "participant management",
        "disconnection handling",
        "trust model",
        "auditing",
        "multi-sig",
        "state channel",
        "yellow network"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Designing a multi-signature payment flow",
        "Implementing fault-tolerant state channel applications",
        "Managing participant lifecycle in a decentralized exchange",
        "Auditing and logging multi-party transaction history"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Further Readingâ€‹\n\n\n  * [App Sessions Core Concepts](/docs/learn/core-concepts/app-sessions) â€” Understanding app sessions\n  * [App Session Methods](/docs/protocol/off-chain/app-sessions) â€” Complete API reference\n  * [Client-Side App Session Signing Guide](/docs/guides/client-side-app-session-signing) â€” Signing implementation details\n  * [Session Keys](/docs/learn/core-concepts/session-keys) â€” Managing session keys\n\n\n\n[PreviousMigration Guide](/docs/guides/migration-guide)\n\n  * Overview\n  * What is an Application Session?\n  * Prerequisites\n    * Environment Setup\n    * Funded Wallets\n    * Install Dependencies\n  * Key Concepts\n    * 1\\. App Definition\n    * 2\\. Allocations\n    * 3\\. Multi-Party Signatures\n  * Step-by-Step Walkthrough\n    * Step 1: Connect to Yellow Network\n    * Step 2: Set Up Participant Wallets\n    * Step 3: Authenticate Both Participants\n    * Step 4: Define Application Configuration\n    * Step 5: Create Session with Initial Allocations\n    * Step 6: Update Session State\n    * Step 7: Close Session with Multi-Party Signatures\n  * Running the Example\n    * Expected Output\n  * Use Cases\n    * 1\\. Peer-to-Peer Escrow\n    * 2\\. Multi-Player Gaming\n    * 3\\. DAO Treasury Management\n    * 4\\. Atomic Swaps\n  * Advanced Topics\n    * Dynamic Participants\n    * Weighted Voting\n    * Challenge Periods\n    * State Validation\n  * Troubleshooting\n    * \"Authentication failed for participant\"\n    * \"Unsupported token\"\n    * \"Insufficient balance\"\n    * \"Invalid signatures\"\n    * \"Session already closed\"\n    * \"Quorum not reached\"\n  * Best Practices\n  * Further Reading\n\nSummary: This guide provides a comprehensive framework for implementing multi-party application sessions, enabling secure off-chain state transitions and asset allocations between multiple participants. It covers the entire lifecycle of collaborative financial interactions, including authentication, state updates, and final settlement via multi-party signatures.\n\nRelated terms: multi-party session, state channel, off-chain state, multi-sig, escrow, atomic swap, session keys, quorum, state update, DAO treasury, multi-party signature, app session, yellow network, multiparty\n\nUse cases: Peer-to-Peer Escrow, Multi-Player Gaming, DAO Treasury Management, Atomic Swaps",
    "metadata": {
      "title": "Multi-Party Application Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/guides/multi-party-app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This guide provides a comprehensive framework for implementing multi-party application sessions, enabling secure off-chain state transitions and asset allocations between multiple participants. It covers the entire lifecycle of collaborative financial interactions, including authentication, state updates, and final settlement via multi-party signatures.",
      "keywords": [
        "multi-party session",
        "state channel",
        "off-chain state",
        "multi-sig",
        "escrow",
        "atomic swap",
        "session keys",
        "quorum",
        "state update",
        "DAO treasury",
        "multi-party signature",
        "app session",
        "yellow network",
        "multiparty"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "Peer-to-Peer Escrow",
        "Multi-Player Gaming",
        "DAO Treasury Management",
        "Atomic Swaps"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Learn\n\n\n\n# Learn\n\nWelcome to the Yellow Network learning path. This section builds your understanding from fundamentals to advanced concepts.\n\n* * *\n\nSummary: Provides an educational roadmap for developers to understand the Yellow Network protocol, ranging from basic principles to sophisticated architectural concepts.\n\nRelated terms: Yellow Network, learning path, onboarding, fundamentals, advanced concepts, developer guide, protocol overview, crypto education, blockchain basics, getting started, yello network, yellow protocol, educational resources\n\nUse cases: onboarding new developers to the SDK, understanding the core architecture of Yellow Network, navigating educational resources",
    "metadata": {
      "title": "Learn | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides an educational roadmap for developers to understand the Yellow Network protocol, ranging from basic principles to sophisticated architectural concepts.",
      "keywords": [
        "Yellow Network",
        "learning path",
        "onboarding",
        "fundamentals",
        "advanced concepts",
        "developer guide",
        "protocol overview",
        "crypto education",
        "blockchain basics",
        "getting started",
        "yello network",
        "yellow protocol",
        "educational resources"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "onboarding new developers to the SDK",
        "understanding the core architecture of Yellow Network",
        "navigating educational resources"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Introductionâ€‹\n\n\nStart here to understand what Yellow Network solves and how it works.\n\n**[What Yellow Solves](/docs/learn/introduction/what-yellow-solves)** â€” Understand the core problems: scaling, cost, and speed. Learn why state channels are the answer for high-frequency applications.\n\n**[Architecture at a Glance](/docs/learn/introduction/architecture-at-a-glance)** â€” See how the three protocol layers (on-chain, off-chain, application) work together to enable fast, secure transactions.\n\n* * *\n\nSummary: This section provides a high-level overview of the Yellow Network protocol, detailing its three-layer architecture and the use of state channels to solve blockchain scalability, cost, and speed challenges.\n\nRelated terms: Yellow Network, state channels, scalability, high-frequency trading, off-chain transactions, layer 2, protocol architecture, blockchain speed, cost reduction, on-chain settlement, multi-layer protocol, crypto payments, Yello Network, statechannel\n\nUse cases: high-frequency trading, low-latency crypto payments, scalable dApp development, off-chain state management",
    "metadata": {
      "title": "Learn | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section provides a high-level overview of the Yellow Network protocol, detailing its three-layer architecture and the use of state channels to solve blockchain scalability, cost, and speed challenges.",
      "keywords": [
        "Yellow Network",
        "state channels",
        "scalability",
        "high-frequency trading",
        "off-chain transactions",
        "layer 2",
        "protocol architecture",
        "blockchain speed",
        "cost reduction",
        "on-chain settlement",
        "multi-layer protocol",
        "crypto payments",
        "Yello Network",
        "statechannel"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency trading",
        "low-latency crypto payments",
        "scalable dApp development",
        "off-chain state management"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Getting Startedâ€‹\n\n\nGet hands-on with Yellow Network in minutes.\n\n**[Quickstart: Your First Channel](/docs/learn/getting-started/quickstart)** â€” Create a state channel, perform an off-chain transfer, and verify the transaction in under 10 minutes.\n\n**[Prerequisites& Environment](/docs/learn/getting-started/prerequisites)** â€” Set up a complete development environment with Node.js, TypeScript, and the Nitrolite SDK.\n\n**[Key Terms& Mental Models](/docs/learn/getting-started/key-terms)** â€” Build your vocabulary and conceptual framework for understanding state channels.\n\n* * *\n\nSummary: This section provides a foundational roadmap for developers to set up their environment, learn core state channel concepts, and execute their first off-chain transaction using the Nitrolite SDK.\n\nRelated terms: getting started, quickstart, state channel, off-chain transfer, Nitrolite SDK, Node.js, TypeScript, prerequisites, mental models, setup, installation, first transaction, Yellow Network, crypto payments, environment setup\n\nUse cases: Setting up a development environment for state channel applications, Executing a first off-chain payment between peers, Learning the fundamental terminology of the Yellow Network protocol",
    "metadata": {
      "title": "Learn | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section provides a foundational roadmap for developers to set up their environment, learn core state channel concepts, and execute their first off-chain transaction using the Nitrolite SDK.",
      "keywords": [
        "getting started",
        "quickstart",
        "state channel",
        "off-chain transfer",
        "Nitrolite SDK",
        "Node.js",
        "TypeScript",
        "prerequisites",
        "mental models",
        "setup",
        "installation",
        "first transaction",
        "Yellow Network",
        "crypto payments",
        "environment setup"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "Setting up a development environment for state channel applications",
        "Executing a first off-chain payment between peers",
        "Learning the fundamental terminology of the Yellow Network protocol"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Core Conceptsâ€‹\n\n\nDeep dive into the technology powering Yellow Network.\n\n**[State Channels vs L1/L2](/docs/learn/core-concepts/state-channels-vs-l1-l2)** â€” Compare state channels with Layer 1 and Layer 2 solutions. Understand when each approach is the right choice.\n\n**[App Sessions](/docs/learn/core-concepts/app-sessions)** â€” Multi-party application channels with custom governance and state management.\n\n**[Session Keys](/docs/learn/core-concepts/session-keys)** â€” Delegated keys for secure, gasless interactions without repeated wallet prompts.\n\n**[Challenge-Response& Disputes](/docs/learn/core-concepts/challenge-response)** â€” How Yellow Network handles disputes and ensures your funds are always recoverable.\n\n**[Message Envelope](/docs/learn/core-concepts/message-envelope)** â€” Overview of the Nitro RPC message format and communication protocol.\n\n* * *\n\nSummary: This section outlines the foundational architectural pillars of the Yellow Network, covering state channel mechanics, session-based governance, and secure off-chain communication protocols.\n\nRelated terms: state channels, layer 2, app sessions, session keys, gasless transactions, dispute resolution, challenge-response, message envelope, nitro rpc, multi-party channels, off-chain scaling, fund recovery, governance, state management\n\nUse cases: Evaluating scaling solutions for high-frequency trading, Designing gasless user experiences with delegated keys, Implementing secure multi-party application logic, Understanding protocol-level dispute and recovery mechanisms",
    "metadata": {
      "title": "Learn | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the foundational architectural pillars of the Yellow Network, covering state channel mechanics, session-based governance, and secure off-chain communication protocols.",
      "keywords": [
        "state channels",
        "layer 2",
        "app sessions",
        "session keys",
        "gasless transactions",
        "dispute resolution",
        "challenge-response",
        "message envelope",
        "nitro rpc",
        "multi-party channels",
        "off-chain scaling",
        "fund recovery",
        "governance",
        "state management"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Evaluating scaling solutions for high-frequency trading",
        "Designing gasless user experiences with delegated keys",
        "Implementing secure multi-party application logic",
        "Understanding protocol-level dispute and recovery mechanisms"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nAfter completing the Learn section, continue to:\n\n  * **[Build](/docs/build/quick-start)** â€” Implement complete Yellow Applications\n  * **[Protocol Reference](/docs/protocol/introduction)** â€” Authoritative protocol specification\n\n* * *\n\nSummary: Provides a navigational roadmap for developers transitioning from introductory concepts to practical application building and deep-dive protocol specifications within the Yellow Network ecosystem.\n\nRelated terms: Yellow Network, developer roadmap, getting started, documentation guide, build applications, protocol reference, implementation path, SDK tutorial, crypto development, learning journey, next steps, yellow sdk\n\nUse cases: onboarding new developers, navigating the documentation suite, transitioning to application implementation",
    "metadata": {
      "title": "Learn | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a navigational roadmap for developers transitioning from introductory concepts to practical application building and deep-dive protocol specifications within the Yellow Network ecosystem.",
      "keywords": [
        "Yellow Network",
        "developer roadmap",
        "getting started",
        "documentation guide",
        "build applications",
        "protocol reference",
        "implementation path",
        "SDK tutorial",
        "crypto development",
        "learning journey",
        "next steps",
        "yellow sdk"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "onboarding new developers",
        "navigating the documentation suite",
        "transitioning to application implementation"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Quick Referenceâ€‹\n\n\nTopic| Time| Difficulty  \n---|---|---  \n[What Yellow Solves](/docs/learn/introduction/what-yellow-solves)| 5 min| Beginner  \n[Architecture at a Glance](/docs/learn/introduction/architecture-at-a-glance)| 8 min| Beginner  \n[Quickstart](/docs/learn/getting-started/quickstart)| 10 min| Beginner  \n[Key Terms](/docs/learn/getting-started/key-terms)| 10 min| Beginner  \n[State Channels vs L1/L2](/docs/learn/core-concepts/state-channels-vs-l1-l2)| 12 min| Intermediate  \n[App Sessions](/docs/learn/core-concepts/app-sessions)| 8 min| Intermediate  \n[Session Keys](/docs/learn/core-concepts/session-keys)| 8 min| Intermediate  \n[Challenge-Response](/docs/learn/core-concepts/challenge-response)| 6 min| Intermediate  \n[Message Envelope](/docs/learn/core-concepts/message-envelope)| 5 min| Intermediate  \n  \n\n\n[NextWhat Yellow Solves](/docs/learn/introduction/what-yellow-solves)\n\n  * Introduction\n  * Getting Started\n  * Core Concepts\n  * Next Steps\n  * Quick Reference\n\nSummary: A high-level navigation hub and curriculum overview for the Yellow Network, providing quick access to architectural foundations, core concepts like state channels, and technical primitives for off-chain scaling.\n\nRelated terms: Yellow Network, state channels, off-chain scaling, session keys, app sessions, challenge-response, message envelope, L1 vs L2, blockchain architecture, crypto payments, protocol overview, getting started, yellow crypto\n\nUse cases: onboarding to the Yellow Network ecosystem, evaluating protocol architecture for integration, understanding off-chain state management, comparing scaling solutions",
    "metadata": {
      "title": "Learn | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "A high-level navigation hub and curriculum overview for the Yellow Network, providing quick access to architectural foundations, core concepts like state channels, and technical primitives for off-chain scaling.",
      "keywords": [
        "Yellow Network",
        "state channels",
        "off-chain scaling",
        "session keys",
        "app sessions",
        "challenge-response",
        "message envelope",
        "L1 vs L2",
        "blockchain architecture",
        "crypto payments",
        "protocol overview",
        "getting started",
        "yellow crypto"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "onboarding to the Yellow Network ecosystem",
        "evaluating protocol architecture for integration",
        "understanding off-chain state management",
        "comparing scaling solutions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Advanced\n  * Managing Session Keys\n\n\n\n# Managing Session Keys\n\nThis guide covers the operational details of creating, listing, and revoking session keys via the Clearnode API.\n\nPrerequisites\n\nBefore diving into session key management, make sure you understand the core concepts: what session keys are, how applications and allowances work, and the expiration rules. See **[Session Keys](/docs/learn/core-concepts/session-keys)** for the conceptual foundation.\n\n* * *\n\nSummary: Provides operational procedures for the lifecycle management of session keys, enabling architects to implement secure delegated authorization and programmatic access control via the Clearnode API.\n\nRelated terms: session keys, key management, Clearnode API, revoke access, list sessions, authentication, authorization, allowances, sessionkey, access control, delegated signing, security credentials\n\nUse cases: Revoking compromised application access, Auditing active session keys for security compliance, Provisioning temporary credentials for automated trading, Managing application-specific spending allowances",
    "metadata": {
      "title": "Managing Session Keys | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/advanced/managing-session-keys",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides operational procedures for the lifecycle management of session keys, enabling architects to implement secure delegated authorization and programmatic access control via the Clearnode API.",
      "keywords": [
        "session keys",
        "key management",
        "Clearnode API",
        "revoke access",
        "list sessions",
        "authentication",
        "authorization",
        "allowances",
        "sessionkey",
        "access control",
        "delegated signing",
        "security credentials"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "Revoking compromised application access",
        "Auditing active session keys for security compliance",
        "Provisioning temporary credentials for automated trading",
        "Managing application-specific spending allowances"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## How to Manage Session Keysâ€‹\n\n\n### Clearnodeâ€‹\n\n#### Create and Configureâ€‹\n\nTo create a session key, use the `auth_request` method during authentication. This registers the session key with its configuration:\n\n**Request:**\n    \n    \n    {  \n      \"req\": [  \n        1,  \n        \"auth_request\",  \n        {  \n          \"address\": \"0x1234567890abcdef...\",  \n          \"session_key\": \"0x9876543210fedcba...\",  \n          \"application\": \"Chess Game\",  \n          \"allowances\": [  \n            {  \n              \"asset\": \"usdc\",  \n              \"amount\": \"100.0\"  \n            },  \n            {  \n              \"asset\": \"eth\",  \n              \"amount\": \"0.5\"  \n            }  \n          ],  \n          \"scope\": \"app.create\",  \n          \"expires_at\": 1762417328  \n        },  \n        1619123456789  \n      ],  \n      \"sig\": [\"0x5432abcdef...\"]  \n    }  \n    \n\n**Parameters:**\n\n  * `address` (required): The wallet address that owns this session key\n  * `session_key` (required): The address of the session key to register\n  * `application` (optional): Name of the application using this session key (defaults to \"clearnode\" if not provided)\n  * `allowances` (optional): Array of asset allowances specifying spending limits\n  * `scope` (optional): Permission scope (e.g., \"app.create\", \"ledger.readonly\"). **Note:** This feature is not yet implemented\n  * `expires_at` (required): Unix timestamp (in seconds) when this session key expires\n\nnote\n\nWhen authenticating with an already registered session key, you must still fill in all fields in the request, at least with arbitrary values. This is required by the request itself, however, the values will be ignored as the system uses the session key configuration stored during initial registration. This behavior will be improved in future versions.\n\n#### List Active Session Keysâ€‹\n\nUse the `get_session_keys` method to retrieve all active (non-expired) session keys for the authenticated user:\n\n**Request:**\n    \n    \n    {  \n      \"req\": [1, \"get_session_keys\", {}, 1619123456789],  \n      \"sig\": [\"0x9876fedcba...\"]  \n    }  \n    \n\n**Response:**\n    \n    \n    {  \n      \"res\": [  \n        1,  \n        \"get_session_keys\",  \n        {  \n          \"session_keys\": [  \n            {  \n              \"id\": 1,  \n              \"session_key\": \"0xabcdef1234567890...\",  \n              \"application\": \"Chess Game\",  \n              \"allowances\": [  \n                {  \n                  \"asset\": \"usdc\",  \n                  \"allowance\": \"100.0\",  \n                  \"used\": \"45.0\"  \n                },  \n                {  \n                  \"asset\": \"eth\",  \n                  \"allowance\": \"0.5\",  \n                  \"used\": \"0.0\"  \n                }  \n              ],  \n              \"scope\": \"app.create\",  \n              \"expires_at\": \"2024-12-31T23:59:59Z\",  \n              \"created_at\": \"2024-01-01T00:00:00Z\"  \n            }  \n          ]  \n        },  \n        1619123456789  \n      ],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    \n\n**Response Fields:**\n\n  * `id`: Unique identifier for the session key record\n  * `session_key`: The address of the session key\n  * `application`: Application name this session key is authorized for\n  * `allowances`: Array of allowances with usage tracking:\n    * `asset`: Symbol of the asset (e.g., \"usdc\", \"eth\")\n    * `allowance`: Maximum amount the session key can spend\n    * `used`: Amount already spent by this session key\n  * `scope`: Permission scope (omitted if empty)\n  * `expires_at`: When this session key expires (ISO 8601 format)\n  * `created_at`: When the session key was created (ISO 8601 format)\n\n#### Revoke a Session Keyâ€‹\n\nTo immediately invalidate a session key, use the `revoke_session_key` method:\n\n**Request:**\n    \n    \n    {  \n      \"req\": [  \n        1,  \n        \"revoke_session_key\",  \n        {  \n          \"session_key\": \"0xabcdef1234567890...\"  \n        },  \n        1619123456789  \n      ],  \n      \"sig\": [\"0x9876fedcba...\"]  \n    }  \n    \n\n**Response:**\n    \n    \n    {  \n      \"res\": [  \n        1,  \n        \"revoke_session_key\",  \n        {  \n          \"session_key\": \"0xabcdef1234567890...\"  \n        },  \n        1619123456789  \n      ],  \n      \"sig\": [\"0xabcd1234...\"]  \n    }  \n    \n\n**Permission Rules:**\n\n  * A wallet can revoke any of its session keys\n  * A session key can revoke itself\n  * A session key with `application: \"clearnode\"` can revoke other session keys belonging to the same wallet\n  * A non-\"clearnode\" session key cannot revoke other session keys (only itself)\n\n**Important Notes:**\n\n  * Revocation is **immediate and cannot be undone**\n  * After revocation, any operations attempted with the revoked session key will fail with a validation error\n  * The revoked session key will no longer appear in the `get_session_keys` response\n  * Revocation is useful for security purposes when a session key may have been compromised\n\n**Error Cases:**\n\n  * Session key does not exist, belongs to another wallet, or is expired: `\"operation denied: provided address is not an active session key of this user\"`\n  * Non-\"clearnode\" session key attempting to revoke another session key: `\"operation denied: insufficient permissions for the active session key\"`\n\n### Nitrolite SDKâ€‹\n\nThe Nitrolite SDK provides a higher-level abstraction for managing session keys. For detailed information on using session keys with the Nitrolite SDK, please refer to the SDK documentation.\n\n\n\n[PreviousMessage Envelope (RPC Protocol)](/docs/learn/core-concepts/message-envelope)\n\n  * How to Manage Session Keys\n    * Clearnode\n    * Nitrolite SDK\n\nSummary: This component manages the lifecycle and security configuration of session keys, enabling applications to perform authorized transactions within defined asset allowances and expiration periods.\n\nRelated terms: session keys, auth_request, get_session_keys, authentication, allowances, spending limits, clearnode, access control, session management, wallet authorization, token permissions, sessionkey, authrequest\n\nUse cases: delegated wallet signing for dApps, automated trading with pre-defined spending limits, temporary session authorization for gaming, non-custodial application authentication",
    "metadata": {
      "title": "Managing Session Keys | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/advanced/managing-session-keys",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component manages the lifecycle and security configuration of session keys, enabling applications to perform authorized transactions within defined asset allowances and expiration periods.",
      "keywords": [
        "session keys",
        "auth_request",
        "get_session_keys",
        "authentication",
        "allowances",
        "spending limits",
        "clearnode",
        "access control",
        "session management",
        "wallet authorization",
        "token permissions",
        "sessionkey",
        "authrequest"
      ],
      "function_name": "auth_request",
      "intent": "configuration",
      "use_cases": [
        "delegated wallet signing for dApps",
        "automated trading with pre-defined spending limits",
        "temporary session authorization for gaming",
        "non-custodial application authentication"
      ],
      "function_names": [
        "get_session_keys",
        "session_keys",
        "expires_at",
        "created_at",
        "auth_request"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "* Core Concepts\n  * App Sessions\n\n\n\n# App Sessions\n\nApp sessions are off-chain channels built on top of the unified balance that enable multi-party applications with custom governance rules.\n\n**Goal** : Understand how app sessions work for building multi-party applications.\n\n* * *\n\nSummary: App sessions are off-chain communication channels built on top of unified balances that facilitate multi-party applications with customizable governance rules.\n\nRelated terms: app session, off-chain channel, multi-party application, governance rules, state channel, unified balance, layer 2, payment channel, session management, multi-user, decentralized app, appsessions, offchain\n\nUse cases: multi-party gaming, collaborative DeFi protocols, high-frequency trading, shared state applications",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "App sessions are off-chain communication channels built on top of unified balances that facilitate multi-party applications with customizable governance rules.",
      "keywords": [
        "app session",
        "off-chain channel",
        "multi-party application",
        "governance rules",
        "state channel",
        "unified balance",
        "layer 2",
        "payment channel",
        "session management",
        "multi-user",
        "decentralized app",
        "appsessions",
        "offchain"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "multi-party gaming",
        "collaborative DeFi protocols",
        "high-frequency trading",
        "shared state applications"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## What is an App Session?â€‹\n\n\nAn **app session** is a temporary shared account where multiple participants can:\n\n  * Lock funds from their unified balance\n  * Execute application-specific logic (games, escrow, predictions)\n  * Redistribute funds based on outcomes\n  * Close and release funds back to unified balances\n\nThink of it as a programmable escrow with custom voting rules.\n\n* * *\n\nSummary: An app session acts as a programmable, multi-party escrow environment where participants lock funds to execute custom application logic and settle balances based on agreed-upon outcomes.\n\nRelated terms: app session, shared account, programmable escrow, lock funds, fund redistribution, multi-party, unified balance, settlement, voting rules, state channel, appsessions, session management, payout\n\nUse cases: multi-party escrow services, gaming and betting outcomes, prediction markets, conditional fund redistribution",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "An app session acts as a programmable, multi-party escrow environment where participants lock funds to execute custom application logic and settle balances based on agreed-upon outcomes.",
      "keywords": [
        "app session",
        "shared account",
        "programmable escrow",
        "lock funds",
        "fund redistribution",
        "multi-party",
        "unified balance",
        "settlement",
        "voting rules",
        "state channel",
        "appsessions",
        "session management",
        "payout"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "multi-party escrow services",
        "gaming and betting outcomes",
        "prediction markets",
        "conditional fund redistribution"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## App Session vs Payment Channelâ€‹\n\n\nFeature| Payment Channel| App Session  \n---|---|---  \n**Participants**|  Always 2| 2 or more  \n**Governance**|  Both must sign| Quorum-based  \n**Fund source**|  On-chain deposit| Unified balance  \n**Mid-session changes**|  Via resize (on-chain)| Via intent (off-chain)  \n**Use case**|  Transfers| Applications  \n  \n* * *\n\nSummary: This section defines the architectural differences between Payment Channels and App Sessions, highlighting their distinct governance models, participant counts, and funding mechanisms within the Yellow Network.\n\nRelated terms: payment channel, app session, multi-party, quorum, off-chain, on-chain, unified balance, state channel, governance, session management, layer 2, p2p, application session, state update\n\nUse cases: multi-party application logic, off-chain state transitions, quorum-based governance, unified balance management",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section defines the architectural differences between Payment Channels and App Sessions, highlighting their distinct governance models, participant counts, and funding mechanisms within the Yellow Network.",
      "keywords": [
        "payment channel",
        "app session",
        "multi-party",
        "quorum",
        "off-chain",
        "on-chain",
        "unified balance",
        "state channel",
        "governance",
        "session management",
        "layer 2",
        "p2p",
        "application session",
        "state update"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "multi-party application logic",
        "off-chain state transitions",
        "quorum-based governance",
        "unified balance management"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## App Session Definitionâ€‹\n\n\nEvery app session starts with a **definition** that specifies the rules:\n\nField| Description  \n---|---  \n`protocol`| Version (`NitroRPC/0.4` recommended)  \n`participants`| Wallet addresses (order matters for signatures)  \n`weights`| Voting power per participant  \n`quorum`| Minimum weight required for state updates  \n`challenge`| Dispute window in seconds  \n`nonce`| Unique identifier (typically timestamp)  \n  \nThe `app_session_id` is computed deterministically from the definition using `keccak256(JSON.stringify(definition))`.\n\n* * *\n\nSummary: Defines the foundational configuration and governance parameters for an application session, establishing participant roles, voting thresholds, and dispute resolution windows.\n\nRelated terms: app session, session definition, quorum, challenge window, participant weights, keccak256, session id, nitro protocol, state channel, governance, nonce, wallet addresses, yellow network\n\nUse cases: Initializing a state channel, Configuring multi-party governance, Setting dispute resolution parameters",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the foundational configuration and governance parameters for an application session, establishing participant roles, voting thresholds, and dispute resolution windows.",
      "keywords": [
        "app session",
        "session definition",
        "quorum",
        "challenge window",
        "participant weights",
        "keccak256",
        "session id",
        "nitro protocol",
        "state channel",
        "governance",
        "nonce",
        "wallet addresses",
        "yellow network"
      ],
      "function_name": "app_session_id",
      "intent": "concept",
      "use_cases": [
        "Initializing a state channel",
        "Configuring multi-party governance",
        "Setting dispute resolution parameters"
      ],
      "function_names": [
        "app_session_id",
        "keccak256"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Governance with Quorumâ€‹\n\n\nThe quorum system enables flexible governance patterns.\n\n### How It Worksâ€‹\n\n  1. Each participant has a **weight** (voting power)\n  2. State updates require signatures with total weight â‰¥ **quorum**\n  3. Not everyone needs to signâ€”just enough to meet quorum\n\n### Common Patternsâ€‹\n\nPattern| Setup| Use Case  \n---|---|---  \n**Unanimous**| `weights: [50, 50]`, `quorum: 100`| Both must agree  \n**Trusted Judge**| `weights: [0, 0, 100]`, `quorum: 100`| App determines outcome  \n**2-of-3 Escrow**| `weights: [40, 40, 50]`, `quorum: 80`| Any two can proceed  \n**Weighted DAO**| `weights: [20, 25, 30, 25]`, `quorum: 51`| Majority by stake  \n  \n* * *\n\nSummary: Defines the governance and consensus logic for state updates within an App Session using a weighted signature and quorum threshold system to enable flexible multi-party agreement models.\n\nRelated terms: quorum, governance, voting power, weights, state update, multi-sig, consensus, escrow, DAO, signature threshold, agreement, multi-party, qorum, voting weight\n\nUse cases: multi-party escrow, weighted DAO governance, trusted judge arbitration, unanimous peer-to-peer payments",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the governance and consensus logic for state updates within an App Session using a weighted signature and quorum threshold system to enable flexible multi-party agreement models.",
      "keywords": [
        "quorum",
        "governance",
        "voting power",
        "weights",
        "state update",
        "multi-sig",
        "consensus",
        "escrow",
        "DAO",
        "signature threshold",
        "agreement",
        "multi-party",
        "qorum",
        "voting weight"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "multi-party escrow",
        "weighted DAO governance",
        "trusted judge arbitration",
        "unanimous peer-to-peer payments"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Session Lifecycleâ€‹\n\n\ncreate_app_session\n\nsubmit_app_state\n\nclose_app_session\n\nOpen\n\nClosed\n\n### 1\\. Creationâ€‹\n\n  * Funds locked from participants' unified balances\n  * All participants with non-zero allocations must sign\n  * Status becomes `open`, version starts at `1`\n\n### 2\\. State Updatesâ€‹\n\n  * Redistribute funds with `submit_app_state`\n  * Version must increment by exactly 1\n  * Quorum of signatures required\n\n### 3\\. Closureâ€‹\n\n  * Final allocations distributed to unified balances\n  * Session becomes `closed` (cannot reopen)\n  * Quorum of signatures required\n\n* * *\n\nSummary: This component defines the lifecycle of off-chain application sessions, governing how funds are locked, state transitions are validated through multi-party signatures, and final balances are settled.\n\nRelated terms: session management, state channel, off-chain settlement, fund locking, multi-sig, quorum, versioning, payment channel, ledger update, close session, open session, app state, state transition, yellow network\n\nUse cases: off-chain trading, high-frequency micro-payments, multi-party state synchronization",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the lifecycle of off-chain application sessions, governing how funds are locked, state transitions are validated through multi-party signatures, and final balances are settled.",
      "keywords": [
        "session management",
        "state channel",
        "off-chain settlement",
        "fund locking",
        "multi-sig",
        "quorum",
        "versioning",
        "payment channel",
        "ledger update",
        "close session",
        "open session",
        "app state",
        "state transition",
        "yellow network"
      ],
      "function_name": "create_app_session",
      "intent": "concept",
      "use_cases": [
        "off-chain trading",
        "high-frequency micro-payments",
        "multi-party state synchronization"
      ],
      "function_names": [
        "close_app_session",
        "submit_app_state",
        "create_app_session"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Intent System (NitroRPC/0.4)â€‹\n\n\nThe intent system enables dynamic fund management during active sessions:\n\nIntent| Purpose| Rule  \n---|---|---  \n**OPERATE**|  Redistribute existing funds| Sum unchanged  \n**DEPOSIT**|  Add funds from unified balance| Sum increases  \n**WITHDRAW**|  Remove funds to unified balance| Sum decreases  \n  \nAllocations Are Final State\n\nAllocations always represent the **final state** , not the delta. The Clearnode computes deltas internally.\n\n* * *\n\nSummary: The Intent System facilitates dynamic fund management within active sessions by defining final state allocations for redistributing, adding, or removing liquidity.\n\nRelated terms: intent system, fund management, NitroRPC, OPERATE, DEPOSIT, WITHDRAW, allocation state, unified balance, Clearnode, delta computation, session state, liquidity management, asset redistribution, state channel, fund allocation\n\nUse cases: Rebalancing funds between participants during a session, Topping up session liquidity from a unified wallet, Settling partial gains by withdrawing funds to a main balance",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The Intent System facilitates dynamic fund management within active sessions by defining final state allocations for redistributing, adding, or removing liquidity.",
      "keywords": [
        "intent system",
        "fund management",
        "NitroRPC",
        "OPERATE",
        "DEPOSIT",
        "WITHDRAW",
        "allocation state",
        "unified balance",
        "Clearnode",
        "delta computation",
        "session state",
        "liquidity management",
        "asset redistribution",
        "state channel",
        "fund allocation"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Rebalancing funds between participants during a session",
        "Topping up session liquidity from a unified wallet",
        "Settling partial gains by withdrawing funds to a main balance"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Fund Flowâ€‹\n\n\nApp Session\n\nUnified Balances\n\ncreate (lock)\n\ncreate (lock)\n\nclose (release)\n\nclose (release)\n\nAlice: 200 USDC\n\nBob: 200 USDC\n\nAlice: 100 USDC\n\nBob: 100 USDC\n\n* * *\n\nSummary: Defines the lifecycle of funds within an App Session, detailing how assets are locked from unified balances at session creation and released back upon session closure.\n\nRelated terms: App Session, Fund Flow, Unified Balances, lock funds, release funds, asset allocation, liquidity management, deposit, withdrawal, session lifecycle, state channel, settlement, fund locking, balance sync\n\nUse cases: Allocating collateral for a peer-to-peer trading session, Locking liquidity for high-frequency micro-transactions, Managing temporary asset isolation for multi-party applications",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the lifecycle of funds within an App Session, detailing how assets are locked from unified balances at session creation and released back upon session closure.",
      "keywords": [
        "App Session",
        "Fund Flow",
        "Unified Balances",
        "lock funds",
        "release funds",
        "asset allocation",
        "liquidity management",
        "deposit",
        "withdrawal",
        "session lifecycle",
        "state channel",
        "settlement",
        "fund locking",
        "balance sync"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Allocating collateral for a peer-to-peer trading session",
        "Locking liquidity for high-frequency micro-transactions",
        "Managing temporary asset isolation for multi-party applications"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Protocol Versionsâ€‹\n\n\nVersion| Status| Key Features  \n---|---|---  \n**NitroRPC/0.2**|  Legacy| Basic state updates only  \n**NitroRPC/0.4**|  Current| Intent system (OPERATE, DEPOSIT, WITHDRAW)  \n  \nAlways use `NitroRPC/0.4` for new applications. Protocol version is set at creation and cannot be changed.\n\n* * *\n\nSummary: Defines the available protocol versions for App Sessions, highlighting the transition from basic state updates in NitroRPC/0.2 to the intent-based system in NitroRPC/0.4 for operations, deposits, and withdrawals.\n\nRelated terms: NitroRPC, protocol version, NitroRPC/0.4, NitroRPC/0.2, intent system, state updates, OPERATE, DEPOSIT, WITHDRAW, legacy support, versioning, session configuration, Yellow Network, Nitro RPC, Nitro-RPC\n\nUse cases: selecting protocol version for new apps, upgrading from legacy state updates, implementing intent-based deposits and withdrawals",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the available protocol versions for App Sessions, highlighting the transition from basic state updates in NitroRPC/0.2 to the intent-based system in NitroRPC/0.4 for operations, deposits, and withdrawals.",
      "keywords": [
        "NitroRPC",
        "protocol version",
        "NitroRPC/0.4",
        "NitroRPC/0.2",
        "intent system",
        "state updates",
        "OPERATE",
        "DEPOSIT",
        "WITHDRAW",
        "legacy support",
        "versioning",
        "session configuration",
        "Yellow Network",
        "Nitro RPC",
        "Nitro-RPC"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "selecting protocol version for new apps",
        "upgrading from legacy state updates",
        "implementing intent-based deposits and withdrawals"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Best Practicesâ€‹\n\n\n  1. **Set appropriate challenge periods** : 1 hour minimum, 24 hours recommended\n  2. **Include commission participants** : Apps often have a judge that takes a small fee\n  3. **Plan for disputes** : Design allocations that can be verified by third parties\n  4. **Version carefully** : Each state update must be exactly `current + 1`\n\n* * *\n\nSummary: Outlines architectural best practices for App Sessions, focusing on security parameters, commission structures, and state versioning to ensure reliable dispute resolution.\n\nRelated terms: best practices, challenge period, commission, dispute resolution, state update, versioning, judge, fee management, timeout, allocation, app session, sequence, security tips\n\nUse cases: Configuring secure state channels, Implementing fee-based judge roles, Designing dispute-resistant payment flows, Managing sequential state transitions",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Outlines architectural best practices for App Sessions, focusing on security parameters, commission structures, and state versioning to ensure reliable dispute resolution.",
      "keywords": [
        "best practices",
        "challenge period",
        "commission",
        "dispute resolution",
        "state update",
        "versioning",
        "judge",
        "fee management",
        "timeout",
        "allocation",
        "app session",
        "sequence",
        "security tips"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Configuring secure state channels",
        "Implementing fee-based judge roles",
        "Designing dispute-resistant payment flows",
        "Managing sequential state transitions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Deep Diveâ€‹\n\n\nFor complete method specifications and implementation details:\n\n  * **[App Session Methods](/docs/protocol/off-chain/app-sessions)** â€” Complete method specifications\n  * **[Communication Flows](/docs/protocol/communication-flows#app-session-lifecycle-flow)** â€” Sequence diagrams\n  * **[Implementation Checklist](/docs/protocol/implementation-checklist#state-management)** â€” Building app session support\n\n\n\n[PreviousState Channels vs L1/L2](/docs/learn/core-concepts/state-channels-vs-l1-l2)[NextSession Keys](/docs/learn/core-concepts/session-keys)\n\n  * What is an App Session?\n  * App Session vs Payment Channel\n  * App Session Definition\n  * Governance with Quorum\n    * How It Works\n    * Common Patterns\n  * Session Lifecycle\n    * 1\\. Creation\n    * 2\\. State Updates\n    * 3\\. Closure\n  * Intent System (NitroRPC/0.4)\n  * Fund Flow\n  * Protocol Versions\n  * Best Practices\n  * Deep Dive\n\nSummary: App Sessions serve as off-chain state containers that manage complex multi-party interactions and governance through a structured lifecycle, extending beyond simple payment channel functionality.\n\nRelated terms: app session, state channel, off-chain state, session lifecycle, quorum governance, NitroRPC, state update, multi-party interaction, fund flow, session management, yellow network, payment channel comparison, session keys\n\nUse cases: multi-party state synchronization, off-chain governance and voting, high-frequency state updates, complex decentralized application logic",
    "metadata": {
      "title": "App Sessions | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "App Sessions serve as off-chain state containers that manage complex multi-party interactions and governance through a structured lifecycle, extending beyond simple payment channel functionality.",
      "keywords": [
        "app session",
        "state channel",
        "off-chain state",
        "session lifecycle",
        "quorum governance",
        "NitroRPC",
        "state update",
        "multi-party interaction",
        "fund flow",
        "session management",
        "yellow network",
        "payment channel comparison",
        "session keys"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "multi-party state synchronization",
        "off-chain governance and voting",
        "high-frequency state updates",
        "complex decentralized application logic"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Core Concepts\n  * Challenge-Response & Disputes\n\n\n\n# Challenge-Response & Disputes\n\nIn this guide, you will learn how Yellow Network resolves disputes and ensures your funds are always recoverable.\n\n**Goal** : Understand the security guarantees that make off-chain transactions safe.\n\n* * *\n\nSummary: This component outlines the security framework for resolving off-chain transaction conflicts and ensuring fund recoverability through challenge-response mechanisms. It provides the architectural guarantees necessary for trustless settlement and protection against malicious actors within the network.\n\nRelated terms: dispute resolution, challenge-response, fund recovery, off-chain security, fraud proof, state channel, exit mechanism, arbitration, layer 2 security, settlement, fund safety, transaction finality, dispute period\n\nUse cases: resolving off-chain conflicts, recovering funds from offline peers, ensuring protocol security, handling malicious state updates",
    "metadata": {
      "title": "Challenge-Response & Disputes | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/challenge-response",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component outlines the security framework for resolving off-chain transaction conflicts and ensuring fund recoverability through challenge-response mechanisms. It provides the architectural guarantees necessary for trustless settlement and protection against malicious actors within the network.",
      "keywords": [
        "dispute resolution",
        "challenge-response",
        "fund recovery",
        "off-chain security",
        "fraud proof",
        "state channel",
        "exit mechanism",
        "arbitration",
        "layer 2 security",
        "settlement",
        "fund safety",
        "transaction finality",
        "dispute period"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "resolving off-chain conflicts",
        "recovering funds from offline peers",
        "ensuring protocol security",
        "handling malicious state updates"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Why Challenge-Response Mattersâ€‹\n\n\nIn any off-chain system, a critical question arises: **What if someone tries to cheat?**\n\nState channels solve this with a challenge-response mechanism:\n\n  1. Anyone can submit a state to the blockchain\n  2. Counterparties have time to respond with a newer state\n  3. The newest valid state always wins\n  4. Funds are distributed according to that state\n\n* * *\n\nSummary: Defines the security protocol for state channels by allowing participants to verify and contest off-chain states on-chain, ensuring the most recent valid state determines fund distribution.\n\nRelated terms: dispute resolution, challenge-response, state channel, fraud prevention, on-chain settlement, exit mechanism, security, cheating protection, state update, finality, challange, dispute, settlement window\n\nUse cases: resolving counterparty disputes, securing off-chain transactions, unilateral channel closure, fraud detection and mitigation",
    "metadata": {
      "title": "Challenge-Response & Disputes | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/challenge-response",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the security protocol for state channels by allowing participants to verify and contest off-chain states on-chain, ensuring the most recent valid state determines fund distribution.",
      "keywords": [
        "dispute resolution",
        "challenge-response",
        "state channel",
        "fraud prevention",
        "on-chain settlement",
        "exit mechanism",
        "security",
        "cheating protection",
        "state update",
        "finality",
        "challange",
        "dispute",
        "settlement window"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "resolving counterparty disputes",
        "securing off-chain transactions",
        "unilateral channel closure",
        "fraud detection and mitigation"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## The Trust Modelâ€‹\n\n\nState channels are **trustless** because:\n\nGuarantee| How It's Achieved  \n---|---  \n**Fund custody**|  Smart contract holds funds, not Clearnode  \n**State validity**|  Only signed states are accepted  \n**Dispute resolution**|  On-chain fallback if disagreement  \n**Recovery**|  You can always get your funds back  \n  \n* * *\n\nSummary: Defines the trustless security architecture of state channels, explaining how smart contracts and cryptographic signatures guarantee fund safety and provide on-chain dispute resolution mechanisms.\n\nRelated terms: trustless, state channels, fund custody, dispute resolution, on-chain fallback, signed states, recovery, security model, clearnode, state validity, settlement, arbitration, challenge-response\n\nUse cases: securing user funds, resolving off-chain disagreements, verifying channel state integrity, emergency fund withdrawal",
    "metadata": {
      "title": "Challenge-Response & Disputes | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/challenge-response",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the trustless security architecture of state channels, explaining how smart contracts and cryptographic signatures guarantee fund safety and provide on-chain dispute resolution mechanisms.",
      "keywords": [
        "trustless",
        "state channels",
        "fund custody",
        "dispute resolution",
        "on-chain fallback",
        "signed states",
        "recovery",
        "security model",
        "clearnode",
        "state validity",
        "settlement",
        "arbitration",
        "challenge-response"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "securing user funds",
        "resolving off-chain disagreements",
        "verifying channel state integrity",
        "emergency fund withdrawal"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Channel Dispute Flowâ€‹\n\n\n### Scenario: Clearnode Becomes Unresponsiveâ€‹\n\nYou have a channel with 100 USDC. The Clearnode stops responding.\n\n**Your options:**\n\n  1. Wait for Clearnode to recover\n  2. Force settlement on-chain via challenge\n\n### The Processâ€‹\n\n  1. **Initiate Challenge** : Submit your latest signed state to the blockchain\n  2. **Challenge Period** : Contract sets a timer (e.g., 24 hours)\n  3. **Response Window** : Counterparty can submit a newer state\n  4. **Resolution** : After timeout, challenged state becomes final\n\nchallenge()\n\ncheckpoint() with newer state\n\nTimeout expires\n\nACTIVE\n\nDISPUTE\n\nFINAL\n\nAnyone can submit  \nnewer valid state\n\n* * *\n\nSummary: Defines the protocol's safety mechanism for resolving off-chain channel disputes on-chain when a counterparty becomes unresponsive, ensuring funds can be recovered through a time-locked challenge-response process.\n\nRelated terms: dispute resolution, on-chain settlement, challenge period, unresponsive node, channel closure, state update, force settlement, exit mechanism, fraud proof, timeout, clearnode, settlement, dispute flow\n\nUse cases: recovering funds from offline peer, resolving state disagreement, forced channel closure, security against malicious nodes",
    "metadata": {
      "title": "Challenge-Response & Disputes | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/challenge-response",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the protocol's safety mechanism for resolving off-chain channel disputes on-chain when a counterparty becomes unresponsive, ensuring funds can be recovered through a time-locked challenge-response process.",
      "keywords": [
        "dispute resolution",
        "on-chain settlement",
        "challenge period",
        "unresponsive node",
        "channel closure",
        "state update",
        "force settlement",
        "exit mechanism",
        "fraud proof",
        "timeout",
        "clearnode",
        "settlement",
        "dispute flow"
      ],
      "function_name": "challenge",
      "intent": "concept",
      "use_cases": [
        "recovering funds from offline peer",
        "resolving state disagreement",
        "forced channel closure",
        "security against malicious nodes"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Why This Worksâ€‹\n\n\n### States Are Orderedâ€‹\n\nEvery state has a version number. A newer (higher version) state always supersedes older states.\n\n### States Are Signedâ€‹\n\nWith the default SimpleConsensus adjudicator, both parties must sign every state. If someone signed a state, they can't later claim they didn't agree.\n\nOther Adjudicators\n\nDifferent adjudicators may have different signing requirements. For example, a Remittance adjudicator may only require the sender's signature. The signing rules are defined by the channel's adjudicator contract.\n\n### Challenge Period Provides Fairnessâ€‹\n\nThe waiting window ensures honest parties have time to respond. Network delays don't cause losses.\n\n### On-Chain Contract is Neutralâ€‹\n\nThe smart contract accepts any valid signed state, picks the highest version, and distributes funds exactly as specified.\n\n* * *\n\nSummary: Explains the underlying security principles of the protocol's dispute resolution system, detailing how state versioning, multi-party signatures, and challenge periods ensure trustless settlement.\n\nRelated terms: dispute resolution, state versioning, digital signatures, adjudicator, SimpleConsensus, challenge period, on-chain settlement, trustless, conflict management, state channel, security, signing rules, remittance\n\nUse cases: resolving payment conflicts, ensuring state channel finality, protecting against malicious state updates",
    "metadata": {
      "title": "Challenge-Response & Disputes | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/challenge-response",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Explains the underlying security principles of the protocol's dispute resolution system, detailing how state versioning, multi-party signatures, and challenge periods ensure trustless settlement.",
      "keywords": [
        "dispute resolution",
        "state versioning",
        "digital signatures",
        "adjudicator",
        "SimpleConsensus",
        "challenge period",
        "on-chain settlement",
        "trustless",
        "conflict management",
        "state channel",
        "security",
        "signing rules",
        "remittance"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "resolving payment conflicts",
        "ensuring state channel finality",
        "protecting against malicious state updates"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Challenge Period Selectionâ€‹\n\n\nDuration| Trade-offs  \n---|---  \n**1 hour**|  Fast resolution, tight response window  \n**24 hours**|  Balanced (recommended)  \n**7 days**|  Maximum safety, slow settlement  \n  \nThe Custody Contract enforces a minimum of 1 hour.\n\n* * *\n\nSummary: Defines the configurable timeframes for dispute resolution within the protocol, detailing the trade-offs between settlement speed and participant security.\n\nRelated terms: challenge period, dispute resolution, settlement time, custody contract, response window, arbitration, fraud proof, timeout, security vs speed, yellow network, dispute window, chalenge period, settlement delay\n\nUse cases: configuring dispute resolution parameters, optimizing settlement speed, securing high-value transactions",
    "metadata": {
      "title": "Challenge-Response & Disputes | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/challenge-response",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the configurable timeframes for dispute resolution within the protocol, detailing the trade-offs between settlement speed and participant security.",
      "keywords": [
        "challenge period",
        "dispute resolution",
        "settlement time",
        "custody contract",
        "response window",
        "arbitration",
        "fraud proof",
        "timeout",
        "security vs speed",
        "yellow network",
        "dispute window",
        "chalenge period",
        "settlement delay"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "configuring dispute resolution parameters",
        "optimizing settlement speed",
        "securing high-value transactions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Checkpoint vs Challengeâ€‹\n\n\nOperation| Purpose| Channel Status  \n---|---|---  \n`checkpoint()`| Record state without dispute| Stays ACTIVE  \n`challenge()`| Force dispute resolution| Changes to DISPUTE  \n  \nUse checkpoint for safety snapshots. Use challenge when you need to force settlement.\n\n* * *\n\nSummary: Defines the mechanisms for state synchronization and conflict resolution, distinguishing between non-disruptive state recording and formal dispute initiation for channel settlement.\n\nRelated terms: checkpoint, challenge, dispute resolution, state update, settlement, channel status, safety snapshot, force settlement, conflict management, payment channel, state recording, active status, dispute status, chalenge, check-point\n\nUse cases: Periodic state backup for channel safety, Resolving disagreements between channel participants, Forcing a final settlement on-chain, Managing channel lifecycle transitions",
    "metadata": {
      "title": "Challenge-Response & Disputes | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/challenge-response",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the mechanisms for state synchronization and conflict resolution, distinguishing between non-disruptive state recording and formal dispute initiation for channel settlement.",
      "keywords": [
        "checkpoint",
        "challenge",
        "dispute resolution",
        "state update",
        "settlement",
        "channel status",
        "safety snapshot",
        "force settlement",
        "conflict management",
        "payment channel",
        "state recording",
        "active status",
        "dispute status",
        "chalenge",
        "check-point"
      ],
      "function_name": "challenge",
      "intent": "concept",
      "use_cases": [
        "Periodic state backup for channel safety",
        "Resolving disagreements between channel participants",
        "Forcing a final settlement on-chain",
        "Managing channel lifecycle transitions"
      ],
      "function_names": [
        "challenge",
        "checkpoint"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## What Happens If...â€‹\n\n\nScenario| Outcome  \n---|---  \n**Clearnode goes offline**|  Challenge with latest state, withdraw after timeout  \n**You lose state history**|  Challenge with old state; counterparty submits newer if they have it  \n**Counterparty submits wrong state**|  Submit your newer state via checkpoint  \n**Block reorg occurs**|  Replay events from last confirmed block  \n  \n* * *\n\nSummary: This component outlines the protocol's dispute resolution and recovery mechanisms, detailing how the system handles node failures, state inconsistencies, and blockchain reorganizations to ensure fund safety.\n\nRelated terms: dispute resolution, challenge-response, state channel, fraud proof, timeout, withdrawal, block reorg, state recovery, clearnode, checkpoint, settlement, conflict resolution, dispute period, state update\n\nUse cases: recovering funds from offline nodes, resolving state conflicts, handling blockchain reorgs, protecting against malicious state submission",
    "metadata": {
      "title": "Challenge-Response & Disputes | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/challenge-response",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component outlines the protocol's dispute resolution and recovery mechanisms, detailing how the system handles node failures, state inconsistencies, and blockchain reorganizations to ensure fund safety.",
      "keywords": [
        "dispute resolution",
        "challenge-response",
        "state channel",
        "fraud proof",
        "timeout",
        "withdrawal",
        "block reorg",
        "state recovery",
        "clearnode",
        "checkpoint",
        "settlement",
        "conflict resolution",
        "dispute period",
        "state update"
      ],
      "function_name": null,
      "intent": "error_handling",
      "use_cases": [
        "recovering funds from offline nodes",
        "resolving state conflicts",
        "handling blockchain reorgs",
        "protecting against malicious state submission"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Key Takeawaysâ€‹\n\n\nConcept| Remember  \n---|---  \n**Challenge**|  Force on-chain dispute resolution  \n**Response**|  Submit newer state to defeat challenge  \n**Timeout**|  After period, challenged state becomes final  \n**Checkpoint**|  Record state without dispute  \n  \nSecurity Guarantee\n\nYou can **always** recover your funds according to the latest mutually signed state, regardless of counterparty behavior.\n\n* * *\n\nSummary: Provides a framework for on-chain dispute resolution, ensuring participants can recover funds by challenging invalid states or responding with the latest mutually signed state updates.\n\nRelated terms: challenge, dispute resolution, on-chain settlement, state channel, timeout, checkpoint, fund recovery, fraud proof, exit mechanism, settlement, finality, state update, yellow network, conflict resolution\n\nUse cases: resolving counterparty non-responsiveness, preventing fraudulent state submissions, finalizing channel balances on-chain, recovering funds from offline peers",
    "metadata": {
      "title": "Challenge-Response & Disputes | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/challenge-response",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a framework for on-chain dispute resolution, ensuring participants can recover funds by challenging invalid states or responding with the latest mutually signed state updates.",
      "keywords": [
        "challenge",
        "dispute resolution",
        "on-chain settlement",
        "state channel",
        "timeout",
        "checkpoint",
        "fund recovery",
        "fraud proof",
        "exit mechanism",
        "settlement",
        "finality",
        "state update",
        "yellow network",
        "conflict resolution"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "resolving counterparty non-responsiveness",
        "preventing fraudulent state submissions",
        "finalizing channel balances on-chain",
        "recovering funds from offline peers"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Deep Diveâ€‹\n\n\nFor technical implementation details:\n\n  * **[Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle)** â€” Full state machine\n  * **[Security Considerations](/docs/protocol/on-chain/security)** â€” Threat model and best practices\n  * **[Communication Flows](/docs/protocol/communication-flows#challenge-response-closure-flow)** â€” Sequence diagrams\n\n\n\n[PreviousSession Keys](/docs/learn/core-concepts/session-keys)[NextMessage Envelope (RPC Protocol)](/docs/learn/core-concepts/message-envelope)\n\n  * Why Challenge-Response Matters\n  * The Trust Model\n  * Channel Dispute Flow\n    * Scenario: Clearnode Becomes Unresponsive\n    * The Process\n  * Why This Works\n    * States Are Ordered\n    * States Are Signed\n    * Challenge Period Provides Fairness\n    * On-Chain Contract is Neutral\n  * Challenge Period Selection\n  * Checkpoint vs Challenge\n  * What Happens If...\n  * Key Takeaways\n  * Deep Dive\n\nSummary: This component outlines the protocol's mechanism for resolving conflicts and handling unresponsive participants through a time-bound challenge-response system to ensure state integrity and fund security.\n\nRelated terms: challenge-response, dispute resolution, channel dispute, on-chain settlement, unresponsive node, clearnode, signed states, challenge period, trustless, state update, conflict resolution, settlement, dispute flow, arbitration\n\nUse cases: resolving unresponsive peer issues, securing off-chain state transitions, on-chain dispute arbitration, handling malicious participant behavior",
    "metadata": {
      "title": "Challenge-Response & Disputes | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/challenge-response",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component outlines the protocol's mechanism for resolving conflicts and handling unresponsive participants through a time-bound challenge-response system to ensure state integrity and fund security.",
      "keywords": [
        "challenge-response",
        "dispute resolution",
        "channel dispute",
        "on-chain settlement",
        "unresponsive node",
        "clearnode",
        "signed states",
        "challenge period",
        "trustless",
        "state update",
        "conflict resolution",
        "settlement",
        "dispute flow",
        "arbitration"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "resolving unresponsive peer issues",
        "securing off-chain state transitions",
        "on-chain dispute arbitration",
        "handling malicious participant behavior"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Core Concepts\n  * Message Envelope (RPC Protocol)\n\n\n\n# Message Envelope (RPC Protocol)\n\nIn this guide, you will learn the essentials of how messages are structured and transmitted in Yellow Network.\n\n**Goal** : Understand the Nitro RPC protocol at a conceptual level.\n\n* * *\n\nSummary: Defines the structural format and transmission protocol for messages within the Yellow Network, utilizing the Nitro RPC standard to ensure consistent communication between network participants.\n\nRelated terms: RPC protocol, message envelope, Nitro RPC, data structure, message transmission, communication protocol, network messaging, payload format, request-response, Yellow Network, Nitro protocol, message framing, RPC envelope, message schema, transport layer\n\nUse cases: standardizing node communication, implementing custom RPC clients, debugging network messages, architecting cross-node messaging",
    "metadata": {
      "title": "Message Envelope (RPC Protocol) | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/message-envelope",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the structural format and transmission protocol for messages within the Yellow Network, utilizing the Nitro RPC standard to ensure consistent communication between network participants.",
      "keywords": [
        "RPC protocol",
        "message envelope",
        "Nitro RPC",
        "data structure",
        "message transmission",
        "communication protocol",
        "network messaging",
        "payload format",
        "request-response",
        "Yellow Network",
        "Nitro protocol",
        "message framing",
        "RPC envelope",
        "message schema",
        "transport layer"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "standardizing node communication",
        "implementing custom RPC clients",
        "debugging network messages",
        "architecting cross-node messaging"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Protocol Overviewâ€‹\n\n\n**Nitro RPC** is a lightweight RPC protocol optimized for state channel communication:\n\nFeature| Benefit  \n---|---  \n**Compact format**|  ~30% smaller than traditional JSON-RPC  \n**Signature-based auth**|  Every message is cryptographically verified  \n**Bidirectional**|  Real-time updates via WebSocket  \n**Ordered timestamps**|  Replay attack prevention  \n  \n* * *\n\nSummary: Nitro RPC is a lightweight, signature-verified communication protocol optimized for secure, real-time state channel updates and efficient message exchange.\n\nRelated terms: Nitro RPC, state channel, message envelope, cryptographic signature, WebSocket, replay protection, compact JSON, bidirectional communication, authentication, secure messaging, real-time updates, NitroRPC, state updates, peer-to-peer protocol\n\nUse cases: Secure state channel communication between nodes, Real-time payment channel updates, Preventing replay attacks in off-chain transactions",
    "metadata": {
      "title": "Message Envelope (RPC Protocol) | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/message-envelope",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Nitro RPC is a lightweight, signature-verified communication protocol optimized for secure, real-time state channel updates and efficient message exchange.",
      "keywords": [
        "Nitro RPC",
        "state channel",
        "message envelope",
        "cryptographic signature",
        "WebSocket",
        "replay protection",
        "compact JSON",
        "bidirectional communication",
        "authentication",
        "secure messaging",
        "real-time updates",
        "NitroRPC",
        "state updates",
        "peer-to-peer protocol"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Secure state channel communication between nodes",
        "Real-time payment channel updates",
        "Preventing replay attacks in off-chain transactions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Message Structureâ€‹\n\n\nEvery Nitro RPC message uses a compact JSON array format:\n\nComponent| Type| Description  \n---|---|---  \n**requestId**|  uint64| Unique identifier for correlation  \n**method**|  string| RPC method name (snake_case)  \n**params/result**|  object| Method-specific data  \n**timestamp**|  uint64| Unix milliseconds  \n  \n### Request Wrapperâ€‹\n    \n    \n    { \"req\": [requestId, method, params, timestamp], \"sig\": [...] }  \n    \n\n### Response Wrapperâ€‹\n    \n    \n    { \"res\": [requestId, method, result, timestamp], \"sig\": [...] }  \n    \n\n### Error Responseâ€‹\n    \n    \n    { \"res\": [requestId, \"error\", { \"error\": \"description\" }, timestamp], \"sig\": [...] }  \n    \n\n* * *\n\nSummary: Defines the standardized JSON-RPC message envelope for the Nitro protocol, specifying the compact array format for requests, responses, and error handling with cryptographic signatures.\n\nRelated terms: RPC protocol, message envelope, JSON-RPC, request wrapper, response wrapper, message signature, requestId, Nitro RPC, communication protocol, message format, payload structure, crypto signing, snake_case, error response\n\nUse cases: standardizing cross-node communication, verifying message integrity with signatures, correlating asynchronous requests and responses",
    "metadata": {
      "title": "Message Envelope (RPC Protocol) | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/message-envelope",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the standardized JSON-RPC message envelope for the Nitro protocol, specifying the compact array format for requests, responses, and error handling with cryptographic signatures.",
      "keywords": [
        "RPC protocol",
        "message envelope",
        "JSON-RPC",
        "request wrapper",
        "response wrapper",
        "message signature",
        "requestId",
        "Nitro RPC",
        "communication protocol",
        "message format",
        "payload structure",
        "crypto signing",
        "snake_case",
        "error response"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "standardizing cross-node communication",
        "verifying message integrity with signatures",
        "correlating asynchronous requests and responses"
      ],
      "function_names": [
        "snake_case"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Signature Formatâ€‹\n\n\nEach signature is a 65-byte ECDSA signature (r + s + v) represented as a 0x-prefixed hex string.\n\nContext| What's Signed| Who Signs  \n---|---|---  \n**Requests**|  JSON payload hash| Session key (or main wallet)  \n**Responses**|  JSON payload hash| Clearnode  \n  \n* * *\n\nSummary: Defines the cryptographic signature standard and authentication scheme for RPC message envelopes, ensuring integrity and non-repudiation between clients and Clearnodes using 65-byte ECDSA signatures.\n\nRelated terms: ECDSA, signature format, 65-byte signature, r+s+v, hex string, message envelope, RPC protocol, payload hash, session key, Clearnode, authentication, cryptographic signing, message integrity, 0x-prefixed\n\nUse cases: verifying message authenticity, securing RPC communication, implementing session-based signing, validating Clearnode responses",
    "metadata": {
      "title": "Message Envelope (RPC Protocol) | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/message-envelope",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the cryptographic signature standard and authentication scheme for RPC message envelopes, ensuring integrity and non-repudiation between clients and Clearnodes using 65-byte ECDSA signatures.",
      "keywords": [
        "ECDSA",
        "signature format",
        "65-byte signature",
        "r+s+v",
        "hex string",
        "message envelope",
        "RPC protocol",
        "payload hash",
        "session key",
        "Clearnode",
        "authentication",
        "cryptographic signing",
        "message integrity",
        "0x-prefixed"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "verifying message authenticity",
        "securing RPC communication",
        "implementing session-based signing",
        "validating Clearnode responses"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Method Categoriesâ€‹\n\n\nCategory| Methods  \n---|---  \n**Auth**| `auth_request`, `auth_verify`  \n**Channels**| `create_channel`, `close_channel`, `resize_channel`  \n**Transfers**| `transfer`  \n**App Sessions**| `create_app_session`, `submit_app_state`, `close_app_session`  \n**Queries**| `get_ledger_balances`, `get_channels`, `get_app_sessions`, etc.  \n  \n* * *\n\nSummary: Defines the RPC method categories and specific functions used to manage authentication, state channels, asset transfers, and application sessions within the Yellow Network protocol.\n\nRelated terms: RPC protocol, message envelope, state channels, authentication, asset transfer, app session, ledger balance, channel management, session lifecycle, crypto payments, auth_verify, submit_app_state, create_channel, yellow network\n\nUse cases: Managing state channel lifecycles, Authenticating users and verifying identities, Executing off-chain application state updates, Querying ledger balances and session statuses",
    "metadata": {
      "title": "Message Envelope (RPC Protocol) | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/message-envelope",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the RPC method categories and specific functions used to manage authentication, state channels, asset transfers, and application sessions within the Yellow Network protocol.",
      "keywords": [
        "RPC protocol",
        "message envelope",
        "state channels",
        "authentication",
        "asset transfer",
        "app session",
        "ledger balance",
        "channel management",
        "session lifecycle",
        "crypto payments",
        "auth_verify",
        "submit_app_state",
        "create_channel",
        "yellow network"
      ],
      "function_name": "submit_app_state",
      "intent": "api_reference",
      "use_cases": [
        "Managing state channel lifecycles",
        "Authenticating users and verifying identities",
        "Executing off-chain application state updates",
        "Querying ledger balances and session statuses"
      ],
      "function_names": [
        "submit_app_state",
        "auth_verify",
        "create_channel",
        "resize_channel",
        "create_app_session"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Notificationsâ€‹\n\n\nThe Clearnode pushes real-time updates:\n\nNotification| When Sent  \n---|---  \n`bu` (balance update)| Balance changed  \n`cu` (channel update)| Channel status changed  \n`tr` (transfer)| Incoming/outgoing transfer  \n`asu` (app session update)| App session state changed  \n  \n* * *\n\nSummary: The Clearnode notification system provides real-time asynchronous updates to clients regarding balance changes, channel status transitions, transfers, and application session state modifications.\n\nRelated terms: notifications, real-time updates, balance update, channel status, transfer, app session, bu, cu, tr, asu, clearnode, rpc protocol, event stream, push notifications, state synchronization\n\nUse cases: Real-time balance monitoring, Tracking payment and transfer status, Synchronizing multi-party application states, Automated response to channel status changes",
    "metadata": {
      "title": "Message Envelope (RPC Protocol) | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/message-envelope",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The Clearnode notification system provides real-time asynchronous updates to clients regarding balance changes, channel status transitions, transfers, and application session state modifications.",
      "keywords": [
        "notifications",
        "real-time updates",
        "balance update",
        "channel status",
        "transfer",
        "app session",
        "bu",
        "cu",
        "tr",
        "asu",
        "clearnode",
        "rpc protocol",
        "event stream",
        "push notifications",
        "state synchronization"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "Real-time balance monitoring",
        "Tracking payment and transfer status",
        "Synchronizing multi-party application states",
        "Automated response to channel status changes"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Communication Flowâ€‹\n\n\nClearnodeClientClearnodeClientRequest (signed)Verify signatureProcessResponse (signed)Verify signatureNotification (async)\n\n* * *\n\nSummary: This section defines the secure communication lifecycle between a Client and Clearnode, detailing the exchange of signed requests, responses, and asynchronous notifications within the RPC protocol.\n\nRelated terms: RPC protocol, message envelope, Clearnode, signature verification, signed messages, communication flow, async notifications, request-response, message integrity, cryptographic signing, secure transport, node communication\n\nUse cases: Establishing secure RPC connections, Verifying message authenticity between nodes, Handling asynchronous state updates from Clearnode",
    "metadata": {
      "title": "Message Envelope (RPC Protocol) | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/message-envelope",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section defines the secure communication lifecycle between a Client and Clearnode, detailing the exchange of signed requests, responses, and asynchronous notifications within the RPC protocol.",
      "keywords": [
        "RPC protocol",
        "message envelope",
        "Clearnode",
        "signature verification",
        "signed messages",
        "communication flow",
        "async notifications",
        "request-response",
        "message integrity",
        "cryptographic signing",
        "secure transport",
        "node communication"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Establishing secure RPC connections",
        "Verifying message authenticity between nodes",
        "Handling asynchronous state updates from Clearnode"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Protocol Versionsâ€‹\n\n\nVersion| Status| Key Features  \n---|---|---  \n**NitroRPC/0.2**|  Legacy| Basic state updates  \n**NitroRPC/0.4**|  Current| Intent system, enhanced validation  \n  \nAlways use NitroRPC/0.4 for new implementations.\n\n* * *\n\nSummary: Specifies the RPC protocol versions for the Yellow Network, identifying NitroRPC/0.4 as the current standard featuring an intent system and enhanced validation for secure state updates.\n\nRelated terms: NitroRPC, protocol version, RPC message, message envelope, intent system, state updates, validation, legacy support, communication protocol, Nitro RPC, Nitro-RPC, API versioning, network protocol\n\nUse cases: selecting protocol version, upgrading from legacy RPC, implementing intent-based messaging",
    "metadata": {
      "title": "Message Envelope (RPC Protocol) | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/message-envelope",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Specifies the RPC protocol versions for the Yellow Network, identifying NitroRPC/0.4 as the current standard featuring an intent system and enhanced validation for secure state updates.",
      "keywords": [
        "NitroRPC",
        "protocol version",
        "RPC message",
        "message envelope",
        "intent system",
        "state updates",
        "validation",
        "legacy support",
        "communication protocol",
        "Nitro RPC",
        "Nitro-RPC",
        "API versioning",
        "network protocol"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "selecting protocol version",
        "upgrading from legacy RPC",
        "implementing intent-based messaging"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Key Pointsâ€‹\n\n\n  1. **Compact arrays** instead of verbose JSON objects\n  2. **Every message signed** for authenticity\n  3. **Timestamps** prevent replay attacks\n  4. **Bidirectional** WebSocket for real-time updates\n\n* * *\n\nSummary: Defines the structural and security standards for the RPC communication layer, utilizing compact arrays for efficiency and digital signatures for message authenticity.\n\nRelated terms: RPC protocol, message envelope, compact array, digital signature, replay protection, WebSocket, real-time communication, message signing, authentication, payload structure, network protocol, Yellow Network, message integrity, serialization\n\nUse cases: Securing real-time communication, Optimizing network bandwidth, Preventing replay attacks in payment channels",
    "metadata": {
      "title": "Message Envelope (RPC Protocol) | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/message-envelope",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the structural and security standards for the RPC communication layer, utilizing compact arrays for efficiency and digital signatures for message authenticity.",
      "keywords": [
        "RPC protocol",
        "message envelope",
        "compact array",
        "digital signature",
        "replay protection",
        "WebSocket",
        "real-time communication",
        "message signing",
        "authentication",
        "payload structure",
        "network protocol",
        "Yellow Network",
        "message integrity",
        "serialization"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Securing real-time communication",
        "Optimizing network bandwidth",
        "Preventing replay attacks in payment channels"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Deep Diveâ€‹\n\n\nFor complete technical specifications:\n\n  * **[Message Format](/docs/protocol/off-chain/message-format)** â€” Full format specification\n  * **[Off-Chain Overview](/docs/protocol/off-chain/overview)** â€” Protocol architecture\n  * **[Implementation Checklist](/docs/protocol/implementation-checklist#off-chain-rpc)** â€” Building RPC support\n\n\n\n[PreviousChallenge-Response & Disputes](/docs/learn/core-concepts/challenge-response)[NextManaging Session Keys](/docs/learn/advanced/managing-session-keys)\n\n  * Protocol Overview\n  * Message Structure\n    * Request Wrapper\n    * Response Wrapper\n    * Error Response\n  * Signature Format\n  * Method Categories\n  * Notifications\n  * Communication Flow\n  * Protocol Versions\n  * Key Points\n  * Deep Dive\n\nSummary: Defines the standardized structure for off-chain communication between nodes, specifying how requests, responses, and errors are wrapped and signed within the Yellow Network RPC protocol.\n\nRelated terms: RPC protocol, message envelope, request wrapper, response wrapper, error handling, signature format, off-chain communication, JSON-RPC, message structure, payload signing, notification, protocol versioning, communication flow, yellow network\n\nUse cases: standardizing node-to-node communication, implementing custom RPC clients, verifying message integrity and signatures",
    "metadata": {
      "title": "Message Envelope (RPC Protocol) | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/message-envelope",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the standardized structure for off-chain communication between nodes, specifying how requests, responses, and errors are wrapped and signed within the Yellow Network RPC protocol.",
      "keywords": [
        "RPC protocol",
        "message envelope",
        "request wrapper",
        "response wrapper",
        "error handling",
        "signature format",
        "off-chain communication",
        "JSON-RPC",
        "message structure",
        "payload signing",
        "notification",
        "protocol versioning",
        "communication flow",
        "yellow network"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "standardizing node-to-node communication",
        "implementing custom RPC clients",
        "verifying message integrity and signatures"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Core Concepts\n  * Session Keys\n\n\n\n# Session Keys\n\nSession keys are delegated keys that enable applications to perform operations on behalf of a user's wallet with specified spending limits, permissions, and expiration times. They provide a secure way to grant limited access to applications without exposing the main wallet's private key.\n\nimportant\n\nSession keys are **no longer used as on-chain channel participant addresses** for new channels created after the v0.5.0 release. For all new channels, the wallet address is used directly as the participant address. However, session keys still function correctly for channels that were created before v0.5.0, ensuring backward compatibility.\n\n**Goal** : Understand how session keys enable seamless UX while maintaining security.\n\n* * *\n\nSummary: Session keys are delegated credentials that allow applications to execute transactions within defined constraintsâ€”such as spending limits and expiration timesâ€”without requiring the user's primary private key for every action.\n\nRelated terms: session keys, delegated keys, spending limits, permissions, expiration, wallet security, non-custodial, automated transactions, UX optimization, backward compatibility, key delegation, signing authority, temporary keys, sesion keys, participant address\n\nUse cases: High-frequency micro-payments without manual wallet confirmation, Granting temporary spending authority to a third-party application, Maintaining legacy channel support for pre-v0.5.0 integrations, Implementing time-bound access for automated payment services",
    "metadata": {
      "title": "Session Keys | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/session-keys",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Session keys are delegated credentials that allow applications to execute transactions within defined constraintsâ€”such as spending limits and expiration timesâ€”without requiring the user's primary private key for every action.",
      "keywords": [
        "session keys",
        "delegated keys",
        "spending limits",
        "permissions",
        "expiration",
        "wallet security",
        "non-custodial",
        "automated transactions",
        "UX optimization",
        "backward compatibility",
        "key delegation",
        "signing authority",
        "temporary keys",
        "sesion keys",
        "participant address"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "High-frequency micro-payments without manual wallet confirmation",
        "Granting temporary spending authority to a third-party application",
        "Maintaining legacy channel support for pre-v0.5.0 integrations",
        "Implementing time-bound access for automated payment services"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Why Session Keys Matterâ€‹\n\n\nEvery blockchain operation traditionally requires a wallet signature popup. For high-frequency applications like games or trading, this creates terrible UXâ€”imagine 40+ wallet prompts during a chess game.\n\nSession keys solve this by allowing you to **sign once** , then operate seamlessly for the duration of the session.\n\n* * *\n\nSummary: Session keys provide a mechanism to authorize a series of transactions or state updates with a single initial signature, eliminating repetitive wallet prompts for high-frequency applications.\n\nRelated terms: session keys, wallet signature, UX, high-frequency trading, gaming, sign once, authorization, temporary keys, non-custodial, automated signing, session management, wallet prompts, popups, sessionkey\n\nUse cases: high-frequency trading, blockchain gaming, real-time state updates",
    "metadata": {
      "title": "Session Keys | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/session-keys",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Session keys provide a mechanism to authorize a series of transactions or state updates with a single initial signature, eliminating repetitive wallet prompts for high-frequency applications.",
      "keywords": [
        "session keys",
        "wallet signature",
        "UX",
        "high-frequency trading",
        "gaming",
        "sign once",
        "authorization",
        "temporary keys",
        "non-custodial",
        "automated signing",
        "session management",
        "wallet prompts",
        "popups",
        "sessionkey"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency trading",
        "blockchain gaming",
        "real-time state updates"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Core Conceptsâ€‹\n\n\n### General Rulesâ€‹\n\nimportant\n\nWhen authenticating with an already registered session key, you must still provide all parameters in the `auth_request`. However, the configuration values (`application`, `allowances`, `scope`, and `expires_at`) from the request will be ignored, as the system uses the settings from the initial registration. You may provide arbitrary values for these fields, as they are required by the request format but will not be used.\n\n### Applicationsâ€‹\n\nEach session key is associated with a specific **application name** , which identifies the application or service that will use the session key. The application name is also used to identify **app sessions** that are created using that session key.\n\nThis association serves several purposes:\n\n  * **Application Isolation** : Different applications get separate session keys, preventing one application from using another's delegated access\n  * **Access Control** : Operations performed with a session key are validated against the application specified during registration\n  * **Single Active Key** : Only one session key can be active per wallet+application combination. Registering a new session key for the same application automatically invalidates any existing session key for that application\n\nimportant\n\nOnly one session key is allowed per wallet+application combination. If you register a new session key for the same application, the old one is automatically invalidated and removed from the database.\n\n#### Special Application: \"clearnode\"â€‹\n\nSession keys registered with the application name `\"clearnode\"` receive special treatment:\n\n  * **Root Access** : These session keys bypass spending allowance validation and application restrictions\n  * **Full Permissions** : They can perform any operation the wallet itself could perform\n  * **Backward Compatibility** : This special behavior facilitates migration from older versions\n  * **Expiration Still Applies** : Even with root access, the session key expires according to its `expires_at` timestamp\n\nnote\n\nThe \"clearnode\" application name is primarily for backward compatibility and will be deprecated after a migration period for developers.\n\n### Expirationâ€‹\n\nAll session keys must have an **expiration timestamp** (`expires_at`) that defines when the session key becomes invalid:\n\n  * **Future Timestamp Required** : The expiration time must be set to a future date when registering a session key\n  * **Automatic Invalidation** : Once the expiration time passes, the session key can no longer be used for any operations\n  * **No Re-registration** : It is not possible to re-register an expired session key. You must create a new session key instead\n  * **Applies to All Keys** : Even \"clearnode\" application session keys must respect the expiration timestamp\n\n### Allowancesâ€‹\n\nAllowances define **spending limits** for session keys, specifying which assets the session key can spend and how much:\n    \n    \n    {  \n      \"allowances\": [  \n        {  \n          \"asset\": \"usdc\",  \n          \"amount\": \"100.0\"  \n        },  \n        {  \n          \"asset\": \"eth\",  \n          \"amount\": \"0.5\"  \n        }  \n      ]  \n    }  \n    \n\n#### Allowance Validationâ€‹\n\n  * **Supported Assets Only** : All assets specified in allowances must be supported by the system. Unsupported assets cause authentication to fail\n  * **Usage Tracking** : The system tracks spending per session key by recording which session key was used for each ledger debit operation\n  * **Spending Limits** : Once a session key reaches its spending cap for an asset, further operations requiring that asset are rejected with: `\"operation denied: insufficient session key allowance: X required, Y available\"`\n  * **Empty Allowances** : Providing an empty `allowances` array (`[]`) means zero spending allowed for all assetsâ€”any operation attempting to spend funds will be rejected\n\n#### Allowances for \"clearnode\" Applicationâ€‹\n\nSession keys with `application: \"clearnode\"` are exempt from allowance enforcement:\n\n  * **No Spending Limits** : Allowance checks are bypassed entirely\n  * **Full Financial Access** : These keys can spend any amount of any supported asset\n  * **Expiration Still Matters** : Even without allowance restrictions, the session key still expires according to its `expires_at` timestamp\n\n* * *\n\nSummary: Manages session-based authentication and authorization by associating cryptographic keys with specific applications to ensure isolation, access control, and delegated wallet permissions.\n\nRelated terms: session keys, authentication, auth_request, application isolation, clearnode, root access, wallet permissions, access control, session management, expires_at, key rotation, authorization, delegated signing, sessionkey\n\nUse cases: delegated wallet access, application-specific permissioning, automated trading bot authentication, migrating legacy wallet integrations",
    "metadata": {
      "title": "Session Keys | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/session-keys",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Manages session-based authentication and authorization by associating cryptographic keys with specific applications to ensure isolation, access control, and delegated wallet permissions.",
      "keywords": [
        "session keys",
        "authentication",
        "auth_request",
        "application isolation",
        "clearnode",
        "root access",
        "wallet permissions",
        "access control",
        "session management",
        "expires_at",
        "key rotation",
        "authorization",
        "delegated signing",
        "sessionkey"
      ],
      "function_name": "auth_request",
      "intent": "concept",
      "use_cases": [
        "delegated wallet access",
        "application-specific permissioning",
        "automated trading bot authentication",
        "migrating legacy wallet integrations"
      ],
      "function_names": [
        "auth_request",
        "expires_at"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Session Key Lifecycleâ€‹\n\n\nauth_verify success\n\nUsing session key\n\nexpires_at reached\n\nAllowance depleted\n\nManual revocation\n\nRe-authenticate\n\nRe-authenticate\n\nRe-authenticate\n\nUnauthenticated\n\nAuthenticated\n\nExpired\n\nExhausted\n\nRevoked\n\n* * *\n\nSummary: Defines the state transitions and lifecycle of session keys, outlining the conditions for authentication, expiration, exhaustion, and revocation within the network.\n\nRelated terms: session key, auth_verify, expires_at, key lifecycle, authentication, token expiration, manual revocation, allowance, re-authenticate, session management, key rotation, authverify, session state\n\nUse cases: managing temporary access, automated key rotation, secure session termination",
    "metadata": {
      "title": "Session Keys | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/session-keys",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the state transitions and lifecycle of session keys, outlining the conditions for authentication, expiration, exhaustion, and revocation within the network.",
      "keywords": [
        "session key",
        "auth_verify",
        "expires_at",
        "key lifecycle",
        "authentication",
        "token expiration",
        "manual revocation",
        "allowance",
        "re-authenticate",
        "session management",
        "key rotation",
        "authverify",
        "session state"
      ],
      "function_name": "auth_verify",
      "intent": "concept",
      "use_cases": [
        "managing temporary access",
        "automated key rotation",
        "secure session termination"
      ],
      "function_names": [
        "expires_at",
        "auth_verify"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Security Modelâ€‹\n\n\nApproach| Risk if Compromised| UX Impact  \n---|---|---  \n**Main wallet always**|  Full wallet access| Constant prompts  \n**Session key (limited)**|  Only allowance at risk| Seamless  \n**Session key (unlimited)**|  Unified balance at risk| Seamless but risky  \n  \nSession Key Compromise\n\nIf a session key is compromised, attackers can only spend up to the configured allowance before expiration. This is why setting appropriate limits is critical.\n\n* * *\n\nSummary: This section defines the security architecture of session keys, comparing them against main wallet usage to balance user experience with risk mitigation through spending limits and expiration.\n\nRelated terms: session keys, security model, allowance, spending limits, wallet access, seamless UX, risk mitigation, authentication, signing, hot wallet, private key, session management, yellow network, crypto security\n\nUse cases: High-frequency trading without constant wallet prompts, Limiting exposure of funds in decentralized applications, Automated micro-payments, Non-custodial application security",
    "metadata": {
      "title": "Session Keys | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/session-keys",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section defines the security architecture of session keys, comparing them against main wallet usage to balance user experience with risk mitigation through spending limits and expiration.",
      "keywords": [
        "session keys",
        "security model",
        "allowance",
        "spending limits",
        "wallet access",
        "seamless UX",
        "risk mitigation",
        "authentication",
        "signing",
        "hot wallet",
        "private key",
        "session management",
        "yellow network",
        "crypto security"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "High-frequency trading without constant wallet prompts",
        "Limiting exposure of funds in decentralized applications",
        "Automated micro-payments",
        "Non-custodial application security"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Best Practicesâ€‹\n\n\n### For Usersâ€‹\n\n  1. **Set reasonable allowances** : Don't authorize more than you'll use\n  2. **Use short expirations** : 24 hours is usually sufficient\n  3. **Different keys for different apps** : Isolate risk per application\n  4. **Monitor spending** : Use `get_session_keys` to check usage\n  5. **Revoke when done** : Clean up unused sessions\n\n### For Developersâ€‹\n\n  1. **Secure storage** : Encrypt session keys at rest\n  2. **Never transmit private keys** : Session key stays on device\n  3. **Handle expiration gracefully** : Prompt re-authentication before expiry\n  4. **Verify Clearnode signatures** : Always validate response signatures\n  5. **Clear on logout** : Delete session keys when user logs out\n\n* * *\n\nSummary: Provides security guidelines and operational best practices for managing session keys to ensure secure, isolated, and time-bound access to the Yellow Network protocol.\n\nRelated terms: session keys, key management, security best practices, allowance, revocation, private key safety, Clearnode signatures, session expiration, get_session_keys, session monitoring, key isolation, encryption at rest\n\nUse cases: securing dApp sessions, managing user spending limits, implementing non-custodial key storage",
    "metadata": {
      "title": "Session Keys | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/session-keys",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides security guidelines and operational best practices for managing session keys to ensure secure, isolated, and time-bound access to the Yellow Network protocol.",
      "keywords": [
        "session keys",
        "key management",
        "security best practices",
        "allowance",
        "revocation",
        "private key safety",
        "Clearnode signatures",
        "session expiration",
        "get_session_keys",
        "session monitoring",
        "key isolation",
        "encryption at rest"
      ],
      "function_name": "get_session_keys",
      "intent": "concept",
      "use_cases": [
        "securing dApp sessions",
        "managing user spending limits",
        "implementing non-custodial key storage"
      ],
      "function_names": [
        "get_session_keys"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Alternative: Main Wallet as Root Signerâ€‹\n\n\nYou can skip session keys entirely and sign every request with your main wallet. Use this approach for:\n\n  * Single operations\n  * High-value transactions\n  * Maximum security required\n  * Non-interactive applications\n\n* * *\n\nSummary: This section outlines an alternative security model where the main wallet acts as the direct root signer for transactions, bypassing session keys for high-stakes or non-interactive scenarios.\n\nRelated terms: main wallet, root signer, session keys, transaction signing, high-value transactions, maximum security, non-interactive apps, direct signing, wallet authentication, private key, signing authority, sessionless, cold wallet\n\nUse cases: High-value asset transfers, Single-use payment operations, Automated backend transaction processing, Maximum security protocol interactions",
    "metadata": {
      "title": "Session Keys | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/session-keys",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines an alternative security model where the main wallet acts as the direct root signer for transactions, bypassing session keys for high-stakes or non-interactive scenarios.",
      "keywords": [
        "main wallet",
        "root signer",
        "session keys",
        "transaction signing",
        "high-value transactions",
        "maximum security",
        "non-interactive apps",
        "direct signing",
        "wallet authentication",
        "private key",
        "signing authority",
        "sessionless",
        "cold wallet"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "High-value asset transfers",
        "Single-use payment operations",
        "Automated backend transaction processing",
        "Maximum security protocol interactions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\n  * **[Managing Session Keys](/docs/learn/advanced/managing-session-keys)** â€” Create, list, and revoke session keys with full API examples\n  * **[Authentication Flow](/docs/protocol/off-chain/authentication)** â€” Full 3-step authentication protocol\n  * **[Communication Flows](/docs/protocol/communication-flows#authentication-flow)** â€” Sequence diagrams for auth\n\n\n\n[PreviousApp Sessions](/docs/learn/core-concepts/app-sessions)[NextChallenge-Response & Disputes](/docs/learn/core-concepts/challenge-response)\n\n  * Why Session Keys Matter\n  * Core Concepts\n    * General Rules\n    * Applications\n    * Expiration\n    * Allowances\n  * Session Key Lifecycle\n  * Security Model\n  * Best Practices\n    * For Users\n    * For Developers\n  * Alternative: Main Wallet as Root Signer\n  * Next Steps\n\nSummary: Session keys enable secure, temporary delegation of signing authority from a primary wallet to scoped sub-keys, facilitating automated interactions while protecting the root private key.\n\nRelated terms: session keys, ephemeral keys, delegated signing, authentication, key management, wallet security, root signer, key rotation, session expiration, allowance, off-chain signing, sesion keys, auth flow\n\nUse cases: Automated high-frequency trading, Securing long-lived application sessions, Setting spending allowances for temporary keys, Delegating permissions to third-party dApps",
    "metadata": {
      "title": "Session Keys | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/session-keys",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Session keys enable secure, temporary delegation of signing authority from a primary wallet to scoped sub-keys, facilitating automated interactions while protecting the root private key.",
      "keywords": [
        "session keys",
        "ephemeral keys",
        "delegated signing",
        "authentication",
        "key management",
        "wallet security",
        "root signer",
        "key rotation",
        "session expiration",
        "allowance",
        "off-chain signing",
        "sesion keys",
        "auth flow"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Automated high-frequency trading",
        "Securing long-lived application sessions",
        "Setting spending allowances for temporary keys",
        "Delegating permissions to third-party dApps"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Core Concepts\n  * State Channels vs L1/L2\n\n\n\n# State Channels vs L1/L2\n\nIn this guide, you will learn how state channels compare to Layer 1 and Layer 2 solutions, and when each approach is the right choice.\n\n**Goal** : Understand where state channels fit in the blockchain scaling landscape.\n\n* * *\n\nSummary: Provides a high-level comparison between state channels and Layer 1/Layer 2 solutions to help architects determine the optimal scaling strategy for high-frequency transactions and low-latency requirements.\n\nRelated terms: state channels, layer 1, layer 2, L1 vs L2, blockchain scaling, off-chain, scalability, throughput, latency, settlement, rollups, sidechains, payment channels, state-channels\n\nUse cases: architecting scalable dApps, choosing a payment settlement layer, optimizing transaction latency",
    "metadata": {
      "title": "State Channels vs L1/L2 | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/state-channels-vs-l1-l2",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a high-level comparison between state channels and Layer 1/Layer 2 solutions to help architects determine the optimal scaling strategy for high-frequency transactions and low-latency requirements.",
      "keywords": [
        "state channels",
        "layer 1",
        "layer 2",
        "L1 vs L2",
        "blockchain scaling",
        "off-chain",
        "scalability",
        "throughput",
        "latency",
        "settlement",
        "rollups",
        "sidechains",
        "payment channels",
        "state-channels"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "architecting scalable dApps",
        "choosing a payment settlement layer",
        "optimizing transaction latency"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Solution Comparisonâ€‹\n\n\nSolution| Throughput| Latency| Cost per Op| Best For  \n---|---|---|---|---  \n**Layer 1**|  15-65K TPS| 1-15 sec| $0.001-$50| Settlement, contracts  \n**Layer 2**|  2,000-4,000 TPS| 1-10 sec| $0.01-$0.50| General dApps  \n**State Channels**| **Unlimited** *|  **< 1 sec**| **$0**|  High-frequency, known parties  \n  \n_*Theoretically unlimitedâ€”no consensus bottleneck. Real-world throughput depends on signature generation, network latency, and application logic. Benchmarking documentation coming soon._\n\n* * *\n\nSummary: Provides a comparative analysis of State Channels against Layer 1 and Layer 2 solutions, emphasizing their superior throughput, latency, and cost-efficiency for high-frequency interactions.\n\nRelated terms: state channels, layer 1, layer 2, scalability, throughput, latency, transaction cost, off-chain, high-frequency trading, settlement, blockchain comparison, gas fees, instant payments, TPS, scalability trilemma\n\nUse cases: high-frequency trading, micro-payments, real-time gaming, peer-to-peer interactions",
    "metadata": {
      "title": "State Channels vs L1/L2 | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/state-channels-vs-l1-l2",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a comparative analysis of State Channels against Layer 1 and Layer 2 solutions, emphasizing their superior throughput, latency, and cost-efficiency for high-frequency interactions.",
      "keywords": [
        "state channels",
        "layer 1",
        "layer 2",
        "scalability",
        "throughput",
        "latency",
        "transaction cost",
        "off-chain",
        "high-frequency trading",
        "settlement",
        "blockchain comparison",
        "gas fees",
        "instant payments",
        "TPS",
        "scalability trilemma"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency trading",
        "micro-payments",
        "real-time gaming",
        "peer-to-peer interactions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## How State Channels Workâ€‹\n\n\nState channels operate on a simple principle:\n\n  1. **Lock funds** in a smart contract (on-chain)\n  2. **Exchange signed states** directly between participants (off-chain)\n  3. **Settle** when done or if there's a dispute (on-chain)\n\nThe key insight: most interactions between parties don't need immediate on-chain settlement.\n\n* * *\n\nSummary: Defines the operational lifecycle of state channels, detailing how off-chain signed state exchanges provide scalability while maintaining on-chain security through locking and settlement.\n\nRelated terms: state channels, off-chain, on-chain, settlement, scalability, layer 2, L2, signed states, smart contract, locking funds, dispute resolution, payment channels, state updates, yellow network, statechanel\n\nUse cases: high-frequency trading, micro-payments, real-time asset exchange",
    "metadata": {
      "title": "State Channels vs L1/L2 | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/state-channels-vs-l1-l2",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the operational lifecycle of state channels, detailing how off-chain signed state exchanges provide scalability while maintaining on-chain security through locking and settlement.",
      "keywords": [
        "state channels",
        "off-chain",
        "on-chain",
        "settlement",
        "scalability",
        "layer 2",
        "L2",
        "signed states",
        "smart contract",
        "locking funds",
        "dispute resolution",
        "payment channels",
        "state updates",
        "yellow network",
        "statechanel"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency trading",
        "micro-payments",
        "real-time asset exchange"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## State Channel Advantagesâ€‹\n\n\n### Instant Finalityâ€‹\n\nUnlike L2 solutions that still have block times, state channels provide sub-second finality:\n\nSolution| Transaction Flow  \n---|---  \nL1| Transaction â†’ Mempool â†’ Block â†’ Confirmation  \nL2| Transaction â†’ Sequencer â†’ L2 Block â†’ L1 Data  \nChannels| Signature â†’ Validation â†’ Done  \n  \n### Zero Operational Costâ€‹\n\nOperation| L1 Cost| L2 Cost| State Channel  \n---|---|---|---  \n100 transfers| $500-5000| $10-50| **$0**  \n1000 transfers| $5000-50000| $100-500| **$0**  \n  \n### Privacyâ€‹\n\nOff-chain transactions are only visible to participants. Only opening and final states appear on-chain.\n\n* * *\n\nSummary: This section compares state channels against Layer 1 and Layer 2 solutions, highlighting their advantages in achieving instant finality, zero operational costs for high-volume transactions, and enhanced off-chain privacy.\n\nRelated terms: state channels, L1 vs L2, instant finality, zero gas fees, off-chain transactions, privacy, scalability, payment channels, sub-second settlement, high-frequency trading, microtransactions, layer 2 comparison, blockchain scaling, stait channels\n\nUse cases: high-frequency trading, micro-payments, private peer-to-peer transfers, real-time gaming transactions",
    "metadata": {
      "title": "State Channels vs L1/L2 | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/state-channels-vs-l1-l2",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section compares state channels against Layer 1 and Layer 2 solutions, highlighting their advantages in achieving instant finality, zero operational costs for high-volume transactions, and enhanced off-chain privacy.",
      "keywords": [
        "state channels",
        "L1 vs L2",
        "instant finality",
        "zero gas fees",
        "off-chain transactions",
        "privacy",
        "scalability",
        "payment channels",
        "sub-second settlement",
        "high-frequency trading",
        "microtransactions",
        "layer 2 comparison",
        "blockchain scaling",
        "stait channels"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency trading",
        "micro-payments",
        "private peer-to-peer transfers",
        "real-time gaming transactions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## State Channel Limitationsâ€‹\n\n\n### Known Participantsâ€‹\n\nChannels work between specific participants. Yellow Network addresses this through Clearnodesâ€”off-chain service providers that coordinate channels and provide a unified balance across multiple users and chains.\n\n### Liquidity Requirementsâ€‹\n\nFunds must be locked upfront. You can't spend more than what's locked in the channel.\n\n### Liveness Requirementsâ€‹\n\nParticipants must respond to challenges within the challenge period. Users should ensure they can monitor for challenges or use services that provide this functionality.\n\n* * *\n\nSummary: This section outlines the inherent constraints of state channel technologyâ€”specifically participant limitations, capital lock-up, and liveness requirementsâ€”and explains how Yellow Network's Clearnode architecture mitigates these issues.\n\nRelated terms: state channels, off-chain, Clearnodes, liquidity, liveness, challenge period, locked funds, capital efficiency, monitoring, participant coordination, layer 2, scalability, payment channels, state channel limitations\n\nUse cases: Evaluating protocol trade-offs for high-frequency trading, Designing off-chain settlement systems with Clearnodes, Implementing automated challenge monitoring for channel security, Managing capital allocation for liquidity providers",
    "metadata": {
      "title": "State Channels vs L1/L2 | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/state-channels-vs-l1-l2",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the inherent constraints of state channel technologyâ€”specifically participant limitations, capital lock-up, and liveness requirementsâ€”and explains how Yellow Network's Clearnode architecture mitigates these issues.",
      "keywords": [
        "state channels",
        "off-chain",
        "Clearnodes",
        "liquidity",
        "liveness",
        "challenge period",
        "locked funds",
        "capital efficiency",
        "monitoring",
        "participant coordination",
        "layer 2",
        "scalability",
        "payment channels",
        "state channel limitations"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Evaluating protocol trade-offs for high-frequency trading",
        "Designing off-chain settlement systems with Clearnodes",
        "Implementing automated challenge monitoring for channel security",
        "Managing capital allocation for liquidity providers"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## When to Use Eachâ€‹\n\n\nChoose| When  \n---|---  \n**L1**|  Deploying contracts, one-time large transfers, final settlement  \n**L2**|  General dApps, many unknown users, complex smart contracts  \n**State Channels**|  Known parties, real-time speed, high frequency, zero gas needed  \n  \n* * *\n\nSummary: This section provides a comparative framework for selecting the optimal blockchain layer or scaling solution based on transaction frequency, speed requirements, and participant relationships. It highlights state channels as the superior choice for high-frequency, zero-gas interactions between known parties.\n\nRelated terms: state channels, layer 1, layer 2, L1 vs L2, off-chain scaling, zero gas, real-time payments, high frequency trading, settlement, scalability, gasless, payment channels, microtransactions, transaction speed\n\nUse cases: High-frequency trading between known counterparties, Real-time micro-payments for streaming services, Architectural decision making for dApp scaling, Reducing operational costs for repetitive transactions",
    "metadata": {
      "title": "State Channels vs L1/L2 | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/state-channels-vs-l1-l2",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section provides a comparative framework for selecting the optimal blockchain layer or scaling solution based on transaction frequency, speed requirements, and participant relationships. It highlights state channels as the superior choice for high-frequency, zero-gas interactions between known parties.",
      "keywords": [
        "state channels",
        "layer 1",
        "layer 2",
        "L1 vs L2",
        "off-chain scaling",
        "zero gas",
        "real-time payments",
        "high frequency trading",
        "settlement",
        "scalability",
        "gasless",
        "payment channels",
        "microtransactions",
        "transaction speed"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "High-frequency trading between known counterparties",
        "Real-time micro-payments for streaming services",
        "Architectural decision making for dApp scaling",
        "Reducing operational costs for repetitive transactions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Decision Frameworkâ€‹\n\n\nNo\n\nYes\n\nYes\n\nNo\n\nYes\n\nNo\n\nTransaction\n\nKnown counterparty?\n\nUse L1/L2\n\nHigh frequency?\n\nUse State Channel\n\nLarge value?\n\n* * *\n\nSummary: A decision framework for architects to determine whether to utilize State Channels or L1/L2 solutions based on transaction frequency, counterparty relationship, and value.\n\nRelated terms: state channels, L1, L2, layer 1, layer 2, scalability, high frequency, microtransactions, off-chain, on-chain, settlement, counterparty, transaction value, decision tree, architecture, scaling\n\nUse cases: Choosing a scaling solution, High-frequency trading architecture, Micro-payment system design, Risk assessment for transactions",
    "metadata": {
      "title": "State Channels vs L1/L2 | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/state-channels-vs-l1-l2",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "A decision framework for architects to determine whether to utilize State Channels or L1/L2 solutions based on transaction frequency, counterparty relationship, and value.",
      "keywords": [
        "state channels",
        "L1",
        "L2",
        "layer 1",
        "layer 2",
        "scalability",
        "high frequency",
        "microtransactions",
        "off-chain",
        "on-chain",
        "settlement",
        "counterparty",
        "transaction value",
        "decision tree",
        "architecture",
        "scaling"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Choosing a scaling solution",
        "High-frequency trading architecture",
        "Micro-payment system design",
        "Risk assessment for transactions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## How Yellow Network Addresses Limitationsâ€‹\n\n\nLimitation| Solution  \n---|---  \nKnown participants| Clearnode coordination layer  \nLiquidity| Unified balance across chains  \nLiveness| Always-on Clearnode monitoring  \n  \n* * *\n\nSummary: This section outlines how the Yellow Network architecture overcomes traditional state channel limitations through its Clearnode coordination layer, unified cross-chain liquidity, and persistent liveness monitoring.\n\nRelated terms: state channels, L1, L2, Clearnode, liquidity, liveness, cross-chain, unified balance, coordination layer, scalability, off-chain, payment channels, Yellow Network, layer 1, layer 2\n\nUse cases: cross-chain liquidity management, high-frequency trading, institutional clearing, real-time settlement",
    "metadata": {
      "title": "State Channels vs L1/L2 | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/state-channels-vs-l1-l2",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines how the Yellow Network architecture overcomes traditional state channel limitations through its Clearnode coordination layer, unified cross-chain liquidity, and persistent liveness monitoring.",
      "keywords": [
        "state channels",
        "L1",
        "L2",
        "Clearnode",
        "liquidity",
        "liveness",
        "cross-chain",
        "unified balance",
        "coordination layer",
        "scalability",
        "off-chain",
        "payment channels",
        "Yellow Network",
        "layer 1",
        "layer 2"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "cross-chain liquidity management",
        "high-frequency trading",
        "institutional clearing",
        "real-time settlement"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Key Takeawaysâ€‹\n\n\nState channels shine when you have identified participants who will interact frequentlyâ€”like players in a game, counterparties in a trade, or parties in a payment relationship.\n\nState Channel Sweet Spot\n\n  * Real-time interactions between known parties\n  * High transaction volumes\n  * Zero gas costs required\n  * Instant finality needed\n\n* * *\n\nSummary: This section defines the optimal use cases for state channels, highlighting their advantages in high-frequency, real-time interactions between known parties where zero gas fees and instant finality are required.\n\nRelated terms: state channels, off-chain, layer 2, scalability, instant finality, zero gas, high throughput, peer-to-peer, payment channels, real-time transactions, counterparty, state updates, L1 vs L2, yellow network, statechannel\n\nUse cases: high-frequency trading, real-time gaming, recurring micro-payments, peer-to-peer settlement",
    "metadata": {
      "title": "State Channels vs L1/L2 | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/state-channels-vs-l1-l2",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section defines the optimal use cases for state channels, highlighting their advantages in high-frequency, real-time interactions between known parties where zero gas fees and instant finality are required.",
      "keywords": [
        "state channels",
        "off-chain",
        "layer 2",
        "scalability",
        "instant finality",
        "zero gas",
        "high throughput",
        "peer-to-peer",
        "payment channels",
        "real-time transactions",
        "counterparty",
        "state updates",
        "L1 vs L2",
        "yellow network",
        "statechannel"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency trading",
        "real-time gaming",
        "recurring micro-payments",
        "peer-to-peer settlement"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Deep Diveâ€‹\n\n\nFor technical details on channel implementation:\n\n  * **[Architecture](/docs/protocol/architecture)** â€” System design and fund flows\n  * **[Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle)** â€” State machine and operations\n  * **[Data Structures](/docs/protocol/on-chain/data-structures)** â€” Channel and state formats\n\n\n\n[PreviousKey Terms & Mental Models](/docs/learn/getting-started/key-terms)[NextApp Sessions](/docs/learn/core-concepts/app-sessions)\n\n  * Solution Comparison\n  * How State Channels Work\n  * State Channel Advantages\n    * Instant Finality\n    * Zero Operational Cost\n    * Privacy\n  * State Channel Limitations\n    * Known Participants\n    * Liquidity Requirements\n    * Liveness Requirements\n  * When to Use Each\n  * Decision Framework\n  * How Yellow Network Addresses Limitations\n  * Key Takeaways\n  * Deep Dive\n\nSummary: This section provides a comparative analysis of state channels against Layer 1 and Layer 2 solutions, outlining the trade-offs in finality, cost, and privacy within the Yellow Network ecosystem. It serves as a decision framework for architects to determine when to utilize off-chain state channels versus on-chain transactions.\n\nRelated terms: state channels, Layer 2 scaling, L1 vs L2, instant finality, off-chain transactions, zero gas fees, liquidity locking, liveness requirement, privacy-preserving payments, scalability comparison, payment channels, settlement latency, Yellow Network architecture\n\nUse cases: High-frequency trading or micro-payments requiring instant finality, Designing a cost-efficient payment system with zero per-transaction fees, Evaluating privacy requirements for peer-to-peer financial interactions, Determining liquidity management strategies for off-chain networks",
    "metadata": {
      "title": "State Channels vs L1/L2 | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/core-concepts/state-channels-vs-l1-l2",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section provides a comparative analysis of state channels against Layer 1 and Layer 2 solutions, outlining the trade-offs in finality, cost, and privacy within the Yellow Network ecosystem. It serves as a decision framework for architects to determine when to utilize off-chain state channels versus on-chain transactions.",
      "keywords": [
        "state channels",
        "Layer 2 scaling",
        "L1 vs L2",
        "instant finality",
        "off-chain transactions",
        "zero gas fees",
        "liquidity locking",
        "liveness requirement",
        "privacy-preserving payments",
        "scalability comparison",
        "payment channels",
        "settlement latency",
        "Yellow Network architecture"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "High-frequency trading or micro-payments requiring instant finality",
        "Designing a cost-efficient payment system with zero per-transaction fees",
        "Evaluating privacy requirements for peer-to-peer financial interactions",
        "Determining liquidity management strategies for off-chain networks"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Getting Started\n  * Key Terms & Mental Models\n\n\n\n# Key Terms & Mental Models\n\nIn this guide, you will learn the essential vocabulary and mental models for understanding Yellow Network and state channel technology.\n\n**Goal** : Build a solid conceptual foundation before diving into implementation.\n\n* * *\n\nSummary: Provides a conceptual foundation and glossary of terms for the Yellow Network, explaining the core principles of state channel technology for system design.\n\nRelated terms: state channels, layer 2, off-chain, terminology, mental models, yellow network, blockchain scaling, payment channels, state updates, glossary, conceptual overview, protocol basics, crypto payments, ledger\n\nUse cases: understanding state channel architecture, onboarding new developers to Yellow Network, learning protocol terminology",
    "metadata": {
      "title": "Key Terms & Mental Models | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/key-terms",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a conceptual foundation and glossary of terms for the Yellow Network, explaining the core principles of state channel technology for system design.",
      "keywords": [
        "state channels",
        "layer 2",
        "off-chain",
        "terminology",
        "mental models",
        "yellow network",
        "blockchain scaling",
        "payment channels",
        "state updates",
        "glossary",
        "conceptual overview",
        "protocol basics",
        "crypto payments",
        "ledger"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "understanding state channel architecture",
        "onboarding new developers to Yellow Network",
        "learning protocol terminology"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Core Mental Model: Off-Chain Executionâ€‹\n\n\nThe fundamental insight behind Yellow Network is simple:\n\n> **Most interactions don't need immediate on-chain settlement.**\n\nThink of it like a bar tab:\n\nTraditional (L1)| State Channels  \n---|---  \nPay for each drink separately| Open a tab, pay once at the end  \nWait for bartender each time| Instant service, settle later  \nTransaction per item| One transaction for the whole session  \n  \nState channels apply this pattern to blockchain: **lock funds once** , **transact off-chain** , **settle once**.\n\n* * *\n\nSummary: Introduces the state channel architecture of Yellow Network, explaining how off-chain execution enables high-frequency interactions with deferred on-chain settlement to improve scalability and reduce costs.\n\nRelated terms: state channels, off-chain execution, layer 2, L2 scaling, settlement, payment channel, bar tab, transaction batching, instant transactions, lock funds, session management, scalability, micro-payments, high-frequency trading\n\nUse cases: high-frequency micro-payments, reducing gas fees for recurring interactions, real-time interactive applications, batching multiple transactions into a single settlement",
    "metadata": {
      "title": "Key Terms & Mental Models | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/key-terms",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Introduces the state channel architecture of Yellow Network, explaining how off-chain execution enables high-frequency interactions with deferred on-chain settlement to improve scalability and reduce costs.",
      "keywords": [
        "state channels",
        "off-chain execution",
        "layer 2",
        "L2 scaling",
        "settlement",
        "payment channel",
        "bar tab",
        "transaction batching",
        "instant transactions",
        "lock funds",
        "session management",
        "scalability",
        "micro-payments",
        "high-frequency trading"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency micro-payments",
        "reducing gas fees for recurring interactions",
        "real-time interactive applications",
        "batching multiple transactions into a single settlement"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Essential Vocabularyâ€‹\n\n\n### State Channelâ€‹\n\nA **state channel** is a secure pathway for exchanging cryptographically signed states between participants without touching the blockchain.\n\n**Key properties:**\n\n  * Funds are locked in a smart contract\n  * Participants exchange signed state updates off-chain\n  * Only opening and closing require on-chain transactions\n  * Either party can force on-chain settlement if needed\n\n**Analogy** : Like a private Venmo between two parties, backed by a bank escrow.\n\n* * *\n\n### Channelâ€‹\n\nA **Channel** is the on-chain representation of a state channel. It defines:\n    \n    \n    {  \n      participants: ['0xAlice', '0xBob'],   // Who can participate  \n      adjudicator: '0xContract',            // Rules for state validation  \n      challenge: 86400,                     // Dispute window (seconds)  \n      nonce: 1699123456789                  // Unique identifier  \n    }  \n    \n\nThe **channelId** is computed deterministically from these parameters:\n    \n    \n    channelId = keccak256(participants, adjudicator, challenge, nonce, chainId)  \n    \n\n* * *\n\n### Stateâ€‹\n\nA **State** is a snapshot of the channel at a specific moment:\n    \n    \n    {  \n      intent: 'OPERATE',           // Purpose: INITIALIZE, OPERATE, RESIZE, FINALIZE  \n      version: 5,                  // Incremental counter (higher = newer)  \n      data: '0x...',               // Application-specific data  \n      allocations: [...],          // How funds are distributed  \n      sigs: ['0xSig1', '0xSig2']   // Participant signatures  \n    }  \n    \n\n**Key rule** : A higher version number always supersedes a lower one, regardless of allocations.\n\n* * *\n\n### Allocationâ€‹\n\nAn **Allocation** specifies how funds should be distributed:\n    \n    \n    {  \n      destination: '0xAlice',              // Recipient address  \n      token: '0xUSDC_CONTRACT',            // Token contract  \n      amount: 50000000n                    // Amount in smallest unit (6 decimals for USDC)  \n    }  \n    \n\nThe sum of allocations represents the total funds in the channel.\n\n* * *\n\n### Clearnodeâ€‹\n\nA **Clearnode** is the off-chain service that:\n\n  1. **Manages the Nitro RPC protocol** for state channel operations\n  2. **Provides unified balance** aggregated across multiple chains\n  3. **Coordinates channels** between users\n  4. **Hosts app sessions** for multi-party applications\n\n**Think of it as** : A game server that acts as your entry point to Yellow Networkâ€”centralized for speed, but trustless because of on-chain guarantees.\n\n* * *\n\n### Unified Balanceâ€‹\n\nYour **unified balance** is the aggregation of funds across all chains where you have deposits:\n    \n    \n    Polygon: 50 USDC  â”  \n    Base:    30 USDC  â”œâ”€â†’ Unified Balance: 100 USDC  \n    Arbitrum: 20 USDC â”˜  \n    \n\nYou can:\n\n  * Transfer from unified balance instantly (off-chain)\n  * Withdraw to any supported chain\n  * Lock funds into app sessions\n\n* * *\n\n### App Sessionâ€‹\n\nAn **App Session** is an off-chain channel built on top of the unified balance for multi-party applications:\n    \n    \n    {  \n      protocol: 'NitroRPC/0.4',  \n      participants: ['0xAlice', '0xBob', '0xJudge'],  \n      weights: [40, 40, 50],         // Voting power  \n      quorum: 80,                    // Required weight for state updates  \n      challenge: 3600,               // Dispute window  \n      nonce: 1699123456789  \n    }  \n    \n\n**Use cases** : Games, prediction markets, escrow, any multi-party coordination.\n\n* * *\n\n### Session Keyâ€‹\n\nA **session key** is a temporary cryptographic key that:\n\n  * Is generated locally on your device\n  * Has limited permissions and spending caps\n  * Expires after a specified time\n  * Allows gasless signing without wallet prompts\n\n**Flow** :\n\n  1. Generate session keypair locally\n  2. Main wallet authorizes the session key (one-time EIP-712 signature)\n  3. All subsequent operations use the session key\n  4. Session expires or can be revoked\n\n* * *\n\nSummary: Defines the fundamental architectural building blocks of the protocol, explaining how state channels, channel identities, state snapshots, and fund allocations enable secure off-chain transactions and on-chain settlement.\n\nRelated terms: state channel, off-chain, channelId, state update, allocation, settlement, adjudicator, challenge window, nonce, cryptographic signature, escrow, smart contract, versioning, layer 2\n\nUse cases: off-chain payment processing, dispute resolution and settlement, multi-party fund distribution, high-frequency micro-transactions",
    "metadata": {
      "title": "Key Terms & Mental Models | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/key-terms",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the fundamental architectural building blocks of the protocol, explaining how state channels, channel identities, state snapshots, and fund allocations enable secure off-chain transactions and on-chain settlement.",
      "keywords": [
        "state channel",
        "off-chain",
        "channelId",
        "state update",
        "allocation",
        "settlement",
        "adjudicator",
        "challenge window",
        "nonce",
        "cryptographic signature",
        "escrow",
        "smart contract",
        "versioning",
        "layer 2"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "off-chain payment processing",
        "dispute resolution and settlement",
        "multi-party fund distribution",
        "high-frequency micro-transactions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Protocol Componentsâ€‹\n\n\n### Nitroliteâ€‹\n\n**Nitrolite** is the on-chain smart contract protocol:\n\n  * Defines channel data structures\n  * Implements create, close, challenge, resize operations\n  * Provides cryptographic verification\n  * Currently version 0.5.0\n\n* * *\n\n### Nitro RPCâ€‹\n\n**Nitro RPC** is the off-chain communication protocol:\n\n  * Compact JSON array format for efficiency\n  * Every message is cryptographically signed\n  * Bidirectional real-time communication\n  * Currently version 0.4\n\n**Message format** :\n    \n    \n    [requestId, method, params, timestamp]  \n      \n    // Example  \n    [42, \"transfer\", {\"destination\": \"0x...\", \"amount\": \"50.0\"}, 1699123456789]  \n    \n\n* * *\n\n### Custody Contractâ€‹\n\nThe **Custody Contract** is the main on-chain entry point:\n\n  * Locks and unlocks participant funds\n  * Tracks channel status (VOID â†’ ACTIVE â†’ FINAL)\n  * Validates signatures and state transitions\n  * Handles dispute resolution\n\n* * *\n\n### Adjudicatorâ€‹\n\nAn **Adjudicator** defines rules for valid state transitions:\n\nType| Rule  \n---|---  \n**SimpleConsensus**|  Both participants must sign (default)  \n**Remittance**|  Only sender must sign  \n**Custom**|  Application-specific logic  \n  \n* * *\n\nSummary: Defines the core architectural components of the Yellow Network, outlining the relationship between on-chain smart contracts for fund management and off-chain RPC protocols for secure, real-time state updates.\n\nRelated terms: Nitrolite, Nitro RPC, Custody Contract, Adjudicator, state channel, off-chain communication, smart contract, cryptographic signing, dispute resolution, state transition, SimpleConsensus, Remittance, channel lifecycle, on-chain verification\n\nUse cases: Architecting a state channel system, Implementing secure off-chain messaging, Defining custom state transition rules, Managing on-chain fund custody",
    "metadata": {
      "title": "Key Terms & Mental Models | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/key-terms",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the core architectural components of the Yellow Network, outlining the relationship between on-chain smart contracts for fund management and off-chain RPC protocols for secure, real-time state updates.",
      "keywords": [
        "Nitrolite",
        "Nitro RPC",
        "Custody Contract",
        "Adjudicator",
        "state channel",
        "off-chain communication",
        "smart contract",
        "cryptographic signing",
        "dispute resolution",
        "state transition",
        "SimpleConsensus",
        "Remittance",
        "channel lifecycle",
        "on-chain verification"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Architecting a state channel system",
        "Implementing secure off-chain messaging",
        "Defining custom state transition rules",
        "Managing on-chain fund custody"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## State Lifecycleâ€‹\n\n\n### Channel Statesâ€‹\n\nChannel doesn't exist\n\ncreate()\n\nOff-chain updates\n\nchallenge()\n\nclose()\n\ncheckpoint()\n\nTimeout\n\nDeleted\n\nVOID\n\nACTIVE\n\nDISPUTE\n\nFINAL\n\nStatus| Meaning  \n---|---  \n**VOID**|  Channel doesn't exist on-chain  \n**INITIAL**|  Created, waiting for all participants (legacy)  \n**ACTIVE**|  Fully operational, off-chain updates happening  \n**DISPUTE**|  Challenge period active, parties can submit newer states  \n**FINAL**|  Closed, funds distributed, metadata deleted  \n  \n* * *\n\n### State Intentsâ€‹\n\nIntent| When Used| Purpose  \n---|---|---  \n**INITIALIZE**| `create()`| First state when opening channel  \n**OPERATE**|  Off-chain updates| Normal operation, redistribution  \n**RESIZE**| `resize()`| Add or remove funds  \n**FINALIZE**| `close()`| Final state for cooperative closure  \n  \n* * *\n\nSummary: Defines the state machine and lifecycle transitions for payment channels, detailing how off-chain updates move between active, dispute, and finality phases.\n\nRelated terms: channel lifecycle, state machine, off-chain updates, dispute resolution, payment channel, on-chain settlement, state transition, channel status, fund redistribution, cooperative closure, challenge period, state intent, channel opening, channel closing, state management\n\nUse cases: Managing payment channel transitions, Handling on-chain disputes, Modifying channel liquidity, Cooperative channel settlement",
    "metadata": {
      "title": "Key Terms & Mental Models | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/key-terms",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the state machine and lifecycle transitions for payment channels, detailing how off-chain updates move between active, dispute, and finality phases.",
      "keywords": [
        "channel lifecycle",
        "state machine",
        "off-chain updates",
        "dispute resolution",
        "payment channel",
        "on-chain settlement",
        "state transition",
        "channel status",
        "fund redistribution",
        "cooperative closure",
        "challenge period",
        "state intent",
        "channel opening",
        "channel closing",
        "state management"
      ],
      "function_name": "create",
      "intent": "concept",
      "use_cases": [
        "Managing payment channel transitions",
        "Handling on-chain disputes",
        "Modifying channel liquidity",
        "Cooperative channel settlement"
      ],
      "function_names": [
        "resize",
        "close",
        "create"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Security Conceptsâ€‹\n\n\n### Challenge Periodâ€‹\n\nWhen a dispute arises:\n\n  1. Party A submits their latest state via `challenge()`\n  2. **Challenge period** starts (typically 24 hours)\n  3. Party B can submit a newer valid state via `checkpoint()`\n  4. If no newer state, Party A's state becomes final after timeout\n\n**Purpose** : Gives honest parties time to respond to incorrect claims.\n\n* * *\n\n### Signaturesâ€‹\n\nTwo contexts for signatures:\n\nContext| Hash Method| Signed By  \n---|---|---  \n**On-chain**|  Raw `packedState` (no prefix)| Main wallet  \n**Off-chain RPC**|  JSON payload hash| Session key  \n  \n**On-chain packedState** :\n    \n    \n    keccak256(abi.encode(channelId, intent, version, data, allocations))  \n    \n\n* * *\n\n### Quorumâ€‹\n\nFor app sessions, **quorum** defines the minimum voting weight required for state updates:\n    \n    \n    Participants: [Alice, Bob, Judge]  \n    Weights:      [40,    40,   50]  \n    Quorum: 80  \n      \n    Valid combinations:  \n    - Alice + Bob = 80 âœ“  \n    - Alice + Judge = 90 âœ“  \n    - Bob + Judge = 90 âœ“  \n    - Alice alone = 40 âœ—  \n    \n\n* * *\n\nSummary: Defines the core security and consensus mechanisms of the Yellow Network, covering dispute resolution through challenge periods, cryptographic signature standards, and quorum-based state validation.\n\nRelated terms: dispute resolution, challenge period, checkpoint, quorum, state update, signature, session key, on-chain, off-chain, multi-party, voting weight, timeout, packedState, keccak256\n\nUse cases: resolving payment disputes, multi-party state validation, securing off-chain transactions, decentralized governance",
    "metadata": {
      "title": "Key Terms & Mental Models | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/key-terms",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the core security and consensus mechanisms of the Yellow Network, covering dispute resolution through challenge periods, cryptographic signature standards, and quorum-based state validation.",
      "keywords": [
        "dispute resolution",
        "challenge period",
        "checkpoint",
        "quorum",
        "state update",
        "signature",
        "session key",
        "on-chain",
        "off-chain",
        "multi-party",
        "voting weight",
        "timeout",
        "packedState",
        "keccak256"
      ],
      "function_name": "challenge",
      "intent": "concept",
      "use_cases": [
        "resolving payment disputes",
        "multi-party state validation",
        "securing off-chain transactions",
        "decentralized governance"
      ],
      "function_names": [
        "challenge",
        "checkpoint"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Quick Reference Tableâ€‹\n\n\nTerm| One-Line Definition  \n---|---  \n**State Channel**|  Off-chain execution backed by on-chain funds  \n**Clearnode**|  Off-chain service coordinating state channels  \n**Unified Balance**|  Aggregated funds across all chains  \n**App Session**|  Multi-party application channel  \n**Session Key**|  Temporary key with limited permissions  \n**Challenge Period**|  Dispute resolution window  \n**Quorum**|  Minimum signature weight for approval  \n**Allocation**|  Fund distribution specification  \n**packedState**|  Canonical payload for signing  \n  \n* * *\n\nSummary: This section defines the core terminology and conceptual framework of the Yellow Network, outlining the fundamental components of its off-chain state channel architecture and fund management.\n\nRelated terms: State Channel, Clearnode, Unified Balance, App Session, Session Key, Challenge Period, Quorum, Allocation, packedState, off-chain execution, dispute resolution, multi-party channel, signature weight, fund distribution, Layer 2 scaling\n\nUse cases: Onboarding developers to the Yellow Network ecosystem, Understanding the security model of off-chain state transitions, Designing multi-party payment flows using session keys and quorums",
    "metadata": {
      "title": "Key Terms & Mental Models | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/key-terms",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section defines the core terminology and conceptual framework of the Yellow Network, outlining the fundamental components of its off-chain state channel architecture and fund management.",
      "keywords": [
        "State Channel",
        "Clearnode",
        "Unified Balance",
        "App Session",
        "Session Key",
        "Challenge Period",
        "Quorum",
        "Allocation",
        "packedState",
        "off-chain execution",
        "dispute resolution",
        "multi-party channel",
        "signature weight",
        "fund distribution",
        "Layer 2 scaling"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Onboarding developers to the Yellow Network ecosystem",
        "Understanding the security model of off-chain state transitions",
        "Designing multi-party payment flows using session keys and quorums"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nNow that you understand the vocabulary, continue to:\n\n  * **[State Channels vs L1/L2](/docs/learn/core-concepts/state-channels-vs-l1-l2)** â€” Deep comparison with other scaling solutions\n  * **[App Sessions](/docs/learn/core-concepts/app-sessions)** â€” Multi-party application patterns\n  * **[Session Keys](/docs/learn/core-concepts/session-keys)** â€” Authentication and security\n\nFor complete definitions, see the **[Glossary](/docs/protocol/glossary)**.\n\n\n\n[PreviousPrerequisites & Environment](/docs/learn/getting-started/prerequisites)[NextState Channels vs L1/L2](/docs/learn/core-concepts/state-channels-vs-l1-l2)\n\n  * Core Mental Model: Off-Chain Execution\n  * Essential Vocabulary\n    * State Channel\n    * Channel\n    * State\n    * Allocation\n    * Clearnode\n    * Unified Balance\n    * App Session\n    * Session Key\n  * Protocol Components\n    * Nitrolite\n    * Nitro RPC\n    * Custody Contract\n    * Adjudicator\n  * State Lifecycle\n    * Channel States\n    * State Intents\n  * Security Concepts\n    * Challenge Period\n    * Signatures\n    * Quorum\n  * Quick Reference Table\n  * Next Steps\n\nSummary: This section establishes the foundational mental models and essential vocabulary for the Yellow Network, outlining core concepts like off-chain execution, state channels, and protocol components.\n\nRelated terms: state channel, off-chain execution, clearnode, unified balance, app session, session key, nitrolite, nitro rpc, adjudicator, challenge period, multi-party, scaling, layer 2, state update, custody contract\n\nUse cases: architecting off-chain payment systems, understanding protocol security models, onboarding to state channel technology",
    "metadata": {
      "title": "Key Terms & Mental Models | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/key-terms",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section establishes the foundational mental models and essential vocabulary for the Yellow Network, outlining core concepts like off-chain execution, state channels, and protocol components.",
      "keywords": [
        "state channel",
        "off-chain execution",
        "clearnode",
        "unified balance",
        "app session",
        "session key",
        "nitrolite",
        "nitro rpc",
        "adjudicator",
        "challenge period",
        "multi-party",
        "scaling",
        "layer 2",
        "state update",
        "custody contract"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "architecting off-chain payment systems",
        "understanding protocol security models",
        "onboarding to state channel technology"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Getting Started\n  * Prerequisites & Environment\n\n\n\n# Prerequisites & Environment\n\nIn this guide, you will set up a complete development environment for building applications on Yellow Network.\n\n**Goal** : Have a working local environment ready for Yellow App development.\n\n* * *\n\nSummary: This section outlines the foundational setup requirements and environment configuration steps necessary to begin building and testing applications on the Yellow Network.\n\nRelated terms: setup, installation, environment configuration, getting started, development tools, local environment, prerequisites, Yellow App development, SDK setup, dependencies, dev environment, initial configuration, system requirements, toolchain\n\nUse cases: Setting up a local development machine for Yellow Network integration, Verifying system compatibility before installing the SDK, Preparing a CI/CD environment for Yellow App testing",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the foundational setup requirements and environment configuration steps necessary to begin building and testing applications on the Yellow Network.",
      "keywords": [
        "setup",
        "installation",
        "environment configuration",
        "getting started",
        "development tools",
        "local environment",
        "prerequisites",
        "Yellow App development",
        "SDK setup",
        "dependencies",
        "dev environment",
        "initial configuration",
        "system requirements",
        "toolchain"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Setting up a local development machine for Yellow Network integration",
        "Verifying system compatibility before installing the SDK",
        "Preparing a CI/CD environment for Yellow App testing"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## System Requirementsâ€‹\n\n\nRequirement| Minimum| Recommended  \n---|---|---  \n**Node.js**|  18.x| 20.x or later  \n**npm/yarn/pnpm**|  Latest stable| Latest stable  \n**Operating System**|  macOS, Linux, Windows| macOS, Linux  \n  \n* * *\n\nSummary: Specifies the minimum and recommended system requirements, including Node.js versions and package managers, necessary to initialize and run the Yellow Network SDK.\n\nRelated terms: Node.js, npm, yarn, pnpm, system requirements, environment setup, installation prerequisites, macOS, Linux, Windows, SDK setup, development environment, dependencies, node version, package manager\n\nUse cases: Setting up a local development environment, Verifying CI/CD pipeline compatibility, Troubleshooting installation issues",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Specifies the minimum and recommended system requirements, including Node.js versions and package managers, necessary to initialize and run the Yellow Network SDK.",
      "keywords": [
        "Node.js",
        "npm",
        "yarn",
        "pnpm",
        "system requirements",
        "environment setup",
        "installation prerequisites",
        "macOS",
        "Linux",
        "Windows",
        "SDK setup",
        "development environment",
        "dependencies",
        "node version",
        "package manager"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Setting up a local development environment",
        "Verifying CI/CD pipeline compatibility",
        "Troubleshooting installation issues"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Required Knowledgeâ€‹\n\n\nBefore building on Yellow Network, you should be comfortable with:\n\nTopic| Why It Matters  \n---|---  \n**JavaScript/TypeScript**|  SDK and examples are in TypeScript  \n**Async/await patterns**|  All network operations are asynchronous  \n**Basic Web3 concepts**|  Wallets, transactions, signatures  \n**ERC-20 tokens**|  Fund management involves token operations  \n  \nNew to Web3?\n\nIf you're new to blockchain development, start with the [Ethereum Developer Documentation](https://ethereum.org/developers) to understand wallets, transactions, and smart contract basics.\n\n* * *\n\nSummary: Defines the technical prerequisites and foundational knowledge required for developers to integrate with the Yellow Network SDK, focusing on language proficiency and Web3 concepts.\n\nRelated terms: JavaScript, TypeScript, Async/await, Web3, Wallets, Transactions, Signatures, ERC-20, Blockchain, Prerequisites, Environment setup, Getting started, Yellow Network, Crypto development\n\nUse cases: Initial developer onboarding, Environment preparation, Technical feasibility assessment",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the technical prerequisites and foundational knowledge required for developers to integrate with the Yellow Network SDK, focusing on language proficiency and Web3 concepts.",
      "keywords": [
        "JavaScript",
        "TypeScript",
        "Async/await",
        "Web3",
        "Wallets",
        "Transactions",
        "Signatures",
        "ERC-20",
        "Blockchain",
        "Prerequisites",
        "Environment setup",
        "Getting started",
        "Yellow Network",
        "Crypto development"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Initial developer onboarding",
        "Environment preparation",
        "Technical feasibility assessment"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 1: Install Node.jsâ€‹\n\n\n### macOS (using Homebrew)â€‹\n    \n    \n    # Install Homebrew if you don't have it  \n    /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"  \n      \n    # Install Node.js  \n    brew install node@20  \n      \n    # Verify installation  \n    node --version  # Should show v20.x.x  \n    npm --version   # Should show 10.x.x  \n    \n\n### Linux (Ubuntu/Debian)â€‹\n    \n    \n    # Install Node.js via NodeSource  \n    curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -  \n    sudo apt-get install -y nodejs  \n      \n    # Verify installation  \n    node --version  \n    npm --version  \n    \n\n### Windowsâ€‹\n\nDownload and run the installer from [nodejs.org](https://nodejs.org/).\n\n* * *\n\nSummary: Provides step-by-step instructions for installing the required Node.js runtime environment on macOS, Linux, and Windows to ensure compatibility with the Yellow Network SDK.\n\nRelated terms: Node.js, npm, installation, environment setup, prerequisites, macOS, Linux, Windows, Homebrew, NodeSource, runtime, development environment, SDK setup, node version, package manager\n\nUse cases: setting up a new development environment, preparing system for SDK installation, ensuring runtime compatibility",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides step-by-step instructions for installing the required Node.js runtime environment on macOS, Linux, and Windows to ensure compatibility with the Yellow Network SDK.",
      "keywords": [
        "Node.js",
        "npm",
        "installation",
        "environment setup",
        "prerequisites",
        "macOS",
        "Linux",
        "Windows",
        "Homebrew",
        "NodeSource",
        "runtime",
        "development environment",
        "SDK setup",
        "node version",
        "package manager"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "setting up a new development environment",
        "preparing system for SDK installation",
        "ensuring runtime compatibility"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 2: Install Core Dependenciesâ€‹\n\n\nCreate a new project and install the required packages:\n    \n    \n    # Create project directory  \n    mkdir yellow-app && cd yellow-app  \n      \n    # Initialize project  \n    npm init -y  \n      \n    # Install core dependencies  \n    npm install @erc7824/nitrolite viem  \n      \n    # Install development dependencies  \n    npm install -D typescript @types/node tsx  \n    \n\n### Package Overviewâ€‹\n\nPackage| Purpose  \n---|---  \n`@erc7824/nitrolite`| Yellow Network SDK for state channel operations  \n`viem`| Modern Ethereum library for wallet and contract interactions  \n`typescript`| Type safety and better developer experience  \n`tsx`| Run TypeScript files directly  \n  \n* * *\n\nSummary: This section outlines the initial setup and installation of essential libraries, including the Nitrolite SDK and Viem, required to build applications on the Yellow Network state channel protocol.\n\nRelated terms: installation, setup, dependencies, nitrolite, viem, state channel, sdk, ethereum, typescript, npm install, project initialization, erc7824, yellow network, dev environment, package manager\n\nUse cases: Setting up a new Yellow Network project, Integrating state channel capabilities into a Node.js app, Configuring a development environment for crypto payments",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the initial setup and installation of essential libraries, including the Nitrolite SDK and Viem, required to build applications on the Yellow Network state channel protocol.",
      "keywords": [
        "installation",
        "setup",
        "dependencies",
        "nitrolite",
        "viem",
        "state channel",
        "sdk",
        "ethereum",
        "typescript",
        "npm install",
        "project initialization",
        "erc7824",
        "yellow network",
        "dev environment",
        "package manager"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "Setting up a new Yellow Network project",
        "Integrating state channel capabilities into a Node.js app",
        "Configuring a development environment for crypto payments"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 3: Configure TypeScriptâ€‹\n\n\nCreate `tsconfig.json`:\n    \n    \n    {  \n      \"compilerOptions\": {  \n        \"target\": \"ES2022\",  \n        \"module\": \"ESNext\",  \n        \"moduleResolution\": \"bundler\",  \n        \"strict\": true,  \n        \"esModuleInterop\": true,  \n        \"skipLibCheck\": true,  \n        \"outDir\": \"./dist\",  \n        \"rootDir\": \"./src\"  \n      },  \n      \"include\": [\"src/**/*\"],  \n      \"exclude\": [\"node_modules\"]  \n    }  \n    \n\nUpdate `package.json`:\n    \n    \n    {  \n      \"type\": \"module\",  \n      \"scripts\": {  \n        \"dev\": \"tsx watch src/index.ts\",  \n        \"build\": \"tsc\",  \n        \"start\": \"node dist/index.js\"  \n      }  \n    }  \n    \n\n* * *\n\nSummary: Defines the required TypeScript and Node.js environment settings to ensure compatibility with the Yellow Network SDK's modern ECMAScript and module requirements.\n\nRelated terms: TypeScript configuration, tsconfig.json, package.json, environment setup, ESM modules, ES2022, compiler options, build scripts, project initialization, SDK setup, node configuration, typescript setup, module resolution\n\nUse cases: Initializing a new SDK project, Configuring build pipelines for payment apps, Setting up a TypeScript development environment",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the required TypeScript and Node.js environment settings to ensure compatibility with the Yellow Network SDK's modern ECMAScript and module requirements.",
      "keywords": [
        "TypeScript configuration",
        "tsconfig.json",
        "package.json",
        "environment setup",
        "ESM modules",
        "ES2022",
        "compiler options",
        "build scripts",
        "project initialization",
        "SDK setup",
        "node configuration",
        "typescript setup",
        "module resolution"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Initializing a new SDK project",
        "Configuring build pipelines for payment apps",
        "Setting up a TypeScript development environment"
      ],
      "function_names": [
        "node_modules"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 4: Set Up Environment Variablesâ€‹\n\n\nCreate `.env` for sensitive configuration:\n    \n    \n    # .env - Never commit this file!  \n      \n    # Your wallet private key (for development only)  \n    PRIVATE_KEY=0x...  \n      \n    # RPC endpoints  \n    SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_KEY  \n    BASE_RPC_URL=https://base-sepolia.g.alchemy.com/v2/YOUR_KEY  \n      \n    # Clearnode WebSocket endpoint  \n    # Production: wss://clearnet.yellow.com/ws  \n    # Sandbox: wss://clearnet-sandbox.yellow.com/ws  \n    CLEARNODE_WS_URL=wss://clearnet-sandbox.yellow.com/ws  \n    \n\nAdd to `.gitignore`:\n    \n    \n    # .gitignore  \n    .env  \n    .env.local  \n    node_modules/  \n    dist/  \n    \n\nInstall dotenv for loading environment variables:\n    \n    \n    npm install dotenv  \n    \n\n* * *\n\nSummary: Provides instructions for configuring environment variables, including wallet private keys and network endpoints, to establish secure connections with blockchain RPCs and the Yellow Network Clearnode.\n\nRelated terms: environment variables, configuration, private key, RPC endpoint, WebSocket, Clearnode, dotenv, setup, security, .env, wallet connection, network settings, infura, alchemy, gitignore\n\nUse cases: Initial project initialization, Connecting to testnets like Sepolia and Base, Securing private keys during development, Establishing WebSocket connections to Clearnode",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides instructions for configuring environment variables, including wallet private keys and network endpoints, to establish secure connections with blockchain RPCs and the Yellow Network Clearnode.",
      "keywords": [
        "environment variables",
        "configuration",
        "private key",
        "RPC endpoint",
        "WebSocket",
        "Clearnode",
        "dotenv",
        "setup",
        "security",
        ".env",
        "wallet connection",
        "network settings",
        "infura",
        "alchemy",
        "gitignore"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Initial project initialization",
        "Connecting to testnets like Sepolia and Base",
        "Securing private keys during development",
        "Establishing WebSocket connections to Clearnode"
      ],
      "function_names": [
        "node_modules"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 5: Wallet Setupâ€‹\n\n\n### Development Walletâ€‹\n\nFor development, create a dedicated wallet:\n    \n    \n    // scripts/create-wallet.ts  \n    import { generatePrivateKey, privateKeyToAccount } from 'viem/accounts';  \n      \n    const privateKey = generatePrivateKey();  \n    const account = privateKeyToAccount(privateKey);  \n      \n    console.log('New Development Wallet');  \n    console.log('----------------------');  \n    console.log('Address:', account.address);  \n    console.log('Private Key:', privateKey);  \n    console.log('\\nâš ï¸  Save this private key securely and add to .env');  \n    \n\nRun it:\n    \n    \n    npx tsx scripts/create-wallet.ts  \n    \n\n### Get Test Tokensâ€‹\n\n#### Yellow Network Sandbox Faucet (Recommended)â€‹\n\nFor testing on the Yellow Network Sandbox, you can request test tokens directly to your unified balance:\n    \n    \n    curl -XPOST https://clearnet-sandbox.yellow.com/faucet/requestTokens \\  \n      -H \"Content-Type: application/json\" \\  \n      -d '{\"userAddress\":\"<your_wallet_address>\"}'  \n    \n\nReplace `<your_wallet_address>` with your actual wallet address.\n\nNo On-Chain Operations Needed\n\nTest tokens (ytest.USD) are credited directly to your unified balance on the Sandbox Clearnode. No deposit or channel operations are requiredâ€”you can start transacting immediately!\n\n#### Testnet Faucets (For On-Chain Testing)â€‹\n\nIf you need on-chain test tokens for Sepolia or Base Sepolia:\n\nNetwork| Faucet  \n---|---  \nSepolia| [sepoliafaucet.com](https://sepoliafaucet.com)  \nBase Sepolia| [base.org/faucet](https://www.coinbase.com/faucets/base-ethereum-goerli-faucet)  \n  \nDevelopment Only\n\nNever use your main wallet or real funds for development. Always create a separate development wallet with test tokens.\n\n* * *\n\nSummary: This section guides developers through creating a dedicated development wallet and acquiring test tokens via the Yellow Network Sandbox faucet or public testnets to prepare the environment for protocol interaction.\n\nRelated terms: wallet setup, private key, viem, test tokens, faucet, sandbox, ytest.USD, Sepolia, Base Sepolia, account creation, development environment, crypto wallet, testnet funds, clearnode\n\nUse cases: local development environment setup, funding test accounts, sandbox transaction testing",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section guides developers through creating a dedicated development wallet and acquiring test tokens via the Yellow Network Sandbox faucet or public testnets to prepare the environment for protocol interaction.",
      "keywords": [
        "wallet setup",
        "private key",
        "viem",
        "test tokens",
        "faucet",
        "sandbox",
        "ytest.USD",
        "Sepolia",
        "Base Sepolia",
        "account creation",
        "development environment",
        "crypto wallet",
        "testnet funds",
        "clearnode"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "local development environment setup",
        "funding test accounts",
        "sandbox transaction testing"
      ],
      "function_names": [
        "your_wallet_address"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 6: Verify Setupâ€‹\n\n\nCreate `src/index.ts` to verify everything works:\n    \n    \n    import 'dotenv/config';  \n    import { createPublicClient, http } from 'viem';  \n    import { sepolia } from 'viem/chains';  \n    import { privateKeyToAccount } from 'viem/accounts';  \n      \n    async function main() {  \n      // Verify environment variables  \n      const privateKey = process.env.PRIVATE_KEY;  \n      if (!privateKey) {  \n        throw new Error('PRIVATE_KEY not set in .env');  \n      }  \n      \n      // Create account from private key  \n      const account = privateKeyToAccount(privateKey as `0x${string}`);  \n      console.log('âœ“ Wallet loaded:', account.address);  \n      \n      // Create public client  \n      const client = createPublicClient({  \n        chain: sepolia,  \n        transport: http(process.env.SEPOLIA_RPC_URL),  \n      });  \n      \n      // Check connection  \n      const blockNumber = await client.getBlockNumber();  \n      console.log('âœ“ Connected to Sepolia, block:', blockNumber);  \n      \n      // Check balance  \n      const balance = await client.getBalance({ address: account.address });  \n      console.log('âœ“ ETH balance:', balance.toString(), 'wei');  \n      \n      console.log('\\nðŸŽ‰ Environment setup complete!');  \n    }  \n      \n    main().catch(console.error);  \n    \n\nRun the verification:\n    \n    \n    npm run dev  \n    \n\nExpected output:\n    \n    \n    âœ“ Wallet loaded: 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb  \n    âœ“ Connected to Sepolia, block: 12345678  \n    âœ“ ETH balance: 100000000000000000 wei  \n      \n    ðŸŽ‰ Environment setup complete!  \n    \n\n* * *\n\nSummary: Provides a validation script to confirm the development environment is correctly configured with necessary credentials and network connectivity for the Yellow Network.\n\nRelated terms: environment setup, wallet verification, blockchain connection, Sepolia testnet, viem, private key, RPC URL, block number, ETH balance, configuration check, dev environment, setup validation, crypto wallet, web3 provider\n\nUse cases: Initial developer onboarding, Troubleshooting connectivity issues, Verifying wallet credentials and network access",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a validation script to confirm the development environment is correctly configured with necessary credentials and network connectivity for the Yellow Network.",
      "keywords": [
        "environment setup",
        "wallet verification",
        "blockchain connection",
        "Sepolia testnet",
        "viem",
        "private key",
        "RPC URL",
        "block number",
        "ETH balance",
        "configuration check",
        "dev environment",
        "setup validation",
        "crypto wallet",
        "web3 provider"
      ],
      "function_name": "createPublicClient",
      "intent": "tutorial",
      "use_cases": [
        "Initial developer onboarding",
        "Troubleshooting connectivity issues",
        "Verifying wallet credentials and network access"
      ],
      "function_names": [
        "PublicClient"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Project Structureâ€‹\n\n\nRecommended folder structure for Yellow Apps:\n    \n    \n    yellow-app/  \n    â”œâ”€â”€ src/  \n    â”‚   â”œâ”€â”€ index.ts          # Entry point  \n    â”‚   â”œâ”€â”€ config.ts         # Configuration  \n    â”‚   â”œâ”€â”€ client.ts         # Nitrolite client setup  \n    â”‚   â”œâ”€â”€ auth.ts           # Authentication logic  \n    â”‚   â””â”€â”€ channels/  \n    â”‚       â”œâ”€â”€ create.ts     # Channel creation  \n    â”‚       â”œâ”€â”€ transfer.ts   # Transfer operations  \n    â”‚       â””â”€â”€ close.ts      # Channel closure  \n    â”œâ”€â”€ scripts/  \n    â”‚   â””â”€â”€ create-wallet.ts  # Utility scripts  \n    â”œâ”€â”€ .env                  # Environment variables (git-ignored)  \n    â”œâ”€â”€ .gitignore  \n    â”œâ”€â”€ package.json  \n    â””â”€â”€ tsconfig.json  \n    \n\n* * *\n\nSummary: Defines the recommended architectural layout and directory organization for building applications on the Yellow Network, ensuring modularity across authentication, client setup, and channel management.\n\nRelated terms: project structure, folder layout, directory organization, boilerplate, yellow app, nitrolite client, channel management, authentication setup, environment variables, configuration, typescript setup, wallet scripts, scaffolding, project setup, folder hierarchy\n\nUse cases: initializing a new payment application, organizing channel lifecycle logic, configuring environment variables for SDK",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the recommended architectural layout and directory organization for building applications on the Yellow Network, ensuring modularity across authentication, client setup, and channel management.",
      "keywords": [
        "project structure",
        "folder layout",
        "directory organization",
        "boilerplate",
        "yellow app",
        "nitrolite client",
        "channel management",
        "authentication setup",
        "environment variables",
        "configuration",
        "typescript setup",
        "wallet scripts",
        "scaffolding",
        "project setup",
        "folder hierarchy"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "initializing a new payment application",
        "organizing channel lifecycle logic",
        "configuring environment variables for SDK"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Supported Networksâ€‹\n\n\nTo get the current list of supported chains and contract addresses, query the Clearnode's `get_config` endpoint:\n    \n    \n    // Example: Fetch supported chains and contract addresses  \n    const ws = new WebSocket('wss://clearnet-sandbox.yellow.com/ws');  \n      \n    ws.onopen = () => {  \n      const request = {  \n        req: [1, 'get_config', {}, Date.now()],  \n        sig: [] // get_config is a public endpoint, no signature required  \n      };  \n      ws.send(JSON.stringify(request));  \n    };  \n      \n    ws.onmessage = (event) => {  \n      const response = JSON.parse(event.data);  \n      console.log('Supported chains:', response.res[2].chains);  \n      console.log('Contract addresses:', response.res[2].contracts);  \n    };  \n    \n\nDynamic Configuration\n\nThe `get_config` method returns real-time information about supported chains, contract addresses, and Clearnode capabilities. This ensures you always have the most up-to-date network information.\n\n* * *\n\nSummary: This component enables the dynamic retrieval of network-specific metadata, such as supported blockchain chains and smart contract addresses, via the Clearnode's public configuration endpoint. It allows system architects to build environment-agnostic applications that synchronize with the protocol's infrastructure in real-time.\n\nRelated terms: get_config, supported chains, contract addresses, network discovery, Clearnode, WebSocket, dynamic configuration, environment setup, blockchain metadata, public endpoint, getconfig, infrastructure\n\nUse cases: Dynamic discovery of smart contract addresses during app initialization, Verifying blockchain network compatibility for payment routing, Automating environment setup for multi-chain client applications",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component enables the dynamic retrieval of network-specific metadata, such as supported blockchain chains and smart contract addresses, via the Clearnode's public configuration endpoint. It allows system architects to build environment-agnostic applications that synchronize with the protocol's infrastructure in real-time.",
      "keywords": [
        "get_config",
        "supported chains",
        "contract addresses",
        "network discovery",
        "Clearnode",
        "WebSocket",
        "dynamic configuration",
        "environment setup",
        "blockchain metadata",
        "public endpoint",
        "getconfig",
        "infrastructure"
      ],
      "function_name": "get_config",
      "intent": "configuration",
      "use_cases": [
        "Dynamic discovery of smart contract addresses during app initialization",
        "Verifying blockchain network compatibility for payment routing",
        "Automating environment setup for multi-chain client applications"
      ],
      "function_names": [
        "get_config"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nYour environment is ready! Continue to:\n\n  * **[Key Terms& Mental Models](/docs/learn/getting-started/key-terms)** â€” Understand the core concepts\n  * **[Quickstart](/docs/learn/getting-started/quickstart)** â€” Build your first Yellow App\n  * **[State Channels vs L1/L2](/docs/learn/core-concepts/state-channels-vs-l1-l2)** â€” Deep dive into state channels\n\n* * *\n\nSummary: Provides navigational guidance for developers who have completed environment setup, linking to core concepts, quickstart tutorials, and technical deep dives into state channel architecture.\n\nRelated terms: environment setup, getting started, yellow network, state channels, layer 2, blockchain scaling, developer onboarding, mental models, quickstart guide, crypto payments, sdk configuration, yellow app, l1 vs l2, prerequisites\n\nUse cases: initial developer onboarding, understanding protocol architecture, setting up development environment",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides navigational guidance for developers who have completed environment setup, linking to core concepts, quickstart tutorials, and technical deep dives into state channel architecture.",
      "keywords": [
        "environment setup",
        "getting started",
        "yellow network",
        "state channels",
        "layer 2",
        "blockchain scaling",
        "developer onboarding",
        "mental models",
        "quickstart guide",
        "crypto payments",
        "sdk configuration",
        "yellow app",
        "l1 vs l2",
        "prerequisites"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "initial developer onboarding",
        "understanding protocol architecture",
        "setting up development environment"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Common Issuesâ€‹\n\n\n### \"Module not found\" errorsâ€‹\n\nEnsure you have `\"type\": \"module\"` in `package.json` and are using ESM imports.\n\n### \"Cannot find module 'viem'\"â€‹\n\nRun `npm install` to ensure all dependencies are installed.\n\n### RPC rate limitingâ€‹\n\nUse a dedicated RPC provider (Infura, Alchemy) instead of public endpoints for production.\n\n### TypeScript errors with viemâ€‹\n\nEnsure your `tsconfig.json` has `\"moduleResolution\": \"bundler\"` or `\"node16\"`.\n\n\n\n[PreviousQuickstart](/docs/learn/getting-started/quickstart)[NextKey Terms & Mental Models](/docs/learn/getting-started/key-terms)\n\n  * System Requirements\n  * Required Knowledge\n  * Step 1: Install Node.js\n    * macOS (using Homebrew)\n    * Linux (Ubuntu/Debian)\n    * Windows\n  * Step 2: Install Core Dependencies\n    * Package Overview\n  * Step 3: Configure TypeScript\n  * Step 4: Set Up Environment Variables\n  * Step 5: Wallet Setup\n    * Development Wallet\n    * Get Test Tokens\n  * Step 6: Verify Setup\n  * Project Structure\n  * Supported Networks\n  * Next Steps\n  * Common Issues\n    * \"Module not found\" errors\n    * \"Cannot find module 'viem'\"\n    * RPC rate limiting\n    * TypeScript errors with viem\n\nSummary: This section provides the foundational environment configuration and troubleshooting steps required to initialize the Yellow Network SDK, covering dependency management, TypeScript settings, and RPC connectivity.\n\nRelated terms: environment setup, installation, troubleshooting, viem, typescript configuration, rpc provider, node.js, esm modules, wallet configuration, package dependencies, module resolution, rate limiting, testnet tokens, sdk initialization, dev environment\n\nUse cases: Initial SDK integration and project bootstrapping, Debugging build-time errors related to ESM or TypeScript, Configuring production-grade RPC connections to avoid rate limits, Setting up development wallets for testing payment flows",
    "metadata": {
      "title": "Prerequisites & Environment | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/prerequisites",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section provides the foundational environment configuration and troubleshooting steps required to initialize the Yellow Network SDK, covering dependency management, TypeScript settings, and RPC connectivity.",
      "keywords": [
        "environment setup",
        "installation",
        "troubleshooting",
        "viem",
        "typescript configuration",
        "rpc provider",
        "node.js",
        "esm modules",
        "wallet configuration",
        "package dependencies",
        "module resolution",
        "rate limiting",
        "testnet tokens",
        "sdk initialization",
        "dev environment"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Initial SDK integration and project bootstrapping",
        "Debugging build-time errors related to ESM or TypeScript",
        "Configuring production-grade RPC connections to avoid rate limits",
        "Setting up development wallets for testing payment flows"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Getting Started\n  * Quickstart\n\n\n\n# Quickstart Guide\n\nThis guide provides a step-by-step walkthrough of integrating with the Yellow Network using the Nitrolite SDK. We will build a script to connect to the network, authenticate, manage state channels, and transfer funds.\n\nSummary: This guide provides a foundational walkthrough for integrating the Nitrolite SDK with the Yellow Network, covering essential steps from authentication to state channel management and fund transfers.\n\nRelated terms: getting started, quickstart, Nitrolite SDK, Yellow Network, state channels, authentication, fund transfer, integration guide, setup, crypto payments, Nitrolight, onboarding, layer 2\n\nUse cases: Initial SDK integration and environment setup, Establishing secure authentication with the Yellow Network, Implementing basic off-chain fund transfers via state channels",
    "metadata": {
      "title": "Quickstart | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/quickstart",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This guide provides a foundational walkthrough for integrating the Nitrolite SDK with the Yellow Network, covering essential steps from authentication to state channel management and fund transfers.",
      "keywords": [
        "getting started",
        "quickstart",
        "Nitrolite SDK",
        "Yellow Network",
        "state channels",
        "authentication",
        "fund transfer",
        "integration guide",
        "setup",
        "crypto payments",
        "Nitrolight",
        "onboarding",
        "layer 2"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "Initial SDK integration and environment setup",
        "Establishing secure authentication with the Yellow Network",
        "Implementing basic off-chain fund transfers via state channels"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Prerequisitesâ€‹\n\n\n  * [Node.js](https://nodejs.org/) (v18 or higher)\n  * [npm](https://www.npmjs.com/)\n\nSummary: Defines the foundational software environment and version requirements necessary to initialize and run the Yellow Network SDK.\n\nRelated terms: Node.js, npm, prerequisites, installation, setup, environment requirements, getting started, dependencies, node version, package manager, dev setup, system requirements, node.js v18\n\nUse cases: initial project setup, environment verification, SDK installation preparation",
    "metadata": {
      "title": "Quickstart | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/quickstart",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the foundational software environment and version requirements necessary to initialize and run the Yellow Network SDK.",
      "keywords": [
        "Node.js",
        "npm",
        "prerequisites",
        "installation",
        "setup",
        "environment requirements",
        "getting started",
        "dependencies",
        "node version",
        "package manager",
        "dev setup",
        "system requirements",
        "node.js v18"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "initial project setup",
        "environment verification",
        "SDK installation preparation"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Setupâ€‹\n\n\n  1. **Install Dependencies**\n         \n         npm install  \n         \n\n  2. **Environment Variables**\n\nCreate a `.env` file in your project root:\n         \n         # .env  \n         PRIVATE_KEY=your_sepolia_private_key_here  \n         ALCHEMY_RPC_URL=your_alchemy_rpc_url_here\n\nSummary: Provides the foundational setup instructions for the Yellow Network SDK, including dependency installation and environment configuration for blockchain interaction.\n\nRelated terms: setup, installation, configuration, environment variables, private key, RPC URL, Sepolia, Alchemy, npm install, quickstart, getting started, blockchain connection, wallet setup, env file, dot env\n\nUse cases: initial SDK integration, setting up development environment, connecting to Sepolia testnet",
    "metadata": {
      "title": "Quickstart | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/quickstart",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides the foundational setup instructions for the Yellow Network SDK, including dependency installation and environment configuration for blockchain interaction.",
      "keywords": [
        "setup",
        "installation",
        "configuration",
        "environment variables",
        "private key",
        "RPC URL",
        "Sepolia",
        "Alchemy",
        "npm install",
        "quickstart",
        "getting started",
        "blockchain connection",
        "wallet setup",
        "env file",
        "dot env"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "initial SDK integration",
        "setting up development environment",
        "connecting to Sepolia testnet"
      ],
      "function_names": [
        "your_sepolia_private_key_here",
        "your_alchemy_rpc_url_here"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## 1\\. Getting Fundsâ€‹\n\n\nBefore we write code, you need test tokens (`ytest.usd`). In the Sandbox, these tokens land in your **Unified Balance** (Off-Chain), which sits in the Yellow Network's clearing layer.\n\nRequest tokens via the Faucet:\n    \n    \n    curl -XPOST https://clearnet-sandbox.yellow.com/faucet/requestTokens \\  \n      -H \"Content-Type: application/json\" \\  \n      -d '{\"userAddress\":\"<your_wallet_address>\"}'\n\nSummary: This component provides instructions for acquiring test tokens via a faucet to populate a user's off-chain Unified Balance within the Yellow Network sandbox environment.\n\nRelated terms: faucet, test tokens, ytest.usd, unified balance, off-chain, sandbox, request tokens, funding, wallet address, clearing layer, testnet, crypto faucet, get funds\n\nUse cases: funding a test account, sandbox environment setup, testing off-chain transactions",
    "metadata": {
      "title": "Quickstart | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/quickstart",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component provides instructions for acquiring test tokens via a faucet to populate a user's off-chain Unified Balance within the Yellow Network sandbox environment.",
      "keywords": [
        "faucet",
        "test tokens",
        "ytest.usd",
        "unified balance",
        "off-chain",
        "sandbox",
        "request tokens",
        "funding",
        "wallet address",
        "clearing layer",
        "testnet",
        "crypto faucet",
        "get funds"
      ],
      "function_name": "requestTokens",
      "intent": "tutorial",
      "use_cases": [
        "funding a test account",
        "sandbox environment setup",
        "testing off-chain transactions"
      ],
      "function_names": [
        "your_wallet_address"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## 2\\. Initializationâ€‹\n\n\nFirst, we setup the `NitroliteClient` with Viem. This client handles all communication with the Yellow Network nodes and smart contracts.\n    \n    \n    import { NitroliteClient, WalletStateSigner, createECDSAMessageSigner } from '@erc7824/nitrolite';  \n    import { createPublicClient, createWalletClient, http } from 'viem';  \n    import { sepolia } from 'viem/chains';  \n    import { privateKeyToAccount } from 'viem/accounts';  \n    import WebSocket from 'ws';  \n    import 'dotenv/config';  \n      \n    // Setup Viem Clients  \n    const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);  \n    const publicClient = createPublicClient({ chain: sepolia, transport: http(process.env.ALCHEMY_RPC_URL) });  \n    const walletClient = createWalletClient({ chain: sepolia, transport: http(), account });  \n      \n    // Initialize Nitrolite Client  \n    const client = new NitroliteClient({  \n        publicClient,  \n        walletClient,  \n        stateSigner: new WalletStateSigner(walletClient),  \n        addresses: {  \n            custody: '0x019B65A265EB3363822f2752141b3dF16131b262',  \n            adjudicator: '0x7c7ccbc98469190849BCC6c926307794fDfB11F2',  \n        },  \n        chainId: sepolia.id,  \n        challengeDuration: 3600n,  \n    });  \n      \n    // Connect to Sandbox Node  \n    const ws = new WebSocket('wss://clearnet-sandbox.yellow.com/ws');\n\nSummary: The NitroliteClient serves as the primary gateway for the SDK, orchestrating communication between the application, Yellow Network nodes, and underlying smart contracts via Viem integration.\n\nRelated terms: NitroliteClient, Viem integration, blockchain initialization, wallet setup, state signing, RPC configuration, WebSocket connection, Sepolia testnet, smart contract interface, Nitro lite, Nitrolight, crypto payment setup, SDK configuration\n\nUse cases: SDK initialization and environment setup, Connecting to Yellow Network sandbox nodes, Configuring blockchain clients for state-channel interactions",
    "metadata": {
      "title": "Quickstart | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/quickstart",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The NitroliteClient serves as the primary gateway for the SDK, orchestrating communication between the application, Yellow Network nodes, and underlying smart contracts via Viem integration.",
      "keywords": [
        "NitroliteClient",
        "Viem integration",
        "blockchain initialization",
        "wallet setup",
        "state signing",
        "RPC configuration",
        "WebSocket connection",
        "Sepolia testnet",
        "smart contract interface",
        "Nitro lite",
        "Nitrolight",
        "crypto payment setup",
        "SDK configuration"
      ],
      "function_name": "NitroliteClient",
      "intent": "tutorial",
      "use_cases": [
        "SDK initialization and environment setup",
        "Connecting to Yellow Network sandbox nodes",
        "Configuring blockchain clients for state-channel interactions"
      ],
      "function_names": [
        "WalletClient",
        "PublicClient",
        "ECDSAMessageSigner"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## 3\\. Authenticationâ€‹\n\n\nAuthentication involves generating a temporary **Session Key** and verifying your identity using your main wallet (EIP-712).\n    \n    \n    // Generate temporary session key  \n    const sessionPrivateKey = generatePrivateKey();  \n    const sessionSigner = createECDSAMessageSigner(sessionPrivateKey);  \n    const sessionAccount = privateKeyToAccount(sessionPrivateKey);  \n      \n    // Send auth request  \n    const authRequestMsg = await createAuthRequestMessage({  \n        address: account.address,  \n        application: 'Test app',  \n        session_key: sessionAccount.address,  \n        allowances: [{ asset: 'ytest.usd', amount: '1000000000' }],  \n        expires_at: BigInt(Math.floor(Date.now() / 1000) + 3600), // 1 hour  \n        scope: 'test.app',  \n    });  \n    ws.send(authRequestMsg);  \n      \n    // Handle Challenge (in ws.onmessage)  \n    if (type === 'auth_challenge') {  \n        const challenge = response.res[2].challenge_message;  \n        // Sign with MAIN wallet  \n        const signer = createEIP712AuthMessageSigner(walletClient, authParams, { name: 'Test app' });  \n        const verifyMsg = await createAuthVerifyMessageFromChallenge(signer, challenge);  \n        ws.send(verifyMsg);  \n    }\n\nSummary: Establishes a secure communication session by generating a temporary session key and verifying user identity via an EIP-712 challenge-response handshake with a primary wallet.\n\nRelated terms: authentication, session key, EIP-712, wallet signing, challenge-response, login, identity verification, auth request, session management, ECDSA, private key, crypto auth, Yellow Network, auth_challenge, session_key\n\nUse cases: User login and session establishment, Granting asset allowances for dApps, Secure API authentication via wallet",
    "metadata": {
      "title": "Quickstart | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/quickstart",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Establishes a secure communication session by generating a temporary session key and verifying user identity via an EIP-712 challenge-response handshake with a primary wallet.",
      "keywords": [
        "authentication",
        "session key",
        "EIP-712",
        "wallet signing",
        "challenge-response",
        "login",
        "identity verification",
        "auth request",
        "session management",
        "ECDSA",
        "private key",
        "crypto auth",
        "Yellow Network",
        "auth_challenge",
        "session_key"
      ],
      "function_name": "createAuthRequestMessage",
      "intent": "tutorial",
      "use_cases": [
        "User login and session establishment",
        "Granting asset allowances for dApps",
        "Secure API authentication via wallet"
      ],
      "function_names": [
        "EIP712AuthMessageSigner",
        "challenge_message",
        "ECDSAMessageSigner",
        "AuthVerifyMessageFromChallenge",
        "expires_at"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## 4\\. Channel Lifecycleâ€‹\n\n\n### Creating a Channelâ€‹\n\nIf no channel exists, we request the Node to open one.\n    \n    \n    const createChannelMsg = await createCreateChannelMessage(  \n        sessionSigner, // Sign with session key  \n        {  \n            chain_id: 11155111, // Sepolia  \n            token: '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238', // ytest.usd  \n        }  \n    );  \n    ws.send(createChannelMsg);  \n      \n    // Listen for 'create_channel' response, then submit to chain  \n    const createResult = await client.createChannel({  \n        channel,  \n        unsignedInitialState,  \n        serverSignature,  \n    });  \n    \n\n### Funding (Resizing)â€‹\n\nTo fund the channel, we perform a \"Resize\". Since your funds are in your **Unified Balance** (from the Faucet), we use `allocate_amount` to move them into the Channel.\n\n> **Important:** Do NOT use `resize_amount` unless you have deposited funds directly into the L1 Custody Contract.\n    \n    \n    const resizeMsg = await createResizeChannelMessage(  \n        sessionSigner,  \n        {  \n            channel_id: channelId,  \n            allocate_amount: 20n, // Moves 20 units from Unified Balance -> Channel  \n            funds_destination: account.address,  \n        }  \n    );  \n    ws.send(resizeMsg);  \n      \n    // Submit resize proof to chain  \n    await client.resizeChannel({ resizeState, proofStates });  \n    \n\n### Closing & Withdrawingâ€‹\n\nFinally, we cooperatively close the channel. This settles the balance on the L1 Custody Contract, allowing you to withdraw.\n    \n    \n    // Close Channel  \n    const closeMsg = await createCloseChannelMessage(sessionSigner, channelId, account.address);  \n    ws.send(closeMsg);  \n      \n    // Submit close to chain  \n    await client.closeChannel({ finalState, stateData });  \n      \n    // Withdraw from Custody Contract to Wallet  \n    const withdrawalTx = await client.withdrawal(tokenAddress, withdrawableBalance);  \n    console.log('Funds withdrawn:', withdrawalTx);\n\nSummary: Manages the end-to-end lifecycle of state channels, covering creation, liquidity allocation from unified balances, and cooperative settlement for fund withdrawal.\n\nRelated terms: open channel, fund channel, resize channel, close channel, withdraw funds, unified balance, state update, session signer, L1 custody, payment channel, settlement, allocate_amount, channel lifecycle\n\nUse cases: initializing a payment session, allocating liquidity for trading, cooperative channel settlement, withdrawing funds to L1 wallet",
    "metadata": {
      "title": "Quickstart | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/quickstart",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Manages the end-to-end lifecycle of state channels, covering creation, liquidity allocation from unified balances, and cooperative settlement for fund withdrawal.",
      "keywords": [
        "open channel",
        "fund channel",
        "resize channel",
        "close channel",
        "withdraw funds",
        "unified balance",
        "state update",
        "session signer",
        "L1 custody",
        "payment channel",
        "settlement",
        "allocate_amount",
        "channel lifecycle"
      ],
      "function_name": "createChannel",
      "intent": "tutorial",
      "use_cases": [
        "initializing a payment session",
        "allocating liquidity for trading",
        "cooperative channel settlement",
        "withdrawing funds to L1 wallet"
      ],
      "function_names": [
        "create_channel",
        "ChannelMsg",
        "funds_destination",
        "resize_amount",
        "ResizeChannelMessage"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Troubleshootingâ€‹\n\n\nHere are common issues and solutions:\n\n  * **`InsufficientBalance`** :\n\n    * **Cause** : Trying to use `resize_amount` (L1 funds) without depositing first.\n    * **Fix** : Use `allocate_amount` to fund from your Off-chain Unified Balance (Faucet).\n  * **`DepositAlreadyFulfilled`** :\n\n    * **Cause** : Double-submitting a funding request or channel creation.\n    * **Fix** : Check if the channel is already open or funded before sending requests.\n  * **`InvalidState`** :\n\n    * **Cause** : Resizing a closed channel or version mismatch.\n    * **Fix** : Ensure you are using the latest channel state from the Node.\n  * **`operation denied: non-zero allocation`** :\n\n    * **Cause** : Too many \"stale\" channels open.\n    * **Fix** : Run the cleanup script `npx tsx close_all.ts`.\n  * **Timeout waiting for User to fund Custody** :\n\n    * **Cause** : Re-running scripts without closing channels accumulates balance requirements.\n    * **Fix** : Run `close_all.ts` to reset.\n\n### Cleanup Scriptâ€‹\n\nIf you get stuck, use this script to close all open channels:\n    \n    \n    npx tsx close_all.ts\n\nSummary: This section provides diagnostic steps and resolution strategies for common errors encountered during channel lifecycle management and funding operations within the Yellow Network SDK.\n\nRelated terms: troubleshooting, error handling, InsufficientBalance, DepositAlreadyFulfilled, InvalidState, allocate_amount, resize_amount, close_all, channel management, off-chain balance, faucet, stale channels, cleanup script, state mismatch, funding\n\nUse cases: resolving funding errors, cleaning up stale payment channels, resetting SDK state, debugging failed channel creation",
    "metadata": {
      "title": "Quickstart | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/quickstart",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section provides diagnostic steps and resolution strategies for common errors encountered during channel lifecycle management and funding operations within the Yellow Network SDK.",
      "keywords": [
        "troubleshooting",
        "error handling",
        "InsufficientBalance",
        "DepositAlreadyFulfilled",
        "InvalidState",
        "allocate_amount",
        "resize_amount",
        "close_all",
        "channel management",
        "off-chain balance",
        "faucet",
        "stale channels",
        "cleanup script",
        "state mismatch",
        "funding"
      ],
      "function_name": "close_all",
      "intent": "error_handling",
      "use_cases": [
        "resolving funding errors",
        "cleaning up stale payment channels",
        "resetting SDK state",
        "debugging failed channel creation"
      ],
      "function_names": [
        "allocate_amount",
        "resize_amount",
        "close_all"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Complete Codeâ€‹\n\n\n### index.tsâ€‹\n\nClick to view full index.ts\n    \n    \n    import {  \n        NitroliteClient,  \n        WalletStateSigner,  \n        createTransferMessage,  \n        createGetConfigMessage,  \n        createECDSAMessageSigner,  \n        createEIP712AuthMessageSigner,  \n        createAuthVerifyMessageFromChallenge,  \n        createCreateChannelMessage,  \n        createResizeChannelMessage,  \n        createGetLedgerBalancesMessage,  \n        createAuthRequestMessage,  \n        createCloseChannelMessage  \n    } from '@erc7824/nitrolite';  \n    import type {  \n        RPCNetworkInfo,  \n        RPCAsset,  \n        RPCData  \n    } from '@erc7824/nitrolite';  \n    import { createPublicClient, createWalletClient, http } from 'viem';  \n    import { sepolia } from 'viem/chains';  \n    import { privateKeyToAccount, generatePrivateKey } from 'viem/accounts';  \n    import WebSocket from 'ws';  \n    import 'dotenv/config';  \n    import * as readline from 'readline';  \n      \n    console.log('Starting script...');  \n      \n    // Helper to prompt for input  \n    const askQuestion = (query: string): Promise<string> => {  \n        const rl = readline.createInterface({  \n            input: process.stdin,  \n            output: process.stdout,  \n        });  \n        return new Promise(resolve => rl.question(query, ans => {  \n            rl.close();  \n            resolve(ans);  \n        }));  \n    };  \n      \n    // Your wallet private key (use environment variables in production!)  \n    let PRIVATE_KEY = process.env.PRIVATE_KEY as `0x${string}`;  \n      \n    if (!PRIVATE_KEY) {  \n        console.log('PRIVATE_KEY not found in .env');  \n        const inputKey = await askQuestion('Please enter your Private Key: ');  \n        if (!inputKey) {  \n            throw new Error('Private Key is required');  \n        }  \n        PRIVATE_KEY = inputKey.startsWith('0x') ? inputKey as `0x${string}` : `0x${inputKey}` as `0x${string}`;  \n    }  \n      \n    const account = privateKeyToAccount(PRIVATE_KEY);  \n      \n    // Create viem clients  \n    const ALCHEMY_RPC_URL = process.env.ALCHEMY_RPC_URL;  \n    const FALLBACK_RPC_URL = 'https://1rpc.io/sepolia'; // Public fallback  \n      \n    const publicClient = createPublicClient({  \n        chain: sepolia,  \n        transport: http(ALCHEMY_RPC_URL || FALLBACK_RPC_URL),  \n    });  \n      \n    const walletClient = createWalletClient({  \n        chain: sepolia,  \n        transport: http(),  \n        account,  \n    });  \n      \n    interface Config {  \n        assets?: RPCAsset[];  \n        networks?: RPCNetworkInfo[];  \n        [key: string]: any;  \n    }  \n      \n    async function fetchConfig(): Promise<Config> {  \n        const signer = createECDSAMessageSigner(PRIVATE_KEY);  \n        const message = await createGetConfigMessage(signer);  \n      \n        const ws = new WebSocket('wss://clearnet-sandbox.yellow.com/ws');  \n      \n        return new Promise((resolve, reject) => {  \n            ws.onopen = () => {  \n                ws.send(message);  \n            };  \n      \n            ws.onmessage = (event) => {  \n                try {  \n                    const response = JSON.parse(event.data.toString());  \n                    // Response format: [requestId, method, result, timestamp]  \n                    // or NitroliteRPCMessage structure depending on implementation  \n                    // Based on types: NitroliteRPCMessage { res: RPCData }  \n                    // RPCData: [RequestID, RPCMethod, object, Timestamp?]  \n      \n                    if (response.res && response.res[2]) {  \n                        resolve(response.res[2] as Config);  \n                        ws.close();  \n                    } else if (response.error) {  \n                        reject(new Error(response.error.message || 'Unknown RPC error'));  \n                        ws.close();  \n                    }  \n                } catch (err) {  \n                    reject(err);  \n                    ws.close();  \n                }  \n            };  \n      \n            ws.onerror = (error) => {  \n                reject(error);  \n                ws.close();  \n            };  \n        });  \n    }  \n      \n    // Initialize Nitrolite client  \n    console.log('Fetching configuration...');  \n    const config = await fetchConfig();  \n    console.log('Configuration fetched. Assets count:', config.assets?.length);  \n      \n    const client = new NitroliteClient({  \n        publicClient,  \n        walletClient,  \n        // Use WalletStateSigner for signing states  \n        stateSigner: new WalletStateSigner(walletClient),  \n        // Contract addresses  \n        addresses: {  \n            custody: '0x019B65A265EB3363822f2752141b3dF16131b262',  \n            adjudicator: '0x7c7ccbc98469190849BCC6c926307794fDfB11F2',  \n        },  \n        chainId: sepolia.id,  \n        challengeDuration: 3600n, // 1 hour challenge period  \n    });  \n      \n    console.log('âœ“ Client initialized');  \n    console.log('  Wallet Address:', account.address);  \n    console.log('  (Please ensure this address has Sepolia ETH)');  \n      \n    // Connect to Clearnode WebSocket (using sandbox for testing)  \n    const ws = new WebSocket('wss://clearnet-sandbox.yellow.com/ws');  \n      \n    // Step 1: Generate session keypair locally  \n    const sessionPrivateKey = generatePrivateKey();  \n    const sessionAccount = privateKeyToAccount(sessionPrivateKey);  \n    const sessionAddress = sessionAccount.address;  \n      \n    // Helper: Create a signer for the session key  \n    const sessionSigner = createECDSAMessageSigner(sessionPrivateKey);  \n      \n    // Step 2: Send auth_request  \n    const authParams = {  \n        session_key: sessionAddress,        // Session key you generated  \n        allowances: [{                      // Add allowance for ytest.usd  \n            asset: 'ytest.usd',  \n            amount: '1000000000'            // Large amount  \n        }],  \n        expires_at: BigInt(Math.floor(Date.now() / 1000) + 3600), // 1 hour in seconds  \n        scope: 'test.app',  \n    };  \n      \n    const authRequestMsg = await createAuthRequestMessage({  \n        address: account.address,           // Your main wallet address  \n        application: 'Test app',            // Match domain name  \n        ...authParams  \n    });  \n      \n    // We need to capture channelId to close it.  \n    let activeChannelId: string | undefined;  \n      \n    // Helper function to trigger resize  \n    const triggerResize = async (channelId: string, token: string, skipResize: boolean = false) => {  \n        console.log('  Using existing channel:', channelId);  \n      \n        // Add delay to ensure Node indexes the channel  \n        console.log('  Waiting 5s for Node to index channel...');  \n        await new Promise(resolve => setTimeout(resolve, 5000));  \n      \n        // For withdrawal, we don't need to check user balance or allowance  \n        // because the Node (counterparty) is the one depositing funds.  \n      \n      \n        // For withdrawal, we don't deposit (we are withdrawing off-chain funds).  \n        // -------------------------------------------------------------------  \n        // 3. Fund Channel (Resize)  \n        // -------------------------------------------------------------------  \n        // We use 'allocate_amount' to move funds from the User's Unified Balance (off-chain)  \n        // into the Channel. This assumes the user has funds in their Unified Balance (e.g. from faucet).  \n      \n        const amountToFund = 20n;  \n        if (!skipResize) console.log('\\nRequesting resize to fund channel with 20 tokens...');  \n      \n        if (!skipResize) {  \n            const resizeMsg = await createResizeChannelMessage(  \n                sessionSigner,  \n                {  \n                    channel_id: channelId as `0x${string}`,  \n                    // resize_amount: 10n, // <-- This requires L1 funds in Custody (which we don't have)  \n                    allocate_amount: amountToFund,  // <-- This pulls from Unified Balance (Faucet) (Variable name adjusted)  \n                    funds_destination: account.address,  \n                }  \n            );  \n      \n            ws.send(resizeMsg);  \n      \n            // Wait for resize confirmation  \n            console.log('  Waiting for resize confirmation...');  \n            await new Promise<void>((resolve, reject) => {  \n                const timeout = setTimeout(() => reject(new Error('Resize timeout')), 30000);  \n                const handler = (data: any) => {  \n                    const msg = JSON.parse(data.toString());  \n                    if (msg.res && msg.res[1] === 'resize_channel') {  \n                        const payload = msg.res[2];  \n                        if (payload.channel_id === channelId) {  \n                            clearTimeout(timeout);  \n                            ws.off('message', handler);  \n                            resolve();  \n                        }  \n                    }  \n                };  \n                ws.on('message', handler);  \n            });  \n      \n            // Wait for balance update  \n            await new Promise(r => setTimeout(r, 2000));  \n            console.log('âœ“ Resize complete.');  \n        } else {  \n            console.log('  Skipping resize step (already funded).');  \n        }  \n      \n        // Verify Channel Balance  \n        const channelBalances = await publicClient.readContract({  \n            address: client.addresses.custody,  \n            abi: [{  \n                name: 'getChannelBalances',  \n                type: 'function',  \n                stateMutability: 'view',  \n                inputs: [{ name: 'channelId', type: 'bytes32' }, { name: 'tokens', type: 'address[]' }],  \n                outputs: [{ name: 'balances', type: 'uint256[]' }]  \n            }],  \n            functionName: 'getChannelBalances',  \n            args: [channelId as `0x${string}`, [token as `0x${string}`]],  \n        }) as bigint[];  \n        console.log(`âœ“ Channel funded with ${channelBalances[0]} USDC`);  \n      \n        // Check User Balance again  \n        let finalUserBalance = 0n;  \n        try {  \n            const result = await publicClient.readContract({  \n                address: client.addresses.custody,  \n                abi: [{  \n                    type: 'function',  \n                    name: 'getAccountsBalances',  \n                    inputs: [{ name: 'users', type: 'address[]' }, { name: 'tokens', type: 'address[]' }],  \n                    outputs: [{ type: 'uint256[]' }],  \n                    stateMutability: 'view'  \n                }] as const,  \n                functionName: 'getAccountsBalances',  \n                args: [[client.account.address], [token as `0x${string}`]],  \n            }) as bigint[];  \n            finalUserBalance = result[0];  \n            console.log(`âœ“ User Custody Balance after resize: ${finalUserBalance}`);  \n        } catch (e) {  \n            console.warn('    Error checking final user balance:', e);  \n        }  \n      \n        // -------------------------------------------------------------------  \n        // 4. Off-Chain Transfer  \n        // -------------------------------------------------------------------  \n    };  \n      \n    // State to prevent infinite auth loops  \n    let isAuthenticated = false;  \n      \n    // Step 3: Sign the challenge with your MAIN wallet (EIP-712)  \n    ws.onmessage = async (event) => {  \n        const response = JSON.parse(event.data.toString());  \n        console.log('Received WS message:', JSON.stringify(response, null, 2));  \n      \n        if (response.error) {  \n            console.error('RPC Error:', response.error);  \n            process.exit(1); // Exit on error to prevent infinite loops  \n        }  \n      \n        if (response.res && response.res[1] === 'auth_challenge') {  \n            if (isAuthenticated) {  \n                console.log('  Ignoring auth_challenge (already authenticated)');  \n                return;  \n            }  \n      \n            const challenge = response.res[2].challenge_message;  \n      \n            // Create EIP-712 typed data signature with main wallet  \n            const signer = createEIP712AuthMessageSigner(  \n                walletClient,  \n                authParams,  \n                { name: 'Test app' }  \n            );  \n      \n            // Send auth_verify using builder  \n            // We sign with the MAIN wallet for the first verification  \n            const verifyMsg = await createAuthVerifyMessageFromChallenge(  \n                signer,  \n                challenge  \n            );  \n      \n            ws.send(verifyMsg);  \n        }  \n      \n        if (response.res && response.res[1] === 'auth_verify') {  \n            console.log('âœ“ Authenticated successfully');  \n            isAuthenticated = true; // Mark as authenticated  \n            const sessionKey = response.res[2].session_key;  \n            console.log('  Session key:', sessionKey);  \n            console.log('  JWT token received');  \n      \n            // Query Ledger Balances  \n            const ledgerMsg = await createGetLedgerBalancesMessage(  \n                sessionSigner,  \n                account.address,  \n                Date.now()  \n            );  \n            ws.send(ledgerMsg);  \n            console.log('  Sent get_ledger_balances request...');  \n      \n            // Wait for 'channels' message to proceed  \n      \n        }  \n      \n        if (response.res && response.res[1] === 'channels') {  \n            const channels = response.res[2].channels;  \n            const openChannel = channels.find((c: any) => c.status === 'open');  \n      \n            // Derive token  \n            const chainId = sepolia.id;  \n            const supportedAsset = (config.assets as any)?.find((a: any) => a.chain_id === chainId);  \n            const token = supportedAsset ? supportedAsset.token : '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238';  \n      \n            if (openChannel) {  \n                console.log('âœ“ Found existing open channel');  \n      \n                // CORRECT: Check if channel is already funded  \n                const currentAmount = BigInt(openChannel.amount || 0); // Need to parse amount  \n                // Wait, standard RPC returns strings. Let's rely on openChannel structure.  \n                // openChannel object from logs: { ..., amount: \"40\", ... }  \n      \n                if (BigInt(openChannel.amount) >= 20n) {  \n                    console.log(`  Channel already funded with ${openChannel.amount} USDC.`);  \n                    console.log('  Skipping resize to avoid \"Insufficient Balance\" errors.');  \n                    // Call triggerResize but indicate skipping actual resize  \n                    await triggerResize(openChannel.channel_id, token, true);  \n                } else {  \n                    await triggerResize(openChannel.channel_id, token, false);  \n                }  \n            } else {  \n                console.log('  No existing open channel found, creating new one...');  \n                console.log('  Using token:', token, 'for chain:', chainId);  \n      \n                // Request channel creation  \n                const createChannelMsg = await createCreateChannelMessage(  \n                    sessionSigner,  \n                    {  \n                        chain_id: 11155111, // Sepolia  \n                        token: token,  \n                    }  \n                );  \n                ws.send(createChannelMsg);  \n            }  \n        }  \n      \n        if (response.res && response.res[1] === 'create_channel') {  \n            const { channel_id, channel, state, server_signature } = response.res[2];  \n            activeChannelId = channel_id;  \n      \n            console.log('âœ“ Channel prepared:', channel_id);  \n            console.log('  State object:', JSON.stringify(state, null, 2));  \n      \n            // Transform state object to match UnsignedState interface  \n            const unsignedInitialState = {  \n                intent: state.intent,  \n                version: BigInt(state.version),  \n                data: state.state_data, // Map state_data to data  \n                allocations: state.allocations.map((a: any) => ({  \n                    destination: a.destination,  \n                    token: a.token,  \n                    amount: BigInt(a.amount),  \n                })),  \n            };  \n      \n            // Submit to blockchain  \n            const createResult = await client.createChannel({  \n                channel,  \n                unsignedInitialState,  \n                serverSignature: server_signature,  \n            });  \n      \n            // createChannel returns an object { txHash, ... } or just hash depending on version.  \n            // Based on logs: { channelId: ..., initialState: ..., txHash: ... }  \n            // We need to handle both or just the object.  \n            const txHash = typeof createResult === 'string' ? createResult : createResult.txHash;  \n      \n            console.log('âœ“ Channel created on-chain:', txHash);  \n            console.log('  Waiting for transaction confirmation...');  \n            await publicClient.waitForTransactionReceipt({ hash: txHash });  \n            console.log('âœ“ Transaction confirmed');  \n      \n            // Retrieve token from allocations  \n      \n            const token = state.allocations[0].token;  \n            await triggerResize(channel_id, token, false);  \n        }  \n      \n        if (response.res && response.res[1] === 'resize_channel') {  \n            const { channel_id, state, server_signature } = response.res[2];  \n      \n            console.log('âœ“ Resize prepared');  \n            console.log('  Server returned allocations:', JSON.stringify(state.allocations, null, 2));  \n      \n            // Construct the resize state object expected by the SDK  \n            const resizeState = {  \n                intent: state.intent,  \n                version: BigInt(state.version),  \n                data: state.state_data || state.data, // Handle potential naming differences  \n                allocations: state.allocations.map((a: any) => ({  \n                    destination: a.destination,  \n                    token: a.token,  \n                    amount: BigInt(a.amount),  \n                })),  \n                channelId: channel_id,  \n                serverSignature: server_signature,  \n            };  \n      \n            console.log('DEBUG: resizeState:', JSON.stringify(resizeState, (key, value) =>  \n                typeof value === 'bigint' ? value.toString() : value, 2));  \n      \n            let proofStates: any[] = [];  \n            try {  \n                const onChainData = await client.getChannelData(channel_id as `0x${string}`);  \n                console.log('DEBUG: On-chain channel data:', JSON.stringify(onChainData, (key, value) =>  \n                    typeof value === 'bigint' ? value.toString() : value, 2));  \n                if (onChainData.lastValidState) {  \n                    proofStates = [onChainData.lastValidState];  \n                }  \n            } catch (e) {  \n                console.log('DEBUG: Failed to fetch on-chain data:', e);  \n            }  \n      \n            // Calculate total required for the token  \n            const token = resizeState.allocations[0].token;  \n            const requiredAmount = resizeState.allocations.reduce((sum: bigint, a: any) => {  \n                if (a.token === token) return sum + BigInt(a.amount);  \n                return sum;  \n            }, 0n);  \n      \n            console.log(`  Waiting for channel funding (Required: ${requiredAmount})...`);  \n      \n            // Poll for User's Custody Balance (since User allocation is increasing)  \n            let userBalance = 0n;  \n            let retries = 0;  \n            const userAddress = client.account.address;  \n      \n            console.log(`  Checking User Custody Balance for ${userAddress}... [v2]`);  \n      \n            // Check initial balance first  \n            try {  \n                const result = await publicClient.readContract({  \n                    address: client.addresses.custody,  \n                    abi: [  \n                        {  \n                            type: 'function',  \n                            name: 'getAccountsBalances',  \n                            inputs: [  \n                                { name: 'users', type: 'address[]' },  \n                                { name: 'tokens', type: 'address[]' }  \n                            ],  \n                            outputs: [{ type: 'uint256[]' }],  \n                            stateMutability: 'view'  \n                        }  \n                    ] as const,  \n                    functionName: 'getAccountsBalances',  \n                    args: [[userAddress], [token as `0x${string}`]],  \n                }) as bigint[];  \n                userBalance = result[0];  \n            } catch (e) {  \n                console.warn('    Error checking initial user balance:', e);  \n            }  \n      \n            console.log('  Skipping L1 deposit (using off-chain faucet funds)...');  \n      \n            if (true) { // Skip the wait loop as we just deposited  \n                // Define ABI fragment for getAccountsBalances  \n                const custodyAbiFragment = [  \n                    {  \n                        type: 'function',  \n                        name: 'getAccountsBalances',  \n                        inputs: [  \n                            { name: 'users', type: 'address[]' },  \n                            { name: 'tokens', type: 'address[]' }  \n                        ],  \n                        outputs: [{ type: 'uint256[]' }],  \n                        stateMutability: 'view'  \n                    }  \n                ] as const;  \n      \n                while (retries < 30) { // Wait up to 60 seconds  \n                    try {  \n                        const result = await publicClient.readContract({  \n                            address: client.addresses.custody,  \n                            abi: custodyAbiFragment,  \n                            functionName: 'getAccountsBalances',  \n                            args: [[userAddress], [token as `0x${string}`]],  \n                        }) as bigint[];  \n      \n                        userBalance = result[0];  \n                    } catch (e) {  \n                        console.warn('    Error checking user balance:', e);  \n                    }  \n      \n                    if (userBalance >= requiredAmount) {  \n                        console.log(`âœ“ User funded in Custody (Balance: ${userBalance})`);  \n                        break;  \n                    }  \n                    await new Promise(r => setTimeout(r, 2000));  \n                    retries++;  \n                    if (retries % 5 === 0) console.log(`    User Custody Balance: ${userBalance}, Waiting...`);  \n                }  \n      \n                if (userBalance < requiredAmount) {  \n                    console.error('Timeout waiting for User to fund Custody account');  \n                    console.warn('Proceeding with resize despite low user balance...');  \n                }  \n            } else {  \n                console.log(`âœ“ User funded in Custody (Balance: ${userBalance})`);  \n            }  \n      \n            console.log('  Submitting resize to chain...');  \n            // Submit to blockchain  \n            const { txHash } = await client.resizeChannel({  \n                resizeState,  \n                proofStates: proofStates,  \n            });  \n      \n            console.log('âœ“ Channel resized on-chain:', txHash);  \n            console.log('âœ“ Channel funded with 20 USDC');  \n      \n            // Skip Transfer for debugging  \n            console.log('  Skipping transfer to verify withdrawal amount...');  \n            console.log('  Debug: channel_id =', channel_id);  \n      \n            // Wait for server to sync state  \n            await new Promise(r => setTimeout(r, 3000));  \n      \n            if (channel_id) {  \n                console.log('  Closing channel:', channel_id);  \n                const closeMsg = await createCloseChannelMessage(  \n                    sessionSigner,  \n                    channel_id as `0x${string}`,  \n                    account.address  \n                );  \n                ws.send(closeMsg);  \n            } else {  \n                console.log('  No channel ID available to close.');  \n            }  \n        }  \n        // const secondaryAddress = '0x7df1fef832b57e46de2e1541951289c04b2781aa';  \n        // console.log(`  Attempting Transfer to Secondary Wallet: ${secondaryAddress}...`);  \n      \n        // const transferMsg = await createTransferMessage(  \n        //     sessionSigner,  \n        //     {  \n        //         destination: secondaryAddress,  \n        //         allocations: [{  \n        //             asset: 'ytest.usd',  \n        //             amount: '10'  \n        //         }]  \n        //     },  \n        //     Date.now()  \n        // );  \n        // ws.send(transferMsg);  \n        // console.log('  Sent transfer request...');  \n      \n        // if (response.res && response.res[1] === 'transfer') {  \n        //     console.log('âœ“ Transfer complete!');  \n        //     console.log('  Amount: 10 USDC');  \n      \n        //     if (activeChannelId) {  \n        //         console.log('  Closing channel:', activeChannelId);  \n        //         const closeMsg = await createCloseChannelMessage(  \n        //             sessionSigner,  \n        //             activeChannelId as `0x${string}`,  \n        //             account.address  \n        //         );  \n        //         ws.send(closeMsg);  \n        //     } else {  \n        //         console.log('  No active channel ID to close.');  \n        //     }  \n        // }  \n      \n        if (response.res && response.res[1] === 'close_channel') {  \n            const { channel_id, state, server_signature } = response.res[2];  \n            console.log('âœ“ Close prepared');  \n            console.log('  Submitting close to chain...');  \n      \n            // Submit to blockchain  \n            const txHash = await client.closeChannel({  \n                finalState: {  \n                    intent: state.intent,  \n                    version: BigInt(state.version),  \n                    data: state.state_data || state.data,  \n                    allocations: state.allocations.map((a: any) => ({  \n                        destination: a.destination,  \n                        token: a.token,  \n                        amount: BigInt(a.amount),  \n                    })),  \n                    channelId: channel_id,  \n                    serverSignature: server_signature,  \n                },  \n                stateData: state.state_data || state.data || '0x',  \n            });  \n      \n            console.log('âœ“ Channel closed on-chain:', txHash);  \n      \n            // Withdraw funds  \n            console.log('  Withdrawing funds...');  \n            const token = state.allocations[0].token;  \n      \n            await new Promise(r => setTimeout(r, 2000)); // Wait for close to settle  \n      \n            let withdrawableBalance = 0n;  \n            try {  \n                const result = await publicClient.readContract({  \n                    address: client.addresses.custody,  \n                    abi: [{  \n                        type: 'function',  \n                        name: 'getAccountsBalances',  \n                        inputs: [{ name: 'users', type: 'address[]' }, { name: 'tokens', type: 'address[]' }],  \n                        outputs: [{ type: 'uint256[]' }],  \n                        stateMutability: 'view'  \n                    }] as const,  \n                    functionName: 'getAccountsBalances',  \n                    args: [[client.account.address], [token as `0x${string}`]],  \n                }) as bigint[];  \n                withdrawableBalance = result[0];  \n                console.log(`âœ“ User Custody Balance (Withdrawable): ${withdrawableBalance}`);  \n            } catch (e) {  \n                console.warn('    Error checking withdrawable balance:', e);  \n            }  \n      \n            if (withdrawableBalance > 0n) {  \n                console.log(`  Withdrawing ${withdrawableBalance} of ${token}...`);  \n                const withdrawalTx = await client.withdrawal(token as `0x${string}`, withdrawableBalance);  \n                console.log('âœ“ Funds withdrawn:', withdrawalTx);  \n            } else {  \n                console.log('  No funds to withdraw.');  \n            }  \n      \n            process.exit(0);  \n        }  \n    };  \n      \n    // Start the flow  \n    if (ws.readyState === WebSocket.OPEN) {  \n        ws.send(authRequestMsg);  \n    } else {  \n        ws.on('open', () => {  \n            ws.send(authRequestMsg);  \n        });  \n    }  \n    \n\n### close_all.tsâ€‹\n\nClick to view full close_all.ts\n    \n    \n    import {  \n        NitroliteClient,  \n        WalletStateSigner,  \n        createECDSAMessageSigner,  \n        createEIP712AuthMessageSigner,  \n        createAuthRequestMessage,  \n        createAuthVerifyMessageFromChallenge,  \n        createCloseChannelMessage,  \n    } from '@erc7824/nitrolite';  \n    import { createPublicClient, createWalletClient, http } from 'viem';  \n    import { sepolia } from 'viem/chains';  \n    import { privateKeyToAccount, generatePrivateKey } from 'viem/accounts';  \n    import WebSocket from 'ws';  \n    import 'dotenv/config';  \n    import * as readline from 'readline';  \n      \n    // Helper to prompt for input  \n    const askQuestion = (query: string): Promise<string> => {  \n        const rl = readline.createInterface({  \n            input: process.stdin,  \n            output: process.stdout,  \n        });  \n        return new Promise(resolve => rl.question(query, ans => {  \n            rl.close();  \n            resolve(ans);  \n        }));  \n    };  \n      \n    // Configuration  \n    const WS_URL = 'wss://clearnet-sandbox.yellow.com/ws';  \n      \n    async function main() {  \n        console.log('Starting cleanup script...');  \n      \n        // Setup Viem Clients  \n        let PRIVATE_KEY = process.env.PRIVATE_KEY as `0x${string}`;  \n      \n        if (!PRIVATE_KEY) {  \n            console.log('PRIVATE_KEY not found in .env');  \n            const inputKey = await askQuestion('Please enter your Private Key: ');  \n            if (!inputKey) {  \n                throw new Error('Private Key is required');  \n            }  \n            PRIVATE_KEY = inputKey.startsWith('0x') ? inputKey as `0x${string}` : `0x${inputKey}` as `0x${string}`;  \n        }  \n      \n        const account = privateKeyToAccount(PRIVATE_KEY);  \n      \n        const ALCHEMY_RPC_URL = process.env.ALCHEMY_RPC_URL;  \n        const FALLBACK_RPC_URL = 'https://1rpc.io/sepolia'; // Public fallback  \n        const RPC_URL = ALCHEMY_RPC_URL || FALLBACK_RPC_URL;  \n        const publicClient = createPublicClient({  \n            chain: sepolia,  \n            transport: http(RPC_URL),  \n        });  \n        const walletClient = createWalletClient({  \n            account,  \n            chain: sepolia,  \n            transport: http(RPC_URL),  \n        });  \n      \n        // Initialize Nitrolite Client  \n        const client = new NitroliteClient({  \n            publicClient,  \n            walletClient,  \n            addresses: {  \n                custody: '0x019B65A265EB3363822f2752141b3dF16131b262',  \n                adjudicator: '0x7c7ccbc98469190849BCC6c926307794fDfB11F2',  \n            },  \n            challengeDuration: 3600n,  \n            chainId: sepolia.id,  \n            stateSigner: new WalletStateSigner(walletClient),  \n        });  \n      \n        // Connect to WebSocket  \n        const ws = new WebSocket(WS_URL);  \n        const sessionPrivateKey = generatePrivateKey();  \n        const sessionSigner = createECDSAMessageSigner(sessionPrivateKey);  \n        const sessionAccount = privateKeyToAccount(sessionPrivateKey);  \n      \n        await new Promise<void>((resolve, reject) => {  \n            ws.on('open', () => resolve());  \n            ws.on('error', (err) => reject(err));  \n        });  \n        console.log('âœ“ Connected to WebSocket');  \n      \n        // Authenticate  \n        const authParams = {  \n            session_key: sessionAccount.address,  \n            allowances: [{ asset: 'ytest.usd', amount: '1000000000' }],  \n            expires_at: BigInt(Math.floor(Date.now() / 1000) + 3600),  \n            scope: 'test.app',  \n        };  \n      \n        const authRequestMsg = await createAuthRequestMessage({  \n            address: account.address,  \n            application: 'Test app',  \n            ...authParams  \n        });  \n        ws.send(authRequestMsg);  \n      \n        ws.on('message', async (data) => {  \n            const response = JSON.parse(data.toString());  \n      \n            if (response.res) {  \n                const type = response.res[1];  \n      \n                if (type === 'auth_challenge') {  \n                    const challenge = response.res[2].challenge_message;  \n                    const signer = createEIP712AuthMessageSigner(walletClient, authParams, { name: 'Test app' });  \n                    const verifyMsg = await createAuthVerifyMessageFromChallenge(signer, challenge);  \n                    ws.send(verifyMsg);  \n                }  \n      \n                if (type === 'auth_verify') {  \n                    console.log('âœ“ Authenticated');  \n      \n                    // Fetch open channels from L1 Contract  \n                    console.log('Fetching open channels from L1...');  \n                    try {  \n                        const openChannelsL1 = await client.getOpenChannels();  \n                        console.log(`Found ${openChannelsL1.length} open channels on L1.`);  \n      \n                        if (openChannelsL1.length === 0) {  \n                            console.log('No open channels on L1 to close.');  \n                            process.exit(0);  \n                        }  \n      \n                        // Iterate and close  \n                        for (const channelId of openChannelsL1) {  \n                            console.log(`Attempting to close channel ${channelId}...`);  \n      \n                            // Send close request to Node  \n                            const closeMsg = await createCloseChannelMessage(  \n                                sessionSigner,  \n                                channelId,  \n                                account.address  \n                            );  \n                            ws.send(closeMsg);  \n      \n                            // Small delay to avoid rate limits  \n                            await new Promise(r => setTimeout(r, 500));  \n                        }  \n      \n                    } catch (e) {  \n                        console.error('Error fetching L1 channels:', e);  \n                        process.exit(1);  \n                    }  \n                }  \n      \n                if (type === 'close_channel') {  \n                    const { channel_id, state, server_signature } = response.res[2];  \n                    console.log(`âœ“ Node signed close for ${channel_id}`);  \n      \n                    const finalState = {  \n                        intent: state.intent,  \n                        version: BigInt(state.version),  \n                        data: state.state_data,  \n                        allocations: state.allocations.map((a: any) => ({  \n                            destination: a.destination,  \n                            token: a.token,  \n                            amount: BigInt(a.amount),  \n                        })),  \n                        channelId: channel_id,  \n                        serverSignature: server_signature,  \n                    };  \n      \n                    try {  \n                        console.log(`  Submitting close to L1 for ${channel_id}...`);  \n                        const txHash = await client.closeChannel({  \n                            finalState,  \n                            stateData: finalState.data  \n                        });  \n                        console.log(`âœ“ Closed on-chain: ${txHash}`);  \n                    } catch (e) {  \n                        // If it fails (e.g. already closed or race condition), just log and continue  \n                        console.error(`Failed to close ${channel_id} on-chain:`, e);  \n                    }  \n                }  \n      \n                if (response.error) {  \n                    console.error('WS Error:', response.error);  \n                }  \n            }  \n        });  \n    }  \n      \n    main();  \n    \n\n\n\n[PreviousArchitecture at a Glance](/docs/learn/introduction/architecture-at-a-glance)[NextPrerequisites & Environment](/docs/learn/getting-started/prerequisites)\n\n  * Prerequisites\n  * Setup\n  * 1\\. Getting Funds\n  * 2\\. Initialization\n  * 3\\. Authentication\n  * 4\\. Channel Lifecycle\n    * Creating a Channel\n    * Funding (Resizing)\n    * Closing & Withdrawing\n  * Troubleshooting\n    * Cleanup Script\n  * Complete Code\n    * index.ts\n    * close_all.ts\n\nSummary: This component provides a comprehensive boilerplate for initializing the Nitrolite SDK, enabling developers to authenticate wallets, establish payment channels, and manage ledger balances within the Yellow Network. It serves as the foundational entry point for integrating off-chain state channel functionality into decentralized applications.\n\nRelated terms: Quickstart, Nitrolite, Payment channel, State channel, Wallet authentication, EIP-712, ECDSA signing, Ledger balance, Off-chain payments, SDK initialization, Nitro lite, Channel management, Crypto checkout, Session management\n\nUse cases: Initializing a payment service provider node, Opening and managing state channels for high-frequency trading, Implementing secure wallet-to-network authentication, Automating off-chain asset transfers",
    "metadata": {
      "title": "Quickstart | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/getting-started/quickstart",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component provides a comprehensive boilerplate for initializing the Nitrolite SDK, enabling developers to authenticate wallets, establish payment channels, and manage ledger balances within the Yellow Network. It serves as the foundational entry point for integrating off-chain state channel functionality into decentralized applications.",
      "keywords": [
        "Quickstart",
        "Nitrolite",
        "Payment channel",
        "State channel",
        "Wallet authentication",
        "EIP-712",
        "ECDSA signing",
        "Ledger balance",
        "Off-chain payments",
        "SDK initialization",
        "Nitro lite",
        "Channel management",
        "Crypto checkout",
        "Session management"
      ],
      "function_name": "NitroliteClient",
      "intent": "tutorial",
      "use_cases": [
        "Initializing a payment service provider node",
        "Opening and managing state channels for high-frequency trading",
        "Implementing secure wallet-to-network authentication",
        "Automating off-chain asset transfers"
      ],
      "function_names": [
        "WalletClient",
        "EIP712AuthMessageSigner",
        "create_channel",
        "close_all",
        "resize_amount"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "* Introduction\n  * Architecture at a Glance\n\n\n\n# Architecture at a Glance\n\nIn this guide, you will learn how Yellow Network's three protocol layers work together to enable fast, secure, off-chain transactions.\n\n* * *\n\nSummary: Provides a high-level overview of Yellow Network's three-layered protocol architecture designed for high-speed, secure, off-chain transaction processing.\n\nRelated terms: Yellow Network, Architecture, Off-chain transactions, Protocol layers, Scalability, Layered architecture, Fast payments, Secure transactions, State channels, Payment protocol, Network topology, System design, Crypto infrastructure, Multi-layer protocol\n\nUse cases: Understanding system design for high-throughput trading, Evaluating security models for off-chain settlement, Designing integrations with multi-layered payment protocols",
    "metadata": {
      "title": "Architecture at a Glance | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/architecture-at-a-glance",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a high-level overview of Yellow Network's three-layered protocol architecture designed for high-speed, secure, off-chain transaction processing.",
      "keywords": [
        "Yellow Network",
        "Architecture",
        "Off-chain transactions",
        "Protocol layers",
        "Scalability",
        "Layered architecture",
        "Fast payments",
        "Secure transactions",
        "State channels",
        "Payment protocol",
        "Network topology",
        "System design",
        "Crypto infrastructure",
        "Multi-layer protocol"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Understanding system design for high-throughput trading",
        "Evaluating security models for off-chain settlement",
        "Designing integrations with multi-layered payment protocols"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## The Three Layersâ€‹\n\n\nYellow Network consists of three interconnected layers, each with a specific responsibility:\n\nBlockchain Layer\n\nOn-Chain Layer\n\nOff-Chain Layer\n\nApplication Layer\n\nNitro RPC Protocol\n\nOn-chain operations\n\nMonitors events\n\nYour Application  \nGames, Payments, DeFi\n\nClient SDK\n\nClearnode\n\nCustody & Adjudicator Contracts\n\nEthereum, Polygon, Base, etc.\n\nLayer| Purpose| Speed| Cost  \n---|---|---|---  \n**Application**|  Your business logic and user interface| â€”| â€”  \n**Off-Chain**|  Instant state updates via Nitro RPC| < 1 second| Zero gas  \n**On-Chain**|  Fund custody, disputes, final settlement| Block time| Gas fees  \n  \n* * *\n\nSummary: This component outlines the three-tier architecture of the Yellow Network, detailing the interaction between the Application Layer, the Off-Chain Nitro RPC protocol for instant state updates, and the On-Chain settlement layer for custody and dispute resolution.\n\nRelated terms: Yellow Network architecture, Nitro RPC, off-chain scaling, on-chain settlement, state channels, Clearnode, layer 2, gasless transactions, instant payments, blockchain layers, adjudicator contracts, custody, multi-layer protocol, Yellow SDK\n\nUse cases: Designing high-frequency trading systems, Building gasless gaming applications, Implementing secure cross-chain settlements",
    "metadata": {
      "title": "Architecture at a Glance | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/architecture-at-a-glance",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component outlines the three-tier architecture of the Yellow Network, detailing the interaction between the Application Layer, the Off-Chain Nitro RPC protocol for instant state updates, and the On-Chain settlement layer for custody and dispute resolution.",
      "keywords": [
        "Yellow Network architecture",
        "Nitro RPC",
        "off-chain scaling",
        "on-chain settlement",
        "state channels",
        "Clearnode",
        "layer 2",
        "gasless transactions",
        "instant payments",
        "blockchain layers",
        "adjudicator contracts",
        "custody",
        "multi-layer protocol",
        "Yellow SDK"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Designing high-frequency trading systems",
        "Building gasless gaming applications",
        "Implementing secure cross-chain settlements"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## On-Chain Layer: Security Foundationâ€‹\n\n\nThe on-chain layer provides cryptographic guarantees through smart contracts:\n\n### Custody Contractâ€‹\n\nThe **Custody Contract** is the core of Nitrolite's on-chain implementation. It handles:\n\n  * **Channel Creation** : Lock funds and establish participant relationships\n  * **Dispute Resolution** : Process challenges and validate states\n  * **Final Settlement** : Distribute funds according to signed final state\n  * **Fund Management** : Deposit and withdrawal operations\n\n### Adjudicator Contractsâ€‹\n\n**Adjudicators** validate state transitions according to application-specific rules:\n\n  * **SimpleConsensus** : Both participants must sign (default for payment channels)\n  * **Custom Adjudicators** : Application-specific validation logic\n\nOn-Chain Operations\n\nYou only touch the blockchain for:\n\n  1. Opening a channel (lock funds)\n  2. Resizing a channel (add or remove funds)\n  3. Closing a channel (unlock and distribute funds)\n  4. Disputing a state (if counterparty is uncooperative)\n\n* * *\n\nSummary: The On-Chain Layer provides the security foundation for the protocol, using smart contracts to manage fund custody, channel lifecycles, and cryptographic dispute resolution. It ensures that state transitions are validated and final settlements are executed securely on the blockchain.\n\nRelated terms: smart contract, custody, channel creation, dispute resolution, settlement, fund management, adjudicator, state transition, Nitrolite, on-chain, lock funds, payment channel, consensus, state channel, adjudicater\n\nUse cases: Establishing a secure payment channel, Resolving counterparty disputes, Finalizing and withdrawing funds, Implementing custom validation logic",
    "metadata": {
      "title": "Architecture at a Glance | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/architecture-at-a-glance",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The On-Chain Layer provides the security foundation for the protocol, using smart contracts to manage fund custody, channel lifecycles, and cryptographic dispute resolution. It ensures that state transitions are validated and final settlements are executed securely on the blockchain.",
      "keywords": [
        "smart contract",
        "custody",
        "channel creation",
        "dispute resolution",
        "settlement",
        "fund management",
        "adjudicator",
        "state transition",
        "Nitrolite",
        "on-chain",
        "lock funds",
        "payment channel",
        "consensus",
        "state channel",
        "adjudicater"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Establishing a secure payment channel",
        "Resolving counterparty disputes",
        "Finalizing and withdrawing funds",
        "Implementing custom validation logic"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Off-Chain Layer: Speed and Efficiencyâ€‹\n\n\nThe off-chain layer handles high-frequency operations without blockchain transactions.\n\n### Clearnodeâ€‹\n\nA **Clearnode** is the off-chain service that:\n\n  * Manages the Nitro RPC protocol for state channel operations\n  * Provides a unified balance across multiple chains\n  * Coordinates payment channels between users\n  * Hosts app sessions for multi-party applications\n\n### Nitro RPC Protocolâ€‹\n\n**Nitro RPC** is a lightweight protocol optimized for state channel communication:\n\n  * **Compact format** : JSON array structure reduces message size by ~30%\n  * **Signed messages** : Every request and response is cryptographically signed\n  * **Real-time updates** : Bidirectional communication via WebSocket\n    \n    \n    // Compact Nitro RPC format  \n    [requestId, method, params, timestamp]  \n      \n    // Example: Transfer 50 USDC  \n    [42, \"transfer\", {\"destination\": \"0x...\", \"amount\": \"50.0\", \"asset\": \"usdc\"}, 1699123456789]  \n    \n\n* * *\n\nSummary: The off-chain layer leverages Clearnodes and the Nitro RPC protocol to enable high-speed state channel operations, real-time multi-party sessions, and unified cross-chain balance management without on-chain latency.\n\nRelated terms: state channel, Nitro RPC, Clearnode, off-chain, WebSocket, real-time payments, unified balance, multi-party session, signed messages, layer 2, NitroRPC, instant settlement, peer-to-peer\n\nUse cases: high-frequency micro-payments, real-time multi-party applications, cross-chain balance management, low-latency state updates",
    "metadata": {
      "title": "Architecture at a Glance | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/architecture-at-a-glance",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The off-chain layer leverages Clearnodes and the Nitro RPC protocol to enable high-speed state channel operations, real-time multi-party sessions, and unified cross-chain balance management without on-chain latency.",
      "keywords": [
        "state channel",
        "Nitro RPC",
        "Clearnode",
        "off-chain",
        "WebSocket",
        "real-time payments",
        "unified balance",
        "multi-party session",
        "signed messages",
        "layer 2",
        "NitroRPC",
        "instant settlement",
        "peer-to-peer"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency micro-payments",
        "real-time multi-party applications",
        "cross-chain balance management",
        "low-latency state updates"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## How Funds Flowâ€‹\n\n\nThis diagram shows how your tokens move through the system:\n\n1\\. deposit\n\n2\\. resize\n\n3\\. resize\n\n4\\. open session\n\n5\\. close session\n\n6\\. resize/close\n\n7\\. withdraw\n\nUser Wallet  \n(ERC-20)\n\nAvailable Balance  \n(Custody Contract)\n\nChannel-Locked  \n(Custody Contract)\n\nUnified Balance  \n(Clearnode)\n\nApp Sessions  \n(Applications)\n\n### Fund Statesâ€‹\n\nState| Location| What It Means  \n---|---|---  \n**User Wallet**|  Your EOA| Full control, on-chain  \n**Available Balance**|  Custody Contract| Deposited, ready for channels  \n**Channel-Locked**|  Custody Contract| Committed to a specific channel  \n**Unified Balance**|  Clearnode| Available for off-chain operations  \n**App Session**|  Application| Locked in a specific app session  \n  \n* * *\n\nSummary: This section outlines the lifecycle and state transitions of assets within the Yellow Network, detailing how funds move between on-chain wallets, custody contracts, and off-chain application sessions.\n\nRelated terms: deposit, withdraw, fund flow, custody contract, channel-locked, unified balance, clearnode, app session, ERC-20, EOA, liquidity management, off-chain state, token movement, state transitions\n\nUse cases: Managing asset liquidity across protocol layers, Designing off-chain application payment flows, Understanding fund security and custody states",
    "metadata": {
      "title": "Architecture at a Glance | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/architecture-at-a-glance",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the lifecycle and state transitions of assets within the Yellow Network, detailing how funds move between on-chain wallets, custody contracts, and off-chain application sessions.",
      "keywords": [
        "deposit",
        "withdraw",
        "fund flow",
        "custody contract",
        "channel-locked",
        "unified balance",
        "clearnode",
        "app session",
        "ERC-20",
        "EOA",
        "liquidity management",
        "off-chain state",
        "token movement",
        "state transitions"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Managing asset liquidity across protocol layers",
        "Designing off-chain application payment flows",
        "Understanding fund security and custody states"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Channel Lifecycleâ€‹\n\n\nA payment channel progresses through distinct states:\n\ncreate() with both signatures\n\nresize() (add/remove funds)\n\nclose() (cooperative)\n\nchallenge() (if disagreement)\n\ncheckpoint() (newer state)\n\nTimeout expires\n\nVOID\n\nACTIVE\n\nFINAL\n\nDISPUTE\n\nThis is where  \n99% of activity happens\n\nLegacy Flow\n\nThe diagram above shows the recommended flow where both participants sign the initial state, creating the channel directly in ACTIVE status. A legacy flow also exists where only the creator signs initially (status becomes INITIAL), and other participants call `join()` separately. See [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle) for details.\n\n### Typical Flowâ€‹\n\n  1. **Create** : Both parties sign initial state â†’ channel becomes ACTIVE\n  2. **Operate** : Exchange signed states off-chain (unlimited, zero gas)\n  3. **Close** : Both sign final state â†’ funds distributed\n\n### Dispute Path (Rare)â€‹\n\nIf your counterparty becomes unresponsive:\n\n  1. **Challenge** : Submit your latest signed state on-chain\n  2. **Wait** : Challenge period (typically 24 hours) allows counterparty to respond\n  3. **Finalize** : If no newer state is submitted, your state becomes final\n\n* * *\n\nSummary: Defines the state machine and lifecycle transitions for payment channels, facilitating off-chain state updates with on-chain settlement and dispute resolution mechanisms.\n\nRelated terms: payment channel, state machine, off-chain scaling, dispute resolution, channel lifecycle, gasless transactions, settlement, challenge period, cooperative close, multi-party signature, layer 2, state update, join channel\n\nUse cases: high-frequency micro-payments, off-chain asset exchange, peer-to-peer payment streaming, on-chain dispute arbitration",
    "metadata": {
      "title": "Architecture at a Glance | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/architecture-at-a-glance",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the state machine and lifecycle transitions for payment channels, facilitating off-chain state updates with on-chain settlement and dispute resolution mechanisms.",
      "keywords": [
        "payment channel",
        "state machine",
        "off-chain scaling",
        "dispute resolution",
        "channel lifecycle",
        "gasless transactions",
        "settlement",
        "challenge period",
        "cooperative close",
        "multi-party signature",
        "layer 2",
        "state update",
        "join channel"
      ],
      "function_name": "join",
      "intent": "concept",
      "use_cases": [
        "high-frequency micro-payments",
        "off-chain asset exchange",
        "peer-to-peer payment streaming",
        "on-chain dispute arbitration"
      ],
      "function_names": [
        "join"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Communication Patternsâ€‹\n\n\n### Opening a Channelâ€‹\n\nBlockchainClearnodeClientBlockchainClearnodeClientcreate_channel requestchannel config + Clearnode signatureSign statecreate() with BOTH signaturesVerify, lock funds, emit eventEvent detectedChannel now ACTIVE\n\n### Off-Chain Transferâ€‹\n\nReceiverClearnodeSenderReceiverClearnodeSenderComplete in < 1 second, zero gastransfer(destination, amount)Validate, update ledgerConfirmed âœ“balance_update notification\n\n* * *\n\nSummary: This section describes the core communication patterns for establishing state channels and executing off-chain transfers between clients and Clearnodes. It illustrates the lifecycle of a channel from blockchain-backed initialization to near-instant, gasless ledger updates.\n\nRelated terms: channel opening, off-chain transfer, state channel, Clearnode, ledger update, gasless transaction, instant payment, balance update, create channel, digital signature, multi-party state, blockchain event, L2 scaling, payment channel\n\nUse cases: Establishing a secure payment channel, Executing high-speed gasless transfers, Real-time balance synchronization, Multi-party state management",
    "metadata": {
      "title": "Architecture at a Glance | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/architecture-at-a-glance",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section describes the core communication patterns for establishing state channels and executing off-chain transfers between clients and Clearnodes. It illustrates the lifecycle of a channel from blockchain-backed initialization to near-instant, gasless ledger updates.",
      "keywords": [
        "channel opening",
        "off-chain transfer",
        "state channel",
        "Clearnode",
        "ledger update",
        "gasless transaction",
        "instant payment",
        "balance update",
        "create channel",
        "digital signature",
        "multi-party state",
        "blockchain event",
        "L2 scaling",
        "payment channel"
      ],
      "function_name": "create_channel",
      "intent": "concept",
      "use_cases": [
        "Establishing a secure payment channel",
        "Executing high-speed gasless transfers",
        "Real-time balance synchronization",
        "Multi-party state management"
      ],
      "function_names": [
        "balance_update",
        "lientcreate_channel"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Key Takeawaysâ€‹\n\n\nConcept| What to Remember  \n---|---  \n**On-Chain**|  Only for opening, closing, disputesâ€”security layer  \n**Off-Chain**|  Where all the action happensâ€”speed layer  \n**Clearnode**|  Your gateway to the networkâ€”coordination layer  \n**State Channels**|  Lock once, transact unlimited times, settle once  \n  \nSecurity Guarantee\n\nAt every stage, funds remain cryptographically secured. You can always recover your funds according to the latest valid signed state, even if a Clearnode becomes unresponsive.\n\n* * *\n\nSummary: Provides a high-level overview of the Yellow Network's hybrid architecture, detailing the interaction between on-chain security, off-chain performance, and Clearnode coordination. It outlines the fundamental security guarantees of state channels, ensuring fund recoverability through signed states.\n\nRelated terms: architecture, state channels, off-chain, on-chain, Clearnode, security layer, scalability, settlement, cryptographic security, fund recovery, Layer 2, Clear node, state updates, dispute resolution, hybrid protocol\n\nUse cases: Understanding protocol security model, Designing high-frequency trading systems, Implementing non-custodial payment gateways, Evaluating network reliability and fund recovery",
    "metadata": {
      "title": "Architecture at a Glance | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/architecture-at-a-glance",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a high-level overview of the Yellow Network's hybrid architecture, detailing the interaction between on-chain security, off-chain performance, and Clearnode coordination. It outlines the fundamental security guarantees of state channels, ensuring fund recoverability through signed states.",
      "keywords": [
        "architecture",
        "state channels",
        "off-chain",
        "on-chain",
        "Clearnode",
        "security layer",
        "scalability",
        "settlement",
        "cryptographic security",
        "fund recovery",
        "Layer 2",
        "Clear node",
        "state updates",
        "dispute resolution",
        "hybrid protocol"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Understanding protocol security model",
        "Designing high-frequency trading systems",
        "Implementing non-custodial payment gateways",
        "Evaluating network reliability and fund recovery"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nReady to start building? Continue to:\n\n  * **[Quickstart](/docs/learn/getting-started/quickstart)** â€” Create your first channel in minutes\n  * **[Prerequisites](/docs/learn/getting-started/prerequisites)** â€” Set up your development environment\n  * **[Core Concepts](/docs/learn/core-concepts/state-channels-vs-l1-l2)** â€” Deep dive into state channels\n\n\n\n[PreviousWhat Yellow Solves](/docs/learn/introduction/what-yellow-solves)[NextQuickstart](/docs/learn/getting-started/quickstart)\n\n  * The Three Layers\n  * On-Chain Layer: Security Foundation\n    * Custody Contract\n    * Adjudicator Contracts\n  * Off-Chain Layer: Speed and Efficiency\n    * Clearnode\n    * Nitro RPC Protocol\n  * How Funds Flow\n    * Fund States\n  * Channel Lifecycle\n    * Typical Flow\n    * Dispute Path (Rare)\n  * Communication Patterns\n    * Opening a Channel\n    * Off-Chain Transfer\n  * Key Takeaways\n  * Next Steps\n\nSummary: This section provides a high-level overview of the Yellow Network's multi-layered architecture, detailing the interaction between on-chain security contracts and off-chain state channels for efficient fund transfers.\n\nRelated terms: architecture, state channels, on-chain, off-chain, clearnode, nitro rpc, channel lifecycle, custody contract, adjudicator, fund flow, dispute resolution, layer 2, payment protocol, yellow network, scalability\n\nUse cases: Understanding the security model of the payment protocol, Designing a system that integrates with Clearnode and Nitro RPC, Mapping out the lifecycle of a state channel for a custom application, Evaluating the flow of funds between on-chain custody and off-chain transfers",
    "metadata": {
      "title": "Architecture at a Glance | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/architecture-at-a-glance",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section provides a high-level overview of the Yellow Network's multi-layered architecture, detailing the interaction between on-chain security contracts and off-chain state channels for efficient fund transfers.",
      "keywords": [
        "architecture",
        "state channels",
        "on-chain",
        "off-chain",
        "clearnode",
        "nitro rpc",
        "channel lifecycle",
        "custody contract",
        "adjudicator",
        "fund flow",
        "dispute resolution",
        "layer 2",
        "payment protocol",
        "yellow network",
        "scalability"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Understanding the security model of the payment protocol",
        "Designing a system that integrates with Clearnode and Nitro RPC",
        "Mapping out the lifecycle of a state channel for a custom application",
        "Evaluating the flow of funds between on-chain custody and off-chain transfers"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Introduction\n  * What Yellow Solves\n\n\n\n# What Yellow Solves\n\nIn this guide, you will learn why Yellow Network exists, what problems it addresses, and how it provides a faster, cheaper way to build Web3 applications.\n\n* * *\n\nSummary: This section introduces the core value proposition of Yellow Network, explaining how it addresses scalability and cost barriers to enable high-performance Web3 application development.\n\nRelated terms: Yellow Network, Web3 infrastructure, scalability, low latency, cost reduction, decentralized finance, DeFi, layer 3, clearing house, liquidity, interoperability, blockchain performance, Yellow protocol\n\nUse cases: high-frequency trading, cross-chain liquidity provision, optimizing dApp performance, reducing transaction costs",
    "metadata": {
      "title": "What Yellow Solves | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/what-yellow-solves",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section introduces the core value proposition of Yellow Network, explaining how it addresses scalability and cost barriers to enable high-performance Web3 application development.",
      "keywords": [
        "Yellow Network",
        "Web3 infrastructure",
        "scalability",
        "low latency",
        "cost reduction",
        "decentralized finance",
        "DeFi",
        "layer 3",
        "clearing house",
        "liquidity",
        "interoperability",
        "blockchain performance",
        "Yellow protocol"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency trading",
        "cross-chain liquidity provision",
        "optimizing dApp performance",
        "reducing transaction costs"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## The Blockchain Scalability Problemâ€‹\n\n\nEvery blockchain transaction requires global consensus. While this guarantees security and decentralization, it creates three fundamental limitations:\n\nChallenge| Impact on Users  \n---|---  \n**High Latency**|  Transactions take 15 seconds to several minutes for confirmation  \n**High Costs**|  Gas fees spike during network congestion, making microtransactions impractical  \n**Limited Throughput**|  Networks like Ethereum process ~15-30 transactions per second  \n  \nFor applications requiring real-time interactionsâ€”gaming, trading, micropaymentsâ€”these constraints make traditional blockchain unusable as a backend.\n\n* * *\n\nSummary: This section outlines the fundamental blockchain scalability challengesâ€”latency, high costs, and limited throughputâ€”that the Yellow Network protocol addresses to enable real-time decentralized applications.\n\nRelated terms: scalability, latency, throughput, gas fees, microtransactions, real-time trading, blockchain limitations, network congestion, TPS, global consensus, scalabilty, fast payments, low cost\n\nUse cases: high-frequency trading, blockchain gaming, micropayments, real-time decentralized applications",
    "metadata": {
      "title": "What Yellow Solves | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/what-yellow-solves",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the fundamental blockchain scalability challengesâ€”latency, high costs, and limited throughputâ€”that the Yellow Network protocol addresses to enable real-time decentralized applications.",
      "keywords": [
        "scalability",
        "latency",
        "throughput",
        "gas fees",
        "microtransactions",
        "real-time trading",
        "blockchain limitations",
        "network congestion",
        "TPS",
        "global consensus",
        "scalabilty",
        "fast payments",
        "low cost"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency trading",
        "blockchain gaming",
        "micropayments",
        "real-time decentralized applications"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## How Yellow Network Solves Thisâ€‹\n\n\nYellow Network uses **state channels** to move high-frequency operations off-chain while preserving blockchain-level security guarantees.\n\n### The Core Insightâ€‹\n\nMost interactions between parties don't need immediate on-chain settlement. Consider a chess game with a 10 USDC wager:\n\n  * **On-chain approach** : Every move requires a transaction â†’ 40+ transactions â†’ $100s in fees\n  * **State channel approach** : Lock funds once, play off-chain, settle once â†’ 2 transactions â†’ minimal fees\n\nState channels let you execute unlimited off-chain operations between on-chain checkpoints.\n\n### What You Getâ€‹\n\nFeature| Benefit  \n---|---  \n**Instant Transactions**|  Sub-second finality (< 1 second typical)  \n**Zero Gas Costs**|  Off-chain operations incur no blockchain fees  \n**Unlimited Throughput** *| No consensus bottleneck limiting operations  \n**Blockchain Security**|  Funds are always recoverable via on-chain contracts  \n  \n_*Theoretically unlimitedâ€”state channels have no blockchain consensus overhead. Real-world performance depends on signature generation speed, network latency between participants, and application complexity. We'll be publishing detailed benchmarks soon._\n\n* * *\n\nSummary: Yellow Network leverages state channel technology to facilitate high-frequency, off-chain operations with sub-second finality and zero gas fees while ensuring on-chain security guarantees.\n\nRelated terms: state channels, off-chain, scalability, gasless, instant settlement, layer 2, L2, payment channels, high-frequency trading, HFT, blockchain security, throughput, state updates, yellow network, yello network\n\nUse cases: high-frequency trading, micro-payments, gaming and betting, real-time asset exchange",
    "metadata": {
      "title": "What Yellow Solves | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/what-yellow-solves",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Yellow Network leverages state channel technology to facilitate high-frequency, off-chain operations with sub-second finality and zero gas fees while ensuring on-chain security guarantees.",
      "keywords": [
        "state channels",
        "off-chain",
        "scalability",
        "gasless",
        "instant settlement",
        "layer 2",
        "L2",
        "payment channels",
        "high-frequency trading",
        "HFT",
        "blockchain security",
        "throughput",
        "state updates",
        "yellow network",
        "yello network"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency trading",
        "micro-payments",
        "gaming and betting",
        "real-time asset exchange"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## The Nitrolite Protocolâ€‹\n\n\nYellow Network is built on **Nitrolite** , a state channel protocol designed for EVM-compatible chains. Nitrolite provides:\n\n  * **Fund Custody** : Smart contracts that securely lock and release assets\n  * **Dispute Resolution** : Challenge-response mechanism ensuring fair outcomes\n  * **Final Settlement** : Cryptographic guarantees that final allocations are honored\n\nWhen to Use Yellow Network\n\nChoose Yellow Network when your application needs:\n\n  * Real-time interactions between users\n  * Microtransactions or streaming payments\n  * High transaction volumes without gas costs\n  * Multi-party coordination with instant settlement\n\n* * *\n\nSummary: Nitrolite is a state channel protocol for EVM-compatible chains that enables high-frequency, gas-less transactions with secure fund custody and cryptographic settlement guarantees.\n\nRelated terms: Nitrolite, state channel, EVM, microtransactions, gasless, settlement, dispute resolution, fund custody, real-time payments, streaming payments, off-chain, layer 2, smart contracts, instant settlement, multi-party\n\nUse cases: Microtransactions and streaming payments, High-frequency trading or interactions, Multi-party coordination with instant settlement, Gas-efficient payment scaling",
    "metadata": {
      "title": "What Yellow Solves | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/what-yellow-solves",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Nitrolite is a state channel protocol for EVM-compatible chains that enables high-frequency, gas-less transactions with secure fund custody and cryptographic settlement guarantees.",
      "keywords": [
        "Nitrolite",
        "state channel",
        "EVM",
        "microtransactions",
        "gasless",
        "settlement",
        "dispute resolution",
        "fund custody",
        "real-time payments",
        "streaming payments",
        "off-chain",
        "layer 2",
        "smart contracts",
        "instant settlement",
        "multi-party"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Microtransactions and streaming payments",
        "High-frequency trading or interactions",
        "Multi-party coordination with instant settlement",
        "Gas-efficient payment scaling"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Chain Abstraction with Clearnodeâ€‹\n\n\nA **Clearnode** serves as your entry point to Yellow Network. When you connect to a Clearnode:\n\n  1. **Deposit** tokens into the Custody Contract on any supported chain\n  2. **Resize** your channel to move funds to your unified balance\n  3. **Transact** instantly with any other user on the network\n  4. **Withdraw** back through the Custody Contract to any supported chain\n\nFund Flow\n\nFunds flow through the Custody Contract (on-chain) before reaching your unified balance (off-chain). The `resize` operation moves funds between your on-chain available balance and your off-chain unified balance. See [Architecture](/docs/learn/introduction/architecture-at-a-glance#how-funds-flow) for the complete flow.\n\nFor example, deposit 50 USDC on Polygon and 50 USDC on Baseâ€”after resizing, your unified balance shows 100 USDC. You can then withdraw all 100 USDC to Arbitrum if you choose.\n\nDeposit on Polygon  \n50 USDC\n\nUnified Balance  \n100 USDC\n\nDeposit on Base  \n50 USDC\n\nWithdraw to Arbitrum  \n100 USDC\n\n* * *\n\nSummary: Clearnode enables chain abstraction by aggregating deposits from multiple blockchains into a single off-chain unified balance, allowing for instant transactions and flexible cross-chain withdrawals.\n\nRelated terms: Clearnode, chain abstraction, unified balance, custody contract, deposit, withdraw, resize, cross-chain, multi-chain, off-chain, liquidity, asset aggregation, bridge, fund flow, Yellow Network\n\nUse cases: cross-chain asset consolidation, instant off-chain trading, multi-chain liquidity management",
    "metadata": {
      "title": "What Yellow Solves | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/what-yellow-solves",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Clearnode enables chain abstraction by aggregating deposits from multiple blockchains into a single off-chain unified balance, allowing for instant transactions and flexible cross-chain withdrawals.",
      "keywords": [
        "Clearnode",
        "chain abstraction",
        "unified balance",
        "custody contract",
        "deposit",
        "withdraw",
        "resize",
        "cross-chain",
        "multi-chain",
        "off-chain",
        "liquidity",
        "asset aggregation",
        "bridge",
        "fund flow",
        "Yellow Network"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "cross-chain asset consolidation",
        "instant off-chain trading",
        "multi-chain liquidity management"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Real-World Applicationsâ€‹\n\n\n### Payment Applicationsâ€‹\n\n  * **Micropayments** : Pay-per-article, API usage billing, content monetization\n  * **Streaming payments** : Subscription services, hourly billing, real-time payroll\n  * **P2P transfers** : Instant remittances without intermediaries\n\n### Gaming Applicationsâ€‹\n\n  * **Turn-based games** : Chess, poker, strategy games with wagers\n  * **Real-time multiplayer** : In-game economies with instant transactions\n  * **Tournaments** : Prize pools and automated payouts\n\n### DeFi Applicationsâ€‹\n\n  * **High-frequency trading** : Execute trades without MEV concerns\n  * **Prediction markets** : Real-time betting with instant settlement\n  * **Escrow services** : Multi-party coordination with dispute resolution\n\n* * *\n\nSummary: Outlines the practical applications of the Yellow Network protocol, demonstrating its utility in high-frequency payments, gaming economies, and decentralized finance through low-latency, off-chain transaction capabilities.\n\nRelated terms: micropayments, streaming payments, P2P transfers, gaming economy, DeFi, high-frequency trading, HFT, escrow, instant settlement, MEV protection, pay-per-use, content monetization, real-time payroll, wagering, dispute resolution\n\nUse cases: micropayments and API billing, real-time gaming transactions, high-frequency trading without MEV, multi-party escrow and dispute resolution",
    "metadata": {
      "title": "What Yellow Solves | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/what-yellow-solves",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Outlines the practical applications of the Yellow Network protocol, demonstrating its utility in high-frequency payments, gaming economies, and decentralized finance through low-latency, off-chain transaction capabilities.",
      "keywords": [
        "micropayments",
        "streaming payments",
        "P2P transfers",
        "gaming economy",
        "DeFi",
        "high-frequency trading",
        "HFT",
        "escrow",
        "instant settlement",
        "MEV protection",
        "pay-per-use",
        "content monetization",
        "real-time payroll",
        "wagering",
        "dispute resolution"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "micropayments and API billing",
        "real-time gaming transactions",
        "high-frequency trading without MEV",
        "multi-party escrow and dispute resolution"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Security Modelâ€‹\n\n\nYellow Network maintains blockchain-level security despite operating off-chain:\n\nGuarantee| How It's Achieved  \n---|---  \n**Fund Safety**|  All funds locked in audited smart contracts  \n**Dispute Resolution**|  Challenge period allows contesting incorrect states  \n**Cryptographic Proof**|  Every state transition is signed by participants  \n**Recovery Guarantee**|  Users can always recover funds via on-chain contracts  \n  \nIf a Clearnode becomes unresponsive or malicious, you can submit your latest signed state to the blockchain and recover your funds after a challenge period.\n\n* * *\n\nSummary: Defines the protocol's security guarantees, explaining how off-chain state transitions are secured by audited smart contracts and cryptographic proofs to ensure fund safety and trustless recovery.\n\nRelated terms: security model, fund safety, dispute resolution, cryptographic proof, recovery guarantee, off-chain, smart contracts, state transitions, challenge period, Clearnode, signed state, trustless, fund recovery\n\nUse cases: Recovering funds from an unresponsive or malicious node, Verifying the integrity of off-chain transactions, Handling disputes in a peer-to-peer payment channel, Ensuring asset safety during high-frequency trading",
    "metadata": {
      "title": "What Yellow Solves | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/what-yellow-solves",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the protocol's security guarantees, explaining how off-chain state transitions are secured by audited smart contracts and cryptographic proofs to ensure fund safety and trustless recovery.",
      "keywords": [
        "security model",
        "fund safety",
        "dispute resolution",
        "cryptographic proof",
        "recovery guarantee",
        "off-chain",
        "smart contracts",
        "state transitions",
        "challenge period",
        "Clearnode",
        "signed state",
        "trustless",
        "fund recovery"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Recovering funds from an unresponsive or malicious node",
        "Verifying the integrity of off-chain transactions",
        "Handling disputes in a peer-to-peer payment channel",
        "Ensuring asset safety during high-frequency trading"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nNow that you understand what Yellow solves, continue to:\n\n  * **[Architecture at a Glance](/docs/learn/introduction/architecture-at-a-glance)** â€” See how the protocol layers work together\n  * **[Quickstart](/docs/learn/getting-started/quickstart)** â€” Create your first state channel in minutes\n\n\n\n[PreviousLearn](/docs/learn/)[NextArchitecture at a Glance](/docs/learn/introduction/architecture-at-a-glance)\n\n  * The Blockchain Scalability Problem\n  * How Yellow Network Solves This\n    * The Core Insight\n    * What You Get\n  * The Nitrolite Protocol\n  * Chain Abstraction with Clearnode\n  * Real-World Applications\n    * Payment Applications\n    * Gaming Applications\n    * DeFi Applications\n  * Security Model\n  * Next Steps\n\nSummary: Provides a high-level overview of the Yellow Network's solution to blockchain scalability, detailing its core protocol layers and cross-chain abstraction capabilities.\n\nRelated terms: blockchain scalability, state channels, Nitrolite, Clearnode, chain abstraction, layer 2, off-chain settlement, interoperability, payment protocol, DeFi, gaming, security model, Yellow Network\n\nUse cases: cross-chain asset exchange, real-time gaming microtransactions, high-throughput DeFi trading, multi-chain payment settlement",
    "metadata": {
      "title": "What Yellow Solves | Yellow Network",
      "url": "https://docs.yellow.org/docs/learn/introduction/what-yellow-solves",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a high-level overview of the Yellow Network's solution to blockchain scalability, detailing its core protocol layers and cross-chain abstraction capabilities.",
      "keywords": [
        "blockchain scalability",
        "state channels",
        "Nitrolite",
        "Clearnode",
        "chain abstraction",
        "layer 2",
        "off-chain settlement",
        "interoperability",
        "payment protocol",
        "DeFi",
        "gaming",
        "security model",
        "Yellow Network"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "cross-chain asset exchange",
        "real-time gaming microtransactions",
        "high-throughput DeFi trading",
        "multi-chain payment settlement"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "# Page Not Found\n\nWe could not find what you were looking for.\n\nPlease contact the owner of the site that linked you to the original URL and let them know their link is broken.\n\nSummary: This component serves as a standard 404 error page for the documentation site, informing users that the requested resource is unavailable or the link is broken.\n\nRelated terms: 404, page not found, broken link, missing resource, error page, navigation error, not found, yellow network, documentation error, invalid url, link failure, missing page\n\nUse cases: handling broken documentation links, notifying users of missing content, troubleshooting site navigation",
    "metadata": {
      "title": "Yellow Network",
      "url": "https://docs.yellow.org/docs/legacy/about/related-work",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component serves as a standard 404 error page for the documentation site, informing users that the requested resource is unavailable or the link is broken.",
      "keywords": [
        "404",
        "page not found",
        "broken link",
        "missing resource",
        "error page",
        "navigation error",
        "not found",
        "yellow network",
        "documentation error",
        "invalid url",
        "link failure",
        "missing page"
      ],
      "function_name": null,
      "intent": "error_handling",
      "use_cases": [
        "handling broken documentation links",
        "notifying users of missing content",
        "troubleshooting site navigation"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "# Page Not Found\n\nWe could not find what you were looking for.\n\nPlease contact the owner of the site that linked you to the original URL and let them know their link is broken.\n\nSummary: This page serves as a standard 404 error notification indicating that the requested documentation resource within the Yellow Network SDK guide is unavailable or the link is broken.\n\nRelated terms: 404, page not found, broken link, missing content, error, yellow network, documentation error, invalid path, not found, help, support, missing page\n\nUse cases: identifying broken documentation links, troubleshooting navigation errors",
    "metadata": {
      "title": "Yellow Network",
      "url": "https://docs.yellow.org/docs/legacy/about/the-solution",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This page serves as a standard 404 error notification indicating that the requested documentation resource within the Yellow Network SDK guide is unavailable or the link is broken.",
      "keywords": [
        "404",
        "page not found",
        "broken link",
        "missing content",
        "error",
        "yellow network",
        "documentation error",
        "invalid path",
        "not found",
        "help",
        "support",
        "missing page"
      ],
      "function_name": null,
      "intent": "error_handling",
      "use_cases": [
        "identifying broken documentation links",
        "troubleshooting navigation errors"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "# Page Not Found\n\nWe could not find what you were looking for.\n\nPlease contact the owner of the site that linked you to the original URL and let them know their link is broken.\n\nSummary: This component serves as a standard 404 error page for the documentation site, informing users that the requested resource is unavailable or the link is broken.\n\nRelated terms: 404, page not found, broken link, error, missing documentation, navigation error, not found, invalid URL, help, support, yellow network, documentation error\n\nUse cases: handling broken documentation links, notifying users of missing content, troubleshooting navigation issues",
    "metadata": {
      "title": "Yellow Network",
      "url": "https://docs.yellow.org/docs/legacy/architecture",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component serves as a standard 404 error page for the documentation site, informing users that the requested resource is unavailable or the link is broken.",
      "keywords": [
        "404",
        "page not found",
        "broken link",
        "error",
        "missing documentation",
        "navigation error",
        "not found",
        "invalid URL",
        "help",
        "support",
        "yellow network",
        "documentation error"
      ],
      "function_name": null,
      "intent": "error_handling",
      "use_cases": [
        "handling broken documentation links",
        "notifying users of missing content",
        "troubleshooting navigation issues"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "# Page Not Found\n\nWe could not find what you were looking for.\n\nPlease contact the owner of the site that linked you to the original URL and let them know their link is broken.\n\nSummary: This component serves as a standard 404 error page for the Yellow Network documentation, notifying users of missing resources or broken links.\n\nRelated terms: 404, page not found, error, broken link, missing documentation, navigation error, help, support, yellow network, sdk, missing resource, link failure, not found\n\nUse cases: handling broken documentation links, troubleshooting navigation errors",
    "metadata": {
      "title": "Yellow Network",
      "url": "https://docs.yellow.org/docs/legacy/business/market-evaluation",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component serves as a standard 404 error page for the Yellow Network documentation, notifying users of missing resources or broken links.",
      "keywords": [
        "404",
        "page not found",
        "error",
        "broken link",
        "missing documentation",
        "navigation error",
        "help",
        "support",
        "yellow network",
        "sdk",
        "missing resource",
        "link failure",
        "not found"
      ],
      "function_name": null,
      "intent": "error_handling",
      "use_cases": [
        "handling broken documentation links",
        "troubleshooting navigation errors"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Manuals\n\n# Manuals\n\nWork in Progress\n\nThis section is currently under development. Comprehensive manuals and documentation will be available soon.\n\nComing soon: Detailed manuals covering all aspects of the platform.\n\n\n\n[NextRequest Asset Support](/docs/manuals/request-asset-support)\n\nSummary: This section serves as a landing page and placeholder for the Yellow Network's comprehensive technical manuals and platform documentation, which are currently under development.\n\nRelated terms: manuals, documentation, guides, how-to, asset support, request asset, yellow network, platform instructions, developer docs, technical manuals, help center, documenation, manuels\n\nUse cases: Accessing platform documentation, Requesting support for new assets, Navigating technical guides",
    "metadata": {
      "title": "Manuals | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section serves as a landing page and placeholder for the Yellow Network's comprehensive technical manuals and platform documentation, which are currently under development.",
      "keywords": [
        "manuals",
        "documentation",
        "guides",
        "how-to",
        "asset support",
        "request asset",
        "yellow network",
        "platform instructions",
        "developer docs",
        "technical manuals",
        "help center",
        "documenation",
        "manuels"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "Accessing platform documentation",
        "Requesting support for new assets",
        "Navigating technical guides"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Request Asset Support\n\n\n\n# Requesting Asset Support\n\nThis guide is primarily for **project teams, token issuers, and integration partners** who need to add support for new assets or tokens in the Clearnode infrastructure. Following this process will enable Clearnode to recognize and process transfers of your asset across supported blockchain networks.\n\nSummary: This component outlines the process for token issuers and partners to integrate and enable support for new assets or tokens within the Clearnode infrastructure for cross-chain processing.\n\nRelated terms: asset listing, token integration, add token, new asset support, Clearnode, token issuer, asset onboarding, crypto asset, token registration, cross-chain support, asset management, yellow network, token deployment, asset support\n\nUse cases: listing a new ERC-20 token, enabling cross-chain asset transfers, onboarding a project token to Clearnode",
    "metadata": {
      "title": "Requesting Asset Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-asset-support",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component outlines the process for token issuers and partners to integrate and enable support for new assets or tokens within the Clearnode infrastructure for cross-chain processing.",
      "keywords": [
        "asset listing",
        "token integration",
        "add token",
        "new asset support",
        "Clearnode",
        "token issuer",
        "asset onboarding",
        "crypto asset",
        "token registration",
        "cross-chain support",
        "asset management",
        "yellow network",
        "token deployment",
        "asset support"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "listing a new ERC-20 token",
        "enabling cross-chain asset transfers",
        "onboarding a project token to Clearnode"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## What Happens When Support is Addedâ€‹\n\n\nOnce an asset is supported in Clearnode:\n\n  * Users can deposit and withdraw the asset through Clearnode's state channels\n  * The asset becomes available for instant, off-chain transfers via the Nitrolite protocol\n  * The asset can be used in cross-chain operations (deposit on one chain, withdraw on another) for blockchains it was configured on\n  * Applications built on Yellow Network can integrate the asset for payments and settlements\n  * The asset's unified balance is tracked across all supported blockchains\n\nERC20 Compatibility\n\nAdding support for ERC20 tokens is straightforward and requires only configuration changes. Non-standard token implementations may require additional development work and testing.\n\nLiquidity Requirements for Withdrawals\n\nFor a token to be immediately withdrawable on a specific blockchain, Clearnode must be provided with sufficient liquidity on that chain. Without liquidity, users can deposit tokens but cannot withdraw them until liquidity is available. Please contact our Business team to arrange liquidity provision before requesting asset support.\n\nSummary: Outlines the functional implications and requirements for adding new asset support to Clearnode, enabling off-chain transfers, cross-chain interoperability, and unified balance management via state channels.\n\nRelated terms: asset support, token integration, Clearnode, Nitrolite, off-chain transfer, cross-chain, ERC20, liquidity provision, deposit, withdrawal, state channels, unified balance, asset onboarding, token listing\n\nUse cases: Adding a new ERC20 token to the network, Enabling cross-chain asset transfers, Managing liquidity for withdrawals, Integrating custom tokens for off-chain payments",
    "metadata": {
      "title": "Requesting Asset Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-asset-support",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Outlines the functional implications and requirements for adding new asset support to Clearnode, enabling off-chain transfers, cross-chain interoperability, and unified balance management via state channels.",
      "keywords": [
        "asset support",
        "token integration",
        "Clearnode",
        "Nitrolite",
        "off-chain transfer",
        "cross-chain",
        "ERC20",
        "liquidity provision",
        "deposit",
        "withdrawal",
        "state channels",
        "unified balance",
        "asset onboarding",
        "token listing"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Adding a new ERC20 token to the network",
        "Enabling cross-chain asset transfers",
        "Managing liquidity for withdrawals",
        "Integrating custom tokens for off-chain payments"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Understanding Environmentsâ€‹\n\n\nClearnode operates in two distinct environments with separate asset configurations:\n\nEnvironment| Purpose| Typical Assets  \n---|---|---  \n**Sandbox**|  Development, testing, and experimentation| Testnet tokens (Sepolia USDC, Amoy ETH, test tokens, etc.)  \n**Production**|  Live operations with real assets| Mainnet tokens (USDC, USDT, DAI, etc.)  \n  \n**Configuration file location:** `clearnode/chart/config/<sandbox_or_prod>/assets.yaml`\n\n**Important Considerations:**\n\n  * **Production will not support test network tokens** \\- mainnet tokens only\n  * **Sandbox will not support mainnet tokens** \\- testnet tokens only\n  * You must decide which environment needs the asset support based on your use case\n  * If you need support in both environments (e.g., testnet token for development, mainnet token for production), you must submit configuration changes to both files\n\nSummary: This section defines the operational distinction between Sandbox and Production environments in Clearnode, detailing the strict separation of testnet and mainnet asset configurations.\n\nRelated terms: sandbox, production, environment configuration, assets.yaml, Clearnode, testnet tokens, mainnet tokens, Sepolia, Amoy, deployment, asset support, network setup, prod, sand box\n\nUse cases: Setting up a development environment with test tokens, Deploying a production node with real assets, Configuring asset support for specific network environments",
    "metadata": {
      "title": "Requesting Asset Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-asset-support",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section defines the operational distinction between Sandbox and Production environments in Clearnode, detailing the strict separation of testnet and mainnet asset configurations.",
      "keywords": [
        "sandbox",
        "production",
        "environment configuration",
        "assets.yaml",
        "Clearnode",
        "testnet tokens",
        "mainnet tokens",
        "Sepolia",
        "Amoy",
        "deployment",
        "asset support",
        "network setup",
        "prod",
        "sand box"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Setting up a development environment with test tokens",
        "Deploying a production node with real assets",
        "Configuring asset support for specific network environments"
      ],
      "function_names": [
        "sandbox_or_prod"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## How to Request Supportâ€‹\n\n\nAsset support is requested by creating or modifying a configuration file in the [nitrolite](https://github.com/erc7824/nitrolite) repository:\n\n  1. **Fork the repository** : `https://github.com/erc7824/nitrolite`\n  2. **Navigate to the appropriate configuration file** :\n     * For Sandbox: `clearnode/chart/config/sandbox/assets.yaml`\n     * For Production: `clearnode/chart/config/prod/assets.yaml`\n  3. **Add your asset configuration** at the end of the list (see next section for structure)\n  4. **Submit a Pull Request** with a clear description of the asset being added\n  5. **Wait for review** by the development team\n\nThe next section provides detailed guidance on the configuration structure and whether you need to add a new asset or just a token.\n\nSummary: This section outlines the administrative process for adding or modifying supported assets within the Yellow Network by submitting configuration changes to the nitrolite repository.\n\nRelated terms: asset support, add token, token listing, configuration, nitrolite, assets.yaml, pull request, sandbox, production, clearnode, crypto onboarding, asset integration, yaml configuration, token request\n\nUse cases: adding a new cryptocurrency to the network, enabling custom tokens for payments, configuring sandbox environment assets",
    "metadata": {
      "title": "Requesting Asset Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-asset-support",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the administrative process for adding or modifying supported assets within the Yellow Network by submitting configuration changes to the nitrolite repository.",
      "keywords": [
        "asset support",
        "add token",
        "token listing",
        "configuration",
        "nitrolite",
        "assets.yaml",
        "pull request",
        "sandbox",
        "production",
        "clearnode",
        "crypto onboarding",
        "asset integration",
        "yaml configuration",
        "token request"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "adding a new cryptocurrency to the network",
        "enabling custom tokens for payments",
        "configuring sandbox environment assets"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Asset Configuration Structureâ€‹\n\n\n### Understanding Assets vs Tokensâ€‹\n\nIn Clearnode's configuration model:\n\n  * An **asset** represents a logical currency or token type (e.g., \"USDC\", \"ETH\")\n  * A **token** is a specific implementation of that asset on a particular blockchain\n\n**Example:** USDC is an asset that has different token implementations:\n\n  * USDC on Polygon at address `0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359`\n  * USDC on Base at address `0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913`\n  * USDC on Ethereum at address `0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48`\n\n### Before You Start: Check if the Asset Existsâ€‹\n\nBefore adding a new asset, check if Clearnode already supports the asset on other blockchains. If the asset exists but your target blockchain is not listed, you only need to add a **token entry** to the existing asset. If the asset doesn't exist at all, you need to add both the **asset** and its **token(s)**.\n\n#### Scenario 1: Asset exists, add a token to a new blockchainâ€‹\n    \n    \n    assets:  \n      - name: \"USD Coin\"  \n        symbol: \"usdc\"  \n        tokens:  \n          - blockchain_id: 137  \n            address: \"0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359\"  \n            decimals: 6  \n          # Add your new token here  \n          - blockchain_id: 8453  # Base  \n            address: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\"  \n            decimals: 6  \n    \n\n#### Scenario 2: New asset, add both asset and token(s)â€‹\n    \n    \n    assets:  \n      - name: \"My New Token\"  \n        symbol: \"mnt\"  \n        tokens:  \n          - blockchain_id: 137  \n            address: \"0xYourTokenAddressOnPolygon\"  \n            decimals: 18  \n    \n\n### Configuration Fieldsâ€‹\n\n#### Asset Levelâ€‹\n\nEach asset entry requires the following fields:\n    \n    \n    assets:  \n      - name: \"USD Coin\"    # Human-readable name  \n        symbol: \"usdc\"      # Ticker symbol (lowercase)  \n        disabled: false     # If set to `true`, then it is not loaded into configuration  \n        tokens: [...]       # Array of token implementations  \n    \n\nField| Required| Description  \n---|---|---  \n`name`| No| Human-readable name of the asset (e.g., \"USD Coin\"). If omitted, defaults to the symbol.  \n`symbol`| **Yes**|  Ticker symbol for the asset (must be lowercase, e.g., \"usdc\", \"eth\")  \n`disabled`| No| Set to `true` to temporarily disable processing this asset (default: `false`)  \n`tokens`| **Yes**|  Array of blockchain-specific token implementations  \n  \n#### Token Levelâ€‹\n\nEach token within an asset requires the following fields:\n    \n    \n    tokens:  \n      - name: \"USD Coin on Polygon\"      # Token-specific name  \n        symbol: \"usdc\"                   # Token-specific symbol  \n        blockchain_id: 137               # Chain ID  \n        disabled: false                  # Skip processing (default: false)  \n        address: \"0x3c499c542cEF...\"     # Contract address  \n        decimals: 6                      # Token decimals  \n    \n\nField| Required| Description  \n---|---|---  \n`name`| No| Token name on this blockchain (inherits from asset if not specified)  \n`symbol`| No| Token symbol on this blockchain (inherits from asset if not specified)  \n`blockchain_id`| **Yes**|  Chain ID where this token is deployed (must match a supported blockchain)  \n`disabled`| No| Set to `true` to temporarily disable this token (default: `false`)  \n`address`| **Yes**|  Token's smart contract address (must be a valid address on the specified chain)  \n`decimals`| **Yes**|  Number of decimal places the token uses (e.g., 6 for USDC, 18 for ETH)  \n  \n### Prerequisites for Adding Assetsâ€‹\n\nBefore submitting your configuration:\n\n  1. **Blockchain Support** : Ensure the blockchain (by `blockchain_id`) is already supported in `blockchains.yaml`\n  2. **Token Deployment** : The token contract must be deployed and verified on the target blockchain\n  3. **ERC20 Compliance** : Token should follow the standard ERC20 interface for seamless integration\n  4. **Correct Decimals** : Verify the token's decimal places (commonly 6 or 18, but varies by token)\n  5. **Valid Address** : Double-check the contract address is correct and matches the intended blockchain\n\nBlockchain Must Be Supported First\n\nYou cannot add a token on a blockchain that is not yet supported in Clearnode. If your target blockchain is not in the `blockchains.yaml` configuration, you must first follow the [Request Blockchain Support](/docs/manuals/request-blockchain-support) guide before requesting asset support.\n\nSummary: Defines the hierarchical configuration structure for assets and tokens within Clearnode, distinguishing between logical currency types and their specific blockchain-based implementations for multi-chain support.\n\nRelated terms: asset configuration, token mapping, multi-chain, blockchain_id, smart contract address, USDC, Clearnode, ticker symbol, decimals, asset management, cross-chain, token implementation, crypto assets, yaml configuration\n\nUse cases: Adding support for a new stablecoin across multiple networks, Mapping an existing asset to a new Layer 2 blockchain, Configuring custom tokens for private network deployments",
    "metadata": {
      "title": "Requesting Asset Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-asset-support",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the hierarchical configuration structure for assets and tokens within Clearnode, distinguishing between logical currency types and their specific blockchain-based implementations for multi-chain support.",
      "keywords": [
        "asset configuration",
        "token mapping",
        "multi-chain",
        "blockchain_id",
        "smart contract address",
        "USDC",
        "Clearnode",
        "ticker symbol",
        "decimals",
        "asset management",
        "cross-chain",
        "token implementation",
        "crypto assets",
        "yaml configuration"
      ],
      "function_name": "blockchain_id",
      "intent": "configuration",
      "use_cases": [
        "Adding support for a new stablecoin across multiple networks",
        "Mapping an existing asset to a new Layer 2 blockchain",
        "Configuring custom tokens for private network deployments"
      ],
      "function_names": [
        "blockchain_id"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Need Help?â€‹\n\n\nIf you have questions about asset support requests, encounter issues during configuration, or need clarification on any part of this process, please don't hesitate to contact the development team.\n\n\n\n[PreviousManuals](/docs/manuals/)[NextRequest Blockchain Support](/docs/manuals/request-blockchain-support)\n\n  * What Happens When Support is Added\n  * Understanding Environments\n  * How to Request Support\n  * Asset Configuration Structure\n    * Understanding Assets vs Tokens\n    * Before You Start: Check if the Asset Exists\n    * Configuration Fields\n    * Prerequisites for Adding Assets\n  * Need Help?\n\nSummary: This guide outlines the process for requesting and configuring support for new assets and tokens within the Yellow Network, detailing prerequisites, configuration structures, and environment-specific requirements.\n\nRelated terms: asset support, token listing, add cryptocurrency, asset configuration, blockchain support, token vs asset, environment setup, network integration, asset request, yellow network, crypto onboarding, token metadata, configuration fields, asset registration\n\nUse cases: adding a new ERC-20 token to the network, configuring multi-chain asset support, onboarding custom protocol assets",
    "metadata": {
      "title": "Requesting Asset Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-asset-support",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This guide outlines the process for requesting and configuring support for new assets and tokens within the Yellow Network, detailing prerequisites, configuration structures, and environment-specific requirements.",
      "keywords": [
        "asset support",
        "token listing",
        "add cryptocurrency",
        "asset configuration",
        "blockchain support",
        "token vs asset",
        "environment setup",
        "network integration",
        "asset request",
        "yellow network",
        "crypto onboarding",
        "token metadata",
        "configuration fields",
        "asset registration"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "adding a new ERC-20 token to the network",
        "configuring multi-chain asset support",
        "onboarding custom protocol assets"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Request Blockchain Support\n\n\n\n# Requesting Blockchain Support\n\nThis guide is primarily for **blockchain integrators, infrastructure teams, and project partners** who need to add support for new blockchain networks in the Clearnode infrastructure. Following this process will enable Clearnode to connect to your blockchain and provide off-chain clearing and settlement services.\n\nSummary: This guide outlines the process for blockchain integrators and infrastructure teams to add support for new blockchain networks within the Clearnode ecosystem to enable off-chain clearing and settlement.\n\nRelated terms: blockchain integration, network support, Clearnode, off-chain clearing, settlement, infrastructure, chain onboarding, multi-chain, cross-chain, L1 support, L2 support, network connectivity, blockchain partners\n\nUse cases: onboarding a new blockchain network, enabling off-chain settlement for a specific chain, infrastructure partnership integration",
    "metadata": {
      "title": "Requesting Blockchain Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-blockchain-support",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This guide outlines the process for blockchain integrators and infrastructure teams to add support for new blockchain networks within the Clearnode ecosystem to enable off-chain clearing and settlement.",
      "keywords": [
        "blockchain integration",
        "network support",
        "Clearnode",
        "off-chain clearing",
        "settlement",
        "infrastructure",
        "chain onboarding",
        "multi-chain",
        "cross-chain",
        "L1 support",
        "L2 support",
        "network connectivity",
        "blockchain partners"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "onboarding a new blockchain network",
        "enabling off-chain settlement for a specific chain",
        "infrastructure partnership integration"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## What Happens When Support is Addedâ€‹\n\n\nOnce a blockchain is supported in Clearnode:\n\n  * Clearnode can establish RPC connections to the specified blockchain network\n  * The Nitrolite protocol smart contracts (custody, adjudicator, and balance checker) will be monitored on that chain\n  * Users can deposit and withdraw assets on that blockchain through Clearnode\n  * State channels can leverage that blockchain for on-chain settlement when needed\n  * Assets deployed on the supported blockchain become available for cross-chain clearing\n\nNon-EVM and Limited Infrastructure Support\n\nIf your blockchain support request concerns a **non-EVM blockchain** or a blockchain with **limited infrastructure support** (e.g., scarce RPC providers, incomplete tooling, experimental networks), **you must contact the development team before proceeding** with this guide. These cases require custom development and cannot be handled through standard configuration.\n\nContact the dev team via [GitHub Issues](https://github.com/layer-3/nitrolite/issues).\n\nSummary: This section outlines the operational capabilities enabled when a blockchain is integrated into Clearnode, including RPC connectivity, smart contract monitoring, and cross-chain settlement functionality.\n\nRelated terms: blockchain integration, network support, RPC connection, Nitrolite protocol, on-chain settlement, cross-chain clearing, asset deposit, asset withdrawal, state channels, non-EVM support, infrastructure requirements, Clearnode configuration, multi-chain, layer 3\n\nUse cases: Enabling cross-chain asset transfers, Integrating a new L1/L2 blockchain, Setting up on-chain settlement for state channels, Configuring non-EVM network support",
    "metadata": {
      "title": "Requesting Blockchain Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-blockchain-support",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the operational capabilities enabled when a blockchain is integrated into Clearnode, including RPC connectivity, smart contract monitoring, and cross-chain settlement functionality.",
      "keywords": [
        "blockchain integration",
        "network support",
        "RPC connection",
        "Nitrolite protocol",
        "on-chain settlement",
        "cross-chain clearing",
        "asset deposit",
        "asset withdrawal",
        "state channels",
        "non-EVM support",
        "infrastructure requirements",
        "Clearnode configuration",
        "multi-chain",
        "layer 3"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Enabling cross-chain asset transfers",
        "Integrating a new L1/L2 blockchain",
        "Setting up on-chain settlement for state channels",
        "Configuring non-EVM network support"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Understanding Environmentsâ€‹\n\n\nClearnode operates in two distinct environments with separate configurations:\n\nEnvironment| Purpose| Typical Networks  \n---|---|---  \n**Sandbox**|  Development, testing, and experimentation| Testnets (Sepolia, Polygon Amoy, etc.)  \n**Production**|  Live operations with real assets| Mainnets (Ethereum, Polygon, Base, Linea, etc.)  \n  \n**Configuration file location:** `clearnode/chart/config/<sandbox_or_prod>/blockchains.yaml`\n\n**Important Considerations:**\n\n  * **Production will not support test networks** \\- mainnet blockchains only\n  * **Sandbox will not support mainnet networks** \\- testnet blockchains only\n  * You must decide which environment needs the blockchain support based on your use case\n  * If you need support in both environments (e.g., testnet for development, mainnet for production), you must submit configuration changes to both files\n\nSummary: Defines the operational environments for Clearnode, distinguishing between Sandbox for development on testnets and Production for live operations on mainnets.\n\nRelated terms: sandbox, production, testnet, mainnet, clearnode, environment configuration, network support, Sepolia, Polygon Amoy, Ethereum, Base, blockchain setup, deployment, blockchains.yaml\n\nUse cases: setting up a development environment, preparing for mainnet launch, configuring blockchain network access",
    "metadata": {
      "title": "Requesting Blockchain Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-blockchain-support",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the operational environments for Clearnode, distinguishing between Sandbox for development on testnets and Production for live operations on mainnets.",
      "keywords": [
        "sandbox",
        "production",
        "testnet",
        "mainnet",
        "clearnode",
        "environment configuration",
        "network support",
        "Sepolia",
        "Polygon Amoy",
        "Ethereum",
        "Base",
        "blockchain setup",
        "deployment",
        "blockchains.yaml"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "setting up a development environment",
        "preparing for mainnet launch",
        "configuring blockchain network access"
      ],
      "function_names": [
        "sandbox_or_prod"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## How to Request Supportâ€‹\n\n\nBlockchain support is requested by creating or modifying a configuration file in the [nitrolite](https://github.com/erc7824/nitrolite) repository:\n\n  1. **Fork the repository** : `https://github.com/erc7824/nitrolite`\n  2. **Navigate to the appropriate configuration file** :\n     * For Sandbox: `clearnode/chart/config/sandbox/blockchains.yaml`\n     * For Production: `clearnode/chart/config/prod/blockchains.yaml`\n  3. **Add your blockchain configuration** at the end of the `blockchains` list (see next section for structure)\n  4. **Submit a Pull Request** with a clear description of the blockchain being added\n  5. **Wait for review** by the development team\n\nThe next section provides detailed guidance on the configuration structure.\n\nSummary: This section outlines the administrative and technical process for integrating new blockchain networks into the Yellow Network by submitting configuration updates to the Nitrolite repository.\n\nRelated terms: blockchain support, add network, nitrolite, configuration file, blockchains.yaml, pull request, sandbox setup, production deployment, clearnode, network integration, chain onboarding, blockchain config, github fork, erc7824\n\nUse cases: Integrating a new Layer 1 or Layer 2 blockchain, Setting up a sandbox environment for testing, Onboarding a production-ready network",
    "metadata": {
      "title": "Requesting Blockchain Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-blockchain-support",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the administrative and technical process for integrating new blockchain networks into the Yellow Network by submitting configuration updates to the Nitrolite repository.",
      "keywords": [
        "blockchain support",
        "add network",
        "nitrolite",
        "configuration file",
        "blockchains.yaml",
        "pull request",
        "sandbox setup",
        "production deployment",
        "clearnode",
        "network integration",
        "chain onboarding",
        "blockchain config",
        "github fork",
        "erc7824"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Integrating a new Layer 1 or Layer 2 blockchain",
        "Setting up a sandbox environment for testing",
        "Onboarding a production-ready network"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Blockchain Configuration Structureâ€‹\n\n\n### Overviewâ€‹\n\nThe `blockchains.yaml` file contains two main sections:\n\n  * `default_contract_addresses`: Default smart contract addresses applied to all blockchains (unless overridden)\n  * `blockchains`: Array of blockchain configurations\n\n### Configuration Fieldsâ€‹\n\nEach blockchain entry requires the following fields:\n    \n    \n    blockchains:  \n      - name: polygon                 # Blockchain name (lowercase, underscores allowed)  \n        id: 137                       # Chain ID for validation  \n        disabled: false               # Whether to disable (default: false)  \n        block_step: 10000             # Block range for scanning (default: 10000)  \n        contract_addresses:           # Override default contract addresses  \n          custody: \"0x...\"  \n          adjudicator: \"0x...\"  \n          balance_checker: \"0x...\"  \n    \n\n**Field Descriptions:**\n\nField| Required| Description  \n---|---|---  \n`name`| **Yes**|  Unique identifier for the blockchain (lowercase, underscores allowed, e.g., `polygon`, `base`, `arbitrum_one`)  \n`id`| **Yes**|  Chain ID used for validation (must match the blockchain's official chain ID)  \n`disabled`| No| Set to `true` to disable or `false` to enable (default: `false`)  \n`block_step`| No| Number of blocks to scan per query when monitoring events (default: `10000`). Adjust based on blockchain or RPC provider performance.  \n`contract_addresses`| No| Override default contract addresses for this specific blockchain  \n  \n### Contract Deploymentâ€‹\n\nWhen requesting the addition of a new blockchain, addresses of the infrastructure smart contracts must be provided:\n\n  * **Custody Contract** : Manages user deposits and withdrawals\n  * **Adjudicator Contract** : Handles dispute resolution for state channels\n  * **Balance Checker Contract** : Provides efficient balance queries\n\nSmart contract deployment\n\nFor now, you don't need to deploy these contracts yourself. The development team will handle contract deployment on the new blockchain as part of the support process.\n\nYou can submit your request with smart contract addresses set to placeholder values (e.g., `0x0000000000000000000000000000000000000000`). The team will replace them with the actual deployed addresses during integration.\n\nComing Soon: Cross-Chain Contract Deployment Tool\n\nWe are developing a tool to simplify the deployment of Nitrolite protocol smart contracts across multiple blockchains with deterministic addresses. This will enable deploying contracts to the same address on different chains, making configuration management significantly easier.\n\nRead on to learn how to specify contract addresses in the configuration.\n\nYou have two options for providing contract addresses:\n\n#### Option 1: Using Default Contract Addressesâ€‹\n\nIf you deploy contracts at the addresses specified in the `default_contract_addresses`, you don't need to specify `contract_addresses` in each blockchain entry.\n    \n    \n    default_contract_addresses:  \n      custody: \"0x490fb189DdE3a01B00be9BA5F41e3447FbC838b6\"  \n      adjudicator: \"0xcbbc03a873c11beeFA8D99477E830be48d8Ae6D7\"  \n      balance_checker: \"0x2352c63A83f9Fd126af8676146721Fa00924d7e4\"  \n      \n    blockchains:  \n      - name: polygon  \n        id: 137  \n        enabled: true  \n      - name: base  \n        id: 8453  \n        enabled: true  \n    \n\nThis approach is cleaner when contracts are deployed at identical addresses.\n\n#### Option 2: Blockchain-Specific Contract Addressesâ€‹\n\nIf contract addresses differ on your blockchain, specify them individually:\n    \n    \n    blockchains:  \n      - name: polygon  \n        id: 137  \n        enabled: true  \n        contract_addresses:  \n          custody: \"0xPolygonCustodyAddress...\"  \n          adjudicator: \"0xPolygonAdjudicatorAddress...\"  \n          balance_checker: \"0xPolygonBalanceCheckerAddress...\"  \n      - name: base  \n        id: 8453  \n        enabled: true  \n        contract_addresses:  \n          custody: \"0xBaseCustodyAddress...\"  \n          adjudicator: \"0xBaseAdjudicatorAddress...\"  \n          balance_checker: \"0xBaseBalanceCheckerAddress...\"  \n    \n\nContract Address Requirements\n\nEach blockchain **must have all three contract addresses configured** either through `default_contract_addresses` or blockchain-specific `contract_addresses`. If defaults are not provided, every blockchain must explicitly define all three addresses. Missing contract addresses will cause Clearnode to fail on startup.\n\nSummary: Defines the configuration structure for integrating blockchain networks into the Yellow Network, specifying chain identifiers, event monitoring parameters, and core infrastructure contract addresses.\n\nRelated terms: blockchain configuration, blockchains.yaml, chain ID, block_step, custody contract, adjudicator contract, balance checker, network integration, multi-chain support, RPC scanning, smart contract addresses, chainid, blockstep\n\nUse cases: Integrating a new blockchain network into the protocol, Optimizing RPC performance via block range adjustment, Specifying infrastructure contract deployments for specific chains",
    "metadata": {
      "title": "Requesting Blockchain Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-blockchain-support",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the configuration structure for integrating blockchain networks into the Yellow Network, specifying chain identifiers, event monitoring parameters, and core infrastructure contract addresses.",
      "keywords": [
        "blockchain configuration",
        "blockchains.yaml",
        "chain ID",
        "block_step",
        "custody contract",
        "adjudicator contract",
        "balance checker",
        "network integration",
        "multi-chain support",
        "RPC scanning",
        "smart contract addresses",
        "chainid",
        "blockstep"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Integrating a new blockchain network into the protocol",
        "Optimizing RPC performance via block range adjustment",
        "Specifying infrastructure contract deployments for specific chains"
      ],
      "function_names": [
        "contract_addresses",
        "arbitrum_one",
        "default_contract_addresses",
        "balance_checker",
        "block_step"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Need Help?â€‹\n\n\nIf you have questions about blockchain support requests, encounter issues during integration, or need clarification on any part of this process, please don't hesitate to contact the development team.\n\n\n\n[PreviousRequest Asset Support](/docs/manuals/request-asset-support)[NextRunning Clearnode Locally](/docs/manuals/running-clearnode-locally)\n\n  * What Happens When Support is Added\n  * Understanding Environments\n  * How to Request Support\n  * Blockchain Configuration Structure\n    * Overview\n    * Configuration Fields\n    * Contract Deployment\n  * Need Help?\n\nSummary: This section provides a comprehensive guide and support channel for integrating new blockchain networks into the Yellow Network, covering configuration structures and contract deployment procedures.\n\nRelated terms: blockchain support, network integration, asset support, clearnode, blockchain configuration, contract deployment, environment setup, chain onboarding, add new network, yellow network, crypto protocol, dev support, blockchain setup\n\nUse cases: Integrating a new blockchain network, Configuring cross-chain assets, Deploying protocol contracts to a new chain",
    "metadata": {
      "title": "Requesting Blockchain Support | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/request-blockchain-support",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section provides a comprehensive guide and support channel for integrating new blockchain networks into the Yellow Network, covering configuration structures and contract deployment procedures.",
      "keywords": [
        "blockchain support",
        "network integration",
        "asset support",
        "clearnode",
        "blockchain configuration",
        "contract deployment",
        "environment setup",
        "chain onboarding",
        "add new network",
        "yellow network",
        "crypto protocol",
        "dev support",
        "blockchain setup"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Integrating a new blockchain network",
        "Configuring cross-chain assets",
        "Deploying protocol contracts to a new chain"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Running Clearnode Locally\n\n\n\n# Running Clearnode Locally\n\nThis manual explains how to run a Clearnode locally using Docker Compose for development and testing purposes. Clearnode is an implementation of a message broker node providing ledger services for the Nitrolite protocol, which enables efficient off-chain payment channels with on-chain settlement capabilities.\n\nSummary: This guide provides instructions for deploying a local Clearnode instance using Docker Compose to support development and testing of the Nitrolite protocol's off-chain payment and ledger services.\n\nRelated terms: local setup, Docker Compose, Clearnode, Nitrolite protocol, message broker, ledger services, off-chain payment channels, on-chain settlement, development environment, node deployment, Clear node, Nitrolight, testing\n\nUse cases: Local development of payment applications, Testing Nitrolite protocol integrations, Simulating off-chain payment channels, Debugging ledger service interactions",
    "metadata": {
      "title": "Running Clearnode Locally | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/running-clearnode-locally",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This guide provides instructions for deploying a local Clearnode instance using Docker Compose to support development and testing of the Nitrolite protocol's off-chain payment and ledger services.",
      "keywords": [
        "local setup",
        "Docker Compose",
        "Clearnode",
        "Nitrolite protocol",
        "message broker",
        "ledger services",
        "off-chain payment channels",
        "on-chain settlement",
        "development environment",
        "node deployment",
        "Clear node",
        "Nitrolight",
        "testing"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "Local development of payment applications",
        "Testing Nitrolite protocol integrations",
        "Simulating off-chain payment channels",
        "Debugging ledger service interactions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Prerequisitesâ€‹\n\n\n  * Docker and Docker Compose installed on your system\n  * Git (to clone the repository)\n\nSummary: This section outlines the foundational software requirements, specifically Docker and Git, needed to deploy and operate a Clearnode instance within a local development environment.\n\nRelated terms: Clearnode, local setup, installation, Docker, Docker Compose, Git, prerequisites, environment setup, node deployment, self-hosting, infrastructure, containerization, dev environment, Yellow Network\n\nUse cases: local development environment setup, testing Clearnode functionality, infrastructure preparation for node operators",
    "metadata": {
      "title": "Running Clearnode Locally | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/running-clearnode-locally",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the foundational software requirements, specifically Docker and Git, needed to deploy and operate a Clearnode instance within a local development environment.",
      "keywords": [
        "Clearnode",
        "local setup",
        "installation",
        "Docker",
        "Docker Compose",
        "Git",
        "prerequisites",
        "environment setup",
        "node deployment",
        "self-hosting",
        "infrastructure",
        "containerization",
        "dev environment",
        "Yellow Network"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "local development environment setup",
        "testing Clearnode functionality",
        "infrastructure preparation for node operators"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Quick Startâ€‹\n\n\n### 1\\. Clone the Repositoryâ€‹\n    \n    \n    git clone https://github.com/erc7824/nitrolite.git  \n    cd nitrolite/clearnode  \n    \n\n### 2\\. Configuration Setupâ€‹\n\nCreate a configuration directory:\n    \n    \n    cp -r config/compose/example config/compose/local  \n    \n\n### 3\\. Configure Blockchain Connectionsâ€‹\n\nEdit `config/compose/local/blockchains.yaml` to configure your blockchain connections. Here's an example:\n    \n    \n    default_contract_addresses:  \n      custody: \"0x490fb189DdE3a01B00be9BA5F41e3447FbC838b6\"  \n      adjudicator: \"0xcbbc03a873c11beeFA8D99477E830be48d8Ae6D7\"  \n      balance_checker: \"0x2352c63A83f9Fd126af8676146721Fa00924d7e4\"  \n      \n    blockchains:  \n      - name: polygon  \n        id: 137  \n        disabled: false  \n        block_step: 10000  \n      - name: base  \n        id: 8453  \n        disabled: true  \n    \n\n### 4\\. Configure Assetsâ€‹\n\nEdit `config/compose/local/assets.yaml` to configure supported assets:\n    \n    \n    assets:  \n      - name: \"USD Coin\"  \n        symbol: \"usdc\"  \n        tokens:  \n          - blockchain_id: 137  \n            address: \"0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359\"  \n            decimals: 6  \n      - name: \"Wrapped Ether\"  \n        symbol: \"weth\"  \n        tokens:  \n          - blockchain_id: 137  \n            address: \"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619\"  \n            decimals: 18  \n    \n\n### 5\\. Environment Variablesâ€‹\n\nCreate a `.env` file in `config/compose/local/.env` with the following:\n    \n    \n    # Required  \n    BROKER_PRIVATE_KEY=your_private_key_here  \n      \n    # Add RPC endpoints for each enabled blockchain  \n    POLYGON_BLOCKCHAIN_RPC=wss://my-polygon-rpc.example.com  \n    # BASE_BLOCKCHAIN_RPC=wss://my-base-rpc.example.com  \n      \n    # Optional configuration  \n    CLEARNODE_LOG_LEVEL=info  \n    \n\n### 6\\. Start Servicesâ€‹\n\nRun the following command to start all services:\n    \n    \n    docker compose up  \n    \n\nThis will start:\n\n  * Clearnode service on port 8000 (WebSocket/HTTP)\n  * PostgreSQL database\n  * Prometheus metrics on port 4242\n\n### 7\\. Stop Servicesâ€‹\n\nTo stop all services:\n    \n    \n    docker compose down\n\nSummary: This guide provides a step-by-step procedure for deploying a local Clearnode instance, the core infrastructure component of the Yellow Network, using Docker Compose and multi-chain configuration files.\n\nRelated terms: clearnode, local setup, docker compose, blockchain configuration, rpc endpoint, node deployment, self-hosting, nitrolite, asset mapping, private key setup, infrastructure, yellow network, broker node, environment variables\n\nUse cases: Setting up a local development environment for testing protocol integrations, Deploying a private broker node to manage cross-chain liquidity, Configuring multi-chain asset support and contract addresses for a payment gateway",
    "metadata": {
      "title": "Running Clearnode Locally | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/running-clearnode-locally",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This guide provides a step-by-step procedure for deploying a local Clearnode instance, the core infrastructure component of the Yellow Network, using Docker Compose and multi-chain configuration files.",
      "keywords": [
        "clearnode",
        "local setup",
        "docker compose",
        "blockchain configuration",
        "rpc endpoint",
        "node deployment",
        "self-hosting",
        "nitrolite",
        "asset mapping",
        "private key setup",
        "infrastructure",
        "yellow network",
        "broker node",
        "environment variables"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Setting up a local development environment for testing protocol integrations",
        "Deploying a private broker node to manage cross-chain liquidity",
        "Configuring multi-chain asset support and contract addresses for a payment gateway"
      ],
      "function_names": [
        "default_contract_addresses",
        "block_step",
        "balance_checker",
        "blockchain_id",
        "your_private_key_here"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Configuration Referenceâ€‹\n\n\n### Environment Variablesâ€‹\n\nVariable| Description| Required| Default  \n---|---|---|---  \n`BROKER_PRIVATE_KEY`| Private key used for signing broker messages| Yes| -  \n`DATABASE_DRIVER`| Database driver to use (postgres/sqlite)| No| sqlite  \n`CLEARNODE_CONFIG_DIR_PATH`| Path to directory containing configuration files| No| .  \n`CLEARNODE_DATABASE_URL`| Database connection string| No| clearnode.db  \n`CLEARNODE_LOG_LEVEL`| Logging level (debug, info, warn, error)| No| info  \n`HTTP_PORT`| Port for the HTTP/WebSocket server| No| 8000  \n`METRICS_PORT`| Port for Prometheus metrics| No| 4242  \n`MSG_EXPIRY_TIME`| Time in seconds for message timestamp validation| No| 60  \n`<BLOCKCHAIN_NAME>_BLOCKCHAIN_RPC`| RPC endpoint for each enabled blockchain| Yes| -  \n  \n### Blockchain Configuration (blockchains.yaml)â€‹\n\n**Configuration Structure:**\n\n  * **default_contract_addresses** : That's the optional set of default contract addresses applied to all blockchains unless overridden\n\n    * `custody`: Custody contract address\n    * `adjudicator`: Adjudicator contract address\n    * `balance_checker`: Balance checker contract address\n  * **blockchains** : Array of blockchain configurations\n\n    * `name`: Blockchain name (required; lowercase, underscores allowed)\n    * `id`: Chain ID for validation (required)\n    * `disabled`: Whether to disable this blockchain (optional, default: false)\n    * `block_step`: Block range for scanning (optional, default: 10000)\n    * `contract_addresses`: Override default addresses for this specific blockchain (optional)\n      * `custody`: Custody contract address\n      * `adjudicator`: Adjudicator contract address\n      * `balance_checker`: Balance checker contract address\n\nwarning\n\nEven though both `default_contract_addresses` and blockchain-specific `contract_addresses` are described as optional, each blockchain must have all required contract addresses set. If no defaults are provided under `default_contract_addresses`, you must specify `custody`, `adjudicator`, and `balance_checker` addresses for every blockchain in its `contract_addresses` section. Otherwise, Clearnode will fail to start due to missing contract address configuration.\n\nRPC endpoints follow the pattern: `<BLOCKCHAIN_NAME_UPPERCASE>_BLOCKCHAIN_RPC`\n\nExample:\n    \n    \n    MY_NETWORK_BLOCKCHAIN_RPC=wss://my-network-rpc.example.com  \n    \n\n### Asset Configuration (assets.yaml)â€‹\n\n**Configuration Structure:**\n\n  * **assets** : Array of asset configurations\n    * `name`: Human-readable name of the asset (e.g., \"USD Coin\")\n    * `symbol`: Ticker symbol for the asset (required; lowercase, e.g., \"usdc\")\n    * `disabled`: Whether to skip processing this asset (optional, default: false)\n    * `tokens`: Array of blockchain-specific token implementations\n      * `name`: Token name on this blockchain (optional, inherits from asset)\n      * `symbol`: Token symbol on this blockchain (optional, inherits from asset)\n      * `blockchain_id`: Chain ID where this token is deployed (required)\n      * `disabled`: Whether to skip processing this token (optional, default: false)\n      * `address`: Token's contract address (required)\n      * `decimals`: Number of decimal places for the token (required)\n\n**Asset Token Inheritance:**\n\n  * If a token's `name` is not specified, it uses the asset's `name`\n  * If a token's `symbol` is not specified, it uses the asset's `symbol`\n  * If an asset's `name` is not specified, it defaults to the asset's `symbol`\n\nSummary: This component defines the configuration schema for Clearnode, detailing the environment variables and YAML structures necessary for node initialization, database connectivity, and multi-chain smart contract integration.\n\nRelated terms: Clearnode, environment variables, blockchains.yaml, RPC endpoint, BROKER_PRIVATE_KEY, custody contract, adjudicator contract, balance checker, block scanning, multi-chain setup, node deployment, database configuration, Yellow Network, clear node, blockchain configuration\n\nUse cases: Setting up a local development environment for Yellow Network, Configuring a broker node to support multiple blockchain networks, Customizing database and logging settings for a production Clearnode deployment, Overriding default smart contract addresses for specific testnets",
    "metadata": {
      "title": "Running Clearnode Locally | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/running-clearnode-locally",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the configuration schema for Clearnode, detailing the environment variables and YAML structures necessary for node initialization, database connectivity, and multi-chain smart contract integration.",
      "keywords": [
        "Clearnode",
        "environment variables",
        "blockchains.yaml",
        "RPC endpoint",
        "BROKER_PRIVATE_KEY",
        "custody contract",
        "adjudicator contract",
        "balance checker",
        "block scanning",
        "multi-chain setup",
        "node deployment",
        "database configuration",
        "Yellow Network",
        "clear node",
        "blockchain configuration"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Setting up a local development environment for Yellow Network",
        "Configuring a broker node to support multiple blockchain networks",
        "Customizing database and logging settings for a production Clearnode deployment",
        "Overriding default smart contract addresses for specific testnets"
      ],
      "function_names": [
        "contract_addresses",
        "default_contract_addresses",
        "block_step",
        "balance_checker",
        "blockchain_id"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Key Featuresâ€‹\n\n\n  * **Multi-Chain Support** : Connect to multiple EVM blockchains simultaneously\n  * **Off-Chain Payments** : Efficient payment channels for high-throughput transactions\n  * **Virtual Applications** : Create multi-participant applications\n  * **Message Forwarding** : Bi-directional message routing between participants\n  * **Flexible Database** : Support for both PostgreSQL and SQLite\n  * **Prometheus Metrics** : Built-in monitoring on port 4242\n  * **Quorum-Based Signatures** : Multi-signature schemes with weight-based quorums\n\nSummary: Clearnode serves as the core infrastructure node for the Yellow Network, providing the foundational layer for multi-chain connectivity, off-chain payment channels, and secure multi-party application state management.\n\nRelated terms: Clearnode, multi-chain, EVM, off-chain payments, payment channels, virtual applications, message routing, PostgreSQL, SQLite, Prometheus, monitoring, quorum signatures, multi-sig, state channel, layer 2\n\nUse cases: High-frequency micro-payments via off-chain channels, Building multi-party decentralized applications, Cross-chain message routing and liquidity management, Infrastructure monitoring for node health and performance",
    "metadata": {
      "title": "Running Clearnode Locally | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/running-clearnode-locally",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Clearnode serves as the core infrastructure node for the Yellow Network, providing the foundational layer for multi-chain connectivity, off-chain payment channels, and secure multi-party application state management.",
      "keywords": [
        "Clearnode",
        "multi-chain",
        "EVM",
        "off-chain payments",
        "payment channels",
        "virtual applications",
        "message routing",
        "PostgreSQL",
        "SQLite",
        "Prometheus",
        "monitoring",
        "quorum signatures",
        "multi-sig",
        "state channel",
        "layer 2"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "High-frequency micro-payments via off-chain channels",
        "Building multi-party decentralized applications",
        "Cross-chain message routing and liquidity management",
        "Infrastructure monitoring for node health and performance"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Troubleshootingâ€‹\n\n\n### Common Issuesâ€‹\n\n  1. **Port Conflicts** : If you encounter port conflicts, check which services are running on ports 8000 (HTTP/WebSocket) or 4242 (metrics) and either stop them or modify the ports in docker-compose.yml\n\n  2. **RPC Configuration** : Ensure RPC endpoints match the pattern `<BLOCKCHAIN_NAME_UPPERCASE>_BLOCKCHAIN_RPC` and that the chain ID matches your configuration\n\n  3. **Configuration Files** : Make sure `blockchains.yaml` and `assets.yaml` are properly formatted YAML files in your CONFIG_DIR_PATH\n\n  4. **Database Connection** : If using PostgreSQL, ensure the database service is running and accessible\n\n\n### Useful Commandsâ€‹\n\nCheck service status:\n    \n    \n    docker-compose ps  \n    \n\nView logs for a specific service:\n    \n    \n    docker-compose logs -f <service-name>  \n    \n\nRestart a specific service:\n    \n    \n    docker-compose restart <service-name>  \n    \n\nClean up (remove containers, networks, and volumes):\n    \n    \n    docker-compose down -v\n\nSummary: This section provides diagnostic procedures and resolution steps for common infrastructure and configuration issues encountered when deploying a Clearnode instance locally. It outlines specific checks for port availability, RPC connectivity, and service orchestration using Docker Compose.\n\nRelated terms: troubleshooting, debugging, docker-compose, port conflict, RPC configuration, logs, service management, local deployment, clearnode, database connection, YAML validation, node setup, error resolution, docker logs\n\nUse cases: resolving local deployment failures, debugging RPC connectivity issues, monitoring Clearnode service logs, resetting local node environment",
    "metadata": {
      "title": "Running Clearnode Locally | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/running-clearnode-locally",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section provides diagnostic procedures and resolution steps for common infrastructure and configuration issues encountered when deploying a Clearnode instance locally. It outlines specific checks for port availability, RPC connectivity, and service orchestration using Docker Compose.",
      "keywords": [
        "troubleshooting",
        "debugging",
        "docker-compose",
        "port conflict",
        "RPC configuration",
        "logs",
        "service management",
        "local deployment",
        "clearnode",
        "database connection",
        "YAML validation",
        "node setup",
        "error resolution",
        "docker logs"
      ],
      "function_name": null,
      "intent": "error_handling",
      "use_cases": [
        "resolving local deployment failures",
        "debugging RPC connectivity issues",
        "monitoring Clearnode service logs",
        "resetting local node environment"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Development Tipsâ€‹\n\n\n  1. **Debug Mode** : Set `CLEARNODE_LOG_LEVEL=debug` for verbose logging\n  2. **Database Access** : Use a database client to connect to `localhost:5432` with PostgreSQL credentials\n\n\n\n[PreviousRequest Blockchain Support](/docs/manuals/request-blockchain-support)\n\n  * Prerequisites\n  * Quick Start\n    * 1\\. Clone the Repository\n    * 2\\. Configuration Setup\n    * 3\\. Configure Blockchain Connections\n    * 4\\. Configure Assets\n    * 5\\. Environment Variables\n    * 6\\. Start Services\n    * 7\\. Stop Services\n  * Configuration Reference\n    * Environment Variables\n    * Blockchain Configuration (blockchains.yaml)\n    * Asset Configuration (assets.yaml)\n  * Key Features\n  * Troubleshooting\n    * Common Issues\n    * Useful Commands\n  * Development Tips\n\nSummary: Provides a comprehensive guide for developers to deploy and manage a Clearnode instance locally for testing and development purposes.\n\nRelated terms: Clearnode, local development, self-hosting, PostgreSQL, debug logging, environment variables, blockchain setup, asset configuration, node deployment, localhost, dev environment, troubleshooting, clearnode setup\n\nUse cases: local development and testing, debugging node behavior, configuring custom blockchain assets",
    "metadata": {
      "title": "Running Clearnode Locally | Yellow Network",
      "url": "https://docs.yellow.org/docs/manuals/running-clearnode-locally",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a comprehensive guide for developers to deploy and manage a Clearnode instance locally for testing and development purposes.",
      "keywords": [
        "Clearnode",
        "local development",
        "self-hosting",
        "PostgreSQL",
        "debug logging",
        "environment variables",
        "blockchain setup",
        "asset configuration",
        "node deployment",
        "localhost",
        "dev environment",
        "troubleshooting",
        "clearnode setup"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "local development and testing",
        "debugging node behavior",
        "configuring custom blockchain assets"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## System Overviewâ€‹\n\n\nThe Nitrolite protocol architecture consists of multiple layers working together to enable scalable, secure state channel operations:\n\nBlockchain Layer\n\nOn-Chain Layer  \n(Smart Contracts)\n\nClient SDK\n\nOff-Chain Layer  \n(Fast Updates)\n\nApplication Layer\n\nCommunicate via RPC using NitroRPC protocol\n\nOperate on-chain state channels\n\nObserve events\n\nChess, DEX, Gaming, Payments, Custom Logic\n\nClearnode\n\nClient SDK\n\nCustody, Adjudicator contracts\n\nEthereum, Polygon, etc.\n\nSummary: Provides a high-level overview of the Nitrolite protocol's multi-layered architecture, illustrating the interaction between on-chain smart contracts, off-chain state channels, and the Client SDK for scalable decentralized applications.\n\nRelated terms: Nitrolite, state channels, off-chain updates, NitroRPC, Clearnode, layer 2, scalability, smart contracts, adjudicator, custody, Ethereum, Polygon, L2, Yellow Network, architecture\n\nUse cases: building decentralized exchanges, real-time gaming state updates, scalable payment systems, custom state channel logic",
    "metadata": {
      "title": "Architecture | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/architecture",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a high-level overview of the Nitrolite protocol's multi-layered architecture, illustrating the interaction between on-chain smart contracts, off-chain state channels, and the Client SDK for scalable decentralized applications.",
      "keywords": [
        "Nitrolite",
        "state channels",
        "off-chain updates",
        "NitroRPC",
        "Clearnode",
        "layer 2",
        "scalability",
        "smart contracts",
        "adjudicator",
        "custody",
        "Ethereum",
        "Polygon",
        "L2",
        "Yellow Network",
        "architecture"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "building decentralized exchanges",
        "real-time gaming state updates",
        "scalable payment systems",
        "custom state channel logic"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Communication Patternsâ€‹\n\n\n### On-Chain Channel Openingâ€‹\n\nThe channel opening process follows a coordinated sequence between client and a clearnode:\n\n  1. Client requests channel creation from a clearnode via Nitro RPC\n  2. The clearnode returns a channel struct and signed initial state (signature at index 1)\n  3. Client signs the initial state (signature at index 0)\n  4. Client calls the `create(...)` method of the Custody Smart Contract on the blockchain, providing the channel and initial state with both signatures\n  5. Contract verifies signatures and emits `Opened` event\n  6. Channel becomes ACTIVE immediately\n  7. The clearnode monitors the `Opened` event and updates its internal state\n\nBlockchainClearnodeClientBlockchainClearnodeClientcreate_channel requestchannel struct + signed initial state (clearnode signature)Add own signaturecreate() with BOTH signaturesVerify signaturesSet status = ACTIVEEmit Opened eventOpened event (monitored)channel_update notification\n\nCooperative Opening\n\nChannel opening requires cooperation between both parties, ensuring mutual agreement before funds are locked.\n\n### Off-Chain Updatesâ€‹\n\n**Off-Chain Updates** :\n\n  1. Participants exchange signed state updates:\n\n     * **For Payment Channels** (User â†” Clearnode): States are exchanged directly via Nitro RPC\n\n     * **For App Sessions** (Multi-party): State exchange is managed by the App itself (peer-to-peer). Once the state has enough signatures to satisfy quorum, a responsible party submits the signed state to the Clearnode\n\n  2. No blockchain transactions required\n\n  3. Latest valid state maintained off-chain\n\n  4. Can be checkpointed on-chain at any time\n\n     * _Current Implementation Note_ : While this is the ideal design goal, the current implementation does not store the state off-chain, so checkpointing is not currently supported. This functionality is under development and will be more enforced in the next version of the protocol.\n\nZero Gas Fees\n\nOff-chain updates are instant (< 1 second) and incur zero gas fees, enabling high-frequency operations.\n\n### On-Chain Channel Closingâ€‹\n\nChannels can be closed in two ways:\n\n**Cooperative Closure** :\n\n  1. All participants negotiate and agree on the final state\n  2. Each participant signs the final state with `intent = FINALIZE`\n  3. Any participant submits the fully-signed final state to the Custody Contract via `close()`\n  4. Contract verifies all signatures and distributes funds according to final allocations\n  5. Channel status becomes FINAL\n\nThis is the preferred closure method. It requires only 1 transaction and is gas-efficient.\n\n**Non-Cooperative Closure** :\n\n  1. A participant submits the latest known state to the Custody Contract via `challenge()`\n  2. Contract verifies signatures and sets channel status to DISPUTE\n  3. A challenge period begins (e.g., 24 hours), allowing the other party to respond\n  4. If participants decides to cooperate again, they may produce a newer valid state, and any of them can submit it via `checkpoint()`, thus stopping the challenge period and moving the channel from DISPUTE back to ACTIVE status\n  5. If not, after the challenge period expires, any participant calls `close()` to finalize with the latest submitted state\n  6. Contract distributes funds according to the final state allocations\n\nThis mechanism resolves disputes when parties cannot cooperate. It requires a waiting period for security and is more expensive due to multiple transactions.\n\nYes\n\nNo\n\nActive Channel\n\nParties Agree?\n\nCooperative Close  \nFast, Cheap\n\nChallenge-Response  \nSlow, Secure\n\nSummary: Defines the communication workflows for establishing on-chain payment channels and managing off-chain state transitions between clients, clearnodes, and smart contracts. It provides the architectural foundation for secure, gasless transactions and multi-party session management within the Yellow Network.\n\nRelated terms: open channel, off-chain updates, Nitro RPC, Custody Smart Contract, state transition, gasless transaction, clearnode, signature verification, multi-party session, checkpointing, peer-to-peer, on-chain event, channel creation\n\nUse cases: Establishing a secure payment channel between a user and a clearnode, Executing high-frequency off-chain transactions without gas fees, Managing multi-party application sessions with peer-to-peer state exchange",
    "metadata": {
      "title": "Architecture | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/architecture",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the communication workflows for establishing on-chain payment channels and managing off-chain state transitions between clients, clearnodes, and smart contracts. It provides the architectural foundation for secure, gasless transactions and multi-party session management within the Yellow Network.",
      "keywords": [
        "open channel",
        "off-chain updates",
        "Nitro RPC",
        "Custody Smart Contract",
        "state transition",
        "gasless transaction",
        "clearnode",
        "signature verification",
        "multi-party session",
        "checkpointing",
        "peer-to-peer",
        "on-chain event",
        "channel creation"
      ],
      "function_name": "create_channel",
      "intent": "concept",
      "use_cases": [
        "Establishing a secure payment channel between a user and a clearnode",
        "Executing high-frequency off-chain transactions without gas fees",
        "Managing multi-party application sessions with peer-to-peer state exchange"
      ],
      "function_names": [
        "checkpoint",
        "close",
        "lientcreate_channel",
        "channel_update",
        "challenge"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Fund Flowâ€‹\n\n\nThe following diagram illustrates how funds flow through the Nitrolite protocol:\n\ndeposit\n\nresize\n\nresize\n\nresize\n\nopen/deposit\n\nwithdraw / close session\n\nresize / close channel\n\nwithdraw\n\nUser Wallet  \n(ERC-20)\n\nAvailable  \n(Custody SC)\n\nUnified Balance  \n(Clearnode)\n\nChannel-Locked  \n(Custody SC)\n\nApp Sessions  \n(Application)\n\n**Flow Explanation** :\n\n  1. **Deposit** : User deposits ERC-20 tokens into the **Available** balance of the Custody Contract.\n  2. **Resize** : Funds can be moved between **Available** balance and **Unified Balance** (managed off-chain by the clearnode).\n  3. **Channel Lock** : Funds can also be moved between **Available** balance and **Channel-Locked** balance via resize operations, or between **Channel-Locked** and **Unified Balance**.\n  4. **App Sessions** : Funds from the **Unified Balance** can be allocated to App Sessions.\n  5. **Release** : When app sessions close or funds are withdrawn, they return to the **Unified Balance**.\n  6. **Unlock/Withdraw** : Funds can be moved back to **Available** balance (via resize/close) and then withdrawn to the **User Wallet**.\n\nSecurity Guarantee\n\nAt every stage, funds remain cryptographically secured. Users can always recover their funds according to the latest valid signed state, even if the clearnode becomes unresponsive.\n\n\n\n[PreviousTerminology](/docs/protocol/terminology)[NextOverview](/docs/protocol/on-chain/overview)\n\n  * System Overview\n  * Communication Patterns\n    * On-Chain Channel Opening\n    * Off-Chain Updates\n    * On-Chain Channel Closing\n  * Fund Flow\n\nSummary: Defines the lifecycle and movement of assets across the Nitrolite protocol, detailing how funds transition between on-chain custody contracts, off-chain unified balances, and active application sessions.\n\nRelated terms: deposit, withdraw, fund flow, asset management, ERC-20, Custody SC, Clearnode, Unified Balance, Channel-Locked, off-chain, state update, liquidity, fundflow, cryptographic security\n\nUse cases: Managing liquidity between on-chain and off-chain layers, Allocating funds for high-frequency application sessions, Non-custodial fund recovery during node failure, Moving assets between unified balances and payment channels",
    "metadata": {
      "title": "Architecture | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/architecture",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the lifecycle and movement of assets across the Nitrolite protocol, detailing how funds transition between on-chain custody contracts, off-chain unified balances, and active application sessions.",
      "keywords": [
        "deposit",
        "withdraw",
        "fund flow",
        "asset management",
        "ERC-20",
        "Custody SC",
        "Clearnode",
        "Unified Balance",
        "Channel-Locked",
        "off-chain",
        "state update",
        "liquidity",
        "fundflow",
        "cryptographic security"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Managing liquidity between on-chain and off-chain layers",
        "Allocating funds for high-frequency application sessions",
        "Non-custodial fund recovery during node failure",
        "Moving assets between unified balances and payment channels"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Cross-Layer Communication Flows\n\n\n\n# Cross-Layer Communication Flows\n\nThis section illustrates how the on-chain and off-chain layers interact during typical operations. Each flow shows the sequence of method calls and data exchange between Client, Clearnode, and Smart Contracts.\n\nFlow Navigation\n\nJump to a specific flow:\n\n  * Authentication Flow \\- Establish session with session key delegation\n  * Channel Creation Flow \\- Open payment channel on blockchain\n  * Off-Chain Transfer Flow \\- Instant transfers without gas\n  * App Session Lifecycle \\- Multi-party application flow\n  * Cooperative Closure \\- Fast channel closure\n  * Challenge-Response Closure \\- Dispute resolution\n\n* * *\n\nSummary: This section outlines the architectural interaction patterns between on-chain smart contracts and off-chain Clearnodes, detailing the sequence of operations for channel management, state updates, and dispute resolution.\n\nRelated terms: cross-layer communication, off-chain transfer, payment channel, clearnode, session delegation, dispute resolution, gasless transactions, state channel, cooperative closure, challenge-response, layer 2, on-chain synchronization, authentication flow, sequence diagrams\n\nUse cases: Designing secure off-chain to on-chain synchronization, Implementing dispute resolution for payment channels, Optimizing transaction costs via gasless transfers, Managing multi-party application session lifecycles",
    "metadata": {
      "title": "Cross-Layer Communication Flows | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/communication-flows",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the architectural interaction patterns between on-chain smart contracts and off-chain Clearnodes, detailing the sequence of operations for channel management, state updates, and dispute resolution.",
      "keywords": [
        "cross-layer communication",
        "off-chain transfer",
        "payment channel",
        "clearnode",
        "session delegation",
        "dispute resolution",
        "gasless transactions",
        "state channel",
        "cooperative closure",
        "challenge-response",
        "layer 2",
        "on-chain synchronization",
        "authentication flow",
        "sequence diagrams"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Designing secure off-chain to on-chain synchronization",
        "Implementing dispute resolution for payment channels",
        "Optimizing transaction costs via gasless transfers",
        "Managing multi-party application session lifecycles"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Authentication Flowâ€‹\n\n\n### Purposeâ€‹\n\nEstablish authenticated session with session key delegation.\n\n### Actorsâ€‹\n\n  * **Client** : User application or SDK\n  * **Clearnode** : Off-chain service provider\n\n### Sequence Diagramâ€‹\n\nClearnodeMain WalletClientClearnodeMain WalletClient1\\. Generate Session Keypair2\\. auth_request (public, no signature)3\\. Generate Challenge4\\. Sign Challenge with MAIN wallet (EIP-712)5\\. Validate & Issue SessionSubsequent requests signed with session_keysession_private_key = random()session_address = address(session_public_key)auth_request(address, session_key, allowances, scope, expires_at)Validate params, generate UUIDauth_challenge(challenge_message)Sign Policy typed data (challenge, scope, wallet, session_key, expires_at, allowances)EIP-712 signatureauth_verify(challenge, sig) // or auth_verify(challenge, jwt)Recover main wallet from sig (or validate jwt)Create session + JWT{address, session_key, jwt_token, success}\n\n### Stepsâ€‹\n\n#### Step 1: Client Generates Session Keypairâ€‹\n\nThe session key is generated entirely off-chain and the private key never leaves the client:\n    \n    \n    session_private_key = random()  \n    session_public_key = derive(session_private_key)  \n    session_address = address(session_public_key)  \n    \n\n#### Step 2: Client â†’ Clearnode: `auth_request` (public, no signature)â€‹\n\nThe client sends a public registration request (no signature required):\n    \n    \n    Request:  \n    {  \n      address: user_wallet_address  \n      session_key: session_address  \n      allowances: [{\"asset\": \"usdc\", \"amount\": \"100.0\"}]  \n      scope: \"transfer,app.create\"  \n      expires_at: 1762417328123  // Unix ms  \n    }  \n    \n\n#### Step 3: Clearnode Validates and Generates Challengeâ€‹\n\nThe clearnode performs validation:\n\n  * Validate address/session_key format, optional allowances/scope, expires_at\n  * Generate challenge UUID\n\n#### Step 4: Clearnode â†’ Client: `auth_challenge`â€‹\n\nThe clearnode responds with a challenge:\n    \n    \n    Response:  \n    {  \n      challenge_message: \"550e8400-e29b-41d4-a716-446655440000\"  \n    }  \n    Signature: signed by Clearnode  \n    \n\n#### Step 5: Client Signs Challenge (MAIN wallet, EIP-712)â€‹\n\nThe client signs the challenge using the main wallet over the Policy typed data (includes challenge, wallet, session_key, expires_at, scope, allowances):\n    \n    \n    challenge_signature = signTypedData(policyTypedData, main_wallet_private_key)  \n    \n\n#### Step 6: Client â†’ Clearnode: `auth_verify`â€‹\n\nThe client submits the signed challenge (or a previously issued JWT):\n    \n    \n    Request:  \n    {  \n      challenge: \"550e8400-e29b-41d4-a716-446655440000\",  \n      // alternatively:  \n      // jwt: \"<existing_jwt>\"  \n    }  \n    Signature: EIP-712 signature by main wallet (required if jwt is absent)  \n    \n\n#### Step 7: Clearnode Validates Challengeâ€‹\n\nThe clearnode validates:\n\n  * Signature recovers the wallet used in `auth_request`\n  * Challenge matches pending authentication\n  * Challenge not expired or reused\n\n#### Step 8: Clearnode â†’ Client: `auth_verify` Responseâ€‹\n\nThe clearnode confirms authentication:\n    \n    \n    Response:  \n    {  \n      address: user_wallet_address  \n      session_key: session_address  \n      jwt_token: \"<jwt>\"  \n      success: true  \n    }  \n    \n\n#### Step 9: Session Establishedâ€‹\n\n  * All subsequent requests signed with `session_private_key`\n  * The clearnode enforces allowances and expiration\n  * No main wallet interaction required until session expires\n\n### Key Pointsâ€‹\n\nSession Security\n\n  * Session private key **NEVER** leaves the client\n  * Main wallet only signs once (`auth_request`)\n  * All subsequent operations use session key\n  * Allowances prevent unlimited spending\n  * Challenge-response prevents replay attacks\n\n**Related Methods** : [`auth_request`](/docs/off-chain/authentication#step-1-auth_request), [`auth_challenge`](/docs/off-chain/authentication#step-2-auth_challenge), [`auth_verify`](/docs/off-chain/authentication#step-3-auth_verify)\n\n* * *\n\nSummary: This component defines the authentication handshake between a client and a Clearnode to establish a secure session via session key delegation and EIP-712 signature verification. It enables users to authorize specific actions and asset allowances for a temporary session key, ensuring secure off-chain interactions without exposing the main wallet's private key.\n\nRelated terms: login, session key, EIP-712, JWT, authentication, Clearnode, challenge-response, wallet delegation, auth_verify, signature verification, off-chain session, token issuance, auth_request\n\nUse cases: Session key delegation for dApps, Scoped asset allowance authorization, Secure off-chain service authentication, Non-custodial session management",
    "metadata": {
      "title": "Cross-Layer Communication Flows | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/communication-flows",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the authentication handshake between a client and a Clearnode to establish a secure session via session key delegation and EIP-712 signature verification. It enables users to authorize specific actions and asset allowances for a temporary session key, ensuring secure off-chain interactions without exposing the main wallet's private key.",
      "keywords": [
        "login",
        "session key",
        "EIP-712",
        "JWT",
        "authentication",
        "Clearnode",
        "challenge-response",
        "wallet delegation",
        "auth_verify",
        "signature verification",
        "off-chain session",
        "token issuance",
        "auth_request"
      ],
      "function_name": "auth_verify",
      "intent": "concept",
      "use_cases": [
        "Session key delegation for dApps",
        "Scoped asset allowance authorization",
        "Secure off-chain service authentication",
        "Non-custodial session management"
      ],
      "function_names": [
        "signatureauth_verify",
        "challenge_message",
        "user_wallet_address",
        "auth_verify",
        "existing_jwt"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Channel Creation Flowâ€‹\n\n\n### Purposeâ€‹\n\nOpen a payment channel with zero initial balance; fund it later via `resize_channel`.\n\n### Actorsâ€‹\n\n  * **Client** : User application or SDK\n  * **Clearnode** : Off-chain service provider\n  * **Smart Contract** : Custody Contract\n  * **Blockchain** : Ethereum-compatible network\n\n### Sequence Diagramâ€‹\n\nBlockchainClearnodeClientBlockchainClearnodeClientOff-Chain Preparation2\\. Prepare Channel3\\. Validate & SignOn-Chain ExecutionChannel is now ACTIVEcreate_channel(chain_id, token)Generate unique nonceCreate channel configCreate initial state (intent: INITIALIZE, version: 0, zero allocations)Pack & sign state{channel_id, channel, state, server_signature}Verify Clearnode signatureSign packed state with user keyCustody.create(channel, state, sig_user, sig_clearnode)Verify signaturesCreate channel (zero balance)Set status to OPEN/ACTIVEEmit Opened eventOpened event (monitored)Opened event\n\n### Stepsâ€‹\n\n#### Step 1: Client â†’ Clearnode: `create_channel`â€‹\n\nClient requests channel creation:\n    \n    \n    Request:  \n    {  \n      chain_id: 137  // Polygon  \n      token: \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\"  // USDC  \n    }  \n    Signature: session key signature  \n    \n\n#### Step 2: Clearnode Processes Requestâ€‹\n\nThe clearnode:\n\n  * Validates token is supported on chain\n  * Generates unique nonce\n  * Selects adjudicator (SimpleConsensus for payment channels)\n  * Creates Channel struct\n  * Computes `channelId` = `keccak256(abi.encode(Channel))`\n  * Creates initial State with `intent: INITIALIZE`, `version: 0`, `state_data: \"0x\"`, zero allocations\n  * Packs state (`abi.encode(channelId, intent, version, data, allocations)` in Solidity terms)\n  * Signs packed state with clearnode's participant key\n\n#### Step 3: Clearnode â†’ Client: Responseâ€‹\n    \n    \n    Response:  \n    {  \n      channel: {  \n        participants: [user_address, clearnode_address]  \n        adjudicator: 0xSimpleConsensusAddress  \n        challenge: 86400  \n        nonce: 1699123456789  \n      }  \n      state: {  \n        intent: INITIALIZE  \n        version: 0  \n        data: \"0x\"  \n        allocations: [  \n          {destination: user_address, token: usdc, amount: 0},  \n          {destination: clearnode_address, token: usdc, amount: 0}  \n        ]  \n      }  \n      server_signature: \"0xClearnodeSig...\"  \n      channel_id: \"0xChannelId...\"  \n    }  \n    \n\nClearnode Signs First\n\nThe clearnode provides its signature **BEFORE** the user commits funds on-chain. This ensures both parties have committed before any on-chain transaction occurs.\n\n#### Steps 4-5: Client Validates and Signsâ€‹\n\nClient:\n\n  * Recomputes `channelId` and verifies it matches\n  * Recomputes packed state and verifies clearnode signature\n  * Signs packed state with user's participant key\n\n#### Step 6: Client â†’ Blockchain: `Custody.create()`â€‹\n\nClient submits transaction:\n    \n    \n    Custody.create(channel, state, userSig, serverSig)  \n    \n\n#### Step 7: Blockchain Validates and Creates Channelâ€‹\n\nContract:\n\n  * Verifies user's signature is valid\n  * Verifies clearnode's signature is valid\n  * Stores channel parameters and funding state (zero balances)\n  * Sets channel status to `OPEN`\n  * Emits `Opened` event\n\n#### Step 8: Event Listener Detects Creationâ€‹\n\nThe clearnode's event listener:\n\n  * Detects `Opened` event\n  * Validates channel parameters\n\n#### Steps 9-10: Notificationsâ€‹\n\nThe clearnode:\n\n  * Updates internal database: channel status = open (zero balance)\n  * Sends `channel_update` notification to client\n\n#### Step 11: Channel Activeâ€‹\n\n  * Channel active with zero balance\n  * Use `resize_channel` to fund the channel\n\n### Key Pointsâ€‹\n\nTwo-Phase Process\n\n  * **Off-chain preparation** : Clearnode prepares and signs channel configuration\n  * **On-chain execution** : User submits transaction to lock funds\n  * This ensures clearnode is ready to join before user risks funds\n\n**Related Methods** : [`create_channel`](/docs/off-chain/channel-methods#create_channel)\n\n* * *\n\nSummary: This component defines the sequence for establishing an off-chain payment channel with zero initial balance, coordinating state signing between the client and Clearnode before on-chain registration. It ensures both parties agree on the initial channel configuration and adjudicator settings before committing to the blockchain.\n\nRelated terms: open channel, create_channel, payment channel, state channel, off-chain, on-chain, clearnode, session key, digital signature, keccak256, adjudicator, smart contract, layer 2, channel setup, create_chanel\n\nUse cases: high-frequency micropayments, off-chain trading session initialization, secure peer-to-provider payment link",
    "metadata": {
      "title": "Cross-Layer Communication Flows | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/communication-flows",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the sequence for establishing an off-chain payment channel with zero initial balance, coordinating state signing between the client and Clearnode before on-chain registration. It ensures both parties agree on the initial channel configuration and adjudicator settings before committing to the blockchain.",
      "keywords": [
        "open channel",
        "create_channel",
        "payment channel",
        "state channel",
        "off-chain",
        "on-chain",
        "clearnode",
        "session key",
        "digital signature",
        "keccak256",
        "adjudicator",
        "smart contract",
        "layer 2",
        "channel setup",
        "create_chanel"
      ],
      "function_name": "create_channel",
      "intent": "concept",
      "use_cases": [
        "high-frequency micropayments",
        "off-chain trading session initialization",
        "secure peer-to-provider payment link"
      ],
      "function_names": [
        "sig_clearnode",
        "keccak256",
        "sig_user",
        "create_channel",
        "resize_channel"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Off-Chain Transfer Flowâ€‹\n\n\n### Purposeâ€‹\n\nTransfer funds between users instantly without blockchain transaction.\n\n### Actorsâ€‹\n\n  * **Sender (Client A)** : Initiating user\n  * **Clearnode** : Off-chain service provider\n  * **Receiver (Client B)** : Receiving user\n\n### Sequence Diagramâ€‹\n\nClient BClearnodeClient AClient BClearnodeClient A2\\. Validate Request3\\. Update Ledger4\\. Notify ReceiverComplete: < 1 second, zero gastransfer(destination, amount, asset)Check A authenticatedCheck A has sufficient balanceCheck B exists (has channel)Debit entry (A: -50 USDC)Credit entry (B: +50 USDC)Create transaction recordTransfer confirmed âœ“transfer_received eventbalance_update event\n\n### Stepsâ€‹\n\n#### Step 1: Client A â†’ Clearnode: `transfer`â€‹\n\nSender initiates transfer:\n    \n    \n    Request:  \n    {  \n      destination: \"0xClientB_Address\",   // or destination_user_tag: \"UX123D\"  \n      allocations: [{\"asset\": \"usdc\", \"amount\": \"50.0\"}]  \n    }  \n    Signature: Client A's session key  \n    \n\n#### Step 2: Clearnode Validatesâ€‹\n\nThe clearnode validates:\n\n  * Client A is authenticated\n  * Client A has >= 50 USDC available balance\n  * Destination address/tag is valid (account is created if new)\n  * Asset \"usdc\" is supported\n\n#### Step 3: Clearnode Creates Ledger Entriesâ€‹\n\nDouble-entry bookkeeping:\n\n**Entry 1 (Debit from Client A unified account)** :\n    \n    \n    {  \n      account_id: Client A address  \n      asset: \"usdc\"  \n      credit: \"0.0\"  \n      debit: \"50.0\"  \n    }  \n    \n\n**Entry 2 (Credit to Client B unified account)** :\n    \n    \n    {  \n      account_id: Client B address  \n      asset: \"usdc\"  \n      credit: \"50.0\"  \n      debit: \"0.0\"  \n    }  \n    \n\n#### Step 4: Clearnode Creates Transaction Recordâ€‹\n    \n    \n    {  \n      id: 1,  \n      tx_type: \"transfer\",  \n      from_account: Client A address,  \n      from_account_tag: \"NQKO7C\",  \n      to_account: Client B address,  \n      to_account_tag: \"UX123D\",  \n      asset: \"usdc\",  \n      amount: \"50.0\",  \n      created_at: \"2023-05-01T12:00:00Z\"  \n    }  \n    \n\n#### Step 5: Clearnode â†’ Client A: Responseâ€‹\n    \n    \n    Response:  \n    {  \n      transactions: [  \n        {  \n          id: 1,  \n          tx_type: \"transfer\",  \n          from_account: \"0xA...\",  \n          from_account_tag: \"NQKO7C\",  \n          to_account: \"0xB...\",  \n          to_account_tag: \"UX123D\",  \n          asset: \"usdc\",  \n          amount: \"50.0\",  \n          created_at: \"2023-05-01T12:00:00Z\"  \n        }  \n      ]  \n    }  \n    \n\n#### Step 6-7: Clearnode â†’ Clients: Notificationsâ€‹\n\n  * `tr` (transfer) notification to sender/receiver with `transactions` array\n  * `bu` (balance update) notification reflecting new balances\n\n#### Step 9: Transfer Completeâ€‹\n\n  * Instant (< 1 second)\n  * No blockchain transaction\n  * Zero gas fees\n  * Both parties notified\n\n### Key Pointsâ€‹\n\nInstant Settlement\n\n  * **Purely off-chain** : Database transaction, no blockchain\n  * **Instant settlement** : < 1 second typical\n  * **Zero gas fees** : No on-chain transaction required\n  * **Double-entry bookkeeping** : Accounting accuracy guaranteed\n  * **Receiver account auto-created** : Destination tag/address need not have a prior balance\n\n**Related Methods** : [`transfer`](/docs/off-chain/transfers#transfer)\n\n* * *\n\nSummary: Facilitates instant, zero-gas off-chain asset transfers between users by utilizing a Clearnode to perform atomic ledger updates and internal transaction recording without immediate blockchain settlement.\n\nRelated terms: off-chain transfer, instant payment, zero gas, Clearnode, ledger update, double-entry bookkeeping, P2P, internal transfer, session key signing, asset allocation, balance_update, cross-layer, yellow network, transfer_received, gasless\n\nUse cases: instant peer-to-peer payments, gasless microtransactions, internal platform asset rebalancing",
    "metadata": {
      "title": "Cross-Layer Communication Flows | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/communication-flows",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Facilitates instant, zero-gas off-chain asset transfers between users by utilizing a Clearnode to perform atomic ledger updates and internal transaction recording without immediate blockchain settlement.",
      "keywords": [
        "off-chain transfer",
        "instant payment",
        "zero gas",
        "Clearnode",
        "ledger update",
        "double-entry bookkeeping",
        "P2P",
        "internal transfer",
        "session key signing",
        "asset allocation",
        "balance_update",
        "cross-layer",
        "yellow network",
        "transfer_received",
        "gasless"
      ],
      "function_name": "transfer",
      "intent": "concept",
      "use_cases": [
        "instant peer-to-peer payments",
        "gasless microtransactions",
        "internal platform asset rebalancing"
      ],
      "function_names": [
        "from_account",
        "destination_user_tag",
        "from_account_tag",
        "eventbalance_update",
        "to_account"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## App Session Lifecycle Flowâ€‹\n\n\n### Purposeâ€‹\n\nCreate, update, and close a collaborative app session with multiple participants.\n\n### Actorsâ€‹\n\n  * **Client A** : Participant 1\n  * **Client B** : Participant 2\n  * **Clearnode** : Off-chain service provider\n\n### Scenarioâ€‹\n\nTwo-player chess game with 100 USDC stake each.\n\n### Sequence Diagramâ€‹\n\nClearnodeClient BClient AClearnodeClient BClient ACreate (lock funds)Update (submit_app_state)Closecreate_app_session(definition, allocations, session_data?)co-sign (if non-zero allocation)Validate quorum, balances, allowancesLock allocations from unified balances{app_session_id, status:\"open\", version:1}asu/bu notificationssubmit_app_state(app_session_id, intent, version, allocations, session_data?)co-signs to meet quorumValidate intent rules, version, quorum, allowancesApply operate/deposit/withdraw{app_session_id, status:\"open\", version:n}asu/bu notificationsclose_app_session(app_session_id, allocations, session_data?)co-signs to meet quorumValidate sums and quorum, release to unified balances{app_session_id, status:\"closed\", version:n+1}asu/bu notifications\n\n### Sequence (Create â†’ Update â†’ Close)â€‹\n\n  1. **Create (off-chain):`create_app_session`**\n\n     * Client signs request (all participants with non-zero allocations must sign).\n     * Clearnode validates protocol version (0.2/0.4), quorum, balances, allowances/session keys.\n     * Funds are locked from each signerâ€™s unified balance into the app session account.\n     * **Response (minimal)** : `app_session_id`, `status: \"open\"`, `version: 1`. Full metadata is not echoed; use `get_app_sessions` to read it.\n\n**Example Request** :\n    \n    {  \n      \"req\": [1,\"create_app_session\",{  \n        \"definition\": {  \n          \"protocol\": \"NitroRPC/0.4\",  \n          \"participants\": [\"0xA\",\"0xB\"],  \n          \"weights\": [100,100],  \n          \"quorum\": 200,  \n          \"challenge\": 86400,  \n          \"nonce\": 1699123  \n        },  \n        \"allocations\": [  \n          {\"participant\": \"0xA\",\"asset\": \"usdc\",\"amount\": \"100.0\"},  \n          {\"participant\": \"0xB\",\"asset\": \"usdc\",\"amount\": \"100.0\"}  \n        ],  \n        \"session_data\": \"{\\\"game\\\":\\\"chess\\\"}\"  \n      },1699123456789],  \n      \"sig\": [\"0xUserSig\",\"0xCoSig\"]  \n    }  \n    \n\n  2. **State Updates (off-chain):`submit_app_state`**\n\n     * v0.4 requires `version = current+1`; v0.2 rejects `intent`/`version` and only allows a single update.\n     * Intents:\n       * `operate`: redistribute, sum must stay equal.\n       * `deposit`: sum must increase; depositor must sign and have available unified balance.\n       * `withdraw`: sum must decrease; session must have funds.\n     * Quorum required; session-key allowances enforced.\n     * **Response (minimal)** : `app_session_id`, `status: \"open\"`, `version` (new). No metadata echoed.\n     * Notifications: `asu` (app session update) + `bu` (balance update for deposit/withdraw).\n\n**Example Request (deposit v0.4)** :\n    \n    {  \n      \"req\": [2,\"submit_app_state\",{  \n        \"app_session_id\": \"0xSession\",  \n        \"intent\": \"deposit\",  \n        \"version\": 2,  \n        \"allocations\": [  \n          {\"participant\": \"0xA\",\"asset\": \"usdc\",\"amount\": \"150.0\"},  \n          {\"participant\": \"0xB\",\"asset\": \"usdc\",\"amount\": \"100.0\"}  \n        ]  \n      },1699123456790],  \n      \"sig\": [\"0xUserSig\",\"0xCoSig\"]  \n    }  \n    \n\n  3. **Close (off-chain):`close_app_session`**\n\n     * Requires quorum signatures; final allocations must match total balances.\n     * **Response (minimal)** : `app_session_id`, `status: \"closed\"`, `version` (incremented). No metadata echoed.\n     * Funds are released to participantsâ€™ unified balances; notifications `asu` and `bu` are sent.\n\n**Example Request** :\n    \n    {  \n      \"req\": [3,\"close_app_session\",{  \n        \"app_session_id\": \"0xSession\",  \n        \"allocations\": [  \n          {\"participant\": \"0xA\",\"asset\": \"usdc\",\"amount\": \"180.0\"},  \n          {\"participant\": \"0xB\",\"asset\": \"usdc\",\"amount\": \"20.0\"}  \n        ]  \n      },1699123456795],  \n      \"sig\": [\"0xUserSig\",\"0xCoSig\"]  \n    }  \n    \n\n\n### Key Pointsâ€‹\n\nApp Sessions\n\nApp sessions enable multi-party applications with custom governance rules. Funds are locked from unified balance for the duration of the session.\n\n**Related Methods** : [`create_app_session`](/docs/off-chain/app-sessions#create_app_session), [`submit_app_state`](/docs/off-chain/app-sessions#submit_app_state), [`close_app_session`](/docs/off-chain/app-sessions#close_app_session)\n\n* * *\n\nSummary: Manages the end-to-end lifecycle of multi-party collaborative sessions, facilitating secure off-chain state transitions, fund locking, and final settlement via a Clearnode service provider.\n\nRelated terms: app session, state channel, off-chain, fund locking, multi-party, session lifecycle, create_app_session, submit_app_state, close_app_session, Clearnode, unified balance, co-signing, quorum, nitro protocol, yellow network\n\nUse cases: multi-player gaming with stakes, collaborative DeFi applications, state channel payments, escrow-based services",
    "metadata": {
      "title": "Cross-Layer Communication Flows | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/communication-flows",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Manages the end-to-end lifecycle of multi-party collaborative sessions, facilitating secure off-chain state transitions, fund locking, and final settlement via a Clearnode service provider.",
      "keywords": [
        "app session",
        "state channel",
        "off-chain",
        "fund locking",
        "multi-party",
        "session lifecycle",
        "create_app_session",
        "submit_app_state",
        "close_app_session",
        "Clearnode",
        "unified balance",
        "co-signing",
        "quorum",
        "nitro protocol",
        "yellow network"
      ],
      "function_name": "create_app_session",
      "intent": "concept",
      "use_cases": [
        "multi-player gaming with stakes",
        "collaborative DeFi applications",
        "state channel payments",
        "escrow-based services"
      ],
      "function_names": [
        "submit_app_state",
        "session_data",
        "app_session_id",
        "losecreate_app_session",
        "create_app_session"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Cooperative Closure Flowâ€‹\n\n\n### Purposeâ€‹\n\nClose channel when all parties agree on final state.\n\n### Actorsâ€‹\n\n  * **Client** : User application\n  * **Clearnode** : Off-chain service provider\n  * **Smart Contract** : Custody Contract\n  * **Blockchain** : Ethereum-compatible network\n\n### Key Pointsâ€‹\n\nPreferred Method\n\nCooperative closure is **fast (1 transaction)** , **cheap (low gas)** , and **immediate (no waiting period)**. Always use this when possible.\n\n### Sequence Diagramâ€‹\n\nBlockchainClearnodeClientBlockchainClearnodeClientclose_channel(channel_id, funds_destination)Validate channel open/resizing and not challengedBuild FINALIZE state (version = current+1, data = \"0x\", allocations){channel_id, state, server_signature}Verify server_signature and sign packed stateCustody.close(channel_id, state, userSig, serverSig)Verify signatures, close channel, emit eventEvent observedUpdate DB and balancescu + bu notifications\n\n### Sequenceâ€‹\n\n  1. **Client â†’ Clearnode** : `close_channel(channel_id, funds_destination)`\n\n     * Authenticated request signed by the user (session key or wallet).\n\n**Example Request** :\n    \n    {  \n      \"req\": [10,\"close_channel\",{  \n        \"channel_id\": \"0xChannel\",  \n        \"funds_destination\": \"0xUser\"  \n      },1699123457000],  \n      \"sig\": [\"0xUserSig\"]  \n    }  \n    \n\n  2. **Clearnode** : validates channel exists and is `open`/`resizing`, checks challenged-channel guard, builds FINALIZE state:\n\n     * `intent: FINALIZE`, `version = current+1`, `state_data: \"0x\"`, allocations split between user and broker based on channel balance.\n     * Signs packed state (`keccak256(abi.encode(channelId, intent, version, data, allocations))`).\n  3. **Clearnode â†’ Client** : response with `channel_id`, `state`, `server_signature`.\n\n  4. **Client** : verifies server signature, signs the same packed state.\n\n  5. **Client â†’ Blockchain** : `Custody.close(channel_id, state, userSig, serverSig)` (one tx).\n\n  6. **Blockchain** : verifies both signatures, closes channel, emits `Closed/Opened`-equivalent event (implementation-specific), releases funds.\n\n  7. **Clearnode** : observes event, updates DB, sends `cu` (channel update) and `bu` (balance update) notifications.\n\n\n**Related Methods** : [`close_channel`](/docs/off-chain/channel-methods#close_channel)\n\n* * *\n\nSummary: This component defines the protocol for a cooperative channel closure, enabling participants to mutually sign a final state for immediate, low-cost on-chain settlement without a challenge period.\n\nRelated terms: close channel, cooperative closure, settle funds, withdraw, state channel, off-chain settlement, FINALIZE state, Custody contract, signature verification, multi-party agreement, gas optimization, immediate settlement, close_channel, exit protocol, channel termination\n\nUse cases: Finalizing a trading session to withdraw assets to a mainnet wallet, Mutual termination of a state channel to avoid dispute periods, Settling balances after a series of off-chain microtransactions",
    "metadata": {
      "title": "Cross-Layer Communication Flows | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/communication-flows",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the protocol for a cooperative channel closure, enabling participants to mutually sign a final state for immediate, low-cost on-chain settlement without a challenge period.",
      "keywords": [
        "close channel",
        "cooperative closure",
        "settle funds",
        "withdraw",
        "state channel",
        "off-chain settlement",
        "FINALIZE state",
        "Custody contract",
        "signature verification",
        "multi-party agreement",
        "gas optimization",
        "immediate settlement",
        "close_channel",
        "exit protocol",
        "channel termination"
      ],
      "function_name": "close_channel",
      "intent": "concept",
      "use_cases": [
        "Finalizing a trading session to withdraw assets to a mainnet wallet",
        "Mutual termination of a state channel to avoid dispute periods",
        "Settling balances after a series of off-chain microtransactions"
      ],
      "function_names": [
        "keccak256",
        "close_channel",
        "server_signature",
        "channel_id",
        "state_data"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Challenge-Response Closure Flowâ€‹\n\n\n### Purposeâ€‹\n\nClose channel when other party is unresponsive or disputes final state.\n\n### Actorsâ€‹\n\n  * **Client** : User application\n  * **Clearnode** : Off-chain service provider (may be unresponsive)\n  * **Smart Contract** : Custody Contract\n  * **Blockchain** : Ethereum-compatible network\n\n### Key Pointsâ€‹\n\nChallenge Period\n\nThis method requires waiting for the challenge period (typically 24 hours) to elapse. Use only when cooperative closure fails.\n\n### Sequence Diagramâ€‹\n\nOtherPartyClearnodeBlockchainClientOtherPartyClearnodeBlockchainClientHold latest signed statealt[Newer state posted]Wait for challenge period expiryCustody.challenge(channelId, state, sigs)Start challenge timer (challenge period)Custody.checkpoint(channelId, newerState, sigs)Replace pending stateCustody.close(channelId, state, sigs) // after timeout if uncontestedFinalize channel, emit eventEvent observed when back onlineUpdate DB, balancescu + bu notifications\n\n### Sequence (User-initiated, clearnode unresponsive)â€‹\n\n  1. **Prerequisite** : User holds the latest mutually signed state (or clearnode-signed latest) for the channel.\n  2. **Client â†’ Blockchain** : `Custody.challenge(channelId, state, sigs...)`\n     * Submits the latest signed state to start the challenge.\n  3. **Challenge Window** : Other party can respond with a newer valid state before timeout.\n  4. **If no newer state is posted** : After the challenge period, user calls `Custody.close(channelId, state, sigs...)` to finalize.\n  5. **Blockchain** : finalizes channel, releases funds per challenged state, emits closure event.\n  6. **Clearnode** (when responsive again): observes event, updates DB, sends `cu`/`bu` notifications to participants.\n\n**Related Methods** : On-chain `Custody.challenge()` and `Custody.close()`\n\n* * *\n\nSummary: Defines the non-cooperative channel closure protocol used to settle funds on-chain when a counterparty is unresponsive or a state dispute arises. It utilizes a time-locked challenge window to ensure the most recent valid state is used for final settlement.\n\nRelated terms: force close, dispute resolution, challenge period, unresponsive node, on-chain settlement, Custody contract, state update, channel closure, timeout, exit mechanism, non-cooperative, Ethereum, layer 2\n\nUse cases: recovering funds from offline provider, resolving state disputes, unilateral channel exit",
    "metadata": {
      "title": "Cross-Layer Communication Flows | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/communication-flows",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the non-cooperative channel closure protocol used to settle funds on-chain when a counterparty is unresponsive or a state dispute arises. It utilizes a time-locked challenge window to ensure the most recent valid state is used for final settlement.",
      "keywords": [
        "force close",
        "dispute resolution",
        "challenge period",
        "unresponsive node",
        "on-chain settlement",
        "Custody contract",
        "state update",
        "channel closure",
        "timeout",
        "exit mechanism",
        "non-cooperative",
        "Ethereum",
        "layer 2"
      ],
      "function_name": "Custody.challenge",
      "intent": "concept",
      "use_cases": [
        "recovering funds from offline provider",
        "resolving state disputes",
        "unilateral channel exit"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nNow that you understand how all protocol layers work together:\n\n  1. **Review Method Details** : Visit Part 2 (Off-Chain RPC Protocol) for complete method specifications\n  2. **Explore Reference** : See [Protocol Reference](/docs/protocol/protocol-reference) for constants and standards\n  3. **Implementation Guide** : Check [Implementation Checklist](/docs/protocol/implementation-checklist) for best practices\n  4. **Quick Start** : Follow the [Quick Start Guide](/docs/protocol/quick-start) to begin building\n\nComplete Flows\n\nThese flows represent the most common operations. For edge cases and error handling, consult the specific method documentation in Part 2.\n\n\n\n[PreviousQuery Methods & Notifications](/docs/protocol/off-chain/queries)[NextProtocol Reference](/docs/protocol/protocol-reference)\n\n  * Authentication Flow\n    * Purpose\n    * Actors\n    * Sequence Diagram\n    * Steps\n    * Key Points\n  * Channel Creation Flow\n    * Purpose\n    * Actors\n    * Sequence Diagram\n    * Steps\n    * Key Points\n  * Off-Chain Transfer Flow\n    * Purpose\n    * Actors\n    * Sequence Diagram\n    * Steps\n    * Key Points\n  * App Session Lifecycle Flow\n    * Purpose\n    * Actors\n    * Scenario\n    * Sequence Diagram\n    * Sequence (Create â†’ Update â†’ Close)\n    * Key Points\n  * Cooperative Closure Flow\n    * Purpose\n    * Actors\n    * Key Points\n    * Sequence Diagram\n    * Sequence\n  * Challenge-Response Closure Flow\n    * Purpose\n    * Actors\n    * Key Points\n    * Sequence Diagram\n    * Sequence (User-initiated, clearnode unresponsive)\n  * Next Steps\n\nSummary: This section provides a high-level overview of the interaction sequences between protocol layers, covering essential operations like authentication, channel management, and state transitions.\n\nRelated terms: cross-layer communication, authentication flow, channel creation, off-chain transfer, app session lifecycle, cooperative closure, challenge-response, sequence diagrams, protocol layers, state updates, settlement, transaction flow, clearing node, p2p communication\n\nUse cases: Establishing secure peer-to-peer communication channels, Executing fast off-chain asset transfers, Managing decentralized application session lifecycles, Resolving disputes through challenge-response mechanisms",
    "metadata": {
      "title": "Cross-Layer Communication Flows | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/communication-flows",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section provides a high-level overview of the interaction sequences between protocol layers, covering essential operations like authentication, channel management, and state transitions.",
      "keywords": [
        "cross-layer communication",
        "authentication flow",
        "channel creation",
        "off-chain transfer",
        "app session lifecycle",
        "cooperative closure",
        "challenge-response",
        "sequence diagrams",
        "protocol layers",
        "state updates",
        "settlement",
        "transaction flow",
        "clearing node",
        "p2p communication"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Establishing secure peer-to-peer communication channels",
        "Executing fast off-chain asset transfers",
        "Managing decentralized application session lifecycles",
        "Resolving disputes through challenge-response mechanisms"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Glossary\n\n\n\n# Glossary\n\nComplete alphabetical reference of all protocol terms and concepts.\n\nQuick Reference\n\nThis glossary provides concise definitions of all Nitrolite protocol terms. For detailed explanations with examples and diagrams, see the respective sections in the documentation.\n\n* * *\n\nSummary: Provides a comprehensive alphabetical reference of all terms, concepts, and technical vocabulary used within the Nitrolite protocol and Yellow Network ecosystem.\n\nRelated terms: glossary, definitions, terminology, dictionary, reference, Nitrolite, protocol terms, concepts, vocabulary, documentation, help, explanation, yellow network, crypto terms, sdk reference\n\nUse cases: onboarding new developers to the SDK, clarifying protocol-specific terminology, standardizing technical communication across teams",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a comprehensive alphabetical reference of all terms, concepts, and technical vocabulary used within the Nitrolite protocol and Yellow Network ecosystem.",
      "keywords": [
        "glossary",
        "definitions",
        "terminology",
        "dictionary",
        "reference",
        "Nitrolite",
        "protocol terms",
        "concepts",
        "vocabulary",
        "documentation",
        "help",
        "explanation",
        "yellow network",
        "crypto terms",
        "sdk reference"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "onboarding new developers to the SDK",
        "clarifying protocol-specific terminology",
        "standardizing technical communication across teams"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Aâ€‹\n\n\n### Adjudicatorâ€‹\n\nSmart contract that validates state transitions according to application-specific rules. Each channel specifies an adjudicator that determines which state updates are valid.\n\n**Examples** : SimpleConsensus, RemittanceAdjudicator\n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures), [Security Considerations](/docs/protocol/on-chain/security)\n\n* * *\n\n### Allocationâ€‹\n\nSpecification of how funds are distributed, containing destination, token, and amount. Allocations define where funds should be sent when a channel closes or how they're distributed within an app session.\n\n**Structure** :\n    \n    \n    {  \n      destination: address,  // Recipient wallet address  \n      token: address,        // ERC-20 token contract  \n      amount: uint256        // Amount in smallest unit  \n    }  \n    \n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures#allocation)\n\n* * *\n\n### App Sessionâ€‹\n\nOff-chain channels built on top of payment channels, intended to be used by app developers to enable application-specific interactions and transactions without touching the blockchain. Previously known as Virtual Ledger Channels (VLC).\n\n**Features** :\n\n  * Multi-party participation\n  * Custom governance rules (quorum, weights)\n  * Fund locking from unified balance\n  * Application-specific state management\n\n**Related** : [App Sessions Methods](/docs/off-chain/app-sessions), [Communication Flows](/docs/protocol/communication-flows#app-session-lifecycle-flow)\n\n* * *\n\nSummary: Defines the fundamental architectural building blocks of the Yellow Network protocol, specifically covering state validation mechanisms, fund distribution structures, and off-chain application layers.\n\nRelated terms: Adjudicator, Allocation, App Session, Virtual Ledger Channel, VLC, state transition, fund distribution, off-chain channel, multi-party, ERC-20, smart contract validation, payment channel, state management, quorum\n\nUse cases: Defining fund distribution logic for channel closure, Implementing custom application logic in off-chain sessions, Validating state transitions via smart contracts, Managing multi-party transactions without on-chain overhead",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the fundamental architectural building blocks of the Yellow Network protocol, specifically covering state validation mechanisms, fund distribution structures, and off-chain application layers.",
      "keywords": [
        "Adjudicator",
        "Allocation",
        "App Session",
        "Virtual Ledger Channel",
        "VLC",
        "state transition",
        "fund distribution",
        "off-chain channel",
        "multi-party",
        "ERC-20",
        "smart contract validation",
        "payment channel",
        "state management",
        "quorum"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Defining fund distribution logic for channel closure",
        "Implementing custom application logic in off-chain sessions",
        "Validating state transitions via smart contracts",
        "Managing multi-party transactions without on-chain overhead"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Câ€‹\n\n\n### Challenge Periodâ€‹\n\nDuration (in seconds) that parties have to respond to a dispute. When a channel is challenged, all participants have this amount of time to submit a newer state before the challenged state becomes final.\n\n**Typical Values** :\n\n  * Default: 86400 seconds (24 hours)\n  * Minimum recommended: 3600 seconds (1 hour)\n  * Maximum recommended: 604800 seconds (7 days)\n\n**Related** : [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle#closure---challenge-response)\n\n* * *\n\n### Channelâ€‹\n\nA secure communication pathway between participants that locks funds in an on-chain smart contract while enabling off-chain state updates. Channels are the foundation of the Nitrolite protocol.\n\n**Lifecycle** : VOID â†’ INITIAL â†’ ACTIVE â†’ (DISPUTE) â†’ FINAL\n\n**Related** : [On-Chain Protocol](/docs/protocol/on-chain/overview), [Data Structures](/docs/protocol/on-chain/data-structures#channel)\n\n* * *\n\n### channelIdâ€‹\n\nA unique identifier for a channel, formatted as a 0x-prefixed hex string (32 bytes). Computed deterministically from the channel configuration.\n\n**Computation** :\n    \n    \n    channelId = keccak256(abi.encode(  \n      channel.participants,  \n      channel.adjudicator,  \n      channel.challenge,  \n      channel.nonce  \n    ))  \n    \n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures#channel-identifier)\n\n* * *\n\n### Checkpointâ€‹\n\nRecording a state on-chain without entering dispute mode. Checkpointing creates an on-chain record of the current state but keeps the channel in ACTIVE status.\n\n**Benefits** :\n\n  * Shortens effective challenge history\n  * Provides on-chain proof of state\n  * Doesn't start challenge period\n\n**Related** : [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle#checkpointing)\n\n* * *\n\n### Clearnodeâ€‹\n\nA virtual ledger layer that provides a unified ledger (through Nitro RPC) and coordinates state channels (through Nitrolite), providing chain abstraction for developers and users.\n\n**Responsibilities** :\n\n  * Manage off-chain RPC protocol\n  * Provide unified balance\n  * Join payment channels\n  * Coordinate app sessions\n\n**Related** : [Architecture](/docs/protocol/architecture), [Off-Chain RPC Protocol](/docs/off-chain/overview)\n\n* * *\n\n### Creatorâ€‹\n\nThe participant at index 0 in a channel who initiates channel creation. The Creator constructs the channel configuration, prepares the initial funding state, signs it (signature at position 0), and calls the on-chain `create()` function to lock their funds and establish the channel.\n\n**Typically** : A user or light client opening a payment channel with a clearnode.\n\n**Related** : [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle#creation-phase), [Protocol Reference](/docs/protocol/protocol-reference#participant-indices)\n\n* * *\n\n### Custody Contractâ€‹\n\nThe main on-chain contract implementing channel creation, joining, closure, and resizing. It is an implementation of the Nitrolite protocol.\n\n**Interfaces Implemented** :\n\n  * `IChannel` \\- Core channel operations\n  * `IDeposit` \\- Fund management\n  * `IChannelReader` \\- State queries\n\n**Related** : [On-Chain Overview](/docs/protocol/on-chain/overview), [Data Structures](/docs/protocol/on-chain/data-structures)\n\n* * *\n\nSummary: Defines fundamental concepts of the Yellow Network protocol, including state channel mechanics, dispute resolution windows, and the Clearnode coordination layer.\n\nRelated terms: challenge period, state channel, channelId, checkpoint, Clearnode, dispute resolution, off-chain, on-chain, Nitrolite, ledger, chain abstraction, keccak256, smart contract, channel lifecycle\n\nUse cases: resolving channel disputes, tracking off-chain state, implementing chain-agnostic ledgers, calculating channel identifiers",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines fundamental concepts of the Yellow Network protocol, including state channel mechanics, dispute resolution windows, and the Clearnode coordination layer.",
      "keywords": [
        "challenge period",
        "state channel",
        "channelId",
        "checkpoint",
        "Clearnode",
        "dispute resolution",
        "off-chain",
        "on-chain",
        "Nitrolite",
        "ledger",
        "chain abstraction",
        "keccak256",
        "smart contract",
        "channel lifecycle"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "resolving channel disputes",
        "tracking off-chain state",
        "implementing chain-agnostic ledgers",
        "calculating channel identifiers"
      ],
      "function_names": [
        "create"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Iâ€‹\n\n\n### Intentâ€‹\n\nIn NitroRPC/0.4, specifies the type of app session state update. The intent system enables dynamic fund management within active sessions.\n\n**Types** :\n\n  * **OPERATE** : Redistribute existing funds (sum unchanged)\n  * **DEPOSIT** : Add funds to session from unified balance\n  * **WITHDRAW** : Remove funds from session to unified balance\n\n**Related** : [App Sessions](/docs/off-chain/app-sessions#submit_app_state)\n\n* * *\n\nSummary: Defines the 'Intent' parameter in NitroRPC state updates, which facilitates dynamic fund management within active app sessions through operations like redistribution, deposits, and withdrawals.\n\nRelated terms: Intent, NitroRPC, state update, fund management, OPERATE, DEPOSIT, WITHDRAW, session balance, liquidity management, app session, off-chain state, balance adjustment, dynamic funding, Yellow Network, Nitro RPC\n\nUse cases: dynamic session funding, rebalancing session liquidity, withdrawing profits from active session, depositing collateral to existing channel",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the 'Intent' parameter in NitroRPC state updates, which facilitates dynamic fund management within active app sessions through operations like redistribution, deposits, and withdrawals.",
      "keywords": [
        "Intent",
        "NitroRPC",
        "state update",
        "fund management",
        "OPERATE",
        "DEPOSIT",
        "WITHDRAW",
        "session balance",
        "liquidity management",
        "app session",
        "off-chain state",
        "balance adjustment",
        "dynamic funding",
        "Yellow Network",
        "Nitro RPC"
      ],
      "function_name": "submit_app_state",
      "intent": "concept",
      "use_cases": [
        "dynamic session funding",
        "rebalancing session liquidity",
        "withdrawing profits from active session",
        "depositing collateral to existing channel"
      ],
      "function_names": [
        "submit_app_state"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Lâ€‹\n\n\n### Ledger Entryâ€‹\n\nDouble-entry bookkeeping record of a debit or credit. Every financial operation in a clearnode creates two ledger entries to maintain accounting accuracy.\n\n**Fields** :\n\n  * account_id\n  * asset\n  * credit (incoming)\n  * debit (outgoing)\n  * created_at\n\n**Related** : [Transfers](/docs/off-chain/transfers#off-chain-processing), [Query Methods](/docs/off-chain/queries#get_ledger_entries)\n\n* * *\n\n### Ledger Transactionâ€‹\n\nUser-facing transaction record showing transfers, deposits, withdrawals, and app session operations. Provides a simplified view of financial activity.\n\n**Types** :\n\n  * `transfer` \\- Direct transfer between users\n  * `deposit` \\- Funds deposited to unified balance\n  * `withdrawal` \\- Funds withdrawn from unified balance\n  * `app_deposit` \\- Funds locked in app session\n  * `app_withdrawal` \\- Funds released from app session\n\n**Related** : [Query Methods](/docs/off-chain/queries#get_ledger_transactions)\n\n* * *\n\nSummary: Defines the fundamental accounting structures for the Yellow Network, distinguishing between internal double-entry ledger records and user-facing transaction types for tracking financial activity.\n\nRelated terms: ledger, bookkeeping, debit, credit, transaction history, audit trail, financial record, app session, fund locking, unified balance, account activity, ledger entry, ledger transaction, clearnode\n\nUse cases: auditing financial activity, reconciling account balances, tracking app session fund locks, generating user transaction history",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the fundamental accounting structures for the Yellow Network, distinguishing between internal double-entry ledger records and user-facing transaction types for tracking financial activity.",
      "keywords": [
        "ledger",
        "bookkeeping",
        "debit",
        "credit",
        "transaction history",
        "audit trail",
        "financial record",
        "app session",
        "fund locking",
        "unified balance",
        "account activity",
        "ledger entry",
        "ledger transaction",
        "clearnode"
      ],
      "function_name": "get_ledger_transactions",
      "intent": "concept",
      "use_cases": [
        "auditing financial activity",
        "reconciling account balances",
        "tracking app session fund locks",
        "generating user transaction history"
      ],
      "function_names": [
        "app_deposit",
        "app_withdrawal",
        "get_ledger_transactions",
        "created_at",
        "account_id"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Mâ€‹\n\n\n### Magic Numberâ€‹\n\nConstant in `state.data` signaling special states. Magic numbers enable smart contracts to identify the type of state without complex parsing.\n\n**Values** :\n\n  * **CHANOPEN** = 7877 (0x1EC5) - Initial funding state\n  * **CHANCLOSE** = 7879 (0x1EC7) - Final closing state\n\n**Related** : [Protocol Reference](/docs/protocol/protocol-reference#magic-numbers), [Data Structures](/docs/protocol/on-chain/data-structures)\n\n* * *\n\nSummary: Defines constant identifiers used in state data to signal specific channel lifecycle events, such as opening or closing, allowing smart contracts to efficiently recognize state types.\n\nRelated terms: Magic Number, CHANOPEN, CHANCLOSE, state.data, channel state, smart contract constants, state identification, protocol constants, 0x1EC5, 0x1EC7, channel funding, channel closing, state machine, hex codes, state transition\n\nUse cases: Identifying channel initialization, Signaling final settlement, Optimizing smart contract state parsing",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines constant identifiers used in state data to signal specific channel lifecycle events, such as opening or closing, allowing smart contracts to efficiently recognize state types.",
      "keywords": [
        "Magic Number",
        "CHANOPEN",
        "CHANCLOSE",
        "state.data",
        "channel state",
        "smart contract constants",
        "state identification",
        "protocol constants",
        "0x1EC5",
        "0x1EC7",
        "channel funding",
        "channel closing",
        "state machine",
        "hex codes",
        "state transition"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Identifying channel initialization",
        "Signaling final settlement",
        "Optimizing smart contract state parsing"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Nâ€‹\n\n\n### Nonceâ€‹\n\nUnique number ensuring channel identifier uniqueness. Even with identical participants and configuration, different nonces create different channel IDs.\n\n**Typical Value** : Timestamp in milliseconds\n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures#channel), [Channel Creation](/docs/off-chain/channel-methods#create_channel)\n\n* * *\n\n### Nitro RPCâ€‹\n\nThe off-chain communication protocol for state channel operations. A lightweight, RPC-based RPC protocol with compact message format and signature-based authentication.\n\n**Versions** :\n\n  * **NitroRPC/0.2** : Legacy (basic state updates)\n  * **NitroRPC/0.4** : Current (intent system)\n\n**Related** : [Off-Chain RPC Protocol](/docs/off-chain/overview), [Message Format](/docs/off-chain/message-format)\n\n* * *\n\n### Nitroliteâ€‹\n\nThe on-chain smart contract protocol for state channels. Defines the structure of channels, states, and the rules for creation, updates, and closure.\n\n**Version** : 0.5.0 (Mainnet deployments live; not production yet)\n\n**Related** : [On-Chain Protocol](/docs/protocol/on-chain/overview), [Protocol Reference](/docs/protocol/protocol-reference#protocol-versions)\n\n* * *\n\nSummary: This glossary defines the foundational architectural elements of the Yellow Network, specifically the Nitro RPC off-chain communication protocol, the Nitrolite on-chain smart contract framework, and the role of nonces in channel identification.\n\nRelated terms: Nonce, Nitro RPC, Nitrolite, state channel, off-chain protocol, on-chain contract, channel ID, message format, signature authentication, NitroRPC, Nitrolight, channel creation, state update, intent system\n\nUse cases: Designing off-chain communication between network nodes, Ensuring unique channel identification during multi-party setup, Integrating with on-chain smart contract protocols for state enforcement",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This glossary defines the foundational architectural elements of the Yellow Network, specifically the Nitro RPC off-chain communication protocol, the Nitrolite on-chain smart contract framework, and the role of nonces in channel identification.",
      "keywords": [
        "Nonce",
        "Nitro RPC",
        "Nitrolite",
        "state channel",
        "off-chain protocol",
        "on-chain contract",
        "channel ID",
        "message format",
        "signature authentication",
        "NitroRPC",
        "Nitrolight",
        "channel creation",
        "state update",
        "intent system"
      ],
      "function_name": "create_channel",
      "intent": "concept",
      "use_cases": [
        "Designing off-chain communication between network nodes",
        "Ensuring unique channel identification during multi-party setup",
        "Integrating with on-chain smart contract protocols for state enforcement"
      ],
      "function_names": [
        "create_channel"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Pâ€‹\n\n\n### Participantâ€‹\n\nAn entity (identified by a wallet address) that is part of a channel. Typically includes a Creator (user) and a Clearnode or Clearnode Operator.\n\n**In Payment Channels** :\n\n  * Index 0: Creator (user)\n  * Index 1: Clearnode\n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures#channel), [Protocol Reference](/docs/protocol/protocol-reference#participant-indices)\n\n* * *\n\nSummary: Defines the 'Participant' entity in the Yellow Network protocol, representing entities identified by wallet addresses that interact within payment channels as either Creators or Clearnodes.\n\nRelated terms: Participant, wallet address, channel member, Creator, Clearnode, Clearnode Operator, payment channel, index 0, index 1, user, node operator, channel entity, participant index, yellow network\n\nUse cases: Identifying channel members, Assigning roles in a payment channel, Resolving participant indices during state updates",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the 'Participant' entity in the Yellow Network protocol, representing entities identified by wallet addresses that interact within payment channels as either Creators or Clearnodes.",
      "keywords": [
        "Participant",
        "wallet address",
        "channel member",
        "Creator",
        "Clearnode",
        "Clearnode Operator",
        "payment channel",
        "index 0",
        "index 1",
        "user",
        "node operator",
        "channel entity",
        "participant index",
        "yellow network"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Identifying channel members",
        "Assigning roles in a payment channel",
        "Resolving participant indices during state updates"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Qâ€‹\n\n\n### Quorumâ€‹\n\nMinimum total weight of signatures required to approve app session state updates. The quorum defines the governance threshold for multi-party applications.\n\n**Example** :\n    \n    \n    participants: [Alice, Bob, Judge]  \n    weights: [40, 40, 50]  \n    quorum: 80  \n      \n    // Valid signature combinations:  \n    // - Alice + Bob (40 + 40 = 80) âœ“  \n    // - Alice + Judge (40 + 50 = 90) âœ“  \n    // - Bob + Judge (40 + 50 = 90) âœ“  \n    // - Alice alone (40 < 80) âœ—  \n    \n\n**Related** : [App Sessions](/docs/off-chain/app-sessions#create_app_session), [Governance Examples](/docs/off-chain/app-sessions#governance-examples)\n\n* * *\n\nSummary: Defines the governance threshold and signature weight requirements necessary to validate and approve state updates within multi-party app sessions.\n\nRelated terms: Quorum, signature threshold, multi-party governance, state update approval, weight-based voting, consensus, app session, multi-sig, validator weights, joint authorization, qorum, signature weight\n\nUse cases: multi-party escrow, decentralized governance, collaborative transaction signing, dispute resolution",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the governance threshold and signature weight requirements necessary to validate and approve state updates within multi-party app sessions.",
      "keywords": [
        "Quorum",
        "signature threshold",
        "multi-party governance",
        "state update approval",
        "weight-based voting",
        "consensus",
        "app session",
        "multi-sig",
        "validator weights",
        "joint authorization",
        "qorum",
        "signature weight"
      ],
      "function_name": "create_app_session",
      "intent": "concept",
      "use_cases": [
        "multi-party escrow",
        "decentralized governance",
        "collaborative transaction signing",
        "dispute resolution"
      ],
      "function_names": [
        "create_app_session"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Râ€‹\n\n\n### requestIdâ€‹\n\nA unique identifier for an RPC request, used for correlating requests and responses. Generated by the client for each request.\n\n**Type** : uint64\n\n**Related** : [Message Format](/docs/off-chain/message-format#general-structure)\n\n* * *\n\nSummary: Defines the requestId as a unique uint64 identifier generated by clients to correlate asynchronous RPC requests with their corresponding responses.\n\nRelated terms: requestId, RPC identifier, correlation ID, request tracking, message correlation, uint64, request-response matching, unique ID, client-generated ID, requestID, reqId, message header, sequence number\n\nUse cases: correlating RPC requests and responses, tracking asynchronous message state, debugging network communication",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the requestId as a unique uint64 identifier generated by clients to correlate asynchronous RPC requests with their corresponding responses.",
      "keywords": [
        "requestId",
        "RPC identifier",
        "correlation ID",
        "request tracking",
        "message correlation",
        "uint64",
        "request-response matching",
        "unique ID",
        "client-generated ID",
        "requestID",
        "reqId",
        "message header",
        "sequence number"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "correlating RPC requests and responses",
        "tracking asynchronous message state",
        "debugging network communication"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Sâ€‹\n\n\n### Session Keyâ€‹\n\nA temporary cryptographic key delegated by a user's main wallet that provides a flexible way for the user to manage security of their funds by giving specific permissions and allowances for specific apps.\n\n**Features** :\n\n  * Spending limits (allowances)\n  * Operation scope restrictions\n  * Expiration time\n  * Gasless signing (no wallet prompts)\n\n**Related** : [Authentication](/docs/off-chain/authentication), [Communication Flows](/docs/protocol/communication-flows#authentication-flow)\n\n* * *\n\n### Stateâ€‹\n\nA snapshot of the channel at a point in time, including fund allocations and application-specific data. States are signed by participants to authorize transitions.\n\n**Components** :\n\n  * `intent` \\- Purpose of the state (INITIALIZE, OPERATE, RESIZE, FINALIZE)\n  * `version` \\- Incremental version number for comparison\n  * `data` \\- Application-specific data or magic number\n  * `allocations` \\- Fund distribution\n  * `sigs` \\- Participant signatures\n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures#state)\n\n* * *\n\n### packedStateâ€‹\n\nA specific encoding of a channelId, state.intent, state.version, state.data, state.allocations, used for signing and signature verification.\n\n**Computation** :\n    \n    \n    packedState = abi.encode(  \n      channelId,  \n      state.intent,  \n      state.version,  \n      state.data,  \n      state.allocations  \n    )  \n    \n\n**Related** : [Data Structures](/docs/protocol/on-chain/data-structures#packed-state)\n\n* * *\n\nSummary: This glossary section defines the fundamental building blocks of the Yellow Network protocol's state management and security model, specifically focusing on session-based delegation and the structure of off-chain channel snapshots.\n\nRelated terms: Session Key, State, packedState, gasless signing, channel state, fund allocation, signature verification, off-chain, spending limits, session management, abi encoding, state transition, cryptographic delegation\n\nUse cases: Implementing gasless user experiences, Managing off-chain channel state transitions, Securing delegated wallet permissions",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This glossary section defines the fundamental building blocks of the Yellow Network protocol's state management and security model, specifically focusing on session-based delegation and the structure of off-chain channel snapshots.",
      "keywords": [
        "Session Key",
        "State",
        "packedState",
        "gasless signing",
        "channel state",
        "fund allocation",
        "signature verification",
        "off-chain",
        "spending limits",
        "session management",
        "abi encoding",
        "state transition",
        "cryptographic delegation"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Implementing gasless user experiences",
        "Managing off-chain channel state transitions",
        "Securing delegated wallet permissions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Uâ€‹\n\n\n### Unified Balanceâ€‹\n\nAn abstraction that aggregates a user's funds across multiple blockchain networks, managed by a clearnode. The unified balance provides a single view of all assets regardless of which chain they're locked on.\n\n**Benefits** :\n\n  * Chain abstraction\n  * Simplified fund management\n  * Cross-chain transfers without bridges\n  * Single balance for all operations\n\n**Related** : [Architecture](/docs/protocol/architecture#fund-flow), [Transfers](/docs/off-chain/transfers#unified-balance-mechanics)\n\n* * *\n\nSummary: The Unified Balance is a chain-agnostic abstraction layer that aggregates a user's assets across multiple blockchains into a single managed view, facilitating seamless cross-chain operations without traditional bridges.\n\nRelated terms: unified balance, chain abstraction, cross-chain, clearnode, asset aggregation, bridgeless transfer, multi-chain wallet, fund management, liquidity pooling, interoperability, unifyed balance, crosschain, aggregated balance\n\nUse cases: cross-chain asset management, bridgeless fund transfers, multi-network liquidity aggregation",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The Unified Balance is a chain-agnostic abstraction layer that aggregates a user's assets across multiple blockchains into a single managed view, facilitating seamless cross-chain operations without traditional bridges.",
      "keywords": [
        "unified balance",
        "chain abstraction",
        "cross-chain",
        "clearnode",
        "asset aggregation",
        "bridgeless transfer",
        "multi-chain wallet",
        "fund management",
        "liquidity pooling",
        "interoperability",
        "unifyed balance",
        "crosschain",
        "aggregated balance"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "cross-chain asset management",
        "bridgeless fund transfers",
        "multi-network liquidity aggregation"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Wâ€‹\n\n\n### Weightâ€‹\n\nVoting power assigned to a participant in an app session. Weights determine how much influence each participant has in governance decisions.\n\n**Usage** : Sum of signer weights must meet quorum for state updates to be valid.\n\n**Related** : [App Sessions](/docs/off-chain/app-sessions#create_app_session)\n\n* * *\n\nSummary: Defines 'Weight' as the voting power assigned to participants in an app session, used to determine if a quorum is met for valid state updates.\n\nRelated terms: weight, voting power, quorum, governance, state update, signer weight, app session, consensus, multi-sig, threshold, wight, session governance, participant influence\n\nUse cases: governance in multi-party channels, defining transaction approval thresholds, customizing participant influence in app sessions",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines 'Weight' as the voting power assigned to participants in an app session, used to determine if a quorum is met for valid state updates.",
      "keywords": [
        "weight",
        "voting power",
        "quorum",
        "governance",
        "state update",
        "signer weight",
        "app session",
        "consensus",
        "multi-sig",
        "threshold",
        "wight",
        "session governance",
        "participant influence"
      ],
      "function_name": "create_app_session",
      "intent": "concept",
      "use_cases": [
        "governance in multi-party channels",
        "defining transaction approval thresholds",
        "customizing participant influence in app sessions"
      ],
      "function_names": [
        "create_app_session"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Additional Termsâ€‹\n\n\n### appSessionIdâ€‹\n\nA unique identifier for an app session, formatted as a 0x-prefixed hex string (32 bytes). Used for all subsequent operations on that specific app session.\n\n* * *\n\n### chainIdâ€‹\n\nA blockchain network identifier (uint64). Examples: 1 (Ethereum Mainnet), 137 (Polygon), 8453 (Base), 42161 (Arbitrum One), 10 (Optimism).\n\n* * *\n\n### assetSymbolâ€‹\n\nA lowercase string identifier for a supported asset (e.g., \"usdc\", \"eth\", \"weth\", \"usdt\", \"dai\", \"wbtc\"). Asset symbols are consistent across chains.\n\n* * *\n\n### walletAddressâ€‹\n\nA user's blockchain address (0x-prefixed hex string, 20 bytes) that identifies their account and owns funds. Used to identify participants in channels and app sessions.\n\n* * *\n\nSummary: Defines core data types and identifiers used throughout the Yellow Network SDK to ensure consistent communication and state management across blockchain networks and application sessions.\n\nRelated terms: appSessionId, chainId, assetSymbol, walletAddress, session identifier, network ID, token symbol, crypto address, blockchain network, hex string, asset identifier, participant ID, chain identifier, session ID, wallet addr\n\nUse cases: Identifying unique application sessions for state updates, Specifying target blockchain networks for cross-chain operations, Mapping assets across different supported chains, Identifying participants in payment channels or multi-party sessions",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines core data types and identifiers used throughout the Yellow Network SDK to ensure consistent communication and state management across blockchain networks and application sessions.",
      "keywords": [
        "appSessionId",
        "chainId",
        "assetSymbol",
        "walletAddress",
        "session identifier",
        "network ID",
        "token symbol",
        "crypto address",
        "blockchain network",
        "hex string",
        "asset identifier",
        "participant ID",
        "chain identifier",
        "session ID",
        "wallet addr"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Identifying unique application sessions for state updates",
        "Specifying target blockchain networks for cross-chain operations",
        "Mapping assets across different supported chains",
        "Identifying participants in payment channels or multi-party sessions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Cross-Referencesâ€‹\n\n\nFor detailed explanations of these terms with examples, diagrams, and use cases, refer to:\n\n  * **Core Concepts** : [Terminology](/docs/protocol/terminology)\n  * **On-Chain Details** : [On-Chain Protocol](/docs/protocol/on-chain/overview)\n  * **Off-Chain Details** : [Off-Chain RPC Protocol](/docs/off-chain/overview)\n  * **Implementation** : [Quick Start Guide](/docs/protocol/quick-start), [Implementation Checklist](/docs/protocol/implementation-checklist)\n\nUsing This Glossary\n\nPress `Ctrl+F` (or `Cmd+F` on Mac) to search for specific terms. Most terms also appear as tooltips throughout the documentation for quick reference.\n\n\n\n[PreviousProtocol Reference](/docs/protocol/protocol-reference)[NextImplementation Checklist](/docs/protocol/implementation-checklist)\n\n  * A\n    * Adjudicator\n    * Allocation\n    * App Session\n  * C\n    * Challenge Period\n    * Channel\n    * channelId\n    * Checkpoint\n    * Clearnode\n    * Creator\n    * Custody Contract\n  * I\n    * Intent\n  * L\n    * Ledger Entry\n    * Ledger Transaction\n  * M\n    * Magic Number\n  * N\n    * Nonce\n    * Nitro RPC\n    * Nitrolite\n  * P\n    * Participant\n  * Q\n    * Quorum\n  * R\n    * requestId\n  * S\n    * Session Key\n    * State\n    * packedState\n  * U\n    * Unified Balance\n  * W\n    * Weight\n  * Additional Terms\n    * appSessionId\n    * chainId\n    * assetSymbol\n    * walletAddress\n  * Cross-References\n\nSummary: This component serves as a comprehensive glossary and cross-reference guide for the Yellow Network protocol, defining key terminology for both on-chain and off-chain operations.\n\nRelated terms: glossary, terminology, definitions, adjudicator, app session, channel, ledger, nitro rpc, unified balance, challenge period, nonce, quorum, dictionary, protocol terms\n\nUse cases: Onboarding developers to protocol terminology, Clarifying system architecture components, Reference for state machine and channel concepts",
    "metadata": {
      "title": "Glossary | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/glossary",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component serves as a comprehensive glossary and cross-reference guide for the Yellow Network protocol, defining key terminology for both on-chain and off-chain operations.",
      "keywords": [
        "glossary",
        "terminology",
        "definitions",
        "adjudicator",
        "app session",
        "channel",
        "ledger",
        "nitro rpc",
        "unified balance",
        "challenge period",
        "nonce",
        "quorum",
        "dictionary",
        "protocol terms"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Onboarding developers to protocol terminology",
        "Clarifying system architecture components",
        "Reference for state machine and channel concepts"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Implementation Checklist\n\n\n\n# Implementation Checklist\n\nComprehensive checklist for building a compliant Nitrolite client with security best practices.\n\nProgressive Implementation\n\nYou don't need to implement everything at once. Start with Core Protocol and On-Chain Integration, then add Off-Chain RPC and advanced features progressively.\n\n* * *\n\nSummary: A comprehensive roadmap for developers to build secure and compliant Nitrolite clients, detailing the progression from core protocol integration to advanced off-chain features.\n\nRelated terms: Nitrolite, client implementation, security best practices, core protocol, on-chain integration, off-chain RPC, compliance, development roadmap, SDK setup, integration guide, Yellow Network, crypto payment, blockchain node, implementation checklist\n\nUse cases: Building a Nitrolite-compliant client, Securing a payment node, Planning a protocol integration roadmap",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "A comprehensive roadmap for developers to build secure and compliant Nitrolite clients, detailing the progression from core protocol integration to advanced off-chain features.",
      "keywords": [
        "Nitrolite",
        "client implementation",
        "security best practices",
        "core protocol",
        "on-chain integration",
        "off-chain RPC",
        "compliance",
        "development roadmap",
        "SDK setup",
        "integration guide",
        "Yellow Network",
        "crypto payment",
        "blockchain node",
        "implementation checklist"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "Building a Nitrolite-compliant client",
        "Securing a payment node",
        "Planning a protocol integration roadmap"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Core Protocol Supportâ€‹\n\n\nFoundation requirements for any Nitrolite implementation.\n\n### Identifier Computationâ€‹\n\n  * **Compute channelId from Channel struct**\n\n    * Hash participants, adjudicator, challenge, nonce using keccak256\n    * Verify deterministic computation (same inputs = same output)\n    * Reference: [Data Structures](/docs/protocol/on-chain/data-structures#channel-identifier)\n  * **Compute payload hash (packedState) from channel state**\n\n    * Compute `packedState = keccak256(abi.encode(channelId, state.intent, state.version, state.data, state.allocations))`\n    * Ensure proper ABI encoding\n    * Reference: [Data Structures](/docs/protocol/on-chain/data-structures#packed-state)\n\n### Signature Handlingâ€‹\n\n  * **Generate signatures**\n\n    * Support ECDSA signatures (standard for EOA wallets)\n    * Encode as `bytes` format (65 bytes: r + s + v)\n    * For on-chain: sign raw `packedState` hash\n    * For off-chain RPC: sign EIP-712 typed data structures\n    * Reference: [Signature Standards](/docs/protocol/protocol-reference#signature-standards)\n  * **Verify signatures**\n\n    * Recover signer address from signature\n    * Validate signer matches expected participant\n    * Support EIP-1271 for smart contract wallets\n    * Support EIP-6492 for counterfactual contracts\n    * Handle EIP-191 for personal signatures where applicable\n\nSignature Standards\n\nOn-chain signatures use raw `packedState` hash for chain-agnostic compatibility. Off-chain RPC messages use EIP-712 typed data for user-facing signatures (e.g., authentication). Refer to [Signature Standards](/docs/protocol/protocol-reference#signature-standards) for details.\n\n* * *\n\nSummary: Defines the foundational cryptographic requirements for Nitrolite implementations, including deterministic channel ID generation and multi-standard signature handling for both on-chain and off-chain operations.\n\nRelated terms: keccak256, ECDSA, EIP-712, EIP-1271, EIP-6492, signature verification, channelId, packedState, abi encoding, wallet authentication, cryptographic hashing, state channel, message signing, signature standards\n\nUse cases: wallet integration for state channels, off-chain payment verification, multi-party signature validation, custom client implementation",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the foundational cryptographic requirements for Nitrolite implementations, including deterministic channel ID generation and multi-standard signature handling for both on-chain and off-chain operations.",
      "keywords": [
        "keccak256",
        "ECDSA",
        "EIP-712",
        "EIP-1271",
        "EIP-6492",
        "signature verification",
        "channelId",
        "packedState",
        "abi encoding",
        "wallet authentication",
        "cryptographic hashing",
        "state channel",
        "message signing",
        "signature standards"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "wallet integration for state channels",
        "off-chain payment verification",
        "multi-party signature validation",
        "custom client implementation"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## On-Chain Integrationâ€‹\n\n\nSmart contract interactions for channel lifecycle management.\n\n### Blockchain Connectionâ€‹\n\n  * **Connect to Ethereum-compatible blockchain**\n\n    * Support multiple chains (Ethereum, Polygon, Arbitrum, Optimism, Base)\n    * Use Web3 provider (e.g., Infura, Alchemy)\n    * Handle network switching\n    * Implement retry logic for failed connections\n  * **Load contract ABIs**\n\n    * Custody Contract ABI\n    * Adjudicator contract ABI (application-specific)\n    * ERC-20 token ABI\n\n### Channel Operationsâ€‹\n\n  * **Create channel (`Custody.create`)**\n\n    * Verify state has `intent = INITIALIZE` (1) and `version = 0`\n    * Preferred: include both participant signatures to start in `ACTIVE`\n    * Legacy: single sig â†’ `INITIAL`; wait for `join()` to reach `ACTIVE`\n    * Handle ERC-20 approvals only if depositing at creation (legacy flow)\n    * Reference: [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle#creation-phase)\n  * **Monitor activation / join**\n\n    * Subscribe to `Opened` and `Joined` events\n    * In legacy flow, ensure `join()` transitions `INITIAL` â†’ `ACTIVE`\n  * **Cooperative closure (`Custody.close`)**\n\n    * Build state with `intent = FINALIZE` (3), `version = current+1`, `data = \"0x\"`\n    * Require both participant signatures; submit single tx\n    * Confirm funds destination and allocations match expectations\n    * Reference: [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle#cooperative-closure)\n  * **Dispute / challenge**\n\n    * Persist latest fully signed state for `challenge()`\n    * During `DISPUTE`, accept newer state via `checkpoint()` (on-chain) if available\n    * After challenge timeout, finalize with `close()` using challenged state\n    * Reference: [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle#challenge-phase)\n\n### Event Listeningâ€‹\n\n  * **Listen to contract events**\n\n    * `Opened(channelId, channel, deposits)` \\- Channel created and active\n    * `Challenged(channelId, state, expiration)` \\- Dispute started (expiration = challenge period end)\n    * `Closed(channelId, allocations)` \\- Channel finalized\n    * `Resized(channelId)` \\- Channel capacity changed\n  * **Process events in order**\n\n    * Maintain event log cursor/checkpoint\n    * Handle blockchain reorganizations\n    * Implement event replay for recovery\n  * **Update internal state based on events**\n\n    * Sync channel status (INITIAL â†’ ACTIVE â†’ DISPUTE â†’ FINAL)\n    * Update unified balance when channels open/close\n    * Notify users of status changes\n\nEvent Recovery\n\nImplement event recovery for when your application restarts or loses connection. Replay events from last checkpoint to current block.\n\n* * *\n\nSummary: This component provides a comprehensive implementation checklist for integrating the Yellow Network protocol with EVM-compatible blockchains, covering smart contract interactions, channel lifecycle management, and event monitoring.\n\nRelated terms: open channel, close channel, dispute resolution, EVM integration, smart contract, ERC-20, state transition, event listener, on-chain settlement, custody contract, adjudicator, blockchain connection, web3 provider, channel lifecycle, checkpoint\n\nUse cases: On-chain channel lifecycle management, Implementing secure dispute resolution for off-chain transactions, Multi-chain payment settlement integration, Automating smart contract event monitoring for state updates",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component provides a comprehensive implementation checklist for integrating the Yellow Network protocol with EVM-compatible blockchains, covering smart contract interactions, channel lifecycle management, and event monitoring.",
      "keywords": [
        "open channel",
        "close channel",
        "dispute resolution",
        "EVM integration",
        "smart contract",
        "ERC-20",
        "state transition",
        "event listener",
        "on-chain settlement",
        "custody contract",
        "adjudicator",
        "blockchain connection",
        "web3 provider",
        "channel lifecycle",
        "checkpoint"
      ],
      "function_name": "Custody.create",
      "intent": "tutorial",
      "use_cases": [
        "On-chain channel lifecycle management",
        "Implementing secure dispute resolution for off-chain transactions",
        "Multi-chain payment settlement integration",
        "Automating smart contract event monitoring for state updates"
      ],
      "function_names": [
        "Closed",
        "checkpoint",
        "close",
        "Resized",
        "Challenged"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Off-Chain RPCâ€‹\n\n\nRPC communication with clearnode.\n\n### Connection Managementâ€‹\n\n  * **Establish RPC connection**\n\n    * Connect to clearnode RPC endpoint\n    * Handle connection timeouts\n    * Implement exponential backoff for reconnection\n    * Reference: [Off-Chain Overview](/docs/off-chain/overview)\n  * **Implement message format**\n\n    * Compact JSON array format: `[requestId, method, params, timestamp]`\n    * Request wrapper: `{req: [...], sig: [...]}`\n    * Response wrapper: `{res: [...], sig: [...]}`\n    * Error format: `{res: [requestId, \"error\", {error: \"message\"}, timestamp], sig: [...]}`\n    * Reference: [Message Format](/docs/off-chain/message-format)\n  * **Handle network outages gracefully**\n\n    * Detect connection loss\n    * Queue pending requests\n    * Reconnect automatically\n    * Resubmit queued requests after reconnection\n\n### Authenticationâ€‹\n\n  * **Implement 3-step flow (auth_request â†’ auth_challenge â†’ auth_verify)**\n\n    * Generate session keypair locally; never transmit the private key\n    * `auth_request`: public, unsigned; send address, session_key, allowances (optional), scope (optional, not enforced), **expires_at (required, ms)**\n    * Store the exact parameters; response method is `auth_challenge` with `challenge_message`\n    * `auth_verify`: sign EIP-712 Policy typed data with **main wallet** (not session key) including challenge, wallet, session_key, expires_at, scope, allowances; or pass `jwt` to reuse without signature\n    * Response returns `{address, session_key, jwt_token, success}`; use session key for all subsequent private calls\n    * Reference: [Authentication](/docs/off-chain/authentication)\n  * **Session key management**\n\n    * Specify allowances per asset (unrestricted if omitted); enforce spending caps on every debit\n    * Set `expires_at`; re-authenticate before expiry; handle â€œsession expiredâ€ errors\n    * Rotate/revoke session keys as needed; avoid reusing keys across applications\n  * **Request signing & verification**\n\n    * Client signs all private RPC requests with session key; validate clearnode signatures on responses\n    * Ensure canonical JSON serialization of `req`/`res` arrays before hashing/signing\n\n### Method Implementationâ€‹\n\n  * **Implement all required methods**\n\n    * **Authentication** : auth_request, auth_verify\n    * **Channel Management** : create_channel, close_channel, resize_channel\n    * **Transfers** : transfer\n    * **App Sessions** : create_app_session, submit_app_state, close_app_session\n    * **Queries** : get_config, get_assets, get_app_definition, get_channels, get_app_sessions, get_ledger_balances, get_ledger_entries, get_ledger_transactions, get_rpc_history, get_user_tag, get_session_keys, ping\n    * Reference: [Queries](/docs/off-chain/queries)\n  * **Handle server notifications**\n\n    * `bu` (Balance Update) - Balance changed\n    * `cu` (Channel Update) - Channel status changed\n    * `tr` (Transfer) - Incoming/outgoing transfer\n    * `asu` (App Session Update) - App session state changed\n    * Reference: [Notifications](/docs/off-chain/queries#notifications)\n\nMethod Prioritization\n\nStart with: authentication â†’ create_channel â†’ transfer â†’ get_ledger_balances. Add other methods as needed for your use case.\n\n* * *\n\nSummary: This component outlines the technical requirements for establishing secure off-chain communication with the Yellow Network clearnode, focusing on RPC connection stability and the EIP-712 session-based authentication lifecycle.\n\nRelated terms: RPC connection, clearnode, EIP-712, session key, authentication flow, JWT token, off-chain, message signing, exponential backoff, request queuing, auth_verify, auth_request, connection management, JSON-RPC, session management\n\nUse cases: Securely connecting a backend service to the Yellow Network clearnode, Implementing session-based user authentication with main wallet signing, Managing automated RPC reconnection and request queuing during network outages, Enforcing granular asset spending allowances for session keys",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component outlines the technical requirements for establishing secure off-chain communication with the Yellow Network clearnode, focusing on RPC connection stability and the EIP-712 session-based authentication lifecycle.",
      "keywords": [
        "RPC connection",
        "clearnode",
        "EIP-712",
        "session key",
        "authentication flow",
        "JWT token",
        "off-chain",
        "message signing",
        "exponential backoff",
        "request queuing",
        "auth_verify",
        "auth_request",
        "connection management",
        "JSON-RPC",
        "session management"
      ],
      "function_name": "auth_verify",
      "intent": "configuration",
      "use_cases": [
        "Securely connecting a backend service to the Yellow Network clearnode",
        "Implementing session-based user authentication with main wallet signing",
        "Managing automated RPC reconnection and request queuing during network outages",
        "Enforcing granular asset spending allowances for session keys"
      ],
      "function_names": [
        "create_channel",
        "create_app_session",
        "close_channel",
        "get_user_tag",
        "close_app_session"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## State Managementâ€‹\n\n\nOff-chain state tracking and synchronization.\n\n### State Storageâ€‹\n\n  * **Store latest signed states securely**\n\n    * Save complete state struct (data, allocations, sigs)\n    * Include channelId and version\n    * Persist to durable storage (database, filesystem)\n    * Implement atomic updates\n  * **Track state versions**\n\n    * Maintain version counter per channel and app session\n    * Reject states with version â‰¤ current version\n    * Increment version for each new state\n  * **Implement unified balance tracking**\n\n    * Aggregate funds across all chains\n    * Track funds in unified account vs channel escrow vs app session accounts\n    * Update on channel open/close and transfers\n    * Reference: [Transfers](/docs/off-chain/transfers)\n  * **Handle app session state updates**\n\n    * Verify quorum met (sum of weights â‰¥ quorum)\n    * Track locked funds per session\n    * Release funds on session close\n    * Reference: [App Sessions](/docs/off-chain/app-sessions)\n\n### State Validationâ€‹\n\n  * **Verify signatures before accepting states**\n\n    * Check all required signatures present\n    * Validate each signature against expected signer\n    * Ensure quorum met for app sessions\n  * **Validate state transitions**\n\n    * For channels: verify StateIntent (INITIALIZE, RESIZE, FINALIZE)\n    * For app sessions: verify quorum and allocation rules\n    * Verify version increments correctly\n    * For closure: allocations valid and complete\n  * **Maintain state history**\n\n    * Keep N most recent states per channel\n    * Useful for dispute resolution\n    * Implement pruning strategy for old states\n\n* * *\n\nSummary: This component outlines the architectural requirements for managing off-chain state, including secure storage of signed states, version tracking, and multi-party signature validation to ensure protocol integrity.\n\nRelated terms: state management, off-chain state, state synchronization, signature verification, versioning, balance tracking, channel state, app session, quorum, dispute resolution, atomic updates, state storage, state validation, state transition, Yellow Network\n\nUse cases: secure off-chain state storage, multi-party signature verification, cross-chain balance aggregation, dispute resolution preparation",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component outlines the architectural requirements for managing off-chain state, including secure storage of signed states, version tracking, and multi-party signature validation to ensure protocol integrity.",
      "keywords": [
        "state management",
        "off-chain state",
        "state synchronization",
        "signature verification",
        "versioning",
        "balance tracking",
        "channel state",
        "app session",
        "quorum",
        "dispute resolution",
        "atomic updates",
        "state storage",
        "state validation",
        "state transition",
        "Yellow Network"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "secure off-chain state storage",
        "multi-party signature verification",
        "cross-chain balance aggregation",
        "dispute resolution preparation"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Securityâ€‹\n\n\nCritical security practices for production deployments.\n\n### Key Managementâ€‹\n\n  * **Secure key storage**\n\n    * Never log private keys\n    * Use secure key storage (keychain, HSM, encrypted database)\n    * Implement key rotation\n    * Separate signing keys from storage keys\n  * **Implement signature verification**\n\n    * Verify all incoming signatures\n    * Validate signer matches expected participant\n    * Check signature freshness (timestamp)\n  * **Never share private keys or session key private keys**\n\n    * Session keys stay on client\n    * Never transmit private keys over network\n    * Use separate keys for different purposes\n\n### Challenge Monitoringâ€‹\n\n  * **Monitor blockchain for channel events**\n\n    * Subscribe to all channels you participate in\n    * Alert on `Challenged` events\n    * Automated response to challenges\n  * **Respond to challenges within challenge period**\n\n    * Maintain latest valid state\n    * Submit newer state if challenged with old state\n    * Set alerts for challenge expiration\n  * **Implement automated challenge response**\n\n    * Detect challenges automatically\n    * Submit newer state without manual intervention\n    * Fallback to manual response if needed\n\n### Session Key Managementâ€‹\n\n  * **Session key allowance enforcement**\n\n    * Track spending per session key\n    * Reject operations exceeding allowance\n    * Alert user when approaching limit\n  * **Validate spending limits client-side**\n\n    * Check allowance before submitting operations\n    * Provide clear error messages\n    * Offer to re-authenticate with higher allowance\n\n### Best Practicesâ€‹\n\n  * **Never sign two states with same version number**\n\n    * Maintain version counter\n    * Reject duplicate versions\n    * Use atomic version increment\n  * **Keep track of latest state you've signed**\n\n    * Store all signed states\n    * Never sign older version\n    * Use for dispute resolution\n  * **Set appropriate challenge periods**\n\n    * Balance security (longer) vs UX (shorter)\n    * Consider block time and congestion\n    * Minimum: 1 hour (enforced by Custody Contract `MIN_CHALLENGE_PERIOD`)\n  * **Validate all inputs thoroughly**\n\n    * Check address formats\n    * Verify amounts are positive\n    * Validate asset symbols\n    * Sanitize user input\n  * **Log all state transitions for auditing**\n\n    * Timestamp all operations\n    * Record signatures and signers\n    * Maintain audit trail\n    * Implement log rotation\n\n* * *\n\nSummary: This component outlines the essential security protocols and operational requirements for production deployments, focusing on key protection, automated challenge monitoring, and session-based spending limits.\n\nRelated terms: security, key management, private keys, signature verification, session keys, challenge monitoring, state updates, blockchain events, spending limits, HSM, dispute resolution, versioning, signing, multi-party, secure storage\n\nUse cases: Production environment setup, Automated channel dispute resolution, Secure session key implementation, Multi-party state synchronization",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component outlines the essential security protocols and operational requirements for production deployments, focusing on key protection, automated challenge monitoring, and session-based spending limits.",
      "keywords": [
        "security",
        "key management",
        "private keys",
        "signature verification",
        "session keys",
        "challenge monitoring",
        "state updates",
        "blockchain events",
        "spending limits",
        "HSM",
        "dispute resolution",
        "versioning",
        "signing",
        "multi-party",
        "secure storage"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "Production environment setup",
        "Automated channel dispute resolution",
        "Secure session key implementation",
        "Multi-party state synchronization"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Error Handlingâ€‹\n\n\nRobust error handling for production reliability.\n\n### RPC Errorsâ€‹\n\n  * **Handle error responses**\n    * Error response format: `{res: [requestId, \"error\", {error: \"descriptive message\"}, timestamp], sig: [...]}`\n    * No numeric error codes; errors have descriptive messages only\n    * Common errors: \"authentication required\", \"insufficient balance\", \"channel not found\", \"session expired, please re-authenticate\"\n    * Always check if response method is `\"error\"`\n    * Reference: [Error Handling](/docs/protocol/protocol-reference#error-handling)\n\n### Transaction Errorsâ€‹\n\n  * **Implement retry logic for critical operations**\n\n    * Exponential backoff\n    * Maximum retry attempts\n    * Idempotent operations\n  * **Handle gas estimation failures**\n\n    * Provide manual gas limit option\n    * Retry with higher gas limit\n    * Alert user to potential issues\n  * **Handle transaction reverts**\n\n    * Parse revert reason\n    * Provide helpful error messages\n    * Suggest corrective actions\n\n* * *\n\nSummary: This section provides a checklist for implementing robust error handling, covering RPC error response formats, transaction retry strategies, and gas estimation failures to ensure production reliability.\n\nRelated terms: error handling, RPC error, transaction revert, gas estimation, retry logic, exponential backoff, idempotency, authentication required, session expired, debugging, troubleshooting, failover, error response, gas limit, eror\n\nUse cases: Building production-ready payment applications, Handling failed blockchain transactions, Implementing automated retry mechanisms, Debugging RPC communication issues",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section provides a checklist for implementing robust error handling, covering RPC error response formats, transaction retry strategies, and gas estimation failures to ensure production reliability.",
      "keywords": [
        "error handling",
        "RPC error",
        "transaction revert",
        "gas estimation",
        "retry logic",
        "exponential backoff",
        "idempotency",
        "authentication required",
        "session expired",
        "debugging",
        "troubleshooting",
        "failover",
        "error response",
        "gas limit",
        "eror"
      ],
      "function_name": null,
      "intent": "error_handling",
      "use_cases": [
        "Building production-ready payment applications",
        "Handling failed blockchain transactions",
        "Implementing automated retry mechanisms",
        "Debugging RPC communication issues"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Testingâ€‹\n\n\nComprehensive testing strategy for confidence in production.\n\n### Unit Testingâ€‹\n\n  * **Test signature generation and verification**\n\n    * Known test vectors\n    * Round-trip signing\n    * Invalid signature rejection\n  * **Test identifier computation**\n\n    * channelId determinism\n    * packedState (payload hash) consistency\n    * Known test vectors\n  * **Test state validation logic**\n\n    * Version ordering\n    * Allocation sum validation\n    * StateIntent validation (INITIALIZE, RESIZE, FINALIZE for channels)\n\n### Integration Testingâ€‹\n\n  * **Test both cooperative and challenge closure paths**\n\n    * Cooperative close (happy path)\n    * Challenge initiation\n    * Challenge response\n    * Challenge timeout\n  * **Test multi-chain operations**\n\n    * Open channels on different chains\n    * Cross-chain transfers (via unified balance)\n    * Chain-specific edge cases\n  * **Test network reconnection**\n\n    * Simulate network interruption\n    * Verify automatic reconnection\n    * Check state synchronization\n\n### End-to-End Testingâ€‹\n\n  * **Test complete user journeys**\n\n    * Authentication â†’ Channel Open â†’ Transfer â†’ Channel Close\n    * App session creation â†’ State updates â†’ Closure\n    * Error scenarios and recovery\n  * **Test with real clearnodes**\n\n    * Testnet deployment\n    * Mainnet staging environment\n    * Monitor performance and errors\n\n* * *\n\nSummary: Provides a structured testing strategy for developers to verify the integrity of their Yellow Network implementation, covering cryptographic primitives, state transitions, and full-lifecycle network interactions.\n\nRelated terms: testing, unit tests, integration tests, end-to-end, signature verification, channelId, state validation, cooperative closure, challenge period, multi-chain, network reconnection, clearnodes, testnet, mainnet, state synchronization\n\nUse cases: Validating cryptographic signature and identifier logic, Testing channel lifecycle transitions and dispute resolution, Verifying multi-chain state synchronization and network resilience, Simulating end-to-end user payment journeys",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a structured testing strategy for developers to verify the integrity of their Yellow Network implementation, covering cryptographic primitives, state transitions, and full-lifecycle network interactions.",
      "keywords": [
        "testing",
        "unit tests",
        "integration tests",
        "end-to-end",
        "signature verification",
        "channelId",
        "state validation",
        "cooperative closure",
        "challenge period",
        "multi-chain",
        "network reconnection",
        "clearnodes",
        "testnet",
        "mainnet",
        "state synchronization"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "Validating cryptographic signature and identifier logic",
        "Testing channel lifecycle transitions and dispute resolution",
        "Verifying multi-chain state synchronization and network resilience",
        "Simulating end-to-end user payment journeys"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Performance Optimizationâ€‹\n\n\nOptimize for production workloads.\n\n### Efficiencyâ€‹\n\n  * **Minimize blockchain queries**\n\n    * Cache contract addresses\n    * Batch event queries\n    * Use multicall for multiple reads\n  * **Implement connection pooling**\n\n    * Reuse RPC connections\n    * Pool blockchain RPC connections\n    * Implement connection limits\n  * **Optimize state storage**\n\n    * Index by channelId and app_session_id\n    * Prune old states\n    * Compress stored states\n\n### Monitoringâ€‹\n\n  * **Implement health checks**\n\n    * RPC connection status\n    * Blockchain connection status\n    * Event listener status\n    * Use `ping` method for clearnode health\n  * **Monitor latency**\n\n    * RPC request/response time\n    * Transaction confirmation time\n    * Event processing delay\n  * **Track error rates**\n\n    * Failed transactions\n    * RPC errors\n    * Signature verification failures\n\n* * *\n\nSummary: This component provides a production-readiness checklist for optimizing SDK performance and implementing comprehensive monitoring for blockchain interactions and system health.\n\nRelated terms: performance tuning, rpc optimization, connection pooling, multicall, state pruning, health check, latency monitoring, error tracking, blockchain caching, clearnode ping, channel management, app_session_id, transaction monitoring, state compression\n\nUse cases: Scaling production workloads, Reducing RPC costs and latency, Monitoring system health and uptime, Optimizing state storage for high-volume channels",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component provides a production-readiness checklist for optimizing SDK performance and implementing comprehensive monitoring for blockchain interactions and system health.",
      "keywords": [
        "performance tuning",
        "rpc optimization",
        "connection pooling",
        "multicall",
        "state pruning",
        "health check",
        "latency monitoring",
        "error tracking",
        "blockchain caching",
        "clearnode ping",
        "channel management",
        "app_session_id",
        "transaction monitoring",
        "state compression"
      ],
      "function_name": "ping",
      "intent": "configuration",
      "use_cases": [
        "Scaling production workloads",
        "Reducing RPC costs and latency",
        "Monitoring system health and uptime",
        "Optimizing state storage for high-volume channels"
      ],
      "function_names": [
        "app_session_id"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Documentationâ€‹\n\n\nDocumentation for maintainability.\n\n### Code Documentationâ€‹\n\n  * **Document adjudicator-specific requirements clearly**\n\n    * State validation rules\n    * Version comparison logic\n    * Gas cost estimates\n  * **Document custom state formats**\n\n    * Application-specific data structures\n    * Serialization format\n    * Version compatibility\n\n### User Documentationâ€‹\n\n  * **Provide integration guide**\n\n    * Setup instructions\n    * Code examples\n    * Common patterns\n  * **Document error messages**\n\n    * User-friendly descriptions\n    * Suggested actions\n    * Support contact information\n\n* * *\n\nSummary: Defines the documentation standards required for maintaining the Yellow Network SDK, covering technical adjudicator specifications, state formats, and user-facing integration guides.\n\nRelated terms: documentation, technical writing, integration guide, adjudicator rules, state validation, gas estimation, serialization, error messages, developer experience, SDK setup, versioning, maintainability, docs, dev docs\n\nUse cases: Standardizing SDK documentation, Designing custom state channels, Creating developer integration guides, Optimizing gas cost reporting",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the documentation standards required for maintaining the Yellow Network SDK, covering technical adjudicator specifications, state formats, and user-facing integration guides.",
      "keywords": [
        "documentation",
        "technical writing",
        "integration guide",
        "adjudicator rules",
        "state validation",
        "gas estimation",
        "serialization",
        "error messages",
        "developer experience",
        "SDK setup",
        "versioning",
        "maintainability",
        "docs",
        "dev docs"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Standardizing SDK documentation",
        "Designing custom state channels",
        "Creating developer integration guides",
        "Optimizing gas cost reporting"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Deployment Checklistâ€‹\n\n\nPre-production validation.\n\n### Pre-Productionâ€‹\n\n  * **Audit smart contracts thoroughly before deployment**\n\n    * Use established auditors\n    * Test on testnets first\n    * Gradual mainnet rollout\n  * **Test on testnet extensively**\n\n    * All user flows\n    * Error scenarios\n    * Performance under load\n  * **Implement monitoring and alerting**\n\n    * Error rate alerts\n    * Performance degradation alerts\n    * Challenge event alerts\n\n### Productionâ€‹\n\n  * **Use appropriate challenge periods**\n\n    * Longer for high-value channels\n    * Consider network congestion\n    * Balance security vs UX\n  * **Implement proper key management**\n\n    * Hardware security modules (HSM)\n    * Key rotation policy\n    * Backup and recovery procedures\n  * **Set up incident response procedures**\n\n    * On-call rotation\n    * Escalation procedures\n    * Communication plan\n\n* * *\n\nSummary: This guide outlines the essential security, testing, and operational requirements for transitioning the Yellow Network protocol from development to a production environment.\n\nRelated terms: deployment, checklist, production readiness, smart contract audit, testnet validation, monitoring, alerting, challenge period, HSM, key management, incident response, security best practices, mainnet rollout, error handling, operational security\n\nUse cases: preparing for mainnet launch, establishing security protocols, setting up network monitoring, configuring channel challenge periods",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This guide outlines the essential security, testing, and operational requirements for transitioning the Yellow Network protocol from development to a production environment.",
      "keywords": [
        "deployment",
        "checklist",
        "production readiness",
        "smart contract audit",
        "testnet validation",
        "monitoring",
        "alerting",
        "challenge period",
        "HSM",
        "key management",
        "incident response",
        "security best practices",
        "mainnet rollout",
        "error handling",
        "operational security"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "preparing for mainnet launch",
        "establishing security protocols",
        "setting up network monitoring",
        "configuring channel challenge periods"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Compliance Levelsâ€‹\n\n\n### Minimal (User Client)â€‹\n\nEssential for basic client functionality:\n\n  * Core Protocol Support âœ“\n  * On-Chain Integration (create, close) âœ“\n  * Off-Chain RPC (auth, transfer, basic queries) âœ“\n  * Basic Security âœ“\n\n### Standard (Production Application)â€‹\n\nAdd:\n\n  * Complete method implementation âœ“\n  * State Management âœ“\n  * Comprehensive Error Handling âœ“\n  * Testing âœ“\n\n### Advanced (Clearnode Implementation)â€‹\n\nAdd:\n\n  * Server-side RPC routing and authentication âœ“\n  * Event-driven architecture âœ“\n  * Unified balance management (double-entry ledger) âœ“\n  * App session coordination âœ“\n  * High availability and fault tolerance âœ“\n\n* * *\n\nSummary: Defines the tiered compliance requirements for implementing the Yellow Network protocol, ranging from basic client-side functionality to advanced server-side Clearnode infrastructure.\n\nRelated terms: implementation checklist, compliance levels, clearnode, user client, production application, on-chain integration, off-chain rpc, state management, double-entry ledger, event-driven architecture, fault tolerance, yellow network, sdk setup, crypto payment\n\nUse cases: architecting a client-side wallet, developing a production-grade payment gateway, implementing a full clearnode server, evaluating protocol compliance",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the tiered compliance requirements for implementing the Yellow Network protocol, ranging from basic client-side functionality to advanced server-side Clearnode infrastructure.",
      "keywords": [
        "implementation checklist",
        "compliance levels",
        "clearnode",
        "user client",
        "production application",
        "on-chain integration",
        "off-chain rpc",
        "state management",
        "double-entry ledger",
        "event-driven architecture",
        "fault tolerance",
        "yellow network",
        "sdk setup",
        "crypto payment"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "architecting a client-side wallet",
        "developing a production-grade payment gateway",
        "implementing a full clearnode server",
        "evaluating protocol compliance"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\n  1. **Start Simple** : Implement Core Protocol + Basic On-Chain integration\n  2. **Add RPC** : Connect to clearnode, implement authentication and basic methods\n  3. **Enhance Security** : Implement all security best practices\n  4. **Test Thoroughly** : Unit, integration, and end-to-end tests\n  5. **Deploy Gradually** : Testnet â†’ Staging â†’ Production\n\nReady to Build\n\nUse this checklist as a guide throughout your implementation. Check off items as you complete them and refer back to detailed documentation for each section.\n\n* * *\n\nSummary: A high-level implementation roadmap for the Yellow Network protocol, outlining the sequential steps from core integration and RPC setup to security hardening and production deployment.\n\nRelated terms: implementation roadmap, getting started, deployment checklist, clearnode integration, RPC setup, security best practices, testnet deployment, production launch, integration guide, yellow network setup, protocol implementation, developer onboarding, staging environment, unit testing\n\nUse cases: onboarding new developers to the protocol, planning a production-ready deployment, auditing implementation progress, setting up development environments",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "A high-level implementation roadmap for the Yellow Network protocol, outlining the sequential steps from core integration and RPC setup to security hardening and production deployment.",
      "keywords": [
        "implementation roadmap",
        "getting started",
        "deployment checklist",
        "clearnode integration",
        "RPC setup",
        "security best practices",
        "testnet deployment",
        "production launch",
        "integration guide",
        "yellow network setup",
        "protocol implementation",
        "developer onboarding",
        "staging environment",
        "unit testing"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "onboarding new developers to the protocol",
        "planning a production-ready deployment",
        "auditing implementation progress",
        "setting up development environments"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Resourcesâ€‹\n\n\n  * **Communication Flows** : [Communication Flows](/docs/protocol/communication-flows)\n  * **Reference** : [Protocol Reference](/docs/protocol/protocol-reference)\n  * **Channel Lifecycle** : [Channel Lifecycle](/docs/on-chain/channel-lifecycle)\n  * **RPC Methods** : [Queries](/docs/off-chain/queries)\n  * **Example Code** : [Integration Tests](https://github.com/layer-3/nitrolite/tree/main/integration)\n\n\n\n[PreviousGlossary](/docs/protocol/glossary)\n\n  * Core Protocol Support\n    * Identifier Computation\n    * Signature Handling\n  * On-Chain Integration\n    * Blockchain Connection\n    * Channel Operations\n    * Event Listening\n  * Off-Chain RPC\n    * Connection Management\n    * Authentication\n    * Method Implementation\n  * State Management\n    * State Storage\n    * State Validation\n  * Security\n    * Key Management\n    * Challenge Monitoring\n    * Session Key Management\n    * Best Practices\n  * Error Handling\n    * RPC Errors\n    * Transaction Errors\n  * Testing\n    * Unit Testing\n    * Integration Testing\n    * End-to-End Testing\n  * Performance Optimization\n    * Efficiency\n    * Monitoring\n  * Documentation\n    * Code Documentation\n    * User Documentation\n  * Deployment Checklist\n    * Pre-Production\n    * Production\n  * Compliance Levels\n    * Minimal (User Client)\n    * Standard (Production Application)\n    * Advanced (Clearnode Implementation)\n  * Next Steps\n  * Resources\n\nSummary: A comprehensive implementation roadmap and resource directory for architects to verify the completeness of their Yellow Network protocol integration across security, state, and compliance layers.\n\nRelated terms: implementation checklist, integration guide, yellow network, protocol setup, channel management, rpc methods, state management, security best practices, compliance levels, deployment, testing, blockchain connection, signature handling, session keys, clearnode\n\nUse cases: building a user client, developing a production-grade application, implementing a Clearnode, auditing protocol integration",
    "metadata": {
      "title": "Implementation Checklist | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/implementation-checklist",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "A comprehensive implementation roadmap and resource directory for architects to verify the completeness of their Yellow Network protocol integration across security, state, and compliance layers.",
      "keywords": [
        "implementation checklist",
        "integration guide",
        "yellow network",
        "protocol setup",
        "channel management",
        "rpc methods",
        "state management",
        "security best practices",
        "compliance levels",
        "deployment",
        "testing",
        "blockchain connection",
        "signature handling",
        "session keys",
        "clearnode"
      ],
      "function_name": null,
      "intent": "configuration",
      "use_cases": [
        "building a user client",
        "developing a production-grade application",
        "implementing a Clearnode",
        "auditing protocol integration"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## What is Nitrolite?â€‹\n\n\nNitrolite is a state channel protocol that enables off-chain interactions between participants with minimal on-chain operations. The protocol forms a unified virtual ledger (called \"clearnet\") for applications to escrow funds while being fully abstracted from the underlying blockchain.\n\nThe initial version of Nitrolite is EVM-compatible and designed for deployment on Layer 1 and Layer 2 Ethereum networks.\n\nSummary: Nitrolite is a state channel protocol that enables high-performance off-chain interactions and fund escrow via a virtual ledger, abstracting blockchain complexity for EVM-compatible networks.\n\nRelated terms: state channel, off-chain, virtual ledger, clearnet, escrow, EVM, Layer 2, Ethereum, scalability, payment channel, blockchain abstraction, nitrolite, nitro lite, settlement\n\nUse cases: high-frequency micro-payments, decentralized exchange settlement, off-chain application state updates",
    "metadata": {
      "title": "Introduction | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/introduction",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Nitrolite is a state channel protocol that enables high-performance off-chain interactions and fund escrow via a virtual ledger, abstracting blockchain complexity for EVM-compatible networks.",
      "keywords": [
        "state channel",
        "off-chain",
        "virtual ledger",
        "clearnet",
        "escrow",
        "EVM",
        "Layer 2",
        "Ethereum",
        "scalability",
        "payment channel",
        "blockchain abstraction",
        "nitrolite",
        "nitro lite",
        "settlement"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency micro-payments",
        "decentralized exchange settlement",
        "off-chain application state updates"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Design Goalsâ€‹\n\n\nNitrolite is designed with the following objectives:\n\n  * **Scalability** : Move high-frequency operations off-chain\n  * **Cost Efficiency** : Minimize gas fees by reducing on-chain transactions\n  * **Security** : Maintain blockchain-level security guarantees\n  * **Interoperability** : Support multiple blockchains and assets\n  * **Developer Experience** : Provide clear, implementable specifications\n\nSummary: Nitrolite is the high-performance off-chain scaling layer for the Yellow Network, designed to facilitate high-frequency transactions with minimal gas costs and cross-chain interoperability.\n\nRelated terms: Nitrolite, Yellow Network, off-chain scaling, layer 2, L2, gas efficiency, cross-chain, interoperability, high-frequency trading, blockchain security, multi-asset support, scalability, Nitro lite, YellowNetwork\n\nUse cases: High-frequency trading platforms, Cross-chain liquidity provision, Low-latency payment processing, Gas-efficient decentralized finance",
    "metadata": {
      "title": "Introduction | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/introduction",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Nitrolite is the high-performance off-chain scaling layer for the Yellow Network, designed to facilitate high-frequency transactions with minimal gas costs and cross-chain interoperability.",
      "keywords": [
        "Nitrolite",
        "Yellow Network",
        "off-chain scaling",
        "layer 2",
        "L2",
        "gas efficiency",
        "cross-chain",
        "interoperability",
        "high-frequency trading",
        "blockchain security",
        "multi-asset support",
        "scalability",
        "Nitro lite",
        "YellowNetwork"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "High-frequency trading platforms",
        "Cross-chain liquidity provision",
        "Low-latency payment processing",
        "Gas-efficient decentralized finance"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Protocol Layersâ€‹\n\n\nNitrolite consists of three interconnected layers:\n\n  1. **On-Chain Layer** : Smart contracts that handle fund custody, dispute resolution, and final settlement\n  2. **Off-Chain Layer** : RPC protocol for fast, gasless state updates between participants\n  3. **Application Layer** : Arbitrary application logic built on top of the protocol\n\nApplication Layer\n\nOff-Chain RPC Layer\n\nOn-Chain Smart Contract Layer\n\nBlockchain\n\nSummary: Defines the three-tier architecture of the Nitrolite protocol, outlining how on-chain settlement, off-chain RPC state updates, and application logic interact to provide a scalable payment infrastructure.\n\nRelated terms: Nitrolite, Yellow Network, on-chain, off-chain, RPC protocol, smart contracts, gasless transactions, state updates, dispute resolution, settlement layer, application layer, layer 2, L2 scaling, YellowNetwork\n\nUse cases: Architecting scalable payment solutions, Integrating gasless state updates, Designing decentralized application logic, Managing on-chain fund custody",
    "metadata": {
      "title": "Introduction | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/introduction",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the three-tier architecture of the Nitrolite protocol, outlining how on-chain settlement, off-chain RPC state updates, and application logic interact to provide a scalable payment infrastructure.",
      "keywords": [
        "Nitrolite",
        "Yellow Network",
        "on-chain",
        "off-chain",
        "RPC protocol",
        "smart contracts",
        "gasless transactions",
        "state updates",
        "dispute resolution",
        "settlement layer",
        "application layer",
        "layer 2",
        "L2 scaling",
        "YellowNetwork"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Architecting scalable payment solutions",
        "Integrating gasless state updates",
        "Designing decentralized application logic",
        "Managing on-chain fund custody"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Specification Scopeâ€‹\n\n\nThis document defines the Nitrolite protocol in a **programming language-agnostic manner**. Implementers can use these specifications to build compliant implementations in any language (Go, Python, Rust, JavaScript, etc.).\n\nLanguage Independence\n\nImplementation-specific details are referenced but not mandated by this specification. The protocol description is abstract and can be implemented in any programming language.\n\nSummary: This section establishes the Nitrolite protocol as a language-agnostic specification, providing the abstract architectural framework required to build compliant implementations across diverse programming environments.\n\nRelated terms: Nitrolite protocol, language-agnostic, cross-chain, specification, implementation guide, interoperability, agnostic design, protocol standards, multi-language support, Yellow Network, blockchain architecture, SDK framework, Nitrolight, agnosticism\n\nUse cases: Developing custom protocol implementations in new programming languages, Ensuring cross-platform compliance for payment nodes, Architecting language-independent blockchain communication layers",
    "metadata": {
      "title": "Introduction | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/introduction",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section establishes the Nitrolite protocol as a language-agnostic specification, providing the abstract architectural framework required to build compliant implementations across diverse programming environments.",
      "keywords": [
        "Nitrolite protocol",
        "language-agnostic",
        "cross-chain",
        "specification",
        "implementation guide",
        "interoperability",
        "agnostic design",
        "protocol standards",
        "multi-language support",
        "Yellow Network",
        "blockchain architecture",
        "SDK framework",
        "Nitrolight",
        "agnosticism"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Developing custom protocol implementations in new programming languages",
        "Ensuring cross-platform compliance for payment nodes",
        "Architecting language-independent blockchain communication layers"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## RFC 2119 Keywordsâ€‹\n\n\nThe keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n\n\n\n[NextTerminology](/docs/protocol/terminology)\n\n  * What is Nitrolite?\n  * Design Goals\n  * Protocol Layers\n  * Specification Scope\n  * RFC 2119 Keywords\n\nSummary: Provides an overview of the Yellow Network protocol (Nitrolite), defining its architectural layers, design objectives, and the formal RFC 2119 terminology used for technical compliance.\n\nRelated terms: Yellow Network, Nitrolite, protocol architecture, design goals, RFC 2119, technical specification, crypto payment protocol, blockchain layers, compliance standards, Nitrolite SDK, Yellow protocol, state channel design, specification scope\n\nUse cases: architectural overview of Nitrolite, understanding protocol compliance requirements, learning about Yellow Network design principles",
    "metadata": {
      "title": "Introduction | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/introduction",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides an overview of the Yellow Network protocol (Nitrolite), defining its architectural layers, design objectives, and the formal RFC 2119 terminology used for technical compliance.",
      "keywords": [
        "Yellow Network",
        "Nitrolite",
        "protocol architecture",
        "design goals",
        "RFC 2119",
        "technical specification",
        "crypto payment protocol",
        "blockchain layers",
        "compliance standards",
        "Nitrolite SDK",
        "Yellow protocol",
        "state channel design",
        "specification scope"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "architectural overview of Nitrolite",
        "understanding protocol compliance requirements",
        "learning about Yellow Network design principles"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Off-Chain RPC Protocol\n  * App Session Methods\n\n\n\n# App Session Methods\n\nApp sessions enable multi-party applications with custom governance rules, allowing complex interactions on top of payment channels.\n\n* * *\n\nSummary: App sessions facilitate multi-party applications by implementing custom governance rules and complex state interactions layered over existing payment channels.\n\nRelated terms: app session, multi-party application, governance rules, payment channels, off-chain RPC, state channel, layer 2, session management, custom logic, multi-party interaction, appsession, yellow network\n\nUse cases: decentralized gaming with custom rules, complex multi-party escrow agreements, conditional payment logic, collaborative state-based applications",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "App sessions facilitate multi-party applications by implementing custom governance rules and complex state interactions layered over existing payment channels.",
      "keywords": [
        "app session",
        "multi-party application",
        "governance rules",
        "payment channels",
        "off-chain RPC",
        "state channel",
        "layer 2",
        "session management",
        "custom logic",
        "multi-party interaction",
        "appsession",
        "yellow network"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "decentralized gaming with custom rules",
        "complex multi-party escrow agreements",
        "conditional payment logic",
        "collaborative state-based applications"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Overviewâ€‹\n\n\nApp sessions are off-chain channels built on top of the unified balance, intended for app developers to create application-specific interactions. They act as a \"box\" or shared account where multiple participants can transfer funds and execute custom logic with governance rules.\n\n### Key Featuresâ€‹\n\n**Multi-Party Governance** : Define custom voting weights and quorum rules for state updates.\n\n**Application-Specific State** : Store arbitrary application data (game state, escrow conditions, etc.).\n\n**Flexible Fund Management** : Transfer, redistribute, add, or withdraw funds during session lifecycle.\n\n**Instant Updates** : All state changes happen off-chain with zero gas fees.\n\nFor App Developers\n\nApp sessions are specifically designed for app developers building trustless multi-party applications like games, prediction markets, escrow, and collaborative finance.\n\n* * *\n\nSummary: App sessions provide a framework for creating off-chain, multi-party channels that support custom governance, arbitrary state management, and gasless fund transfers for decentralized applications.\n\nRelated terms: App session, Off-chain channel, State channel, Multi-party governance, Zero gas fees, Shared account, Unified balance, Escrow, Quorum rules, Voting weights, Trustless interaction, Layer 2, AppSession, State update, Collaborative finance\n\nUse cases: Decentralized gaming state management, Multi-party escrow services, Prediction markets, Collaborative finance",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "App sessions provide a framework for creating off-chain, multi-party channels that support custom governance, arbitrary state management, and gasless fund transfers for decentralized applications.",
      "keywords": [
        "App session",
        "Off-chain channel",
        "State channel",
        "Multi-party governance",
        "Zero gas fees",
        "Shared account",
        "Unified balance",
        "Escrow",
        "Quorum rules",
        "Voting weights",
        "Trustless interaction",
        "Layer 2",
        "AppSession",
        "State update",
        "Collaborative finance"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Decentralized gaming state management",
        "Multi-party escrow services",
        "Prediction markets",
        "Collaborative finance"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Protocol Versionsâ€‹\n\n\nApp sessions support multiple protocol versions for backward compatibility.\n\n### Version Comparisonâ€‹\n\nFeature| NitroRPC/0.2 (Legacy)| NitroRPC/0.4 (Current)  \n---|---|---  \n**State Updates**|  Basic only| Intent-based (OPERATE, DEPOSIT, WITHDRAW)  \n**Add Funds to Active Session**|  âŒ No| âœ… Yes (DEPOSIT intent)  \n**Remove Funds from Active Session**|  âŒ No| âœ… Yes (WITHDRAW intent)  \n**Fund Redistribution**|  âœ… Yes| âœ… Yes (OPERATE intent)  \n**Error Handling**|  Basic| Enhanced validation  \n**Modify Total Funds**|  Must close & recreate| Can update during session  \n**Recommended For**|  Legacy support only| All new implementations  \n  \nProtocol Version Selection\n\nThe protocol version is specified in the app definition during creation and **cannot be changed** for an existing session. Always use **NitroRPC/0.4** for new app sessions.\n\n* * *\n\nSummary: This section outlines the differences between NitroRPC protocol versions, emphasizing the transition to intent-based state updates and dynamic fund management in version 0.4. It provides a framework for architects to choose the correct protocol version based on required features like mid-session deposits and withdrawals.\n\nRelated terms: NitroRPC, Protocol version, State update, Intent-based, DEPOSIT intent, WITHDRAW intent, OPERATE intent, Backward compatibility, Dynamic funding, Session lifecycle, Liquidity management, Nitro RPC, App session, Versioning, Legacy support\n\nUse cases: Upgrading legacy payment channels to support dynamic deposits, Implementing non-custodial withdrawals from an active session, Selecting the appropriate protocol version for a new dApp integration, Managing multi-party fund redistribution without session restarts",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the differences between NitroRPC protocol versions, emphasizing the transition to intent-based state updates and dynamic fund management in version 0.4. It provides a framework for architects to choose the correct protocol version based on required features like mid-session deposits and withdrawals.",
      "keywords": [
        "NitroRPC",
        "Protocol version",
        "State update",
        "Intent-based",
        "DEPOSIT intent",
        "WITHDRAW intent",
        "OPERATE intent",
        "Backward compatibility",
        "Dynamic funding",
        "Session lifecycle",
        "Liquidity management",
        "Nitro RPC",
        "App session",
        "Versioning",
        "Legacy support"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Upgrading legacy payment channels to support dynamic deposits",
        "Implementing non-custodial withdrawals from an active session",
        "Selecting the appropriate protocol version for a new dApp integration",
        "Managing multi-party fund redistribution without session restarts"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## create_app_sessionâ€‹\n\n\n### Nameâ€‹\n\n`create_app_session`\n\n### Usageâ€‹\n\nCreates a new virtual application session on top of the unified balance. An app session is a \"box\" or shared account where multiple participants can transfer funds and execute application-specific logic with custom governance rules. The app definition specifies participants, their voting weights, quorum requirements for state updates, and the protocol version. Funds are transferred from participants' unified balance accounts to a dedicated App Session Account for the duration of the session. App sessions enable complex multi-party applications like games, prediction markets, escrow, and collaborative financeâ€”all operating off-chain with instant state updates and zero gas fees.\n\n### When to Useâ€‹\n\nWhen multiple participants need to interact with shared funds and application state in a trustless manner. Examples include turn-based games, betting pools, escrow arrangements, DAOs, prediction markets, and any application requiring multi-signature state management.\n\n### Prerequisitesâ€‹\n\n  * All participants with non-zero initial allocations must be [authenticated](/docs/protocol/off-chain/authentication)\n  * All such participants must have sufficient available balance\n  * All such participants must sign the creation request\n  * Protocol version must be supported (NitroRPC/0.2 or NitroRPC/0.4)\n\n### Requestâ€‹\n\nQuick Reference\n\nCommon structures: AppDefinition â€¢ Allocation\n\nParameter| Type| Required| Description| See Also  \n---|---|---|---|---  \n`definition`| AppDefinition| Yes| Configuration defining the app session rules and participants| â†“ Structure  \n`allocations`| Allocation[]| Yes| Initial funds to transfer from participants' unified balance accounts| â†“ Structure  \n`session_data`| string| No| Application-specific initial state (JSON string, max 64KB recommended)  \nThis is application-specific; protocol doesn't validate content| â€”  \n  \n#### Session Identifierâ€‹\n\n`app_session_id` is derived deterministically from the entire App definition:\n    \n    \n    appSessionId = keccak256(JSON.stringify({  \n      application: \"...\",  \n      protocol: \"NitroRPC/0.4\",  \n      participants: [...],  \n      weights: [...],  \n      quorum: 100,  \n      challenge: 86400,  \n      nonce: 123456  \n    }))  \n    \n\n  * Includes `application`, `protocol`, `participants`, `weights`, `quorum`, `challenge`, and `nonce`\n  * Does **not** include `chainId` because sessions live entirely off-chain\n  * Client can recompute locally to verify clearnode responses\n  * `nonce` uniqueness is critical: same definition â‡’ same ID\n\nImplementation reference: `clearnode/app_session_service.go`.\n\n#### AppDefinitionâ€‹\n\nField| Type| Required| Description| Default| Allowed Values| Notes  \n---|---|---|---|---|---|---  \n`protocol`| string| Yes| Protocol version for this app session| â€”| `\"NitroRPC/0.2\"` | `\"NitroRPC/0.4\"`| Version cannot be changed after creation; use 0.4 for new sessions  \n`participants`| address[]| Yes| Array of all participant wallet addresses| â€”| Min: 2 participants| Order is important - indices used for signatures and weights  \nLast participant often represents the application/judge  \n`weights`| int64[]| Yes| Voting power for each participant| â€”| â€”| Length must match participants array  \nOrder corresponds to participants array  \nAbsolute values matter for quorum; don't need to sum to 100  \n`quorum`| uint64| Yes| Minimum total weight required to approve state updates| â€”| â€”| Sum of signers' weights must be â‰¥ quorum  \n`challenge`| uint64| No| Challenge period in seconds for disputes| 86400 (24 hours)| â€”| Only relevant if app session state is ever checkpointed on-chain  \n`nonce`| uint64| Yes| Unique identifier| â€”| â€”| Typically timestamp; ensures uniqueness  \n  \n**Example** :\n    \n    \n    {  \n      \"protocol\": \"NitroRPC/0.4\",  \n      \"participants\": [\"0x742d35Cc...\", \"0x8B3192f2...\", \"0x456789ab...\"],  \n      \"weights\": [50, 50, 100],  \n      \"quorum\": 100,  \n      \"challenge\": 3600,  \n      \"nonce\": 1699123456789  \n    }  \n    \n\n#### Allocationâ€‹\n\nField| Type| Required| Description  \n---|---|---|---  \n`participant`| address| Yes| Participant wallet address (must be in `definition.participants`)  \n`asset`| string| Yes| Asset identifier (e.g., `\"usdc\"`)  \n`amount`| string| Yes| Amount in human-readable format (e.g., `\"100.0\"`)  \n  \n**Example** :\n    \n    \n    [  \n          {\"participant\": \"0x742d35Cc...\", \"asset\": \"usdc\", \"amount\": \"100.0\"},  \n          {\"participant\": \"0x8B3192f2...\", \"asset\": \"usdc\", \"amount\": \"100.0\"},  \n          {\"participant\": \"0x456789ab...\", \"asset\": \"usdc\", \"amount\": \"0.0\"}  \n        ]  \n    \n\n**Note** : Participants with zero allocation don't need to sign creation.\n\n### Responseâ€‹\n\nParameter| Type| Description| Format/Structure| Example| Notes  \n---|---|---|---|---|---  \n`app_session_id`| string| Unique identifier for the created app session| 0x-prefixed hex string (32 bytes)| `\"0x9876543210fedcba9876543210fedcba9876543210fedcba9876543210fedcba\"`| Use this for all subsequent operations on this session  \n`status`| string| App session status| `\"open\"`| `\"open\"`| Values: `\"open\"` or `\"closed\"`  \n`version`| number| Current state version| `1`| `1`| Always starts at 1  \n  \nThe Go service returns only these fields on creation. To fetch full metadata (application, participants, quorum, weights, session_data, protocol, challenge, nonce, timestamps), call [`get_app_sessions`](/docs/protocol/off-chain/queries#get_app_sessions) after creation.\n\n* * *\n\nSummary: Initializes a virtual application session that functions as a shared account for multi-party state management and off-chain fund execution under custom governance rules.\n\nRelated terms: create_app_session, app session, shared account, multi-party state, off-chain logic, governance rules, voting weights, quorum, zero gas fees, state channel, virtual session, app definition, fund allocation, multi-sig, app_session_id\n\nUse cases: turn-based games, prediction markets, escrow arrangements, collaborative finance",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Initializes a virtual application session that functions as a shared account for multi-party state management and off-chain fund execution under custom governance rules.",
      "keywords": [
        "create_app_session",
        "app session",
        "shared account",
        "multi-party state",
        "off-chain logic",
        "governance rules",
        "voting weights",
        "quorum",
        "zero gas fees",
        "state channel",
        "virtual session",
        "app definition",
        "fund allocation",
        "multi-sig",
        "app_session_id"
      ],
      "function_name": "create_app_session",
      "intent": "api_reference",
      "use_cases": [
        "turn-based games",
        "prediction markets",
        "escrow arrangements",
        "collaborative finance"
      ],
      "function_names": [
        "app_session_service",
        "session_data",
        "app_session_id",
        "create_app_session",
        "get_app_sessions"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Governance Modelsâ€‹\n\n\nApp sessions support flexible governance through custom weights and quorum configurations.\n\n### Example 1: Simple Two-Player Gameâ€‹\n    \n    \n    Participants: [Alice, Bob]  \n    Weights: [1, 1]  \n    Quorum: 2  \n      \n    Result: Both players must sign every state update  \n    Use case: Chess, poker, betting between two parties  \n    \n\n**Governance** : Cooperative - both parties must agree to all changes.\n\n### Example 2: Game with Judgeâ€‹\n    \n    \n    Participants: [Alice, Bob, Judge]  \n    Weights: [0, 0, 100]  \n    Quorum: 100  \n      \n    Result: Only judge can update state  \n    Use case: Games where application determines outcome  \n    \n\n**Governance** : Authoritative - application/judge has full control.\n\n### Example 3: Multi-Party Escrowâ€‹\n    \n    \n    Participants: [Buyer, Seller, Arbiter]  \n    Weights: [40, 40, 50]  \n    Quorum: 80  \n      \n    Result: Any 2 parties can approve  \n      - Buyer + Seller (80)  \n      - Buyer + Arbiter (90)  \n      - Seller + Arbiter (90)  \n    Use case: Escrowed transactions with dispute resolution  \n    \n\n**Governance** : Flexible 2-of-3 - any two can proceed, preventing single-party blocking.\n\n### Example 4: DAO-like Votingâ€‹\n    \n    \n    Participants: [User1, User2, User3, User4, Contract]  \n    Weights: [20, 25, 30, 25, 0]  \n    Quorum: 51  \n      \n    Result: Majority of weighted votes required (51 out of 100)  \n    Use case: Collaborative funds management  \n    \n\n**Governance** : Weighted majority - decisions require majority approval by stake.\n\n### Example 5: Watch Towerâ€‹\n    \n    \n    Participants: [Alice, Bob, WatchTower]  \n    Weights: [40, 40, 100]  \n    Quorum: 80  \n      \n    Result:  \n      - Normal operation: Alice + Bob (80)  \n      - Emergency: WatchTower alone (100)  \n    Use case: Automated monitoring and intervention  \n    \n\n**Governance** : Dual-mode - normal requires cooperation, emergency allows automated action.\n\nGovernance Flexibility\n\nBy adjusting weights and quorum, you can implement any governance model from fully cooperative (all must sign) to fully authoritative (single party controls) to complex weighted voting systems.\n\n* * *\n\nSummary: This component defines the authorization logic for App Sessions by configuring participant weights and quorum thresholds to enable various trust and governance models.\n\nRelated terms: governance, quorum, weights, multi-sig, consensus, state update, escrow, dispute resolution, DAO, watchtower, threshold, multi-party, quorem, signing\n\nUse cases: multi-party escrow with dispute resolution, collaborative funds management, automated monitoring and intervention, two-player cooperative games",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the authorization logic for App Sessions by configuring participant weights and quorum thresholds to enable various trust and governance models.",
      "keywords": [
        "governance",
        "quorum",
        "weights",
        "multi-sig",
        "consensus",
        "state update",
        "escrow",
        "dispute resolution",
        "DAO",
        "watchtower",
        "threshold",
        "multi-party",
        "quorem",
        "signing"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "multi-party escrow with dispute resolution",
        "collaborative funds management",
        "automated monitoring and intervention",
        "two-player cooperative games"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Fund Transfer Mechanicsâ€‹\n\n\nWhen an app session is created, funds are transferred from the unified balance account to a dedicated App Session Account:\n\ncreate_app_session\n\nAlice's Unified Account  \nBalance: 200 USDC\n\nCreate App Session  \nAlice transfers 100 USDC\n\nAlice's Unified Account  \nBalance: 100 USDC\n\nApp Session Account  \nBalance: 100 USDC  \n(Beneficiary: Alice)\n\n**Balance State Changes** :\n    \n    \n    Before Creation:  \n      Alice's Unified Account:  \n        Balance: 200 USDC  \n      \n    After Creating Session with 100 USDC:  \n      Alice's Unified Account:  \n        Balance: 100 USDC  \n        \n      App Session Account:  \n        Balance: 100 USDC (Beneficiary: Alice)  \n    \n\n### Signature Requirementsâ€‹\n\nAll participants with non-zero initial allocations MUST sign the create_app_session request. The clearnode validates that:\n\n  1. All required signatures are present\n  2. Signatures are valid for respective participants\n  3. Total weight of signers >= quorum (must be met for creation)\n\n* * *\n\nSummary: Manages the initialization of application-specific sessions by isolating funds from a unified account into a dedicated session account, enforced by multi-party signature validation and quorum requirements.\n\nRelated terms: create_app_session, fund transfer, unified balance, session account, multi-party signature, quorum, clearnode, liquidity locking, deposit, state update, authorization, app session, signing\n\nUse cases: Initializing a secure payment channel, Multi-party fund allocation, Session-based escrow setup",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Manages the initialization of application-specific sessions by isolating funds from a unified account into a dedicated session account, enforced by multi-party signature validation and quorum requirements.",
      "keywords": [
        "create_app_session",
        "fund transfer",
        "unified balance",
        "session account",
        "multi-party signature",
        "quorum",
        "clearnode",
        "liquidity locking",
        "deposit",
        "state update",
        "authorization",
        "app session",
        "signing"
      ],
      "function_name": "create_app_session",
      "intent": "api_reference",
      "use_cases": [
        "Initializing a secure payment channel",
        "Multi-party fund allocation",
        "Session-based escrow setup"
      ],
      "function_names": [
        "create_app_session"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## submit_app_stateâ€‹\n\n\n### Nameâ€‹\n\n`submit_app_state`\n\n### Usageâ€‹\n\nSubmits a state update for an active app session. State updates can redistribute funds between participants (OPERATE intent), add funds to the session (DEPOSIT intent), or remove funds from the session (WITHDRAW intent). The intent system is only available in NitroRPC/0.4; version 0.2 sessions only support fund redistribution without explicit intent. Each state update increments the version number, and must be signed by participants whose combined weights meet the quorum requirement. The allocations field always represents the FINAL state after the operation, not the delta.\n\n### When to Useâ€‹\n\nDuring app session lifecycle to update the state based on application logic. Examples include recording game moves, updating scores, reallocating funds based on outcomes, adding stakes, or partially withdrawing winnings.\n\n### Prerequisitesâ€‹\n\n  * App session must exist and be in \"open\" status\n  * Signers must meet quorum requirement\n  * For DEPOSIT intent: Depositing participant must sign (in addition to quorum)\n  * For DEPOSIT intent: Depositing participant must have sufficient available balance\n  * For WITHDRAW intent: Session must have sufficient funds to withdraw\n  * NitroRPC/0.4: `version` must be **exactly current_version + 1**\n  * NitroRPC/0.2: **omit** `intent` and `version` (service rejects them); only OPERATE-style redistribution is supported\n  * If using a session key, spending allowances for that key are enforced\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Format| Example| Notes / See Also  \n---|---|---|---|---|---|---  \n`app_session_id`| string| Yes| Identifier of the app session to update| 0x-prefixed hex string (32 bytes)| `\"0x9876543210fedcba...\"`| -  \n`intent`| string| Yes for v0.4, No for v0.2| Type of operation (NitroRPC/0.4 only)| Allowed: `\"operate\"` | `\"deposit\"` | `\"withdraw\"`| `\"operate\"`| Omit for NitroRPC/0.2 sessions (treated as operate)  \n`version`| number| Yes| Expected next version number| -| `2`| Must be exactly currentVersion + 1; prevents conflicts  \n`allocations`| Allocation[]| Yes| **FINAL allocation state after this update**  \n  \nâš ï¸ **IMPORTANT** : This is the target state, NOT the delta| See Allocation above| After operate from [100, 100] where Alice loses 25 to Bob:  \n`[{\"participant\": \"0xAlice\", \"asset\": \"usdc\", \"amount\": \"75.0\"}, {\"participant\": \"0xBob\", \"asset\": \"usdc\", \"amount\": \"125.0\"}]`| Clearnode validates based on intent rules (see below)  \n`session_data`| string| No| Updated application-specific state| JSON string| `\"{\\\"currentMove\\\":\\\"e2e4\\\",\\\"turn\\\":\\\"black\\\"}\"`| Can be updated independently of allocations  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Format/Structure| Example| Notes  \n---|---|---|---|---|---  \n`app_session_id`| string| Session identifier (echoed)| -| -| -  \n`version`| number| Confirmed new version number| -| `2`| -  \n`status`| string| Updated session status| `\"open\"`| `\"open\"`| Minimal response (no metadata echoed)  \n  \nThe Go handler returns an `AppSessionResponse` type, but for state submissions it only includes `app_session_id`, `version`, and `status` (and does not echo session metadata). Use [`get_app_sessions`](/docs/protocol/off-chain/queries#get_app_sessions) to read the full session record.\n\n* * *\n\nSummary: Facilitates state transitions within an active application session by submitting signed updates to redistribute, deposit, or withdraw funds according to protocol-defined intents and quorum requirements.\n\nRelated terms: submit_app_state, state update, deposit funds, withdraw funds, fund redistribution, session management, quorum signing, NitroRPC, app session, multi-party state, off-chain transaction, versioning, allocation update, submitappstate\n\nUse cases: Recording game moves and updating scores in real-time, Adding additional stakes to an active session, Partial withdrawal of winnings without closing the session, Reallocating funds between participants based on off-chain logic",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Facilitates state transitions within an active application session by submitting signed updates to redistribute, deposit, or withdraw funds according to protocol-defined intents and quorum requirements.",
      "keywords": [
        "submit_app_state",
        "state update",
        "deposit funds",
        "withdraw funds",
        "fund redistribution",
        "session management",
        "quorum signing",
        "NitroRPC",
        "app session",
        "multi-party state",
        "off-chain transaction",
        "versioning",
        "allocation update",
        "submitappstate"
      ],
      "function_name": "submit_app_state",
      "intent": "api_reference",
      "use_cases": [
        "Recording game moves and updating scores in real-time",
        "Adding additional stakes to an active session",
        "Partial withdrawal of winnings without closing the session",
        "Reallocating funds between participants based on off-chain logic"
      ],
      "function_names": [
        "current_version",
        "submit_app_state",
        "session_data",
        "app_session_id",
        "get_app_sessions"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Intent System (NitroRPC/0.4)â€‹\n\n\nThe intent system defines the type of operation being performed. Each intent has specific validation rules.\n\n### Intent: OPERATE (Redistribute Existing Funds)â€‹\n\n**Purpose** : Move funds between participants without changing total amount in session.\n\n**Rules** :\n\n  * Sum of allocations MUST equal sum before operation\n  * No funds added or removed from session\n  * Quorum requirement MUST be met\n  * Depositing participant signature NOT required\n\n**Example** :\n    \n    \n    Current state (version 1):  \n      Alice: 100 USDC  \n      Bob: 100 USDC  \n      Total: 200 USDC  \n      \n    Update (version 2, intent: \"operate\"):  \n      Allocations: [  \n        {\"participant\": \"0xAlice\", \"asset\": \"usdc\", \"amount\": \"75.0\"},  \n        {\"participant\": \"0xBob\", \"asset\": \"usdc\", \"amount\": \"125.0\"}  \n      ]  \n        \n    Result:  \n      Alice: 75 USDC (-25)  \n      Bob: 125 USDC (+25)  \n      Total: 200 USDC (unchanged) âœ“  \n      \n    Validation: Sum before (200) == Sum after (200) âœ“  \n    \n\n**Use Cases** :\n\n  * Record game outcome (winner gets opponent's stake)\n  * Update prediction market positions\n  * Rebalance shared pool\n  * Penalize or reward participants\n\nOPERATE Intent\n\nUse OPERATE for simple fund redistributions within the session. The total amount remains constantâ€”funds just move between participants.\n\n* * *\n\n### Intent: DEPOSIT (Add Funds to Session)â€‹\n\n**Purpose** : Add funds from a participant's unified balance into the session.\n\n**Rules** :\n\n  * Sum of allocations MUST be greater or equal to sum before operation\n  * Increase MUST come from available balance of depositing participant\n  * Depositing participant MUST sign (even if quorum is met without them)\n  * Quorum requirement MUST still be met\n  * Allocations show FINAL amounts (not delta)\n  * If signed via a session key, spending caps for that key are enforced\n\n**Example** :\n    \n    \n    Current state (version 1):  \n      Alice: 100 USDC  \n      Bob: 100 USDC  \n      Total: 200 USDC  \n      \n    Alice's Unified Balance:  \n      Available: 50 USDC  \n      \n    Update (version 2, intent: \"deposit\"):  \n      Allocations: [  \n        {\"participant\": \"0xAlice\", \"asset\": \"usdc\", \"amount\": \"150.0\"},  \n        {\"participant\": \"0xBob\", \"asset\": \"usdc\", \"amount\": \"100.0\"}  \n      ]  \n      Signatures: [AliceSig, QuorumSigs...]  \n        \n    Calculation:  \n      Alice deposit amount = 150 (new) - 100 (old) = 50 USDC  \n        \n    Result:  \n      Alice: 150 USDC (100 + 50 deposited)  \n      Bob: 100 USDC (unchanged)  \n      Total: 250 USDC (+50) âœ“  \n        \n    Alice's Unified Balance After:  \n      Available: 0 USDC (50 transferred to App Session Account)  \n      \n    App Session Account After:  \n      Balance: 250 USDC (increased by 50)  \n      \n    Validation:  \n      - Sum after (250) > Sum before (200) âœ“  \n      - Alice signed âœ“  \n      - Alice had 50 available âœ“  \n    \n\n**Use Cases** :\n\n  * Top up game stake mid-game\n  * Add collateral to escrow\n  * Increase position in prediction market\n  * Buy into ongoing game\n\nDEPOSIT Intent\n\n**Critical Understanding** : The allocations array shows FINAL amounts, not the deposit amount. The clearnode calculates the deposit by comparing previous and new allocations for each participant.\n\n* * *\n\n### Intent: WITHDRAW (Remove Funds from Session)â€‹\n\n**Purpose** : Remove funds from session back to a participant's unified balance.\n\n**Rules** :\n\n  * Sum of allocations MUST be less or equal to sum before operation\n  * Decrease is returned to participant's available balance\n  * Withdrawing participant signature NOT specifically required (quorum sufficient)\n  * Quorum requirement MUST be met\n  * Allocations show FINAL amounts (not delta)\n\n**Example** :\n    \n    \n    Current state (version 1):  \n      Alice: 150 USDC  \n      Bob: 100 USDC  \n      Total: 250 USDC  \n      \n    Update (version 2, intent: \"withdraw\"):  \n      Allocations: [  \n        {\"participant\": \"0xAlice\", \"asset\": \"usdc\", \"amount\": \"150.0\"},  \n        {\"participant\": \"0xBob\", \"asset\": \"usdc\", \"amount\": \"75.0\"}  \n      ]  \n      Signatures: [QuorumSigs...]  \n        \n    Calculation:  \n      Bob withdrawal amount = 100 (old) - 75 (new) = 25 USDC  \n        \n    Result:  \n      Alice: 150 USDC (unchanged)  \n      Bob: 75 USDC (100 - 25 withdrawn)  \n      Total: 225 USDC (-25) âœ“  \n        \n    Bob's Unified Balance After:  \n      Available: +25 USDC  \n      \n    App Session Account After:  \n      Balance: 225 USDC (decreased by 25)  \n      \n    Validation:  \n      - Sum after (225) < Sum before (250) âœ“  \n      - Quorum met âœ“  \n    \n\n**Use Cases** :\n\n  * Cash out partial winnings mid-game\n  * Remove collateral when no longer needed\n  * Take profits from shared investment\n  * Reduce stake in ongoing game\n\n* * *\n\nSummary: Defines the logic and validation rules for state transitions within an app session, specifically governing how funds are redistributed internally or added from external balances via the NitroRPC intent system.\n\nRelated terms: intent system, NitroRPC, OPERATE, DEPOSIT, state update, fund redistribution, add funds, top up, allocation, quorum, session key, spending caps, multi-party, rebalance\n\nUse cases: game outcome settlement, prediction market updates, session funding, pool rebalancing",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the logic and validation rules for state transitions within an app session, specifically governing how funds are redistributed internally or added from external balances via the NitroRPC intent system.",
      "keywords": [
        "intent system",
        "NitroRPC",
        "OPERATE",
        "DEPOSIT",
        "state update",
        "fund redistribution",
        "add funds",
        "top up",
        "allocation",
        "quorum",
        "session key",
        "spending caps",
        "multi-party",
        "rebalance"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "game outcome settlement",
        "prediction market updates",
        "session funding",
        "pool rebalancing"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Version Managementâ€‹\n\n\n  * NitroRPC/0.4: each update MUST be exactly `previous_version + 1`, or it is rejected.\n  * NitroRPC/0.2: omit `intent` and `version`; providing either results in `\"incorrect request: specified parameters are not supported in this protocol\"`.\n\n* * *\n\nSummary: This section defines the versioning constraints for NitroRPC protocols, ensuring sequential state updates and specifying parameter requirements for different protocol versions.\n\nRelated terms: versioning, NitroRPC, state update, protocol version, sequence, previous_version, increment, compatibility, request validation, session management, NitroRPC/0.4, NitroRPC/0.2, protocol migration, state transition\n\nUse cases: ensuring sequential state updates, maintaining backward compatibility with NitroRPC/0.2, validating session message integrity",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section defines the versioning constraints for NitroRPC protocols, ensuring sequential state updates and specifying parameter requirements for different protocol versions.",
      "keywords": [
        "versioning",
        "NitroRPC",
        "state update",
        "protocol version",
        "sequence",
        "previous_version",
        "increment",
        "compatibility",
        "request validation",
        "session management",
        "NitroRPC/0.4",
        "NitroRPC/0.2",
        "protocol migration",
        "state transition"
      ],
      "function_name": "previous_version",
      "intent": "api_reference",
      "use_cases": [
        "ensuring sequential state updates",
        "maintaining backward compatibility with NitroRPC/0.2",
        "validating session message integrity"
      ],
      "function_names": [
        "previous_version"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Quorum Validationâ€‹\n\n\nFor every update, the clearnode validates quorum:\n\nYes\n\nNo\n\nReceive State Update\n\nCalculate Total Weight\n\nSum weights of all signers\n\nTotal Weight >= Quorum?\n\nâœ“ Update Accepted\n\nâœ— Reject: Quorum Not Met\n\n**Validation Logic** :\n    \n    \n    totalWeight = sum of weights for all signers  \n    if (totalWeight >= definition.quorum) {  \n      âœ“ Update accepted  \n    } else {  \n      âœ— Reject: \"Quorum not met\"  \n    }  \n    \n\n**Example** (using Game with Judge scenario):\n    \n    \n    Participants: [Alice, Bob, Judge]  \n    Weights: [0, 0, 100]  \n    Quorum: 100  \n      \n    Valid signature combinations:  \n      - Judge alone: weight = 100 >= 100 âœ“  \n      - Alice + Bob: weight = 0 >= 100 âœ—  \n      - Alice + Bob + Judge: weight = 100 >= 100 âœ“  \n    \n\n* * *\n\nSummary: This component defines the logic for validating state updates within an app session by verifying that the cumulative weight of signers meets a required quorum threshold.\n\nRelated terms: quorum validation, state update, signer weight, clearnode, multi-signature, consensus threshold, signature verification, judge role, participant weight, session security, quorum not met, weight calculation, yellow network, multisig\n\nUse cases: judge-mediated dispute resolution, multi-signature state authorization, custom governance for app sessions",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the logic for validating state updates within an app session by verifying that the cumulative weight of signers meets a required quorum threshold.",
      "keywords": [
        "quorum validation",
        "state update",
        "signer weight",
        "clearnode",
        "multi-signature",
        "consensus threshold",
        "signature verification",
        "judge role",
        "participant weight",
        "session security",
        "quorum not met",
        "weight calculation",
        "yellow network",
        "multisig"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "judge-mediated dispute resolution",
        "multi-signature state authorization",
        "custom governance for app sessions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## close_app_sessionâ€‹\n\n\n### Nameâ€‹\n\n`close_app_session`\n\n### Usageâ€‹\n\nCloses an active app session and distributes all funds from the App Session Account according to the final allocations. Once closed, the app session cannot be reopened; participants must create a new session if they want to continue. The final allocations determine how funds are returned to each participant's unified balance account. Closing requires quorum signatures. The final session_data can record the outcome or final state of the application. All funds in the App Session Account are released immediately.\n\n### When to Useâ€‹\n\nWhen application logic has completed and participants want to finalize the outcome and retrieve their funds. Examples include game ending, escrow condition met, prediction market settled, or any application reaching its natural conclusion.\n\n### Prerequisitesâ€‹\n\n  * App session must exist and be in \"open\" status\n  * Signers must meet quorum requirement\n  * Final allocations must not exceed total funds in session\n  * Sum of final allocations must equal total session funds\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Format/Structure| Example| Notes  \n---|---|---|---|---|---|---  \n`app_session_id`| string| Yes| Identifier of the app session to close| 0x-prefixed hex string (32 bytes)| `\"0x9876543210fedcba...\"`| -  \n`allocations`| Allocation[]| Yes| Final distribution of all funds in the session  \n  \n**IMPORTANT** : Must account for ALL funds; sum must equal session total  \n  \n**Structure (per allocation)** :  \nâ€¢ `participant` (address) - Participant wallet address  \nâ€¢ `asset` (string) - Asset identifier  \nâ€¢ `amount` (string) - Final amount for this participant| See structure| 200 USDC total, winner takes most:  \n`[{\"participant\": \"0xAlice\", \"asset\": \"usdc\", \"amount\": \"180.0\"}, {\"participant\": \"0xBob\", \"asset\": \"usdc\", \"amount\": \"15.0\"}, {\"participant\": \"0xJudge\", \"asset\": \"usdc\", \"amount\": \"5.0\"}]`| Can allocate zero to participants (they get nothing)  \n`session_data`| string| No| Final application state or outcome record| JSON string| `\"{\\\"result\\\":\\\"Alice wins\\\",\\\"finalScore\\\":\\\"3-1\\\"}\"`| Useful for recording outcome for history/analytics  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Format/Structure| Example| Notes  \n---|---|---|---|---|---  \n`app_session_id`| string| Session identifier (echoed)| -| -| -  \n`status`| string| Final status| Value: \"closed\"| `\"closed\"`| Minimal response  \n`version`| number| New session version| -| `2`| Incremented on close  \n  \nclose_app_session response\n\nThe handler returns an `AppSessionResponse` type in Go, but on close it only populates `app_session_id`, `status`, and `version`. For full metadata after closure, query [`get_app_sessions`](/docs/protocol/off-chain/queries#get_app_sessions).\n\n* * *\n\nSummary: The close_app_session method terminates an active application session and executes the final distribution of locked funds to participants' unified balance accounts based on a verified quorum agreement.\n\nRelated terms: close session, settle funds, payout, withdraw, close_app_session, state finalization, quorum signature, allocation, asset distribution, session termination, escrow release, unified balance, multi-party settlement, closeAppSession\n\nUse cases: Settling a prediction market outcome, Releasing funds from a multi-party escrow, Finalizing payouts after a gaming session, Closing a state channel and distributing balances",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The close_app_session method terminates an active application session and executes the final distribution of locked funds to participants' unified balance accounts based on a verified quorum agreement.",
      "keywords": [
        "close session",
        "settle funds",
        "payout",
        "withdraw",
        "close_app_session",
        "state finalization",
        "quorum signature",
        "allocation",
        "asset distribution",
        "session termination",
        "escrow release",
        "unified balance",
        "multi-party settlement",
        "closeAppSession"
      ],
      "function_name": "close_app_session",
      "intent": "api_reference",
      "use_cases": [
        "Settling a prediction market outcome",
        "Releasing funds from a multi-party escrow",
        "Finalizing payouts after a gaming session",
        "Closing a state channel and distributing balances"
      ],
      "function_names": [
        "close_app_session",
        "app_session_id",
        "get_app_sessions",
        "session_data"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Fund Distribution on Closureâ€‹\n\n\nWhen an app session closes, funds return to participants' unified balances:\n    \n    \n    Before Closure:  \n      Alice's Unified Account:  \n        Balance: 100 USDC  \n      \n    App Session Account 0x98765:  \n      Alice: 100 USDC  \n      Bob: 100 USDC  \n      Total: 200 USDC  \n      \n    Close with final allocations:  \n      Alice: 180 USDC  \n      Bob: 20 USDC  \n      \n    After Closure:  \n      Alice's Unified Account:  \n        Balance: 280 USDC (100 + 180 received from session)  \n          \n      Bob's Unified Account:  \n        Balance: 20 USDC (received from session)  \n        \n      App Session Account 0x98765:  \n        Closed (Balance: 0 USDC)  \n    \n\n### Allocation Rulesâ€‹\n\n  1. **Must Sum to Total** :\n\n     * `sum(final_allocations) MUST equal sum(current_allocations)`\n     * Clearnode validates this; cannot create or destroy funds during close\n  2. **Can Be Zero** :\n\n     * Participants can receive zero in final allocation (lost everything)\n     * Example: Losing player in a winner-takes-all game\n  3. **Accounting for Participants** :\n\n     * It is recommended to include an entry for every participant (use zero for losers).\n     * If you omit a participant, the service treats them as receiving zero, as long as per-asset totals still match the session balance.\n  4. **Can Include Non-Financial Participants** :\n\n     * Example: Judge/application can receive commission\n     * `{\"participant\": \"0xJudge\", \"asset\": \"usdc\", \"amount\": \"5.0\"}`\n\n* * *\n\nSummary: This component defines the logic and rules for redistributing funds from a temporary app session account back to participants' unified balances upon session termination. It ensures financial integrity by enforcing that the sum of final allocations matches the total session balance while supporting commissions and zero-sum outcomes.\n\nRelated terms: fund distribution, session closure, unified balance, settlement, allocation rules, Clearnode validation, asset redistribution, payout, winner-takes-all, commission, final_allocations, current_allocations, balance update, crypto payment\n\nUse cases: gaming payout settlement, commission-based service fees, peer-to-peer trade finalization, multi-party fund redistribution",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the logic and rules for redistributing funds from a temporary app session account back to participants' unified balances upon session termination. It ensures financial integrity by enforcing that the sum of final allocations matches the total session balance while supporting commissions and zero-sum outcomes.",
      "keywords": [
        "fund distribution",
        "session closure",
        "unified balance",
        "settlement",
        "allocation rules",
        "Clearnode validation",
        "asset redistribution",
        "payout",
        "winner-takes-all",
        "commission",
        "final_allocations",
        "current_allocations",
        "balance update",
        "crypto payment"
      ],
      "function_name": "final_allocations",
      "intent": "concept",
      "use_cases": [
        "gaming payout settlement",
        "commission-based service fees",
        "peer-to-peer trade finalization",
        "multi-party fund redistribution"
      ],
      "function_names": [
        "sum",
        "current_allocations",
        "final_allocations"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Closure Examplesâ€‹\n\n\n### Example 1: Chess Gameâ€‹\n    \n    \n    Initial:  \n      White: 100 USDC  \n      Black: 100 USDC  \n      Judge: 0 USDC  \n      Total: 200 USDC  \n      \n    Final (White wins):  \n      White: 190 USDC (won 90)  \n      Black: 0 USDC (lost 100)  \n      Judge: 10 USDC (5% commission)  \n      Total: 200 USDC âœ“  \n    \n\n### Example 2: Escrow (Buyer Satisfied)â€‹\n    \n    \n    Initial:  \n      Buyer: 100 USDC  \n      Seller: 0 USDC  \n      Arbiter: 0 USDC  \n      Total: 100 USDC  \n      \n    Final (Successful delivery):  \n      Buyer: 0 USDC  \n      Seller: 99 USDC (payment)  \n      Arbiter: 1 USDC (fee)  \n      Total: 100 USDC âœ“  \n    \n\n### Example 3: Escrow (Dispute, Buyer Refunded)â€‹\n    \n    \n    Initial:  \n      Buyer: 100 USDC  \n      Seller: 0 USDC  \n      Arbiter: 0 USDC  \n      Total: 100 USDC  \n      \n    Final (Arbiter ruled for buyer):  \n      Buyer: 95 USDC (refund minus fee)  \n      Seller: 0 USDC  \n      Arbiter: 5 USDC (dispute fee)  \n      Total: 100 USDC âœ“  \n    \n\n### Example 4: Prediction Marketâ€‹\n    \n    \n    Initial:  \n      User1: 50 USDC (bet YES)  \n      User2: 50 USDC (bet YES)  \n      User3: 40 USDC (bet NO)  \n      Oracle: 0 USDC  \n      Total: 140 USDC  \n      \n    Final (Outcome: YES):  \n      User1: 68.25 USDC (split pot proportionally)  \n      User2: 68.25 USDC  \n      User3: 0 USDC (lost)  \n      Oracle: 3.50 USDC (2.5% fee)  \n      Total: 140 USDC âœ“  \n    \n\nFinal Distribution\n\nAll participants receive funds according to the final allocations, whether they won, lost, or served as neutral parties (judges, arbiters, oracles). The total is always preserved.\n\n* * *\n\n* * *\n\nSummary: Illustrates the final fund distribution logic for multi-party app sessions, demonstrating how balances are reallocated among participants, arbiters, and service providers upon session closure while maintaining total value preservation.\n\nRelated terms: settlement, payout, state closure, fund distribution, escrow, dispute resolution, prediction market, commission, oracle fees, balance preservation, session end, final allocation, refund, arbitration\n\nUse cases: gaming payouts and commissions, escrow and delivery verification, prediction market settlement, dispute resolution and arbiter fees",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Illustrates the final fund distribution logic for multi-party app sessions, demonstrating how balances are reallocated among participants, arbiters, and service providers upon session closure while maintaining total value preservation.",
      "keywords": [
        "settlement",
        "payout",
        "state closure",
        "fund distribution",
        "escrow",
        "dispute resolution",
        "prediction market",
        "commission",
        "oracle fees",
        "balance preservation",
        "session end",
        "final allocation",
        "refund",
        "arbitration"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "gaming payouts and commissions",
        "escrow and delivery verification",
        "prediction market settlement",
        "dispute resolution and arbiter fees"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Implementation Notesâ€‹\n\n\n**State Management** :\n\n  * Always use `intent: \"operate\"` for simple redistributions\n  * Always specify FINAL allocations, never deltas\n  * The clearnode computes deltas internally by comparing with previous state\n  * Version numbers must be strictly sequential\n  * The session_data field can be updated in any intent\n\n**Performance** :\n\n  * Updates are instant (< 1 second) and off-chain\n  * Zero gas fees for all operations\n  * All updates are logged for audit trail\n\n**Notifications** :\n\n  * Participants are notified on all active connections of state changes\n  * Closed sessions remain queryable for history\n\n**Irreversibility** :\n\n  * Closure is instant and atomic\n  * All funds released simultaneously\n  * Once closed, cannot be reopened\n  * To continue, create a new session\n\n* * *\n\nSummary: Defines the operational rules for off-chain app sessions, focusing on gasless state updates, sequential versioning, and atomic closure mechanisms. It ensures system integrity by requiring final allocations and providing instant, irreversible settlement.\n\nRelated terms: off-chain state, gasless transactions, atomic closure, state management, session data, final allocations, sequential versioning, instant settlement, audit trail, payment channel, redistribution, session lifecycle, clearnode, state update, zero gas\n\nUse cases: High-frequency micro-payments, Real-time asset redistribution, Off-chain state synchronization, Atomic session termination",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the operational rules for off-chain app sessions, focusing on gasless state updates, sequential versioning, and atomic closure mechanisms. It ensures system integrity by requiring final allocations and providing instant, irreversible settlement.",
      "keywords": [
        "off-chain state",
        "gasless transactions",
        "atomic closure",
        "state management",
        "session data",
        "final allocations",
        "sequential versioning",
        "instant settlement",
        "audit trail",
        "payment channel",
        "redistribution",
        "session lifecycle",
        "clearnode",
        "state update",
        "zero gas"
      ],
      "function_name": "session_data",
      "intent": "concept",
      "use_cases": [
        "High-frequency micro-payments",
        "Real-time asset redistribution",
        "Off-chain state synchronization",
        "Atomic session termination"
      ],
      "function_names": [
        "session_data"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nExplore other protocol features:\n\n  * **[Queries& Notifications](/docs/protocol/off-chain/queries)** \\- Query session history and receive real-time updates\n  * **[Transfers](/docs/protocol/off-chain/transfers)** \\- Move funds between unified balances\n  * **[Channel Methods](/docs/protocol/off-chain/channel-methods)** \\- Manage underlying payment channels\n\nFor foundational concepts:\n\n  * **[Message Format](/docs/protocol/off-chain/message-format)** \\- Understand request/response structure\n  * **[Authentication](/docs/protocol/off-chain/authentication)** \\- Manage session keys and security\n\n\n\n[PreviousTransfer Method](/docs/protocol/off-chain/transfers)[NextQuery Methods & Notifications](/docs/protocol/off-chain/queries)\n\n  * Overview\n    * Key Features\n  * Protocol Versions\n    * Version Comparison\n  * create_app_session\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n  * Governance Models\n    * Example 1: Simple Two-Player Game\n    * Example 2: Game with Judge\n    * Example 3: Multi-Party Escrow\n    * Example 4: DAO-like Voting\n    * Example 5: Watch Tower\n  * Fund Transfer Mechanics\n    * Signature Requirements\n  * submit_app_state\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n  * Intent System (NitroRPC/0.4)\n    * Intent: OPERATE (Redistribute Existing Funds)\n    * Intent: DEPOSIT (Add Funds to Session)\n    * Intent: WITHDRAW (Remove Funds from Session)\n  * Version Management\n  * Quorum Validation\n  * close_app_session\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n  * Fund Distribution on Closure\n    * Allocation Rules\n  * Closure Examples\n    * Example 1: Chess Game\n    * Example 2: Escrow (Buyer Satisfied)\n    * Example 3: Escrow (Dispute, Buyer Refunded)\n    * Example 4: Prediction Market\n  * Implementation Notes\n  * Next Steps\n\nSummary: This component defines the lifecycle and governance of application sessions, providing methods to initialize, update state, and finalize off-chain interactions with integrated fund management.\n\nRelated terms: app session, state channel, off-chain, create_app_session, submit_app_state, close_app_session, escrow, multi-party, quorum, session management, fund allocation, state update, yellow network, nitro rpc\n\nUse cases: multi-party escrow, off-chain gaming, prediction markets, DAO-like voting",
    "metadata": {
      "title": "App Session Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/app-sessions",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the lifecycle and governance of application sessions, providing methods to initialize, update state, and finalize off-chain interactions with integrated fund management.",
      "keywords": [
        "app session",
        "state channel",
        "off-chain",
        "create_app_session",
        "submit_app_state",
        "close_app_session",
        "escrow",
        "multi-party",
        "quorum",
        "session management",
        "fund allocation",
        "state update",
        "yellow network",
        "nitro rpc"
      ],
      "function_name": "create_app_session",
      "intent": "api_reference",
      "use_cases": [
        "multi-party escrow",
        "off-chain gaming",
        "prediction markets",
        "DAO-like voting"
      ],
      "function_names": [
        "close_app_session",
        "submit_app_state",
        "create_app_session"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "* Off-Chain RPC Protocol\n  * Authentication\n\n\n\n# Authentication\n\nAuthentication with Clearnode can be done in two ways: using your **main wallet as a root signer** for all requests, or delegating to session keys via a secure 3-step challenge-response protocol.\n\n* * *\n\nSummary: Provides authentication mechanisms for Clearnode, allowing users to sign requests using a main wallet or delegate authority to session keys via a challenge-response protocol.\n\nRelated terms: authentication, clearnode, root signer, session keys, challenge-response, off-chain rpc, wallet signing, security, identity, auth, yellow network, yellow-network, sign-in, login\n\nUse cases: secure off-chain communication, delegated signing for automated bots, main wallet identity verification",
    "metadata": {
      "title": "Authentication | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/authentication",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides authentication mechanisms for Clearnode, allowing users to sign requests using a main wallet or delegate authority to session keys via a challenge-response protocol.",
      "keywords": [
        "authentication",
        "clearnode",
        "root signer",
        "session keys",
        "challenge-response",
        "off-chain rpc",
        "wallet signing",
        "security",
        "identity",
        "auth",
        "yellow network",
        "yellow-network",
        "sign-in",
        "login"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "secure off-chain communication",
        "delegated signing for automated bots",
        "main wallet identity verification"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Overviewâ€‹\n\n\nThere are two authentication approaches:\n\n  1. **Main Wallet (Root Signer)** : Sign every request with your main wallet. Simple but requires user interaction for each operation.\n\n  2. **Session Keys (Delegated)** : Establish an authenticated session once, then use a session key for subsequent operations without repeatedly prompting the main wallet.\n\n\nMain Wallet as Root Signer\n\nYou can **skip the session key flow entirely** and use your main wallet to sign all requests. This provides maximum security but requires wallet interaction for every operation. Simply sign each request with your main wallet's private key instead of creating a session key.\n\n### Why Session Keys?â€‹\n\nSession keys provide **flexible security management** :\n\n  * **Granular Permissions** : Specify which operations the session key can perform\n  * **Spending Allowances** : Set maximum spending limits per asset\n  * **Time-Bounded** : Automatic expiration reduces risk of key compromise\n  * **Application-Scoped** : Different keys for different apps\n  * **User Experience** : No repeated wallet prompts during active session\n\nFlexible Security Management\n\nSession keys give users a flexible way to manage security of their funds by providing specific permissions and allowances for specific apps, balancing convenience with security.\n\n### Choosing Your Approachâ€‹\n\nAspect| Main Wallet (Root Signer)| Session Keys (Delegated)  \n---|---|---  \n**Setup**|  None - use immediately| One-time 3-step flow  \n**UX**|  Wallet prompt for every operation| Sign once, use for duration  \n**Security**|  Maximum - full control always| Balanced - limited by allowances  \n**Use Case**|  Single operations, high-value transactions| Interactive apps, frequent operations  \n**Revocation**|  Not needed| Can be revoked anytime  \n**Best For**|  One-time actions, security-critical operations| Gaming, trading bots, dApps with frequent interactions  \n  \nWhen to Use Each\n\n  * **Use Main Wallet** : For single channel creation, large transfers, or when maximum security is required\n  * **Use Session Keys** : For interactive applications, gaming, automated operations, or when user experience matters\n\n### Session Key Authentication Flowâ€‹\n\nThe 3-step process ensures both security and usability:\n\nClearnodeClientUser WalletClearnodeClientUser WalletClearnodeClientUser WalletStep 1: Register Session KeyStep 2: ChallengeStep 3: Verify Session KeyCompleteAll subsequent requests signed with session keyGenerate session keypair (locally)Prepare auth parameters (address, session_key, application, allowances, expires_at)auth_request (public endpoint, no signature)Validate parametersGenerate challenge UUIDauth_challenge (challenge_message)Create EIP-712 typed data with challengeRequest EIP-712 signatureSign with main walletauth_verify (EIP-712 signature by main wallet)Recover address from EIP-712 signatureValidate signature matches main walletCreate session (with allowances)Generate JWT tokenSession established (address, session_key, jwt_token, success)\n\nChallenge-Response Pattern\n\nThis pattern ensures that:\n\n  1. User owns the main wallet (EIP-712 signature in Step 3)\n  2. Challenge is unique and cannot be replayed\n  3. No private keys are ever transmitted\n  4. Session key is authorized by the main wallet\n\n* * *\n\nSummary: This component defines the authentication architecture for the Yellow Network, offering a choice between direct root wallet signing for high-security operations and delegated session keys for improved user experience in high-frequency applications.\n\nRelated terms: authentication, session keys, root signer, wallet signing, delegated authority, permissions, spending limits, JWT, auth challenge, security management, dApp login, signing, session management, walletauth\n\nUse cases: high-frequency trading bots, blockchain gaming interactions, one-time high-value asset transfers, decentralized application session management",
    "metadata": {
      "title": "Authentication | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/authentication",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the authentication architecture for the Yellow Network, offering a choice between direct root wallet signing for high-security operations and delegated session keys for improved user experience in high-frequency applications.",
      "keywords": [
        "authentication",
        "session keys",
        "root signer",
        "wallet signing",
        "delegated authority",
        "permissions",
        "spending limits",
        "JWT",
        "auth challenge",
        "security management",
        "dApp login",
        "signing",
        "session management",
        "walletauth"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency trading bots",
        "blockchain gaming interactions",
        "one-time high-value asset transfers",
        "decentralized application session management"
      ],
      "function_names": [
        "walletauth_verify",
        "challenge_message",
        "expires_at",
        "auth_challenge",
        "jwt_token"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 1: auth_requestâ€‹\n\n\n### Nameâ€‹\n\n`auth_request`\n\n### Usageâ€‹\n\nInitiates authentication with Clearnode by registering a session key. The client sends authentication parameters to register a session key that can act on their behalf. The session key can have restricted permissions including spending limits (allowances), operation scope, and expiration time.\n\n**Important** : `auth_request` is a **public endpoint** and does not require a signature. The client simply needs to prepare and send the authentication parameters.\n\n### When to Useâ€‹\n\n**Optional** : Use this when you want to delegate signing to a session key instead of using your main wallet for every request. This is the first step in establishing an authenticated session with Clearnode.\n\nIf you prefer to use your main wallet as a root signer for all operations, you can skip this entire authentication flow.\n\n### Prerequisitesâ€‹\n\n  * User has a wallet with funds\n  * Client can generate a keypair (e.g., secp256k1)\n  * Client can prepare authentication parameters locally\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example| Notes  \n---|---|---|---|---|---|---  \n`address`| string (wallet address)| Yes| User's main wallet address that owns the funds| -| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`| -  \n`session_key`| string (wallet address)| Yes| Wallet address of the locally-generated session keypair| -| `\"0x9876543210fedcba9876543210fedcba98765432\"`| The private key never leaves the client  \n`application`| string| No| Application identifier for analytics and session management| `\"clearnode\"`| `\"chess-game-app\"`| Helps track which app is using which session  \n`allowances`| Array<Allowance>| No| Spending limits for this session key  \n  \n**Structure (per allowance)** :  \nâ€¢ `asset` (string) - Asset identifier (e.g., \"usdc\", \"eth\")  \nâ€¢ `amount` (string) - Maximum amount this session can spend| Unrestricted if omitted/empty| `[{\"asset\": \"usdc\", \"amount\": \"100.0\"}]`| If empty/omitted, no spending cap is enforced  \n`scope`| string| No| Comma-separated list of permitted operations| All operations permitted| `\"app.create,app.submit,transfer\"`| Future feature, not fully enforced yet  \n`expires_at`| number| Yes| Unix timestamp (milliseconds) when the session key expires| â€”| `1762417328000`| Provide a 13-digit Unix ms timestamp; no server default is applied  \n  \nSpending Allowances\n\nIf you omit `allowances` the session key is unrestricted. Specify explicit allowances to bound risk if a session key is compromised.\n\nAllowances are validated against the brokerâ€™s supported assets. Unsupported symbols will cause authentication to fail.\n\n### Responseâ€‹\n\nParameter| Type| Description| Format| Example| Purpose  \n---|---|---|---|---|---  \n`challenge_message`| string| UUID that client must sign with session key to prove ownership| UUID v4| `\"550e8400-e29b-41d4-a716-446655440000\"`| Proves client controls session key without exposing private key  \n  \n### Signatureâ€‹\n\nRequest **does NOT require a signature** as `auth_request` is a public endpoint.\n\n**Process** :\n\n  1. Client prepares authentication parameters (address, session_key, application, allowances, expires_at)\n  2. Client stores these parameters locally for use in Step 3 (auth_verify)\n  3. Client sends request to Clearnode\n  4. Clearnode validates all parameters before generating a challenge\n\nParameter Storage\n\nKeep the authentication parameters (especially `address`, `session_key`, `application`, `allowances`, `scope`, and `expires_at`) stored locally until Step 3, as you'll need them to create the EIP-712 signature.\n\n### Next Stepâ€‹\n\nUpon receiving the `challenge_message`, client must prepare an EIP-712 signature (or reuse a previously issued `jwt`) and call `auth_verify`.\n\n### Error Casesâ€‹\n\nError Codes\n\nCurrently, the protocol does not use standardized error codes. Errors are returned as descriptive messages.\n\nCommon error scenarios:\n\nError| Description| Recovery  \n---|---|---  \n**Invalid address format**|  Main wallet address is malformed| Verify address format (0x + 40 hex chars)  \n**Invalid session key format**|  Session key address is malformed| Verify session key format  \n**Invalid parameters**|  One or more parameters are invalid or missing| Check all required parameters  \n**Session key already registered**|  This session key is already in use| Generate a new session keypair  \n  \n* * *\n\nSummary: Initiates the authentication process by registering a delegated session key with Clearnode, allowing for scoped permissions and spending limits without requiring the main wallet for every request.\n\nRelated terms: auth_request, session key, authentication, delegated signing, spending limits, allowances, Clearnode, wallet registration, session management, login, authrequest, permissioned keys, secure session\n\nUse cases: delegated signing for high-frequency transactions, setting asset-specific spending limits, establishing secure dApp sessions, non-custodial session management",
    "metadata": {
      "title": "Authentication | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/authentication",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Initiates the authentication process by registering a delegated session key with Clearnode, allowing for scoped permissions and spending limits without requiring the main wallet for every request.",
      "keywords": [
        "auth_request",
        "session key",
        "authentication",
        "delegated signing",
        "spending limits",
        "allowances",
        "Clearnode",
        "wallet registration",
        "session management",
        "login",
        "authrequest",
        "permissioned keys",
        "secure session"
      ],
      "function_name": "auth_request",
      "intent": "api_reference",
      "use_cases": [
        "delegated signing for high-frequency transactions",
        "setting asset-specific spending limits",
        "establishing secure dApp sessions",
        "non-custodial session management"
      ],
      "function_names": [
        "challenge_message",
        "auth_verify",
        "expires_at",
        "auth_request",
        "session_key"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 2: auth_challengeâ€‹\n\n\n### Nameâ€‹\n\n`auth_challenge`\n\n### Usageâ€‹\n\nServer-generated response to `auth_request` containing a challenge that the client must sign to prove control of the session key. This implements a challenge-response authentication pattern to prevent replay attacks and verify the client controls the private key of the session key they registered.\n\n### When to Useâ€‹\n\nAutomatically sent by Clearnode in response to valid `auth_request`. Client does not explicitly call this; it's part of the authentication flow.\n\n### Requestâ€‹\n\nN/A (server-initiated response to `auth_request`)\n\n### Responseâ€‹\n\nParameter| Type| Description| Format| Purpose| Example| Generation| Lifetime  \n---|---|---|---|---|---|---|---  \n`challenge_message`| string| Randomly generated UUID that client must sign| UUID v4| Prevents replay attacks, proves session key ownership| `\"550e8400-e29b-41d4-a716-446655440000\"`| Cryptographically secure random UUID| Single use, expires after 5 minutes if not verified  \n  \n### Signatureâ€‹\n\nThe challenge is returned as a normal RPC response (server signs the envelope like any other RPC response).\n\n### Next Stepâ€‹\n\nClient signs the challenge with session key private key and calls `auth_verify`.\n\nChallenge Uniqueness\n\nEach challenge is unique and single-use. It expires after 5 minutes if not verified. This prevents replay attacks where an attacker might try to reuse a captured challenge signature.\n\n* * *\n\nSummary: Implements a challenge-response authentication mechanism where the server issues a unique, time-bound UUID to verify the client's ownership of a session key and prevent replay attacks.\n\nRelated terms: auth_challenge, challenge-response, replay protection, session key verification, UUID v4, cryptographic proof, authentication flow, Clearnode, secure login, identity verification, authchallenge, server response\n\nUse cases: secure session establishment, preventing replay attacks, cryptographic identity verification",
    "metadata": {
      "title": "Authentication | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/authentication",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Implements a challenge-response authentication mechanism where the server issues a unique, time-bound UUID to verify the client's ownership of a session key and prevent replay attacks.",
      "keywords": [
        "auth_challenge",
        "challenge-response",
        "replay protection",
        "session key verification",
        "UUID v4",
        "cryptographic proof",
        "authentication flow",
        "Clearnode",
        "secure login",
        "identity verification",
        "authchallenge",
        "server response"
      ],
      "function_name": "auth_challenge",
      "intent": "api_reference",
      "use_cases": [
        "secure session establishment",
        "preventing replay attacks",
        "cryptographic identity verification"
      ],
      "function_names": [
        "auth_challenge",
        "auth_request",
        "challenge_message",
        "auth_verify"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Step 3: auth_verifyâ€‹\n\n\n### Nameâ€‹\n\n`auth_verify`\n\n### Usageâ€‹\n\nCompletes the authentication flow by submitting the signed challenge from `auth_challenge`. If the signature is valid and matches the registered session key, the authentication is complete and the session key can be used to sign subsequent requests. This proves the client controls the private key without ever transmitting it.\n\n### When to Useâ€‹\n\nImmediately after receiving `auth_challenge` response. This is the final step in authentication.\n\n### Prerequisitesâ€‹\n\n  * Completed `auth_request` and received `auth_challenge`\n  * Have the challenge_message\n  * Have the session key private key (client-side only)\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Example| Notes  \n---|---|---|---|---|---  \n`challenge`| string| Yes| The challenge_message received from auth_challenge| `\"550e8400-e29b-41d4-a716-446655440000\"`| Must be the exact challenge from Step 2  \n`jwt`| string| No| Existing JWT for re-login without signature| `\"eyJhbGciOi...\"`| If provided, signature is not required  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Example| Notes  \n---|---|---|---|---  \n`address`| string (wallet address)| Authenticated user's main wallet address| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`| Confirms which account is authenticated  \n`session_key`| string (wallet address)| Confirmed session key wallet address| `\"0x9876543210fedcba9876543210fedcba98765432\"`| The authorized session key  \n`jwt_token`| string| JWT token for authenticated API calls| `\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"`| Store securely; validity follows the provided `expires_at`  \n`success`| boolean| Authentication success indicator| `true`| Indicates if authentication completed successfully  \n  \n### Signatureâ€‹\n\nIf `jwt` is omitted, the request **MUST** include an EIP-712 signature signed by the **main wallet** (NOT the session key). If `jwt` is present, no signature is required.\n\n**EIP-712 Typed Data Structure** :\n    \n    \n    {  \n      types: {  \n        EIP712Domain: [  \n          { name: \"name\", type: \"string\" }  \n        ],  \n        Policy: [  \n          { name: \"challenge\", type: \"string\" },  \n          { name: \"scope\", type: \"string\" },  \n          { name: \"wallet\", type: \"address\" },  \n          { name: \"session_key\", type: \"address\" },  \n          { name: \"expires_at\", type: \"uint64\" },  \n          { name: \"allowances\", type: \"Allowance[]\" }  \n        ],  \n        Allowance: [  \n          { name: \"asset\", type: \"string\" },  \n          { name: \"amount\", type: \"string\" }  \n        ]  \n      },  \n      primaryType: \"Policy\",  \n      domain: {  \n        name: <application_name>  // From auth_request  \n      },  \n      message: {  \n        challenge: <challenge_message>,  // From auth_challenge  \n        scope: <scope>,                  // From auth_request  \n        wallet: <address>,               // From auth_request  \n        session_key: <session_key>,      // From auth_request  \n        expires_at: <expires_at>,        // From auth_request (13-digit Unix ms)  \n        allowances: <allowances>         // From auth_request  \n      }  \n    }  \n    \n\n**Signing Process** :\n\n  1. Client creates EIP-712 typed data with challenge and all parameters from Step 1\n  2. User's wallet signs the typed data: `signature = signTypedData(typedData, mainWalletPrivateKey)`\n  3. Client sends request with EIP-712 signature in `sig` array\n\nCritical Security Requirement\n\nThe `auth_verify` signature MUST be an **EIP-712 signature signed by the main wallet** , not the session key. This proves the main wallet owner authorizes the session key to act on their behalf. The signature binds the challenge to the session key authorization.\n\n### Next Stepâ€‹\n\nSession is authenticated. All subsequent private method calls should be signed with the session key. You may also re-authenticate later by sending `auth_verify` with the previously issued `jwt` (no signature required).\n\n### Error Casesâ€‹\n\nError Codes\n\nCurrently, the protocol does not use standardized error codes. Errors are returned as descriptive messages.\n\nCommon error scenarios:\n\nError| Description| Recovery  \n---|---|---  \n**Invalid signature**|  EIP-712 signature doesn't match main wallet or is malformed| Verify main wallet private key used for signing, check EIP-712 structure  \n**Challenge expired**|  Challenge older than 5 minutes| Restart auth flow from `auth_request`  \n**Challenge already used**|  Challenge has been verified already| Generate new session or use existing if still valid  \n**Invalid challenge**|  Challenge not found in pending auths| Ensure `auth_request` succeeded first  \n**Challenge mismatch**|  Challenge doesn't match pending auth| Use exact challenge from `auth_challenge`  \n  \n* * *\n\nSummary: The auth_verify component finalizes the authentication handshake by validating a signed challenge or an existing JWT to establish a secure session and authorize a session key.\n\nRelated terms: auth_verify, authentication, login, EIP-712, JWT, session key, challenge-response, signature verification, wallet connection, identity verification, secure session, authverify, crypto login, sign-in\n\nUse cases: User authentication and login, Session key authorization, JWT-based re-authentication, Secure wallet identity verification",
    "metadata": {
      "title": "Authentication | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/authentication",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The auth_verify component finalizes the authentication handshake by validating a signed challenge or an existing JWT to establish a secure session and authorize a session key.",
      "keywords": [
        "auth_verify",
        "authentication",
        "login",
        "EIP-712",
        "JWT",
        "session key",
        "challenge-response",
        "signature verification",
        "wallet connection",
        "identity verification",
        "secure session",
        "authverify",
        "crypto login",
        "sign-in"
      ],
      "function_name": "auth_verify",
      "intent": "api_reference",
      "use_cases": [
        "User authentication and login",
        "Session key authorization",
        "JWT-based re-authentication",
        "Secure wallet identity verification"
      ],
      "function_names": [
        "application_name",
        "challenge_message",
        "auth_verify",
        "expires_at",
        "auth_challenge"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Complete Authentication Flow Exampleâ€‹\n\n\nPutting it all together:\n\nGenerate session keypair\n\nauth_request  \n(public, no signature)\n\nReceive challenge_message\n\nCreate EIP-712 typed data\n\nauth_verify  \n(EIP-712 sig by main wallet)\n\nSession + JWT established\n\nUse session key for requests\n\nTimeout (expires_at reached)\n\nSpending limit exceeded\n\nManual revocation\n\nMust re-authenticate\n\nMust re-authenticate\n\nMust re-authenticate\n\nError (retry)\n\nTimeout (5 min)\n\nError (retry)\n\nError (retry)\n\nUnauthenticated\n\nPreparingAuth\n\nWaitingForChallenge\n\nCreatingEIP712\n\nSigningWithWallet\n\nWaitingForConfirmation\n\nAuthenticated\n\nSessionExpired\n\nSessionInvalidated\n\nSessionRevoked\n\n* * *\n\nSummary: Establishes a secure, time-bound session between a client and the network using a challenge-response mechanism and EIP-712 signatures to authorize subsequent API requests via session keys.\n\nRelated terms: authentication, session management, EIP-712, JWT, auth_request, auth_verify, challenge-response, wallet signing, session key, token expiration, revocation, login, crypto signature, auth flow\n\nUse cases: secure session establishment, non-custodial wallet login, automated trading authorization, session lifecycle management",
    "metadata": {
      "title": "Authentication | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/authentication",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Establishes a secure, time-bound session between a client and the network using a challenge-response mechanism and EIP-712 signatures to authorize subsequent API requests via session keys.",
      "keywords": [
        "authentication",
        "session management",
        "EIP-712",
        "JWT",
        "auth_request",
        "auth_verify",
        "challenge-response",
        "wallet signing",
        "session key",
        "token expiration",
        "revocation",
        "login",
        "crypto signature",
        "auth flow"
      ],
      "function_name": "auth_verify",
      "intent": "concept",
      "use_cases": [
        "secure session establishment",
        "non-custodial wallet login",
        "automated trading authorization",
        "session lifecycle management"
      ],
      "function_names": [
        "auth_request",
        "challenge_message",
        "expires_at",
        "auth_verify"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Session Managementâ€‹\n\n\n### Session Lifecycleâ€‹\n\n  1. **Creation** : After successful `auth_verify`\n  2. **Active** : Can perform operations until expiration or allowance exceeded\n  3. **Expiration** : Automatic after specified duration\n  4. **Invalidation** : When spending allowances exhausted\n  5. **Revocation** : User or the clearnode can revoke manually\n\n### Checking Session Statusâ€‹\n\nUse `get_session_keys` to view active sessions and their remaining allowances. The response includes session details with current allowance usage and respects the `expires_at` provided during `auth_request`.\n\n### Session Expiration Handlingâ€‹\n\nWhen a session expires according to the `expires_at` you provided, the clearnode will return an error response:\n    \n    \n    {  \n      \"res\": [  \n        <requestId>,  \n        \"error\",  \n        {  \n          \"error\": \"session expired, please re-authenticate\"  \n        },  \n        <timestamp>  \n      ],  \n      \"sig\": [<clearnode_signature>]  \n    }  \n    \n\nError Format\n\nThe protocol does not use numeric error codes. Errors are returned as method `\"error\"` with a descriptive message in the params.\n\n**Recovery** : Re-authenticate by running the 3-step flow again.\n\n### Spending Allowance Trackingâ€‹\n\nThe clearnode tracks spending by monitoring all ledger debit operations:\n    \n    \n    Initial state:  \n      allowance = specified_limit  \n      used = 0  \n      remaining = specified_limit  \n      \n    After operations:  \n      allowance = specified_limit (unchanged)  \n      used = sum_of_all_debits  \n      remaining = allowance - used  \n      \n    When operation exceeds remaining (for assets with an allowance):  \n      Error: \"Session key allowance exceeded: amount_required, remaining_available\"  \n    \n\nAllowance Enforcement\n\nWhen a session key reaches its spending cap, all further operations are rejected. The user must create a new session with fresh allowances or use their main wallet directly.\n\n* * *\n\nSummary: Manages the lifecycle, security parameters, and spending constraints of protocol sessions to enable delegated operations with automated expiration and allowance enforcement.\n\nRelated terms: session management, auth_verify, get_session_keys, spending allowance, session expiration, clearnode, debit tracking, session revocation, authentication flow, spending limit, session status, crypto session, allowance exceeded\n\nUse cases: automated trading bots, delegated wallet spending, temporary session access, limiting financial exposure",
    "metadata": {
      "title": "Authentication | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/authentication",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Manages the lifecycle, security parameters, and spending constraints of protocol sessions to enable delegated operations with automated expiration and allowance enforcement.",
      "keywords": [
        "session management",
        "auth_verify",
        "get_session_keys",
        "spending allowance",
        "session expiration",
        "clearnode",
        "debit tracking",
        "session revocation",
        "authentication flow",
        "spending limit",
        "session status",
        "crypto session",
        "allowance exceeded"
      ],
      "function_name": "auth_verify",
      "intent": "concept",
      "use_cases": [
        "automated trading bots",
        "delegated wallet spending",
        "temporary session access",
        "limiting financial exposure"
      ],
      "function_names": [
        "auth_verify",
        "get_session_keys",
        "amount_required",
        "sum_of_all_debits",
        "clearnode_signature"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Security Best Practicesâ€‹\n\n\n### For Usersâ€‹\n\n  1. **Set Spending Limits** : Always specify `allowances` when creating sessions\n  2. **Short Expirations** : Use shorter expiration times for sensitive operations\n  3. **Application Scoping** : Use different session keys for different applications\n  4. **Monitor Usage** : Regularly check session key spending via `get_session_keys`\n  5. **Revoke When Done** : Revoke sessions when application use is complete\n\n### For Developersâ€‹\n\n  1. **Secure Storage** : Store session key private keys securely (encrypted storage, secure enclaves)\n  2. **Never Transmit** : Never send session key private keys over network\n  3. **Handle Expiration** : Implement automatic re-authentication on session expiry\n  4. **Clear on Logout** : Delete session keys when user logs out\n  5. **Verify Signatures** : Always verify the clearnode's signatures on responses\n\n* * *\n\nSummary: Provides security guidelines and best practices for managing session keys, spending limits, and authentication lifecycles within the Yellow Network protocol.\n\nRelated terms: session keys, authentication, security best practices, spending limits, allowances, private key storage, signature verification, session revocation, clearnode, get_session_keys, auth, secure enclave, session expiry\n\nUse cases: Implementing secure session management, Setting transaction spending limits, Managing session key lifecycles, Verifying network signatures",
    "metadata": {
      "title": "Authentication | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/authentication",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides security guidelines and best practices for managing session keys, spending limits, and authentication lifecycles within the Yellow Network protocol.",
      "keywords": [
        "session keys",
        "authentication",
        "security best practices",
        "spending limits",
        "allowances",
        "private key storage",
        "signature verification",
        "session revocation",
        "clearnode",
        "get_session_keys",
        "auth",
        "secure enclave",
        "session expiry"
      ],
      "function_name": "get_session_keys",
      "intent": "concept",
      "use_cases": [
        "Implementing secure session management",
        "Setting transaction spending limits",
        "Managing session key lifecycles",
        "Verifying network signatures"
      ],
      "function_names": [
        "get_session_keys"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nNow that you're authenticated, you can:\n\n  * **[Create Channels](/docs/protocol/off-chain/channel-methods)** \\- Open payment channels and deposit funds\n  * **[Transfer Funds](/docs/protocol/off-chain/transfers)** \\- Send instant off-chain payments\n  * **[Manage App Sessions](/docs/protocol/off-chain/app-sessions)** \\- Create multi-party application channels\n  * **[Query Data](/docs/protocol/off-chain/queries)** \\- Check balances, transactions, and channel status\n\nFor protocol fundamentals, see:\n\n  * **[Message Format](/docs/protocol/off-chain/message-format)** \\- Understand request/response structure\n  * **[Off-Chain RPC Overview](/docs/protocol/off-chain/overview)** \\- High-level protocol overview\n\n\n\n[PreviousMessage Format](/docs/protocol/off-chain/message-format)[NextChannel Management Methods](/docs/protocol/off-chain/channel-methods)\n\n  * Overview\n    * Why Session Keys?\n    * Choosing Your Approach\n    * Session Key Authentication Flow\n  * Step 1: auth_request\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n    * Signature\n    * Next Step\n    * Error Cases\n  * Step 2: auth_challenge\n    * Name\n    * Usage\n    * When to Use\n    * Request\n    * Response\n    * Signature\n    * Next Step\n  * Step 3: auth_verify\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n    * Signature\n    * Next Step\n    * Error Cases\n  * Complete Authentication Flow Example\n  * Session Management\n    * Session Lifecycle\n    * Checking Session Status\n    * Session Expiration Handling\n    * Spending Allowance Tracking\n  * Security Best Practices\n    * For Users\n    * For Developers\n  * Next Steps\n\nSummary: Provides a secure multi-step authentication framework using session keys to enable persistent, authorized off-chain interactions within the Yellow Network without repeated primary wallet signing.\n\nRelated terms: login, session keys, wallet authentication, auth_request, auth_challenge, auth_verify, off-chain security, identity verification, session management, signature, connect wallet, authentication flow, RPC auth\n\nUse cases: Securely initiating an off-chain trading session, Implementing non-custodial session management for dApps, Authorizing high-frequency off-chain transactions via session keys",
    "metadata": {
      "title": "Authentication | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/authentication",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a secure multi-step authentication framework using session keys to enable persistent, authorized off-chain interactions within the Yellow Network without repeated primary wallet signing.",
      "keywords": [
        "login",
        "session keys",
        "wallet authentication",
        "auth_request",
        "auth_challenge",
        "auth_verify",
        "off-chain security",
        "identity verification",
        "session management",
        "signature",
        "connect wallet",
        "authentication flow",
        "RPC auth"
      ],
      "function_name": "auth_request",
      "intent": "tutorial",
      "use_cases": [
        "Securely initiating an off-chain trading session",
        "Implementing non-custodial session management for dApps",
        "Authorizing high-frequency off-chain transactions via session keys"
      ],
      "function_names": [
        "auth_challenge",
        "auth_request",
        "auth_verify"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "* Off-Chain RPC Protocol\n  * Channel Management Methods\n\n\n\n# Channel Management Methods\n\nChannel management methods enable clients to create, modify, and close payment channels with a clearnode on various blockchain networks.\n\n* * *\n\nSummary: Provides the interface for managing the full lifecycle of off-chain payment channels, allowing clients to open, update, and close secure payment paths with clearnodes across multiple blockchain networks.\n\nRelated terms: payment channel, state channel, off-chain, clearnode, open channel, close channel, update channel, RPC protocol, layer 2, settlement, blockchain interoperability, channel lifecycle, crypto payments, yellow network, payment gateway\n\nUse cases: opening a payment channel, updating channel state off-chain, closing and settling a channel",
    "metadata": {
      "title": "Channel Management Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/channel-methods",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides the interface for managing the full lifecycle of off-chain payment channels, allowing clients to open, update, and close secure payment paths with clearnodes across multiple blockchain networks.",
      "keywords": [
        "payment channel",
        "state channel",
        "off-chain",
        "clearnode",
        "open channel",
        "close channel",
        "update channel",
        "RPC protocol",
        "layer 2",
        "settlement",
        "blockchain interoperability",
        "channel lifecycle",
        "crypto payments",
        "yellow network",
        "payment gateway"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "opening a payment channel",
        "updating channel state off-chain",
        "closing and settling a channel"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Overviewâ€‹\n\n\nPayment channels are the foundation of the Nitrolite protocol. They lock funds on-chain while enabling instant off-chain operations within a unified balance.\n\n### Channel Lifecycle Summaryâ€‹\n\ncreate_channel (off-chain)\n\nUser submits create() transaction\n\nContract locks user funds (status = open)\n\nresize_channel (optional)\n\nUser submits resize() transaction\n\nclose_channel (cooperative)\n\nFunds distributed\n\nchallenge() (non-cooperative)\n\nChallenge period then close()\n\nRequesting\n\nOnChain\n\nACTIVE\n\nResizing\n\nClosing\n\nDisputing\n\n* * *\n\nSummary: This component defines the lifecycle and management methods for payment channels, enabling secure on-chain fund locking for high-frequency off-chain transaction execution.\n\nRelated terms: payment channel, state channel, off-chain scaling, layer 2, fund locking, settlement, dispute resolution, cooperative close, non-cooperative close, liquidity management, nitrolite, channel lifecycle, create_channel, resize_channel, close_channel\n\nUse cases: Establishing a secure payment link between two parties, Adjusting channel liquidity without full closure, Settling balances and withdrawing funds to the main chain, Handling counterparty disputes via challenge periods",
    "metadata": {
      "title": "Channel Management Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/channel-methods",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the lifecycle and management methods for payment channels, enabling secure on-chain fund locking for high-frequency off-chain transaction execution.",
      "keywords": [
        "payment channel",
        "state channel",
        "off-chain scaling",
        "layer 2",
        "fund locking",
        "settlement",
        "dispute resolution",
        "cooperative close",
        "non-cooperative close",
        "liquidity management",
        "nitrolite",
        "channel lifecycle",
        "create_channel",
        "resize_channel",
        "close_channel"
      ],
      "function_name": "create_channel",
      "intent": "api_reference",
      "use_cases": [
        "Establishing a secure payment link between two parties",
        "Adjusting channel liquidity without full closure",
        "Settling balances and withdrawing funds to the main chain",
        "Handling counterparty disputes via challenge periods"
      ],
      "function_names": [
        "resize_channel",
        "close_channel",
        "create_channel"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## create_channelâ€‹\n\n\n### Nameâ€‹\n\n`create_channel`\n\n### Usageâ€‹\n\nInitiates the creation of a payment channel between user and a clearnode on a specific blockchain. The clearnode validates the request, generates a channel configuration with a unique nonce, prepares the initial funding state, and signs it. The user receives the complete channel data and the clearnode's signature, which they must then submit to the blockchain's Custody contract via the `create()` function to finalize channel creation and lock funds on-chain. This two-step process (off-chain preparation, on-chain execution) ensures the clearnode has agreed on channel creation and received an on-chain confirmation that it was created.\n\n### When to Useâ€‹\n\nWhen a user wants to establish a payment channel on a specific blockchain network. This is the first operation after authentication if the user doesn't have an open channel yet. On subsequent connections, users won't need to create a channel again unless they closed it.\n\nTwo-Step Process\n\nChannel creation is intentionally split into two steps:\n\n  1. **Off-chain preparation** : The clearnode prepares and signs the initial state\n  2. **On-chain execution** : User submits transaction to create the channel\n\nThis ensures the clearnode has committed to the channel before the user submits the on-chain transaction.\n\n### Prerequisitesâ€‹\n\n  * User must be [authenticated](/docs/protocol/off-chain/authentication)\n  * Target blockchain and token must be supported by the clearnode\n  * User must have native currency for gas fees\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example| Notes  \n---|---|---|---|---|---|---  \n`chain_id`| uint32| Yes| Blockchain network identifier  \n  \n**Examples** :  \nâ€¢ 1: Ethereum Mainnet  \nâ€¢ 137: Polygon  \nâ€¢ 8453: Base  \nâ€¢ 42161: Arbitrum One  \nâ€¢ 10: Optimism| â€”| `137`| Use `get_config` to see supported chains  \n`token`| string (wallet address)| Yes| ERC-20 token contract address on the specified chain  \n  \nFormat: 0x-prefixed hex (20 bytes)| â€”| `\"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\"`| Must be supported; see `get_assets`  \n  \nInitial Channel State\n\nChannels are created with **zero initial balance** for both participants. To add funds to the channel, use the `resize_channel` method after creation. The challenge period is set to 1 hour (3600 seconds) by default.\n\n### Responseâ€‹\n\nQuick Reference\n\nStructures: Channel â€¢ State â€¢ StateAllocation\n\nParameter| Type| Description| See Also  \n---|---|---|---  \n`channel_id`| string| Computed channel identifier (0x-prefixed hex, 32 bytes)| â€”  \n`channel`| Channel| On-chain channel params| â†“ Structure  \n`state`| State| Initial state (intent INITIALIZE, version 0, empty data, zero allocations)| â†“ Structure  \n`server_signature`| string| Clearnode signature over packed state (hex string)| â€”  \n  \n#### Channel Structureâ€‹\n\nField| Type| Description| Notes  \n---|---|---|---  \n`participants`| wallet address[]| Array of two wallet addresses: [User, Clearnode]| Order: Index 0 = User, Index 1 = Clearnode  \nOrder is critical for signature verification  \n`adjudicator`| wallet address| Adjudicator contract address for this channel| Typically SimpleConsensus for payment channels  \nValidates state transitions during disputes  \n`challenge`| uint64| Challenge period in seconds| Default: 3600 seconds (1 hour)  \n`nonce`| uint64| Unique identifier for this channel| Ensures channelId uniqueness even with same participants  \nServer-generated timestamp or counter  \n  \n**Example** :\n    \n    \n    {  \n      \"participants\": [\"0x742d35Cc...\", \"0x123456Cc...\"],  \n      \"adjudicator\": \"0xAdjudicator123...\",  \n      \"challenge\": 86400,  \n      \"nonce\": 1699123456  \n    }  \n    \n\n#### State Structureâ€‹\n\nField| Type| Description| Notes  \n---|---|---|---  \n`intent`| StateIntent| State purpose indicator| For creation: `INITIALIZE` (1)  \n`version`| uint64| State sequence number| For creation: `0`  \n`state_data`| string| State data (hex)| For creation: `\"0x\"`  \n`allocations`| StateAllocation[]| Fund allocations (raw units)| Order matches participants array; both `0` on creation  \n  \n**Example** :\n    \n    \n    {  \n      \"intent\": 1,  \n      \"version\": 0,  \n      \"state_data\": \"0x\",  \n      \"allocations\": [  \n        {\"participant\": \"0x742d35Cc...\", \"token\": \"0x2791Bca1...\", \"amount\": \"0\"},  \n        {\"participant\": \"0x123456Cc...\", \"token\": \"0x2791Bca1...\", \"amount\": \"0\"}  \n      ]  \n    }  \n    \n\n#### StateAllocation Structureâ€‹\n\nField| Type| Description  \n---|---|---  \n`participant`| string (wallet address)| Participant's wallet address  \n`token`| string (wallet address)| Token contract address  \n`amount`| string| Amount in smallest unit (e.g., `\"100000000\"` for 100 USDC with 6 decimals)  \n  \nClearnode Signature First\n\nThe clearnode provides its signature BEFORE the user commits funds on-chain. This ensures both parties have committed to the channel before any on-chain transaction occurs.\n\n### Next Steps After Receiving Responseâ€‹\n\n  1. **Verify Channel Data**\n\n     * Recompute `channelId` = `keccak256(abi.encode(channel))`\n     * Verify computed ID matches response `channel_id`\n     * Check participants[0] is your wallet address\n     * Verify token matches your request\n  2. **Verify the Clearnode's Signature**\n\n     * Compute `packedState` = `abi.encode(channelId, state.intent, state.version, state.data, state.allocations)`\n     * Recover signer from `server_signature`\n     * Verify signer is the clearnode's known wallet address\n  3. **Sign State with Your Key**\n\n     * Sign `packedState` with your participant key\n     * Include your signature when submitting to blockchain\n  4. **Submit On-Chain Transaction**\n\n     * Call `Custody.create(channel, state, yourSignature, clearnodeSignature)`\n     * Wait for transaction confirmation\n  5. **Monitor for Channel Creation**\n\n     * Listen for `Opened` event (emitted right after transaction is mined)\n     * Or poll `get_channels` until channel appears with status \"open\"\n  6. **Channel Active**\n\n     * Channel appears in `get_channels` with status \"open\"\n     * Channel starts with zero balance\n     * Use `resize_channel` to add funds to the channel\n\n### Error Casesâ€‹\n\nError Format\n\nThe protocol does not use numeric error codes. Errors are returned as method `\"error\"` with descriptive messages.\n\nCommon error scenarios:\n\nError| Description| Recovery  \n---|---|---  \n**Authentication required**|  Not authenticated| Complete [authentication flow](/docs/protocol/off-chain/authentication)  \n**Unsupported chain**| `chain_id` not supported| Use `get_config`  \n**Token not supported**|  Token not in asset config for chain| Use `get_assets`  \n**Invalid signature**|  Caller did not sign request| Sign with channel participant wallet  \n**Channel already exists**|  Open channel with broker already exists| Use existing channel or close it first  \n**Failed to prepare state**|  Internal packing/signing issue| Retry or contact support  \n  \n### Implementation Notesâ€‹\n\n  * The nonce is generated by the clearnode to ensure uniqueness\n  * The channelId can be computed client-side: `keccak256(abi.encode(channel))`\n  * The packedState should be verified: `abi.encode(channelId, state.intent, state.version, state.data, state.allocations)`\n  * Users should verify the clearnode's signature before proceeding\n  * The challenge period can be customized but most users should use defaults\n\n### Sequence Diagramâ€‹\n\nBlockchainClearnodeUserBlockchainClearnodeUser1\\. Request Channel Creation2\\. Prepare Channel3\\. Verify & Sign4\\. Submit On-Chain5\\. Create Channel (Status: ACTIVE)Use resize_channel to add fundscreate_channel(chain_id, token)Generate unique nonceCreate channel configCreate initial state (intent: INITIALIZE, version: 0)Sign state{channel, state, server_signature, channel_id}Verify Clearnode signatureSign state with participant keyCustody.create(channel, state, signatures)Verify signaturesCreate channel with status ACTIVEEmit Opened eventChannel Active (zero balance)Channel Active (zero balance)\n\n* * *\n\nSummary: Initiates the off-chain handshake and configuration for establishing a payment channel between a user and a clearnode, requiring a subsequent on-chain transaction to finalize fund locking.\n\nRelated terms: create_channel, open channel, payment channel, state channel, onboarding, funding, clearnode, off-chain setup, on-chain execution, custody contract, nonce, channel creation, createchannel, deposit funds\n\nUse cases: Initial setup of a payment channel, Establishing a secure link with a clearnode, Locking ERC-20 tokens for off-chain trading",
    "metadata": {
      "title": "Channel Management Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/channel-methods",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Initiates the off-chain handshake and configuration for establishing a payment channel between a user and a clearnode, requiring a subsequent on-chain transaction to finalize fund locking.",
      "keywords": [
        "create_channel",
        "open channel",
        "payment channel",
        "state channel",
        "onboarding",
        "funding",
        "clearnode",
        "off-chain setup",
        "on-chain execution",
        "custody contract",
        "nonce",
        "channel creation",
        "createchannel",
        "deposit funds"
      ],
      "function_name": "create_channel",
      "intent": "api_reference",
      "use_cases": [
        "Initial setup of a payment channel",
        "Establishing a secure link with a clearnode",
        "Locking ERC-20 tokens for off-chain trading"
      ],
      "function_names": [
        "fundscreate_channel",
        "keccak256",
        "create_channel",
        "get_assets",
        "resize_channel"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## close_channelâ€‹\n\n\n### Nameâ€‹\n\n`close_channel`\n\n### Usageâ€‹\n\nInitiates cooperative closure of an active payment channel. The clearnode signs a final state with StateIntent.FINALIZE reflecting the current balance distribution. The user receives this clearnode-signed final state which they must submit to the blockchain's Custody contract via the `close()` function. This is the preferred and most efficient way to close a channel as it requires only one on-chain transaction and completes immediately without a challenge period. Both parties must agree on the final allocation for cooperative closure to work.\n\n### When to Useâ€‹\n\nWhen a user wants to withdraw funds from an active channel and both user and the clearnode agree on the final balance distribution. This should be the default closure method when both parties are online and cooperative.\n\nPreferred Closure Method\n\nCooperative closure is **fast (1 transaction)** , **cheap (low gas)** , and **immediate (no waiting period)**. Always use this method when possible. Challenge-response closure should only be used when the clearnode is unresponsive or disputes the final state.\n\n### Prerequisitesâ€‹\n\n  * Channel must exist and be in ACTIVE status\n  * User must be authenticated\n  * User must have native currency for gas fees\n  * Both parties must agree on final allocations (implicitly, by the clearnode signing)\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example| Notes  \n---|---|---|---|---|---|---  \n`channel_id`| string| Yes| Identifier of the channel to close| -| `\"0xabcdef1234567890...\"`| From get_channels or stored after creation  \n`funds_destination`| string (wallet address)| Yes| Address where your share of channel funds should be sent| -| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`| Typically your wallet address  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Example| Notes  \n---|---|---|---|---  \n`channel_id`| string| Channel identifier| `\"0xabcdef1234...\"`| â€”  \n`state`| State| Final state with intent FINALIZE and version = current+1  \n`state_data`: `\"0x\"`  \n`allocations`: final fund distribution (raw units)| See State structure| `channel` field is omitted in close responses  \n`server_signature`| string| Clearnode signature over packed state| `\"0xabcdef987654...\"`| Hex string  \n  \n### Next Steps After Receiving Responseâ€‹\n\n  1. **Verify Final Allocations**\n\n     * Check allocations match expectations\n     * Verify total matches total locked funds\n     * Ensure your allocation is correct\n  2. **Verify the Clearnode's Signature**\n\n     * Compute `packedState` = `abi.encode(channelId, state.intent, state.version, state.data, state.allocations)`\n     * Verify signature is from the clearnode\n  3. **Sign Final State**\n\n     * Sign `packedState` with your participant key\n     * Include your signature when submitting to blockchain\n  4. **Submit On-Chain**\n\n     * Call `Custody.close(channelId, state, yourSignature, clearnodeSignature)` on blockchain\n     * Both signatures must be present\n  5. **Wait for Confirmation**\n\n     * Transaction confirms\n     * Funds distributed according to allocations\n  6. **Channel Closed**\n\n     * Channel deleted from chain\n     * Funds in your wallet or custody available balance\n  7. **Withdraw if Needed**\n\n     * If funds in custody, call `withdraw()` to move to wallet\n\n### Error Casesâ€‹\n\nError Format\n\nThe protocol does not use numeric error codes. Errors are returned as method `\"error\"` with descriptive messages.\n\nCommon error scenarios:\n\nError| Description| Recovery  \n---|---|---  \n**Authentication required**|  Not authenticated| Re-authenticate  \n**Channel not found**|  Invalid `channel_id`| Verify with `get_channels`  \n**Channel challenged**|  Participant has challenged channels| Resolve challenges first  \n**Channel not open/resizing**|  Status not `open` or `resizing`| Only open/resizing channels can close  \n**Invalid signature**|  Caller did not sign request| Sign with channel participant wallet  \n**Token/asset not found**|  Asset config missing| Ensure channel token is supported  \n**Insufficient/negative balance**|  Ledger balance retrieval or negative balance| Ensure balances are non-negative; retry  \n**Failed to pack/sign state**|  Internal packing/signing issue| Retry or contact support  \n  \n### Comparison: Cooperative vs Challenge Closureâ€‹\n\nAspect| Cooperative (this method)| Challenge  \n---|---|---  \n**Speed**|  Fast (1 transaction)| Slow (challenge period + 1 transaction)  \n**Gas Cost**|  Low (~100k gas)| High (~200k+ gas, 2+ transactions)  \n**Requirements**|  Both parties online & agree| Works if other party unresponsive  \n**Waiting Period**|  None (immediate)| 24+ hours (challenge duration)  \n**Use When**|  Normal operations| Disputes or unresponsiveness  \n  \nWhen to Use Challenge Closure\n\nOnly use challenge closure (on-chain `challenge()` function) when:\n\n  * Clearnode is unresponsive\n  * Clearnode disputes the final allocation\n  * Cooperative closure fails repeatedly\n\nChallenge closure requires waiting for the challenge period to expire before funds are released.\n\n### Implementation Notesâ€‹\n\n  * The StateIntent.FINALIZE (3) signals this is a final state\n  * All participants must sign the final state for it to be accepted on-chain\n  * The allocations determine where funds go when channel closes\n  * Clearnode will only sign if the allocations match the current state of the unified balance\n  * After closing, funds are distributed according to the allocations specified\n  * Users may need to call `withdraw()` separately to move funds from custody ledger to their wallet\n\n* * *\n\nSummary: Initiates a cooperative termination of an active payment channel by generating a finalized state signed by the clearnode for immediate on-chain settlement. This method bypasses challenge periods by ensuring both parties agree on the final balance distribution before submitting to the blockchain.\n\nRelated terms: close channel, terminate session, cooperative closure, finalize state, settlement, withdraw funds, exit channel, payment channel, off-chain exit, on-chain settlement, StateIntent.FINALIZE, custody contract, gas efficiency, immediate withdrawal, closechannel\n\nUse cases: Finalizing a trading session, Withdrawing remaining balance to a wallet, Settling funds after service completion, Terminating a peer-to-peer payment stream",
    "metadata": {
      "title": "Channel Management Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/channel-methods",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Initiates a cooperative termination of an active payment channel by generating a finalized state signed by the clearnode for immediate on-chain settlement. This method bypasses challenge periods by ensuring both parties agree on the final balance distribution before submitting to the blockchain.",
      "keywords": [
        "close channel",
        "terminate session",
        "cooperative closure",
        "finalize state",
        "settlement",
        "withdraw funds",
        "exit channel",
        "payment channel",
        "off-chain exit",
        "on-chain settlement",
        "StateIntent.FINALIZE",
        "custody contract",
        "gas efficiency",
        "immediate withdrawal",
        "closechannel"
      ],
      "function_name": "close_channel",
      "intent": "api_reference",
      "use_cases": [
        "Finalizing a trading session",
        "Withdrawing remaining balance to a wallet",
        "Settling funds after service completion",
        "Terminating a peer-to-peer payment stream"
      ],
      "function_names": [
        "withdraw",
        "funds_destination",
        "close",
        "close_channel",
        "get_channels"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## resize_channelâ€‹\n\n\n### Nameâ€‹\n\n`resize_channel`\n\n### Usageâ€‹\n\nAdjusts the allocations of an existing channel by locking or unlocking funds **without closing the channel**. Unlike older implementations, this uses the `resize()` function on the Custody contract to perform an **in-place update** of the channel's allocations. The same channelId persists throughout the operation, and the channel remains in ACTIVE status. Clearnode prepares a resize state with delta amounts (positive for deposit, negative for withdrawal) that all participants must sign before submitting on-chain.\n\n### When to Useâ€‹\n\nWhen a user wants to adjust channel allocations while keeping the same channel active. This is more efficient than closing and reopening, and maintains the channel's history and state version continuity.\n\nIn-Place Update\n\nThe resize operation updates the channel **in place**. The channelId **stays the same** , and the channel remains ACTIVE throughout. This is the current implementation of channel allocation adjustment.\n\n### Prerequisitesâ€‹\n\n  * Channel must exist and be in ACTIVE status\n  * User must be authenticated\n  * Positive deltas require enough available unified balance\n  * Negative deltas require sufficient channel balance\n  * All participants must sign the resize state (consensus required)\n  * User must have native currency for gas fees\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example| Notes  \n---|---|---|---|---|---|---  \n`channel_id`| string| Yes| Identifier of the channel to resize (stays the same)| -| `\"0xabcdef1234567890...\"`| 0x-prefixed hex string (32 bytes)  \nThis channel_id will NOT change after resize  \n`allocate_amount`| string (decimal)| No| Amount to add/remove between unified balance and the channel before resize| `0`| `\"50.0\"`| Decimal string; can be used together with `resize_amount`; at least one of the two must be non-zero  \n`resize_amount`| string (decimal)| No| Delta to apply to the channel: positive to deposit, negative to withdraw| `0`| `\"75.0\"` or `\"-100.0\"`| Decimal string; can be used together with `allocate_amount`; at least one of the two must be non-zero  \n`funds_destination`| string (wallet address)| Yes| Destination for the user's allocation in the resize state| -| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`| 0x-prefixed hex string (20 bytes)  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Example| Notes  \n---|---|---|---|---  \n`channel_id`| string| Same channel identifier (unchanged)| `\"0xabcdef1234567890...\"`| This does NOT change (in-place update)  \n`state`| State| Resize state to be submitted on-chain  \nâ€¢ `intent` = RESIZE (2)  \nâ€¢ `version` = current+1  \nâ€¢ `state_data` = ABI-encoded `int256[2]` of `[resize_amount, allocate_amount]` (raw units)  \nâ€¢ `allocations` = final absolute allocations after resize| See State structure| `channel` field is omitted in resize responses  \n`server_signature`| string| Clearnode signature over packed state| `\"0x9876fedcba...\"`| Hex string  \n  \n### Next Steps After Receiving Responseâ€‹\n\nThe client must submit the resize state to the blockchain:\n\n  1. **Verify the resize state**\n\n     * Check channel_id matches (should be unchanged)\n     * Verify intent is RESIZE (2)\n     * Confirm version is current + 1\n     * Check allocations reflect the requested change\n  2. **Sign the resize state**\n         \n         packedState = abi.encode(  \n           channel_id,  \n           state.intent,      // StateIntent.RESIZE (2)  \n           state.version,     // Incremented version  \n           state.data,        // ABI-encoded int256[] deltas  \n           state.allocations  // Final allocations  \n         )  \n         user_signature = sign(packedState, participant_private_key)  \n         \n\n  3. **Ensure sufficient balance**\n\n     * Positive deltas require enough available unified balance to cover `allocate_amount + resize_amount` (after decimals conversion)\n     * Negative deltas require the channel to have sufficient funds being deallocated\n  4. **Call`Custody.resize()` on-chain**\n         \n         custody.resize(  \n           channel_id,    // Same channel_id  \n           state,         // Resize state  \n           yourSignature,  \n           clearnodeSignature  \n         )  \n         \n\n  5. **Wait for transaction confirmation**\n\n     * Channel remains ACTIVE (no status change)\n     * Funds locked or unlocked based on delta\n     * Expected deposits updated to new amounts\n  6. **Monitor for`Resized` event**\n         \n         event Resized(bytes32 indexed channelId, int256[] deltaAllocations)  \n         \n\n     * Emitted when resize completes\n     * Contains the delta amounts applied\n     * Confirms operation success\n  7. **Update local state**\n\n     * Channel_id remains the same (no replacement needed)\n     * Unified balance automatically updated\n     * Version incremented\n\n### Error Casesâ€‹\n\nError| Cause| Resolution  \n---|---|---  \nAuthentication required| Not authenticated| Complete authentication flow  \nChannel not found| Invalid channel_id| Verify with `get_channels`  \nChannel challenged| Participant has challenged channels| Resolve challenged channels first  \nOperation denied: resize already ongoing| Channel status is `resizing`| Wait for existing resize to complete  \nOperation denied: channel is not open| Status not `open`| Only open channels can resize  \nInvalid signature| Caller not among channel signers| Sign request with channel participant  \nToken/asset not found for channel| Asset config missing for channel token/chain| Ensure channel token is supported  \nResize operation requires non-zero amounts| Both `resize_amount` and `allocate_amount` are zero| Provide a non-zero value  \nInsufficient unified balance| New channel amount would exceed available balance| Reduce amounts or add funds  \nNew channel amount must be positive| Resize would make channel balance negative| Reduce withdrawal  \nFailed to pack resize amounts/state| Internal packing/signing error| Retry; contact support if persistent  \n  \n### Resize Scenariosâ€‹\n\n#### Scenario 1: Depositing Additional Fundsâ€‹\n\n**Initial State** :\n    \n    \n    Channel (on Polygon): 20 USDC  \n    Channel (on Celo): 5 USDC  \n    Unified balance: 25 USDC total  \n    \n\n**Operation** :\n    \n    \n    resize_channel({  \n      channel_id: \"0xCelo_Channel_Id\",  // Resize Celo channel  \n      allocate_amount: \"0\",  \n      resize_amount: \"75.0\",  // Deposit 75 USDC  \n      funds_destination: \"0x742d35Cc...\"  // Required, even for deposits  \n    })  \n    \n\n**Result** :\n    \n    \n    Channel (on Polygon): 20 USDC (unchanged)  \n    Channel (on Celo): 80 USDC (5 + 75 = 80)  \n    Unified balance: 100 USDC total (reduced available balance to fund deposit)  \n    Same channel_id on Celo (unchanged)  \n    \n\n* * *\n\n#### Scenario 2: Withdrawing Fundsâ€‹\n\n**Initial State** :\n    \n    \n    Channel (on Polygon): 100 USDC  \n    Unified balance: 100 USDC total (all locked in channel)  \n    \n\n**Operation** :\n    \n    \n    resize_channel({  \n      channel_id: \"0xPolygon_Channel_Id\",  \n      allocate_amount: \"0\",  \n      resize_amount: \"-100.0\",  // Withdraw all 100 USDC  \n      funds_destination: \"0x742d35Cc...\"  // User's wallet  \n    })  \n    \n\n**Result** :\n    \n    \n    Channel (on Polygon): 0 USDC (100 - 100 = 0)  \n    Unified balance: 0 USDC  \n    100 USDC returned to available balance (unified)  \n    Same channel_id (unchanged)  \n    Channel still ACTIVE (can be used again or closed)  \n    \n\n* * *\n\n#### Scenario 3: Complex Multi-Chain Rebalancingâ€‹\n\n**Initial State** :\n    \n    \n    Channel (on Polygon): 20 USDC  \n    Channel (on Celo): 80 USDC  \n    Unified balance: 100 USDC total  \n    Want to withdraw all on Polygon (100 USDC)  \n    \n\n**Operation** :\n    \n    \n    // First, allocate Celo funds to Polygon channel  \n    resize_channel({  \n      channel_id: \"0xPolygon_Channel_Id\",  \n      allocate_amount: \"80.0\",  // Allocate from Celo  \n      resize_amount: \"-100.0\",  // Withdraw 100 total  \n      funds_destination: \"0x742d35Cc...\"  \n    })  \n    \n\n**Result** :\n    \n    \n    Channel (on Polygon): 0 USDC  \n    Channel (on Celo): 0 USDC (deallocated)  \n    100 USDC withdrawn to user's wallet  \n    \n\nComplex Rebalancing\n\nMulti-chain rebalancing with `allocate_amount` is an advanced feature. For simple deposit/withdrawal on a single channel, use only `resize_amount` with `allocate_amount` = \"0\".\n\n### Implementation Notesâ€‹\n\n  * The `resize()` function operates **in place** on the same channel\n  * channelId **never changes** (no new channel created)\n  * Channel remains in **ACTIVE** status throughout\n  * State **version increments** like any state update\n  * Delta amounts are encoded as **int256[]** in state.data\n  * Positive deltas increase channel balance (and reduce available unified balance)\n  * Negative deltas decrease channel balance (and increase available unified balance)\n  * **All participants must sign** the resize state (consensus required)\n  * More gas-efficient than close + reopen\n  * Unified balance automatically updated by clearnode\n  * Channel history and state continuity preserved\n\n* * *\n\nSummary: The resize_channel method facilitates in-place adjustments to channel allocations by locking or unlocking funds without terminating the session or changing the channel identifier. This allows for efficient liquidity management while maintaining continuous channel history and active status through multi-party consensus.\n\nRelated terms: resize_channel, deposit, withdrawal, channel allocation, in-place update, state update, liquidity management, multi-party signing, custody contract, delta amount, top up, rebalance, session persistence, resizechannel\n\nUse cases: Increasing liquidity in an active payment channel, Withdrawing excess funds without closing the channel, Dynamic rebalancing of state channel allocations",
    "metadata": {
      "title": "Channel Management Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/channel-methods",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The resize_channel method facilitates in-place adjustments to channel allocations by locking or unlocking funds without terminating the session or changing the channel identifier. This allows for efficient liquidity management while maintaining continuous channel history and active status through multi-party consensus.",
      "keywords": [
        "resize_channel",
        "deposit",
        "withdrawal",
        "channel allocation",
        "in-place update",
        "state update",
        "liquidity management",
        "multi-party signing",
        "custody contract",
        "delta amount",
        "top up",
        "rebalance",
        "session persistence",
        "resizechannel"
      ],
      "function_name": "resize_channel",
      "intent": "api_reference",
      "use_cases": [
        "Increasing liquidity in an active payment channel",
        "Withdrawing excess funds without closing the channel",
        "Dynamic rebalancing of state channel allocations"
      ],
      "function_names": [
        "resize_channel",
        "resize_amount",
        "hannel_id",
        "resize",
        "allocate_amount"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nExplore other off-chain operations:\n\n  * **[Transfers](/docs/protocol/off-chain/transfers)** \\- Send instant off-chain payments using unified balance\n  * **[App Sessions](/docs/protocol/off-chain/app-sessions)** \\- Create multi-party application channels\n  * **[Queries](/docs/protocol/off-chain/queries)** \\- Check channel status, balances, and history\n\nFor protocol fundamentals:\n\n  * **[Authentication](/docs/protocol/off-chain/authentication)** \\- Understand authorization and session management\n  * **[Message Format](/docs/protocol/off-chain/message-format)** \\- Learn request/response structure\n  * **[On-Chain Protocol](/docs/protocol/on-chain/overview)** \\- Deep dive into smart contracts\n\n\n\n[PreviousAuthentication](/docs/protocol/off-chain/authentication)[NextTransfer Method](/docs/protocol/off-chain/transfers)\n\n  * Overview\n    * Channel Lifecycle Summary\n  * create_channel\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n    * Next Steps After Receiving Response\n    * Error Cases\n    * Implementation Notes\n    * Sequence Diagram\n  * close_channel\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n    * Next Steps After Receiving Response\n    * Error Cases\n    * Comparison: Cooperative vs Challenge Closure\n    * Implementation Notes\n  * resize_channel\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n    * Next Steps After Receiving Response\n    * Error Cases\n    * Resize Scenarios\n    * Implementation Notes\n  * Next Steps\n\nSummary: This component defines the lifecycle management of off-chain payment channels, providing the technical interface for establishing, adjusting capacity, and settling peer-to-peer state channels.\n\nRelated terms: open channel, close channel, resize channel, state channel, off-chain settlement, liquidity management, channel lifecycle, payment channel, layer 2, create_channel, close_channel, resize_channel, peer-to-peer, session management\n\nUse cases: Establishing a peer-to-peer payment link, Adjusting channel liquidity for high-volume trading, Cooperative settlement of off-chain balances",
    "metadata": {
      "title": "Channel Management Methods | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/channel-methods",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the lifecycle management of off-chain payment channels, providing the technical interface for establishing, adjusting capacity, and settling peer-to-peer state channels.",
      "keywords": [
        "open channel",
        "close channel",
        "resize channel",
        "state channel",
        "off-chain settlement",
        "liquidity management",
        "channel lifecycle",
        "payment channel",
        "layer 2",
        "create_channel",
        "close_channel",
        "resize_channel",
        "peer-to-peer",
        "session management"
      ],
      "function_name": "create_channel",
      "intent": "api_reference",
      "use_cases": [
        "Establishing a peer-to-peer payment link",
        "Adjusting channel liquidity for high-volume trading",
        "Cooperative settlement of off-chain balances"
      ],
      "function_names": [
        "resize_channel",
        "close_channel",
        "create_channel"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "* Off-Chain RPC Protocol\n  * Message Format\n\n\n\n# Message Format\n\nThe Nitro RPC protocol uses a compact, efficient message format for all communication between clients and a clearnode.\n\n* * *\n\nSummary: Defines the structure and characteristics of the communication protocol used between clients and clearnodes within the Nitro RPC framework to ensure efficient off-chain data exchange.\n\nRelated terms: Nitro RPC, message format, communication protocol, clearnode, off-chain, data structure, payload, RPC request, RPC response, serialization, network protocol, messaging, Yellow Network, Nitro protocol\n\nUse cases: Designing client-side integrations with clearnodes, Optimizing network bandwidth for high-frequency state updates, Debugging communication between SDK components and the network",
    "metadata": {
      "title": "Message Format | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/message-format",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the structure and characteristics of the communication protocol used between clients and clearnodes within the Nitro RPC framework to ensure efficient off-chain data exchange.",
      "keywords": [
        "Nitro RPC",
        "message format",
        "communication protocol",
        "clearnode",
        "off-chain",
        "data structure",
        "payload",
        "RPC request",
        "RPC response",
        "serialization",
        "network protocol",
        "messaging",
        "Yellow Network",
        "Nitro protocol"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Designing client-side integrations with clearnodes",
        "Optimizing network bandwidth for high-frequency state updates",
        "Debugging communication between SDK components and the network"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## General Structureâ€‹\n\n\nEvery Nitro RPC message consists of a compact JSON array format:\n    \n    \n    [requestId, method, params, timestamp]  \n    \n\nCompact Format\n\nThis array-based format reduces message overhead by approximately 30% compared to traditional JSON-RPC, making it ideal for high-frequency state channel operations.\n\n### Componentsâ€‹\n\nComponent| Type| Description  \n---|---|---  \n**requestId**|  uint64| Unique identifier for the request, used to correlate responses  \n**method**|  string| Remote method name to be invoked  \n**params**|  object| Method-specific parameters as a JSON object  \n**timestamp**|  uint64| Server-provided timestamp in milliseconds  \n  \n#### requestIdâ€‹\n\n  * **Purpose** : Correlate requests with their responses\n  * **Type** : Unsigned 64-bit integer\n  * **Generation** : Client-generated, must be unique per connection\n  * **Range** : 0 to 2^64-1\n  * **Example** : `1`, `42`, `9876543210`\n\n#### methodâ€‹\n\n  * **Purpose** : Specify which RPC method to invoke\n  * **Type** : String\n  * **Format** : snake_case (e.g., `create_channel`, not `createChannel`)\n  * **Examples** : `auth_request`, `transfer`, `create_app_session`\n\n#### paramsâ€‹\n\n  * **Purpose** : Provide method-specific parameters\n  * **Type** : JSON object\n  * **Content** : Varies by method\n  * **Example** : `{\"chain_id\": 137, \"token\": \"0x...\", \"amount\": \"100000000\"}`\n  * **Reference** : See [Authentication](/docs/protocol/off-chain/authentication), [Channel Methods](/docs/protocol/off-chain/channel-methods), [Transfers](/docs/protocol/off-chain/transfers), [App Sessions](/docs/protocol/off-chain/app-sessions), and [Queries](/docs/protocol/off-chain/queries) for parameter specifications\n\n#### timestampâ€‹\n\n  * **Purpose** : Request ordering and replay attack prevention\n  * **Type** : Unsigned 64-bit integer (Unix milliseconds)\n  * **Generation** : Client-provided on requests; server-provided on responses\n  * **Example** : `1699123456789` (November 5, 2023, 01:57:36 UTC)\n\n* * *\n\nSummary: Defines the compact, array-based Nitro RPC message structure designed to minimize overhead for high-frequency state channel operations while ensuring request correlation and security.\n\nRelated terms: Nitro RPC, message format, JSON-RPC, state channel, request correlation, compact array, snake_case, requestId, replay protection, off-chain communication, message overhead, timestamping, state update, RPC protocol\n\nUse cases: high-frequency state updates, replay attack prevention, asynchronous request correlation, off-chain node communication",
    "metadata": {
      "title": "Message Format | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/message-format",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the compact, array-based Nitro RPC message structure designed to minimize overhead for high-frequency state channel operations while ensuring request correlation and security.",
      "keywords": [
        "Nitro RPC",
        "message format",
        "JSON-RPC",
        "state channel",
        "request correlation",
        "compact array",
        "snake_case",
        "requestId",
        "replay protection",
        "off-chain communication",
        "message overhead",
        "timestamping",
        "state update",
        "RPC protocol"
      ],
      "function_name": "create_channel",
      "intent": "api_reference",
      "use_cases": [
        "high-frequency state updates",
        "replay attack prevention",
        "asynchronous request correlation",
        "off-chain node communication"
      ],
      "function_names": [
        "create_channel",
        "create_app_session",
        "snake_case",
        "chain_id",
        "Channel"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Request Messageâ€‹\n\n\nA complete request message wraps the payload array and includes signatures.\n\n### Structureâ€‹\n    \n    \n    {  \n      \"req\": [requestId, method, params, timestamp],  \n      \"sig\": [signature1, signature2, ...]  \n    }  \n    \n\n### Fieldsâ€‹\n\n#### reqâ€‹\n\nThe request payload as a 4-element array containing:\n\n  * Request ID\n  * Method name\n  * Parameters object\n  * Timestamp\n\n#### sigâ€‹\n\nArray of ECDSA signatures, one or more depending on the operation:\n\n  * **Single signature** : Most operations (signed by client's session key)\n  * **Multiple signatures** : Multi-party operations (e.g., app session creation)\n\n### Signature Formatâ€‹\n\nEach signature is:\n\n  * **Format** : 0x-prefixed hex string\n  * **Length** : 65 bytes (130 hex characters + \"0x\" prefix)\n  * **Components** : r (32 bytes) + s (32 bytes) + v (1 byte)\n  * **Algorithm** : ECDSA over secp256k1 curve\n  * **Hash** : keccak256 of the exact `req` array bytes\n\n**Example Signature** :\n    \n    \n    0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef01  \n    \n\nEVM-Specific Format\n\nThis signature format (ECDSA over secp256k1 with keccak256 hashing) is specific to EVM-compatible chains. If the protocol extends to support non-EVM chains in the future, signature formats may need to be adapted to match those chains' native cryptographic primitives.\n\nSignature Security\n\nSignatures are computed over the keccak256 hash of the JSON-encoded `req` array. The JSON encoding MUST be consistent (same key ordering, no extra whitespace) to ensure signature validity.\n\n### Complete Exampleâ€‹\n    \n    \n    {  \n      \"req\": [  \n        1,  \n        \"auth_request\",  \n        {  \n          \"address\": \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\",  \n          \"session_key\": \"0x9876543210fedcba9876543210fedcba98765432\",  \n          \"application\": \"trading-dex\",  \n          \"allowances\": [  \n            {\"asset\": \"usdc\", \"amount\": \"1000.0\"},  \n            {\"asset\": \"eth\", \"amount\": \"0.5\"}  \n          ],  \n          \"scope\": \"transfer,app.create\",  \n          \"expires_at\": 1762417328123  \n        },  \n        1699123456789  \n      ],  \n      \"sig\": [  \n        \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef01\"  \n      ]  \n    }  \n    \n\n* * *\n\nSummary: Defines the standardized structure for request messages in the Yellow Network, specifying the payload array and the ECDSA signature requirements for secure, multi-party protocol communication.\n\nRelated terms: message format, request structure, ECDSA signature, secp256k1, keccak256, multi-signature, auth_request, session key, payload, signing, EVM compatibility, hex string, request ID, multi-party auth\n\nUse cases: Authenticating a client session, Authorizing multi-party operations, Constructing signed protocol requests",
    "metadata": {
      "title": "Message Format | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/message-format",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the standardized structure for request messages in the Yellow Network, specifying the payload array and the ECDSA signature requirements for secure, multi-party protocol communication.",
      "keywords": [
        "message format",
        "request structure",
        "ECDSA signature",
        "secp256k1",
        "keccak256",
        "multi-signature",
        "auth_request",
        "session key",
        "payload",
        "signing",
        "EVM compatibility",
        "hex string",
        "request ID",
        "multi-party auth"
      ],
      "function_name": "auth_request",
      "intent": "api_reference",
      "use_cases": [
        "Authenticating a client session",
        "Authorizing multi-party operations",
        "Constructing signed protocol requests"
      ],
      "function_names": [
        "auth_request",
        "session_key",
        "expires_at"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Response Messageâ€‹\n\n\nThe clearnode sends response messages with the same structure, replacing `params` with `result`.\n\n### Structureâ€‹\n    \n    \n    {  \n      \"res\": [requestId, method, result, timestamp],  \n      \"sig\": [signature1, ...]  \n    }  \n    \n\n### Fieldsâ€‹\n\n#### resâ€‹\n\nThe response payload as a 4-element array:\n\n  * Same **requestId** (to correlate with request)\n  * **method** (response method name)\n    * Usually matches the request method\n    * **Exception** : `auth_request` â†’ response has `auth_challenge` method\n    * **Exception** : Errors â†’ response has `error` method\n  * **result** (method-specific response data, replaces params)\n  * **timestamp** (server response time)\n\n#### sigâ€‹\n\nThe clearnode's signature(s) over the response:\n\n  * Proves response authenticity\n  * Verifies response hasn't been tampered with\n  * Enables non-repudiation\n\n### Complete Exampleâ€‹\n    \n    \n    {  \n      \"res\": [  \n        1,  \n        \"auth_challenge\",  \n        {  \n          \"challenge_message\": \"550e8400-e29b-41d4-a716-446655440000\"  \n        },  \n        1699123457000  \n      ],  \n      \"sig\": [  \n        \"0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890ab\"  \n      ]  \n    }  \n    \n\n* * *\n\nSummary: Defines the standardized structure for response messages sent by the clearnode, ensuring data integrity and authenticity through cryptographic signatures and request correlation.\n\nRelated terms: response message, clearnode, message format, signature, authentication, auth_challenge, requestId, timestamp, non-repudiation, data integrity, crypto payment, yellow network, JSON response, sig, res\n\nUse cases: verifying server responses, authenticating with clearnode, correlating requests and responses, ensuring message non-repudiation",
    "metadata": {
      "title": "Message Format | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/message-format",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the standardized structure for response messages sent by the clearnode, ensuring data integrity and authenticity through cryptographic signatures and request correlation.",
      "keywords": [
        "response message",
        "clearnode",
        "message format",
        "signature",
        "authentication",
        "auth_challenge",
        "requestId",
        "timestamp",
        "non-repudiation",
        "data integrity",
        "crypto payment",
        "yellow network",
        "JSON response",
        "sig",
        "res"
      ],
      "function_name": "auth_challenge",
      "intent": "api_reference",
      "use_cases": [
        "verifying server responses",
        "authenticating with clearnode",
        "correlating requests and responses",
        "ensuring message non-repudiation"
      ],
      "function_names": [
        "auth_challenge",
        "auth_request",
        "challenge_message"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Error Responseâ€‹\n\n\nWhen an error occurs, the clearnode sends an error response with method set to `\"error\"`.\n\n### Structureâ€‹\n    \n    \n    {  \n      \"res\": [  \n        requestId,  \n        \"error\",  \n        {  \n          \"error\": \"Error description message\"  \n        },  \n        timestamp  \n      ],  \n      \"sig\": [\"0xServerSignature...\"]  \n    }  \n    \n\nThe result object at position 2 contains a single `\"error\"` field with a descriptive error message string.\n\n### Error Examplesâ€‹\n\n**Authentication Required** :\n    \n    \n    {  \n      \"res\": [  \n        5,  \n        \"error\",  \n        {  \n          \"error\": \"Authentication required: session not established\"  \n        },  \n        1699123456789  \n      ],  \n      \"sig\": [\"0xServerSignature...\"]  \n    }  \n    \n\n**Insufficient Balance** :\n    \n    \n    {  \n      \"res\": [  \n        12,  \n        \"error\",  \n        {  \n          \"error\": \"Insufficient balance: required 100 USDC, available 75 USDC\"  \n        },  \n        1699123456790  \n      ],  \n      \"sig\": [\"0xServerSignature...\"]  \n    }  \n    \n\n**Method Not Found** :\n    \n    \n    {  \n      \"res\": [  \n        8,  \n        \"error\",  \n        {  \n          \"error\": \"Method not found: 'invalid_method'\"  \n        },  \n        1699123456791  \n      ],  \n      \"sig\": [\"0xServerSignature...\"]  \n    }  \n    \n\nError Handling\n\nCheck the response method field (position 1 in `res` array). If it equals `\"error\"`, extract the error message from the result object's `error` field. The error message provides human-readable context about what went wrong.\n\n* * *\n\nSummary: Defines the standardized error response structure used by the Yellow Network clearnode to communicate request failures and provide diagnostic context to client applications.\n\nRelated terms: error response, clearnode, message format, error handling, authentication failure, insufficient funds, invalid method, server signature, requestId, timestamp, failure notification, exception, JSON-RPC error, status code\n\nUse cases: debugging failed API requests, handling authentication timeouts, validating transaction prerequisites, implementing client-side error alerts",
    "metadata": {
      "title": "Message Format | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/message-format",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the standardized error response structure used by the Yellow Network clearnode to communicate request failures and provide diagnostic context to client applications.",
      "keywords": [
        "error response",
        "clearnode",
        "message format",
        "error handling",
        "authentication failure",
        "insufficient funds",
        "invalid method",
        "server signature",
        "requestId",
        "timestamp",
        "failure notification",
        "exception",
        "JSON-RPC error",
        "status code"
      ],
      "function_name": null,
      "intent": "error_handling",
      "use_cases": [
        "debugging failed API requests",
        "handling authentication timeouts",
        "validating transaction prerequisites",
        "implementing client-side error alerts"
      ],
      "function_names": [
        "invalid_method"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Payload Hash Computationâ€‹\n\n\nEvery RPC message (request or response) is signed over the exact serialized `req` or `res` array bytes.\n\n### What is Signedâ€‹\n\n  * **Requests** : The `req` array `[requestId, method, params, timestamp]` exactly as sent\n  * **Responses** : The `res` array `[requestId, method, result, timestamp]` exactly as received\n\n### Hash Formulaâ€‹\n    \n    \n    payloadHash = keccak256(<exact JSON bytes of req or res>)  \n    \n\nUse the same bytes you transmit (or receive) when computing/verifying the hash; do not re-serialize with different spacing or key ordering.\n\n### Exampleâ€‹\n\n**Request Payload** :\n    \n    \n    [42,\"create_app_session\",{\"definition\":{...},\"allocations\":[...]},1699123456789]  \n    \n\nHash that exact byte string, then sign it (client for requests, clearnode for responses).\n\n* * *\n\nSummary: Defines the cryptographic hashing and signing protocol for RPC messages to ensure data integrity and authenticity between clients and nodes.\n\nRelated terms: payload hash, keccak256, message signing, RPC request, RPC response, serialization, data integrity, authentication, signature verification, message format, create_app_session, payloadHash, byte string, cryptographic proof\n\nUse cases: verifying message authenticity, securing RPC communication, implementing custom client signing, debugging signature mismatches",
    "metadata": {
      "title": "Message Format | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/message-format",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the cryptographic hashing and signing protocol for RPC messages to ensure data integrity and authenticity between clients and nodes.",
      "keywords": [
        "payload hash",
        "keccak256",
        "message signing",
        "RPC request",
        "RPC response",
        "serialization",
        "data integrity",
        "authentication",
        "signature verification",
        "message format",
        "create_app_session",
        "payloadHash",
        "byte string",
        "cryptographic proof"
      ],
      "function_name": "create_app_session",
      "intent": "api_reference",
      "use_cases": [
        "verifying message authenticity",
        "securing RPC communication",
        "implementing custom client signing",
        "debugging signature mismatches"
      ],
      "function_names": [
        "create_app_session"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Message Flow Diagramâ€‹\n\n\nThe following diagram illustrates the complete request-response cycle:\n\nClearnodeClientClearnodeClientClearnodeClientGenerate RequestProcess RequestGenerate ResponseProcess ResponseCreate payload: [request_id, method, params, 0]Sign payload with session keySend Request {req, sig}Verify signatureValidate parametersExecute method logicGenerate resultCreate response: [request_id, method, result, timestamp]Sign responseSend Response {res, sig}Verify Clearnode signatureCorrelate by request_idHandle result\n\n* * *\n\nSummary: This section defines the end-to-end request-response lifecycle between a client and Clearnode, detailing payload construction, cryptographic signing with session keys, and message correlation.\n\nRelated terms: message flow, request-response, Clearnode, session key, digital signature, payload structure, request_id, signature verification, crypto protocol, state machine, message correlation, secure communication, yellow network, clearnode client\n\nUse cases: Implementing a custom Clearnode client, Debugging message signing and verification, Designing secure request-response cycles in payment channels",
    "metadata": {
      "title": "Message Format | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/message-format",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section defines the end-to-end request-response lifecycle between a client and Clearnode, detailing payload construction, cryptographic signing with session keys, and message correlation.",
      "keywords": [
        "message flow",
        "request-response",
        "Clearnode",
        "session key",
        "digital signature",
        "payload structure",
        "request_id",
        "signature verification",
        "crypto protocol",
        "state machine",
        "message correlation",
        "secure communication",
        "yellow network",
        "clearnode client"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Implementing a custom Clearnode client",
        "Debugging message signing and verification",
        "Designing secure request-response cycles in payment channels"
      ],
      "function_names": [
        "request_id"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Signature Verification Processâ€‹\n\n\nBoth clients and a clearnode MUST verify signatures on all messages.\n\n### Client Verifying a Clearnode Responseâ€‹\n\n  1. **Extract Response** : Get `res` array from response\n  2. **Compute Hash** : `hash = keccak256(<exact res bytes>)`\n  3. **Recover Address** : Use `sig` to recover signer address\n  4. **Verify** : Confirm recovered address matches the clearnode's known address\n\n### A Clearnode Verifying Client Requestâ€‹\n\n  1. **Extract Request** : Get `req` array from request\n  2. **Compute Hash** : `hash = keccak256(<exact req bytes>)`\n  3. **Recover Address** : Use `sig` to recover signer address\n  4. **Verify** : Confirm recovered address matches authenticated user or registered session key\n\nSignature Verification Requirements\n\n**Most** messages MUST be cryptographically signed and verified. All state-changing operations (channel creation/closure, transfers, app sessions) and authenticated methods require valid signatures. However, **some query methods** (such as `get_config`) may be accessed without signatures. Refer to individual method specifications for signature requirements.\n\n* * *\n\nSummary: Defines the cryptographic protocol for verifying message integrity and authenticity between clients and clearnodes using Keccak256 hashing and address recovery.\n\nRelated terms: signature verification, keccak256, message integrity, authentication, clearnode, cryptographic signing, address recovery, ecdsa, request validation, response validation, secure communication, yellow network, sig verification, get_config\n\nUse cases: verifying clearnode responses, authenticating client requests, securing state-changing operations, validating session keys",
    "metadata": {
      "title": "Message Format | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/message-format",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the cryptographic protocol for verifying message integrity and authenticity between clients and clearnodes using Keccak256 hashing and address recovery.",
      "keywords": [
        "signature verification",
        "keccak256",
        "message integrity",
        "authentication",
        "clearnode",
        "cryptographic signing",
        "address recovery",
        "ecdsa",
        "request validation",
        "response validation",
        "secure communication",
        "yellow network",
        "sig verification",
        "get_config"
      ],
      "function_name": "get_config",
      "intent": "concept",
      "use_cases": [
        "verifying clearnode responses",
        "authenticating client requests",
        "securing state-changing operations",
        "validating session keys"
      ],
      "function_names": [
        "get_config"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## JSON Encoding Consistencyâ€‹\n\n\nTo ensure signature validity, JSON encoding MUST be consistent across all implementations.\n\n### Requirementsâ€‹\n\n  1. **Key Ordering** : Object keys MUST be in a deterministic order\n  2. **No Whitespace** : Remove all unnecessary whitespace\n  3. **No Trailing Commas** : Standard JSON (no trailing commas)\n  4. **UTF-8 Encoding** : Use UTF-8 character encoding\n  5. **Number Format** : Numbers as strings for large integers (avoid precision loss)\n\n### Canonical Exampleâ€‹\n\n**Consistent** (valid for signing):\n    \n    \n    [1,\"transfer\",{\"amount\":\"100\",\"asset\":\"usdc\",\"destination\":\"0x...\"},1699123456]  \n    \n\n**Inconsistent** (would produce different hash):\n    \n    \n    [  1,  \"transfer\",  { \"destination\": \"0x...\", \"amount\": \"100\", \"asset\": \"usdc\" },  1699123456  ]  \n    \n\nImplementation Note\n\nUse a JSON library that supports canonical JSON serialization, or implement strict key ordering and whitespace removal before computing hashes.\n\n* * *\n\nSummary: Defines the mandatory canonical JSON serialization standards required to ensure deterministic hashing and signature validity across all protocol implementations.\n\nRelated terms: JSON encoding, canonical JSON, deterministic serialization, signature verification, message format, hashing, UTF-8, key ordering, whitespace removal, large integers, crypto signing, payload formatting, data integrity, json serialization\n\nUse cases: Generating valid cryptographic signatures, Ensuring cross-platform message consistency, Preventing hash mismatches in state updates",
    "metadata": {
      "title": "Message Format | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/message-format",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the mandatory canonical JSON serialization standards required to ensure deterministic hashing and signature validity across all protocol implementations.",
      "keywords": [
        "JSON encoding",
        "canonical JSON",
        "deterministic serialization",
        "signature verification",
        "message format",
        "hashing",
        "UTF-8",
        "key ordering",
        "whitespace removal",
        "large integers",
        "crypto signing",
        "payload formatting",
        "data integrity",
        "json serialization"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Generating valid cryptographic signatures",
        "Ensuring cross-platform message consistency",
        "Preventing hash mismatches in state updates"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nNow that you understand the message format, explore how it's used in practice:\n\n  * **[Authentication](/docs/protocol/off-chain/authentication)** \\- Learn the 3-step authentication flow\n  * **[Channel Methods](/docs/protocol/off-chain/channel-methods)** \\- See request/response examples for channel operations\n  * **[Transfers](/docs/protocol/off-chain/transfers)** \\- Understand transfer message structure\n  * **[App Sessions](/docs/protocol/off-chain/app-sessions)** \\- Explore multi-signature app session messages\n\nFor a high-level overview, return to **[Off-Chain RPC Overview](/docs/protocol/off-chain/overview)**.\n\n\n\n[PreviousOff-Chain RPC Overview](/docs/protocol/off-chain/overview)[NextAuthentication](/docs/protocol/off-chain/authentication)\n\n  * General Structure\n    * Components\n  * Request Message\n    * Structure\n    * Fields\n    * Signature Format\n    * Complete Example\n  * Response Message\n    * Structure\n    * Fields\n    * Complete Example\n  * Error Response\n    * Structure\n    * Error Examples\n  * Payload Hash Computation\n    * What is Signed\n    * Hash Formula\n    * Example\n  * Message Flow Diagram\n  * Signature Verification Process\n    * Client Verifying a Clearnode Response\n    * A Clearnode Verifying Client Request\n  * JSON Encoding Consistency\n    * Requirements\n    * Canonical Example\n  * Next Steps\n\nSummary: Defines the standardized off-chain communication protocol, covering message structures, cryptographic signing, and verification procedures required for secure interaction within the Yellow Network.\n\nRelated terms: message format, JSON-RPC, off-chain messaging, signature verification, payload hash, canonical JSON, request-response, error handling, cryptographic signing, secure communication, clearnode, msg format, signiture\n\nUse cases: Standardizing off-chain communication between clients and nodes, Implementing cryptographic signature verification, Ensuring JSON canonicalization for consistent hashing, Debugging protocol-level message exchanges",
    "metadata": {
      "title": "Message Format | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/message-format",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the standardized off-chain communication protocol, covering message structures, cryptographic signing, and verification procedures required for secure interaction within the Yellow Network.",
      "keywords": [
        "message format",
        "JSON-RPC",
        "off-chain messaging",
        "signature verification",
        "payload hash",
        "canonical JSON",
        "request-response",
        "error handling",
        "cryptographic signing",
        "secure communication",
        "clearnode",
        "msg format",
        "signiture"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Standardizing off-chain communication between clients and nodes",
        "Implementing cryptographic signature verification",
        "Ensuring JSON canonicalization for consistent hashing",
        "Debugging protocol-level message exchanges"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Off-Chain RPC Protocol\n  * Off-Chain RPC Overview\n\n\n\n# Off-Chain RPC Protocol Overview\n\nThe Off-Chain RPC Protocol defines how clients communicate with a clearnode to perform state channel operations without touching the blockchain.\n\n* * *\n\nSummary: The Off-Chain RPC Protocol enables low-latency communication between clients and clearnodes to execute state channel operations and updates without direct blockchain interaction.\n\nRelated terms: off-chain, RPC, clearnode, state channel, layer 2, gasless, instant settlement, offchain, protocol, scalability, peer-to-peer, state update, fast payments\n\nUse cases: High-frequency trading, Micro-payments, Real-time state channel management, Reducing on-chain transaction costs",
    "metadata": {
      "title": "Off-Chain RPC Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/overview",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The Off-Chain RPC Protocol enables low-latency communication between clients and clearnodes to execute state channel operations and updates without direct blockchain interaction.",
      "keywords": [
        "off-chain",
        "RPC",
        "clearnode",
        "state channel",
        "layer 2",
        "gasless",
        "instant settlement",
        "offchain",
        "protocol",
        "scalability",
        "peer-to-peer",
        "state update",
        "fast payments"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "High-frequency trading",
        "Micro-payments",
        "Real-time state channel management",
        "Reducing on-chain transaction costs"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## What is Nitro RPC?â€‹\n\n\n**Nitro RPC** is a lightweight RPC protocol designed for state channel communication. It uses a compact JSON array format for efficiency and includes signature-based authentication.\n\nProtocol Purpose\n\nNitro RPC enables clients to interact with a clearnode for channel management, fund transfers, and application-specific operationsâ€”all happening off-chain with instant finality and zero gas costs.\n\n* * *\n\nSummary: Nitro RPC is a lightweight, signature-authenticated communication protocol that enables off-chain state channel management and instant, gasless transactions between clients and clearnodes.\n\nRelated terms: Nitro RPC, state channel, off-chain, clearnode, JSON-RPC, signature authentication, instant finality, zero gas, payment channel, channel management, fund transfer, state update, Yellow Network, offchain\n\nUse cases: off-chain fund transfers, state channel management, gasless transaction processing",
    "metadata": {
      "title": "Off-Chain RPC Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/overview",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Nitro RPC is a lightweight, signature-authenticated communication protocol that enables off-chain state channel management and instant, gasless transactions between clients and clearnodes.",
      "keywords": [
        "Nitro RPC",
        "state channel",
        "off-chain",
        "clearnode",
        "JSON-RPC",
        "signature authentication",
        "instant finality",
        "zero gas",
        "payment channel",
        "channel management",
        "fund transfer",
        "state update",
        "Yellow Network",
        "offchain"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "off-chain fund transfers",
        "state channel management",
        "gasless transaction processing"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Key Featuresâ€‹\n\n\n### 1\\. Compact Message Formatâ€‹\n\nNitro RPC uses a streamlined JSON array format instead of verbose JSON objects, reducing message size and improving network efficiency.\n    \n    \n    // Compact format: [requestId, method, params, timestamp]  \n    [1, \"create_channel\", {\"chain_id\": 137, \"token\": \"0x...\", \"amount\": \"1000000\"}, 1699123456789]  \n    \n\nEfficiency Benefit\n\nThe compact array format reduces bandwidth usage by approximately 30% compared to traditional JSON-RPC, crucial for high-frequency state channel updates.\n\n### 2\\. Signature-Based Authenticationâ€‹\n\nEvery request and response is cryptographically signed, ensuring:\n\n  * **Message authenticity** : Verify sender identity\n  * **Message integrity** : Detect tampering\n  * **Non-repudiation** : Proof of communication\n\n### 3\\. Multi-Signature Supportâ€‹\n\nSupports operations requiring multiple participants' signatures:\n\n  * Channel creation (user + a clearnode)\n  * App session state updates (multiple participants based on quorum)\n  * Cooperative channel closure\n\n### 4\\. Timestamp-Based Request Orderingâ€‹\n\nAll messages include timestamps (client-provided on requests, server-provided on responses) enabling:\n\n  * Request ordering\n  * Replay attack prevention\n  * Audit trail for debugging\n\n### 5\\. Channel-Aware Message Structureâ€‹\n\nThe protocol understands channel concepts natively:\n\n  * Packed states\n  * Multi-party signatures\n  * State versioning\n\n* * *\n\nSummary: Defines the Nitro RPC protocol, a high-efficiency communication layer for the Yellow Network that utilizes compact JSON arrays and cryptographic signatures to facilitate secure, low-latency off-chain state channel management and multi-party interactions.\n\nRelated terms: Nitro RPC, off-chain communication, JSON-RPC, compact format, cryptographic signature, multi-sig, state channel, replay protection, bandwidth optimization, clearnode, offchain, multisig, secure messaging, non-repudiation\n\nUse cases: high-frequency state updates, opening a payment channel, multi-party state synchronization, replay attack prevention",
    "metadata": {
      "title": "Off-Chain RPC Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/overview",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the Nitro RPC protocol, a high-efficiency communication layer for the Yellow Network that utilizes compact JSON arrays and cryptographic signatures to facilitate secure, low-latency off-chain state channel management and multi-party interactions.",
      "keywords": [
        "Nitro RPC",
        "off-chain communication",
        "JSON-RPC",
        "compact format",
        "cryptographic signature",
        "multi-sig",
        "state channel",
        "replay protection",
        "bandwidth optimization",
        "clearnode",
        "offchain",
        "multisig",
        "secure messaging",
        "non-repudiation"
      ],
      "function_name": "create_channel",
      "intent": "concept",
      "use_cases": [
        "high-frequency state updates",
        "opening a payment channel",
        "multi-party state synchronization",
        "replay attack prevention"
      ],
      "function_names": [
        "chain_id",
        "create_channel"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Protocol Versionsâ€‹\n\n\nNitro RPC has evolved to support advanced features while maintaining backward compatibility.\n\n### Version Comparisonâ€‹\n\nFeature| NitroRPC/0.2| NitroRPC/0.4  \n---|---|---  \n**Status**|  Legacy| **Current**  \n**Basic State Updates**|  âœ…| âœ…  \n**Intent System**|  âŒ| âœ…  \n**DEPOSIT Intent**|  âŒ| âœ… (add funds to app sessions)  \n**WITHDRAW Intent**|  âŒ| âœ… (remove funds from app sessions)  \n**OPERATE Intent**|  Implicit only| âœ… Explicit  \n**Recommended**|  No| **Yes**  \n  \nVersion Recommendation\n\n**Always use NitroRPC/0.4** for new implementations. Version 0.2 is maintained for backward compatibility only and lacks the intent system required for flexible app session management.\n\n### NitroRPC/0.2 (Legacy)â€‹\n\n**Features** :\n\n  * Basic state updates for app sessions\n  * All updates redistribute existing funds\n  * Cannot add or remove funds from active sessions\n  * Must close and recreate sessions to change total funds\n\n**Use Case** : Maintained for existing applications, not recommended for new development.\n\n### NitroRPC/0.4 (Current)â€‹\n\n**Features** :\n\n  * Intent-based state updates: **OPERATE** , **DEPOSIT** , **WITHDRAW**\n  * Add funds to active app sessions (DEPOSIT)\n  * Remove funds from active sessions (WITHDRAW)\n  * Better error handling and validation\n  * Enhanced security checks\n\n**Use Case** : All new implementations should use this version.\n\n* * *\n\nSummary: This section outlines the evolution of the Nitro RPC protocol, comparing the legacy version with the current version 0.4 which introduces an intent-based system for dynamic fund management within active app sessions.\n\nRelated terms: NitroRPC, Nitro RPC, off-chain rpc, state updates, intent system, deposit intent, withdraw intent, operate intent, app session, Yellow Network, protocol versioning, fund management, nitro rpc 0.4, nitro rpc 0.2\n\nUse cases: Upgrading legacy payment integrations, Dynamic fund management in active sessions, Implementing flexible deposits and withdrawals, Protocol version selection for new SDK builds",
    "metadata": {
      "title": "Off-Chain RPC Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/overview",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the evolution of the Nitro RPC protocol, comparing the legacy version with the current version 0.4 which introduces an intent-based system for dynamic fund management within active app sessions.",
      "keywords": [
        "NitroRPC",
        "Nitro RPC",
        "off-chain rpc",
        "state updates",
        "intent system",
        "deposit intent",
        "withdraw intent",
        "operate intent",
        "app session",
        "Yellow Network",
        "protocol versioning",
        "fund management",
        "nitro rpc 0.4",
        "nitro rpc 0.2"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Upgrading legacy payment integrations",
        "Dynamic fund management in active sessions",
        "Implementing flexible deposits and withdrawals",
        "Protocol version selection for new SDK builds"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Communication Architectureâ€‹\n\n\nNitro RPC enables bidirectional real-time communication between clients and a clearnode.\n\nRPC Connection\n\nEvent Monitoring\n\nState Management\n\n1\\. RPC Request  \n(signed)\n\n2\\. Process & Validate\n\n3\\. RPC Response  \n(signed)\n\nAsync Notifications\n\nBlockchain Events\n\nClient Application\n\nClearnode\n\nBlockchain\n\nDatabase\n\n### Connection Flowâ€‹\n\n  1. **Client Establishes Connection** : Open persistent connection to a clearnode\n  2. **Authentication** : Complete 3-step auth flow (auth_request â†’ auth_challenge â†’ auth_verify)\n  3. **RPC Communication** : Send requests, receive responses\n  4. **Notifications** : Receive real-time updates (balance changes, channel events)\n  5. **Keep-Alive** : Periodic ping/pong to maintain connection (optional, depends upon the implementation chosen)\n\n* * *\n\nSummary: This component defines the bidirectional communication architecture between clients and clearnodes, enabling real-time state management and secure authenticated RPC interactions via the Nitro protocol.\n\nRelated terms: Nitro RPC, clearnode, bidirectional communication, state management, authentication flow, real-time updates, event monitoring, persistent connection, auth_request, auth_verify, auth_challenge, async notifications, keep-alive, off-chain messaging\n\nUse cases: Establishing a secure session with a network node, Real-time monitoring of off-chain state changes, Implementing a persistent messaging layer for high-frequency payments, Authenticating client applications to the Yellow Network",
    "metadata": {
      "title": "Off-Chain RPC Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/overview",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the bidirectional communication architecture between clients and clearnodes, enabling real-time state management and secure authenticated RPC interactions via the Nitro protocol.",
      "keywords": [
        "Nitro RPC",
        "clearnode",
        "bidirectional communication",
        "state management",
        "authentication flow",
        "real-time updates",
        "event monitoring",
        "persistent connection",
        "auth_request",
        "auth_verify",
        "auth_challenge",
        "async notifications",
        "keep-alive",
        "off-chain messaging"
      ],
      "function_name": "auth_request",
      "intent": "concept",
      "use_cases": [
        "Establishing a secure session with a network node",
        "Real-time monitoring of off-chain state changes",
        "Implementing a persistent messaging layer for high-frequency payments",
        "Authenticating client applications to the Yellow Network"
      ],
      "function_names": [
        "auth_challenge",
        "auth_request",
        "auth_verify"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Message Categoriesâ€‹\n\n\nNitro RPC methods are organized into functional categories:\n\n### 1\\. Authentication Methodsâ€‹\n\nEstablish and manage authenticated sessions:\n\n  * `auth_request` \\- Initiate authentication (response: `auth_challenge`)\n  * `auth_verify` \\- Complete authentication with challenge response\n\n### 2\\. Channel Management Methodsâ€‹\n\nCreate and manage payment channels:\n\n  * `create_channel` \\- Open new channel\n  * `close_channel` \\- Cooperatively close channel\n  * `resize_channel` \\- Adjust channel allocations\n\n### 3\\. Transfer Methodsâ€‹\n\nMove funds between users:\n\n  * `transfer` \\- Send funds off-chain with instant settlement\n\n### 4\\. App Session Methodsâ€‹\n\nManage multi-party application channels:\n\n  * `create_app_session` \\- Create new app session\n  * `submit_app_state` \\- Update session state (with intents)\n  * `close_app_session` \\- Finalize and distribute funds\n\n### 5\\. Query Methodsâ€‹\n\nRead state and configuration:\n\n  * Public: `get_config`, `get_assets`, `get_app_definition`, `get_channels`, `get_app_sessions`, `get_ledger_entries`, `get_ledger_transactions`, `ping`\n  * Private (auth required): `get_ledger_balances`, `get_rpc_history`, `get_user_tag`, `get_session_keys`\n\n### 6\\. Notifications (Server-to-Client)â€‹\n\nReal-time updates:\n\n  * `bu` (balance update) - Balance changed\n  * `cu` (channel update) - Channel status changed\n  * `tr` (transfer) - Incoming/outgoing transfer\n  * `asu` (app session update) - App session state changed\n\n* * *\n\nSummary: This component defines the Nitro RPC interface for the Yellow Network, enabling developers to manage off-chain state channels, execute instant fund transfers, and synchronize multi-party application states.\n\nRelated terms: RPC API, off-chain, state channels, payment channel, instant settlement, authentication, session management, ledger, balance updates, nitro protocol, peer-to-peer, multi-party, JSON-RPC, websocket, liquidity\n\nUse cases: instant off-chain fund transfers, high-frequency payment channel management, multi-party application state synchronization, real-time ledger monitoring",
    "metadata": {
      "title": "Off-Chain RPC Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/overview",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the Nitro RPC interface for the Yellow Network, enabling developers to manage off-chain state channels, execute instant fund transfers, and synchronize multi-party application states.",
      "keywords": [
        "RPC API",
        "off-chain",
        "state channels",
        "payment channel",
        "instant settlement",
        "authentication",
        "session management",
        "ledger",
        "balance updates",
        "nitro protocol",
        "peer-to-peer",
        "multi-party",
        "JSON-RPC",
        "websocket",
        "liquidity"
      ],
      "function_name": "create_channel",
      "intent": "api_reference",
      "use_cases": [
        "instant off-chain fund transfers",
        "high-frequency payment channel management",
        "multi-party application state synchronization",
        "real-time ledger monitoring"
      ],
      "function_names": [
        "create_channel",
        "create_app_session",
        "close_channel",
        "get_user_tag",
        "close_app_session"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Security Modelâ€‹\n\n\nThe Off-Chain RPC Protocol provides multiple layers of security:\n\n### Cryptographic Securityâ€‹\n\n  * **ECDSA Signatures** : Every message signed with secp256k1\n  * **Keccak256 Hashing** : Message integrity verification\n  * **Challenge-Response Auth** : Prove key ownership without exposing private keys\n\n### Protocol-Level Securityâ€‹\n\n  * **Request Ordering** : Timestamps prevent replay attacks\n  * **Session Expiration** : Session keys have time limits\n  * **Spending Allowances** : Limit session key spending power\n  * **Signature Verification** : All operations require valid signatures\n\n### Network Securityâ€‹\n\n  * **TLS Encrypted Communication** : Encrypted communication channel\n  * **Origin Validation** : Prevent unauthorized connections\n\nStrong Security Model\n\nThe combination of cryptographic signatures, challenge-response authentication, and spending allowances ensures that even if a session key is compromised, damage is limited by spending caps and expiration times.\n\n* * *\n\nSummary: Defines the multi-layered security framework for the Off-Chain RPC Protocol, ensuring transaction integrity and session safety through cryptographic signatures, time-bound sessions, and spending constraints.\n\nRelated terms: ECDSA, secp256k1, Keccak256, challenge-response, replay attack prevention, session keys, spending allowances, TLS encryption, message signing, authentication, off-chain protocol, integrity verification, private key protection\n\nUse cases: Securing high-frequency off-chain transactions, Implementing session-based spending limits, Preventing unauthorized message replay, Verifying peer identity in a decentralized network",
    "metadata": {
      "title": "Off-Chain RPC Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/overview",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the multi-layered security framework for the Off-Chain RPC Protocol, ensuring transaction integrity and session safety through cryptographic signatures, time-bound sessions, and spending constraints.",
      "keywords": [
        "ECDSA",
        "secp256k1",
        "Keccak256",
        "challenge-response",
        "replay attack prevention",
        "session keys",
        "spending allowances",
        "TLS encryption",
        "message signing",
        "authentication",
        "off-chain protocol",
        "integrity verification",
        "private key protection"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Securing high-frequency off-chain transactions",
        "Implementing session-based spending limits",
        "Preventing unauthorized message replay",
        "Verifying peer identity in a decentralized network"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nExplore the detailed specifications for each part of the protocol:\n\n  * **[Message Format](/docs/protocol/off-chain/message-format)** \\- Learn the request/response structure\n  * **[Authentication](/docs/protocol/off-chain/authentication)** \\- Implement secure session management\n  * **[Channel Methods](/docs/protocol/off-chain/channel-methods)** \\- Create and manage payment channels\n  * **[Transfers](/docs/protocol/off-chain/transfers)** \\- Enable instant off-chain payments\n  * **[App Sessions](/docs/protocol/off-chain/app-sessions)** \\- Build multi-party applications\n  * **[Queries& Notifications](/docs/protocol/off-chain/queries)** \\- Read state and receive updates\n\n* * *\n\nSummary: Provides a navigational overview of the off-chain RPC protocol components, including message structures, channel management, and real-time state synchronization for the Yellow Network.\n\nRelated terms: off-chain, RPC, payment channel, state channel, message format, authentication, session management, transfers, app sessions, queries, notifications, layer 2, scalability, offchain, yellow network\n\nUse cases: building off-chain payment applications, implementing state channel protocols, integrating real-time crypto transfers",
    "metadata": {
      "title": "Off-Chain RPC Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/overview",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a navigational overview of the off-chain RPC protocol components, including message structures, channel management, and real-time state synchronization for the Yellow Network.",
      "keywords": [
        "off-chain",
        "RPC",
        "payment channel",
        "state channel",
        "message format",
        "authentication",
        "session management",
        "transfers",
        "app sessions",
        "queries",
        "notifications",
        "layer 2",
        "scalability",
        "offchain",
        "yellow network"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "building off-chain payment applications",
        "implementing state channel protocols",
        "integrating real-time crypto transfers"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Key Conceptsâ€‹\n\n\nBefore diving into specific methods, ensure you understand these core concepts from the protocol foundation:\n\n  * **Channel** \\- Payment channel locking funds on-chain\n  * **State** \\- Snapshot of channel at a point in time\n  * **Participant** \\- Entity in a channel (user, a clearnode)\n  * **Unified Balance** \\- Aggregated balance across chains\n  * **Session Key** \\- Temporary key with spending limits\n\nRefer to the **[Terminology](/docs/protocol/terminology)** page for complete definitions.\n\n\n\n[PreviousSecurity Considerations](/docs/protocol/on-chain/security)[NextMessage Format](/docs/protocol/off-chain/message-format)\n\n  * What is Nitro RPC?\n  * Key Features\n    * 1\\. Compact Message Format\n    * 2\\. Signature-Based Authentication\n    * 3\\. Multi-Signature Support\n    * 4\\. Timestamp-Based Request Ordering\n    * 5\\. Channel-Aware Message Structure\n  * Protocol Versions\n    * Version Comparison\n    * NitroRPC/0.2 (Legacy)\n    * NitroRPC/0.4 (Current)\n  * Communication Architecture\n    * Connection Flow\n  * Message Categories\n    * 1\\. Authentication Methods\n    * 2\\. Channel Management Methods\n    * 3\\. Transfer Methods\n    * 4\\. App Session Methods\n    * 5\\. Query Methods\n    * 6\\. Notifications (Server-to-Client)\n  * Security Model\n    * Cryptographic Security\n    * Protocol-Level Security\n    * Network Security\n  * Next Steps\n  * Key Concepts\n\nSummary: This section outlines the Nitro RPC architectural framework, defining the core concepts and communication protocols required for secure, off-chain state management and payment channel operations within the Yellow Network.\n\nRelated terms: Nitro RPC, payment channel, state update, off-chain communication, session key, unified balance, multi-signature, cryptographic security, message format, clearnode, layer 2, state machine, signing, p2p payment\n\nUse cases: off-chain state synchronization, high-frequency micro-payments, cross-chain balance aggregation, secure multi-party channel management",
    "metadata": {
      "title": "Off-Chain RPC Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/overview",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the Nitro RPC architectural framework, defining the core concepts and communication protocols required for secure, off-chain state management and payment channel operations within the Yellow Network.",
      "keywords": [
        "Nitro RPC",
        "payment channel",
        "state update",
        "off-chain communication",
        "session key",
        "unified balance",
        "multi-signature",
        "cryptographic security",
        "message format",
        "clearnode",
        "layer 2",
        "state machine",
        "signing",
        "p2p payment"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "off-chain state synchronization",
        "high-frequency micro-payments",
        "cross-chain balance aggregation",
        "secure multi-party channel management"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Off-Chain RPC Protocol\n  * Query Methods & Notifications\n\n\n\n# Query Methods & Notifications\n\nQuery methods retrieve information from a clearnode, while notifications provide real-time updates about state changes.\n\n* * *\n\nSummary: Defines the off-chain RPC communication layer for interacting with clearnodes, facilitating data retrieval and real-time state change monitoring.\n\nRelated terms: RPC, off-chain, clearnode, query, notifications, real-time updates, state changes, data retrieval, messaging protocol, event listening, pub/sub, yellow network, clear node, node communication\n\nUse cases: Monitoring payment channel status, Retrieving historical transaction data, Subscribing to real-time balance updates",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the off-chain RPC communication layer for interacting with clearnodes, facilitating data retrieval and real-time state change monitoring.",
      "keywords": [
        "RPC",
        "off-chain",
        "clearnode",
        "query",
        "notifications",
        "real-time updates",
        "state changes",
        "data retrieval",
        "messaging protocol",
        "event listening",
        "pub/sub",
        "yellow network",
        "clear node",
        "node communication"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Monitoring payment channel status",
        "Retrieving historical transaction data",
        "Subscribing to real-time balance updates"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Overviewâ€‹\n\n\nThe Nitro RPC protocol provides two types of information retrieval:\n\n**Query Methods** : Client-initiated requests to retrieve current state information (balances, channels, sessions, transactions).\n\n**Notifications** : Server-initiated messages sent to all relevant active connections when events occur (balance changes, channel updates, incoming transfers).\n\nReal-Time Updates\n\nCombine query methods for initial state retrieval with notifications for ongoing monitoring. This pattern ensures your application always reflects the latest state without constant polling.\n\n* * *\n\nSummary: The Nitro RPC protocol facilitates state synchronization through a hybrid model of client-initiated queries for data retrieval and server-initiated notifications for real-time event updates. This architecture ensures application state consistency while minimizing network overhead by avoiding continuous polling.\n\nRelated terms: Nitro RPC, query methods, notifications, real-time updates, state retrieval, event monitoring, push notifications, polling, balance updates, channel updates, incoming transfers, synchronization, pub-sub, Yellow Network\n\nUse cases: Synchronizing wallet balances on application startup, Implementing real-time UI updates for incoming transfers, Monitoring payment channel state changes without polling, Building a dashboard for active session tracking",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The Nitro RPC protocol facilitates state synchronization through a hybrid model of client-initiated queries for data retrieval and server-initiated notifications for real-time event updates. This architecture ensures application state consistency while minimizing network overhead by avoiding continuous polling.",
      "keywords": [
        "Nitro RPC",
        "query methods",
        "notifications",
        "real-time updates",
        "state retrieval",
        "event monitoring",
        "push notifications",
        "polling",
        "balance updates",
        "channel updates",
        "incoming transfers",
        "synchronization",
        "pub-sub",
        "Yellow Network"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Synchronizing wallet balances on application startup",
        "Implementing real-time UI updates for incoming transfers",
        "Monitoring payment channel state changes without polling",
        "Building a dashboard for active session tracking"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Query Methods Summaryâ€‹\n\n\nMethod| Authentication| Purpose| Pagination  \n---|---|---|---  \n`get_config`| Public| Retrieve clearnode configuration| No  \n`get_assets`| Public| List supported assets| No  \n`get_app_definition`| Public| Fetch the definition for a specific app session| No  \n`get_channels`| Public| List payment channels| Yes  \n`get_app_sessions`| Public| List app sessions| Yes  \n`get_ledger_balances`| Private| Query current balances| No  \n`get_ledger_entries`| Public| Detailed accounting entries| Yes  \n`get_ledger_transactions`| Public| User-facing transaction history| Yes  \n`get_rpc_history`| Private| Fetch recent RPC invocations| Yes  \n`get_user_tag`| Private| Retrieve user's alphanumeric tag| No  \n`get_session_keys`| Private| List active session keys| Yes  \n`ping`| Public| Connection health check| No  \n  \nAuthentication\n\n**Public methods** can be called without authentication. **Private methods** require completing the [authentication flow](/docs/protocol/off-chain/authentication) first.\n\nPagination defaults\n\nUnless explicitly provided, paginated methods default to `limit = 10` (maximum 100) and `offset = 0`, matching the brokerâ€™s `ListOptions`.\n\n* * *\n\nSummary: Provides a comprehensive reference for querying clearnode configuration, ledger states, and session metadata within the Yellow Network off-chain protocol.\n\nRelated terms: query methods, ledger balances, payment channels, transaction history, clearnode config, session keys, pagination, authentication, RPC history, asset list, ping, ledger entries, app sessions, off-chain state\n\nUse cases: Retrieving user account balances and transaction history for a wallet UI, Monitoring payment channel status and active app sessions, Verifying clearnode connectivity and supported crypto assets, Auditing ledger entries for accounting purposes",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a comprehensive reference for querying clearnode configuration, ledger states, and session metadata within the Yellow Network off-chain protocol.",
      "keywords": [
        "query methods",
        "ledger balances",
        "payment channels",
        "transaction history",
        "clearnode config",
        "session keys",
        "pagination",
        "authentication",
        "RPC history",
        "asset list",
        "ping",
        "ledger entries",
        "app sessions",
        "off-chain state"
      ],
      "function_name": "get_config",
      "intent": "api_reference",
      "use_cases": [
        "Retrieving user account balances and transaction history for a wallet UI",
        "Monitoring payment channel status and active app sessions",
        "Verifying clearnode connectivity and supported crypto assets",
        "Auditing ledger entries for accounting purposes"
      ],
      "function_names": [
        "get_app_definition",
        "get_config",
        "get_ledger_entries",
        "get_assets",
        "get_session_keys"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## get_configâ€‹\n\n\n### Nameâ€‹\n\n`get_config`\n\n### Usageâ€‹\n\nRetrieves the clearnode's configuration: broker address plus supported blockchains and their custody/adjudicator contracts.\n\n### Requestâ€‹\n\nNo parameters.\n\n### Responseâ€‹\n\nParameter| Type| Description| Example  \n---|---|---|---  \n`broker_address`| string| Clearnode's wallet address| `\"0xbbbb567890abcdef...\"`  \n`networks`| array<BlockchainInfo>| List of supported blockchain networks| See structure below  \n  \n#### BlockchainInfo Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`chain_id`| uint32| Network identifier| `137` (Polygon)  \n`name`| string| Human-readable blockchain name| `\"Polygon\"`  \n`custody_address`| string| Custody contract address on this chain| `\"0xCustodyContractAddress...\"`  \n`adjudicator_address`| string| Adjudicator contract address on this chain| `\"0xAdjudicatorAddress...\"`  \n  \n**Use Cases** :\n\n  * Discover supported chains and contract addresses\n  * Verify clearnode wallet address\n\n* * *\n\nSummary: Retrieves the Clearnode's operational configuration, including its broker wallet address and the specific custody and adjudicator contract addresses for all supported blockchain networks.\n\nRelated terms: get_config, clearnode configuration, broker address, custody contract, adjudicator contract, chain id, network discovery, blockchain info, supported networks, node setup, getconfig, clear node, smart contract addresses\n\nUse cases: Discovering supported blockchain networks and contract addresses, Verifying Clearnode broker wallet identity, Initializing client-side SDK with network-specific contract metadata",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Retrieves the Clearnode's operational configuration, including its broker wallet address and the specific custody and adjudicator contract addresses for all supported blockchain networks.",
      "keywords": [
        "get_config",
        "clearnode configuration",
        "broker address",
        "custody contract",
        "adjudicator contract",
        "chain id",
        "network discovery",
        "blockchain info",
        "supported networks",
        "node setup",
        "getconfig",
        "clear node",
        "smart contract addresses"
      ],
      "function_name": "get_config",
      "intent": "api_reference",
      "use_cases": [
        "Discovering supported blockchain networks and contract addresses",
        "Verifying Clearnode broker wallet identity",
        "Initializing client-side SDK with network-specific contract metadata"
      ],
      "function_names": [
        "adjudicator_address",
        "broker_address",
        "custody_address",
        "chain_id",
        "get_config"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## get_assetsâ€‹\n\n\n### Nameâ€‹\n\n`get_assets`\n\n### Usageâ€‹\n\nRetrieves all supported assets and their configurations across supported blockchains.\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Example| Notes  \n---|---|---|---|---|---  \n`chain_id`| uint32| No| Filter by specific chain| `137`| If omitted, returns assets for all chains  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Example  \n---|---|---|---  \n`assets`| array<Asset>| List of supported assets| See structure below  \n  \n#### Asset Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`token`| string| Token contract address| `\"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\"`  \n`chain_id`| uint32| Blockchain network identifier| `137`  \n`symbol`| string| Token symbol| `\"usdc\"`  \n`decimals`| uint8| Number of decimal places| `6`  \n  \n**Use Cases** :\n\n  * Display supported assets in UI\n  * Validate asset identifiers before transfers\n  * Get contract addresses for specific chains\n\n* * *\n\nSummary: Retrieves a comprehensive list of supported cryptographic assets and their configurations across multiple blockchain networks, including contract addresses and metadata.\n\nRelated terms: get_assets, supported tokens, chain_id, asset configuration, token list, blockchain assets, crypto inventory, contract addresses, token metadata, multi-chain assets, getassets, asset discovery, token decimals\n\nUse cases: Displaying supported tokens in a user interface, Validating token contract addresses before initiating transfers, Retrieving multi-chain asset configurations",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Retrieves a comprehensive list of supported cryptographic assets and their configurations across multiple blockchain networks, including contract addresses and metadata.",
      "keywords": [
        "get_assets",
        "supported tokens",
        "chain_id",
        "asset configuration",
        "token list",
        "blockchain assets",
        "crypto inventory",
        "contract addresses",
        "token metadata",
        "multi-chain assets",
        "getassets",
        "asset discovery",
        "token decimals"
      ],
      "function_name": "get_assets",
      "intent": "api_reference",
      "use_cases": [
        "Displaying supported tokens in a user interface",
        "Validating token contract addresses before initiating transfers",
        "Retrieving multi-chain asset configurations"
      ],
      "function_names": [
        "get_assets",
        "chain_id"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## get_app_definitionâ€‹\n\n\n### Nameâ€‹\n\n`get_app_definition`\n\n### Usageâ€‹\n\nRetrieves the immutable definition for a given app session so clients can verify governance parameters and participants.\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Example  \n---|---|---|---|---  \n`app_session_id`| string| Yes| Target app session identifier| `\"0x9876543210fedcba...\"`  \n  \n### Responseâ€‹\n\nReturns the [AppDefinition](/docs/protocol/off-chain/app-sessions#appdefinition) structure:\n\nField| Type| Description  \n---|---|---  \n`protocol`| string| Protocol version (`\"NitroRPC/0.2\"` or `\"NitroRPC/0.4\"`)  \n`participants`| array<address>| Wallet addresses authorized for this session  \n`weights`| array<int64>| Voting weight per participant (aligned with `participants` order)  \n`quorum`| uint64| Minimum combined weight required for updates  \n`challenge`| uint64| Dispute timeout (seconds)  \n`nonce`| uint64| Unique instance identifier  \n  \n**Use Cases** :\n\n  * Validate session metadata before signing states\n  * Display governance rules in UI\n  * Confirm protocol version compatibility\n\n* * *\n\nSummary: Retrieves the immutable configuration and governance parameters of a specific application session, enabling participants to verify protocol versions, authorized addresses, and dispute resolution settings.\n\nRelated terms: get_app_definition, app_session_id, session metadata, governance rules, participant list, NitroRPC, quorum, dispute timeout, challenge period, voting weights, app definition, session config, off-chain session, state channel\n\nUse cases: Verifying session governance parameters before signing state updates, Displaying participant roles and voting weights in a user interface, Ensuring protocol version compatibility between session peers",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Retrieves the immutable configuration and governance parameters of a specific application session, enabling participants to verify protocol versions, authorized addresses, and dispute resolution settings.",
      "keywords": [
        "get_app_definition",
        "app_session_id",
        "session metadata",
        "governance rules",
        "participant list",
        "NitroRPC",
        "quorum",
        "dispute timeout",
        "challenge period",
        "voting weights",
        "app definition",
        "session config",
        "off-chain session",
        "state channel"
      ],
      "function_name": "get_app_definition",
      "intent": "api_reference",
      "use_cases": [
        "Verifying session governance parameters before signing state updates",
        "Displaying participant roles and voting weights in a user interface",
        "Ensuring protocol version compatibility between session peers"
      ],
      "function_names": [
        "get_app_definition",
        "app_session_id"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## get_channelsâ€‹\n\n\n### Nameâ€‹\n\n`get_channels`\n\n### Usageâ€‹\n\nLists all channels for a specific participant address across all supported chains.\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example  \n---|---|---|---|---|---  \n`participant`| string| No| Participant wallet address to query| (empty = all channels)| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`  \n`status`| string| No| Filter by status| -| `\"open\"`  \n`offset`| number| No| Pagination offset| `0`| `42`  \n`limit`| number| No| Number of channels to return| `10` (max 100)| `10`  \n`sort`| string| No| Sort order by created_at| `\"desc\"`| `\"desc\"`  \n  \n**Allowed status values** : `\"open\"` | `\"closed\"` | `\"challenged\"` | `\"resizing\"`\n\n### Responseâ€‹\n\nParameter| Type| Description| Example  \n---|---|---|---  \n`channels`| array<Channel>| List of channels| See structure below  \n  \n#### Channel Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`channel_id`| string| Unique channel identifier| `\"0xabcdef...\"`  \n`participant`| string| User's wallet address| `\"0x742d35Cc...\"`  \n`status`| string| Channel status| `\"open\"`  \n`token`| string| Asset contract address| `\"0x2791Bca1...\"`  \n`wallet`| string| Participant's wallet address| `\"0x742d35Cc...\"`  \n`amount`| string| Total channel capacity (human-readable)| `\"100.0\"`  \n`chain_id`| uint32| Blockchain network identifier| `137`  \n`adjudicator`| string| Dispute resolution contract address| `\"0xAdjudicator...\"`  \n`challenge`| uint64| Dispute timeout period (seconds)| `3600`  \n`nonce`| uint64| Unique nonce ensuring channel uniqueness| `1699123456789`  \n`version`| uint64| Current state version| `5`  \n`created_at`| string| Channel creation timestamp (ISO 8601)| `\"2023-05-01T12:00:00Z\"`  \n`updated_at`| string| Last modification timestamp (ISO 8601)| `\"2023-05-01T14:30:00Z\"`  \n  \n**Use Cases** :\n\n  * Display user's open channels\n  * Check channel status before operations\n  * Monitor multi-chain channel distribution\n\n* * *\n\nSummary: Provides a query interface to retrieve and filter payment channel metadata across multiple blockchain networks for specific participant addresses.\n\nRelated terms: get_channels, list channels, channel status, multi-chain query, payment channel, state channel, pagination, wallet lookup, adjudicator, channel capacity, blockchain indexing, getchannels, channel history\n\nUse cases: Display user's open channels, Check channel status before operations, Monitor multi-chain channel distribution, Audit channel version and nonce history",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a query interface to retrieve and filter payment channel metadata across multiple blockchain networks for specific participant addresses.",
      "keywords": [
        "get_channels",
        "list channels",
        "channel status",
        "multi-chain query",
        "payment channel",
        "state channel",
        "pagination",
        "wallet lookup",
        "adjudicator",
        "channel capacity",
        "blockchain indexing",
        "getchannels",
        "channel history"
      ],
      "function_name": "get_channels",
      "intent": "api_reference",
      "use_cases": [
        "Display user's open channels",
        "Check channel status before operations",
        "Monitor multi-chain channel distribution",
        "Audit channel version and nonce history"
      ],
      "function_names": [
        "created_at",
        "updated_at",
        "chain_id",
        "get_channels",
        "channel_id"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## get_app_sessionsâ€‹\n\n\n### Nameâ€‹\n\n`get_app_sessions`\n\n### Usageâ€‹\n\nLists all app sessions for a participant, sorted by creation date (newest first by default). Optionally filter by status (open/closed). Returns complete session information including participants, voting weights, quorum, protocol version, and current state. Supports pagination for large result sets.\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Allowed Values| Example  \n---|---|---|---|---|---|---  \n`participant`| string (address)| No| Filter by participant wallet address| (empty = all sessions)| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`|   \n`status`| string| No| Filter by status| -| `\"open\"`|   \n`offset`| number| No| Pagination offset| 0| -| `42`  \n`limit`| number| No| Number of sessions to return| 10 (max 100)| -| `10`  \n`sort`| string| No| Sort order by created_at| \"desc\"| `\"desc\"`|   \n  \n**Allowed status values** : `\"open\"` | `\"closed\"`\n\n### Responseâ€‹\n\nParameter| Type| Description| See Also  \n---|---|---|---  \n`app_sessions`| array<AppSessionInfo>| List of app sessions| See structure below  \n  \n#### AppSessionInfoâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`app_session_id`| string| Unique identifier| `\"0x9876543210fedcba...\"`  \n`application`| string| Application identifier| `\"NitroliteChess\"`  \n`status`| string| Current status| `\"open\"` | `\"closed\"`  \n`participants`| array<address>| All participant wallet addresses| `[\"0x742d35Cc...\", \"0x8B3192f2...\"]`  \n`weights`| array<int64>| Voting weights per participant| `[50, 50, 100]`  \n`quorum`| uint64| Required weight for state updates| `100`  \n`protocol`| string| Protocol version| `\"NitroRPC/0.4\"`  \n`challenge`| uint64| Challenge period in seconds| `86400`  \n`version`| number| Current state version| `5`  \n`nonce`| uint64| Unique session identifier| `1699123456789`  \n`session_data`| string| Current application state| `\"{\\\"gameType\\\":\\\"chess\\\",\\\"turn\\\":\\\"white\\\"}\"`  \n`created_at`| string (timestamp)| Creation timestamp| `\"2023-05-01T12:00:00Z\"`  \n`updated_at`| string (timestamp)| Last update timestamp| `\"2023-05-01T14:30:00Z\"`  \n  \n**Use Cases** :\n\n  * Display user's active games or escrows\n  * Monitor session history\n  * Paginate through large session lists\n\nPagination Best Practice\n\nWhen dealing with users who have many app sessions, use pagination with reasonable `limit` values (10-50) to improve performance and user experience.\n\n* * *\n\nSummary: Provides a paginated query interface to retrieve detailed metadata and current state for application sessions associated with specific participants or statuses.\n\nRelated terms: get_app_sessions, list sessions, session history, query state, participant lookup, channel status, pagination, voting weights, quorum, state version, app_session_id, session_data, crypto payments, multi-party state\n\nUse cases: Retrieving active payment channels for a specific user wallet, Auditing historical session states for dispute resolution, Building a dashboard to monitor multi-party application progress, Synchronizing local application state with the network's current session data",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a paginated query interface to retrieve detailed metadata and current state for application sessions associated with specific participants or statuses.",
      "keywords": [
        "get_app_sessions",
        "list sessions",
        "session history",
        "query state",
        "participant lookup",
        "channel status",
        "pagination",
        "voting weights",
        "quorum",
        "state version",
        "app_session_id",
        "session_data",
        "crypto payments",
        "multi-party state"
      ],
      "function_name": "get_app_sessions",
      "intent": "api_reference",
      "use_cases": [
        "Retrieving active payment channels for a specific user wallet",
        "Auditing historical session states for dispute resolution",
        "Building a dashboard to monitor multi-party application progress",
        "Synchronizing local application state with the network's current session data"
      ],
      "function_names": [
        "session_data",
        "app_session_id",
        "app_sessions",
        "updated_at",
        "get_app_sessions"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## get_ledger_balancesâ€‹\n\n\n### Nameâ€‹\n\n`get_ledger_balances`\n\n### Usageâ€‹\n\nRetrieves the ledger balances for an account. If no parameters are provided, returns the authenticated user's unified balance across all assets. Can also query balance within a specific app session by providing the app_session_id. Returns all tracked assets (including those that currently evaluate to zero).\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Format| Example  \n---|---|---|---|---|---  \n`account_id`| string| No| Account or app session identifier| 0x-prefixed hex string or wallet address| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`  \n  \nApp Session Balances\n\nTo query balance within a specific app session, provide the `app_session_id` as the `account_id`.\n\n### Responseâ€‹\n\nParameter| Type| Description| Example  \n---|---|---|---  \n`ledger_balances`| array<Balance>| Balance per asset| See structure below  \n  \n#### Balance Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`asset`| string| Asset identifier| `\"usdc\"`  \n`amount`| string| Balance in human-readable format| `\"100.0\"`  \n  \n**Use Cases** :\n\n  * Display user's current balances\n  * Check available funds before operations\n  * Monitor balance changes in real-time\n\n* * *\n\nSummary: Provides a mechanism to retrieve unified or session-specific asset balances for an account, enabling real-time monitoring of available funds and liquidity across the network.\n\nRelated terms: get_ledger_balances, check balance, wallet balance, asset tracking, account funds, session balance, ledger query, crypto balance, account_id, ledger_balances, getLedgerBalances, balance inquiry, available liquidity, asset holdings\n\nUse cases: displaying user wallet balances, pre-transaction fund verification, monitoring session-specific liquidity",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a mechanism to retrieve unified or session-specific asset balances for an account, enabling real-time monitoring of available funds and liquidity across the network.",
      "keywords": [
        "get_ledger_balances",
        "check balance",
        "wallet balance",
        "asset tracking",
        "account funds",
        "session balance",
        "ledger query",
        "crypto balance",
        "account_id",
        "ledger_balances",
        "getLedgerBalances",
        "balance inquiry",
        "available liquidity",
        "asset holdings"
      ],
      "function_name": "get_ledger_balances",
      "intent": "api_reference",
      "use_cases": [
        "displaying user wallet balances",
        "pre-transaction fund verification",
        "monitoring session-specific liquidity"
      ],
      "function_names": [
        "account_id",
        "ledger_balances",
        "app_session_id",
        "get_ledger_balances"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## get_ledger_entriesâ€‹\n\n\n### Nameâ€‹\n\n`get_ledger_entries`\n\n### Usageâ€‹\n\nRetrieves detailed ledger entries for an account, providing a complete audit trail of all debits and credits. Each entry represents one side of a double-entry bookkeeping transaction. Used for detailed financial reconciliation and accounting. Supports filtering by account, asset, and pagination. Sorted by creation date (newest first by default).\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Allowed Values| Example  \n---|---|---|---|---|---|---  \n`account_id`| string| No| Filter by account identifier| -| -| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`  \n`wallet`| string (address)| No| Filter by wallet address| -| -| `\"0x742d35Cc...\"`  \n`asset`| string| No| Filter by asset| -| -| `\"usdc\"`  \n`offset`| number| No| Pagination offset| 0| -| -  \n`limit`| number| No| Number of entries to return| 10 (max 100)| -| -  \n`sort`| string| No| Sort order by created_at| \"desc\"| \"asc\" | \"desc\"| -  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Structure| Example  \n---|---|---|---|---  \n`ledger_entries`| array<LedgerEntry>| List of ledger entries| See structure below|   \n  \n#### LedgerEntry Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`id`| number| Unique entry identifier| `123`  \n`account_id`| string| Account this entry belongs to| `\"0x742d35Cc...\"`  \n`account_type`| number| Ledger account classification (`1000`=asset, `2000`=liability, etc.)| `1000`  \n`asset`| string| Asset symbol| `\"usdc\"`  \n`participant`| string| Participant wallet address| `\"0x742d35Cc...\"`  \n`credit`| string| Credit amount (incoming funds, \"0.0\" if debit)| `\"100.0\"`  \n`debit`| string| Debit amount (outgoing funds, \"0.0\" if credit)| `\"25.0\"`  \n`created_at`| string| Entry creation timestamp (ISO 8601)| `\"2023-05-01T12:00:00Z\"`  \n  \nAccount types follow the brokerâ€™s GAAP-style codes: `1000` series for assets, `2000` liabilities, `3000` equity, `4000` revenue, and `5000` expenses.\n\n### Double-Entry Bookkeepingâ€‹\n\nEvery transaction creates two entries:\n    \n    \n    Transfer: Alice sends 50 USDC to Bob  \n      \n    Entry 1 (Alice's ledger):  \n      account_id: Alice's address  \n      asset: usdc  \n      credit: 0.0  \n      debit: 50.0  \n        \n    Entry 2 (Bob's ledger):  \n      account_id: Bob's address  \n      asset: usdc  \n      credit: 50.0  \n      debit: 0.0  \n    \n\nAccounting Principle\n\nThe double-entry system ensures that the total of all debits always equals the total of all credits, providing mathematical proof of accounting accuracy. This is the same principle used by traditional financial institutions.\n\n**Use Cases** :\n\n  * Detailed financial reconciliation\n  * Audit trail generation\n  * Accounting system integration\n  * Verify balance calculations\n\n* * *\n\nSummary: Provides a detailed audit trail of debits and credits for specific accounts or assets, supporting double-entry bookkeeping reconciliation and GAAP-compliant financial reporting.\n\nRelated terms: get_ledger_entries, ledger entries, audit trail, double-entry bookkeeping, financial reconciliation, debit, credit, GAAP, account history, transaction log, asset tracking, accounting, ledgering, reconsiliation\n\nUse cases: financial reconciliation and auditing, generating user account statements, tracking asset movements for compliance, debugging transaction history",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a detailed audit trail of debits and credits for specific accounts or assets, supporting double-entry bookkeeping reconciliation and GAAP-compliant financial reporting.",
      "keywords": [
        "get_ledger_entries",
        "ledger entries",
        "audit trail",
        "double-entry bookkeeping",
        "financial reconciliation",
        "debit",
        "credit",
        "GAAP",
        "account history",
        "transaction log",
        "asset tracking",
        "accounting",
        "ledgering",
        "reconsiliation"
      ],
      "function_name": "get_ledger_entries",
      "intent": "api_reference",
      "use_cases": [
        "financial reconciliation and auditing",
        "generating user account statements",
        "tracking asset movements for compliance",
        "debugging transaction history"
      ],
      "function_names": [
        "get_ledger_entries",
        "ledger_entries",
        "created_at",
        "account_id",
        "account_type"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## get_ledger_transactionsâ€‹\n\n\n### Nameâ€‹\n\n`get_ledger_transactions`\n\n### Usageâ€‹\n\nRetrieves user-facing transaction history showing transfers, deposits, withdrawals, and app session operations. Unlike ledger entries (which show accounting details), this provides a simplified view of financial activity with sender, receiver, amount, and transaction type. Supports filtering by asset and transaction type. Sorted by creation date (newest first by default).\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Allowed Values| Example  \n---|---|---|---|---|---|---  \n`account_id`| string| No| Filter by account identifier| -| -| `\"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\"`  \n`asset`| string| No| Filter by asset| -| -| `\"usdc\"`  \n`tx_type`| string| No| Filter by transaction type| -| \"transfer\" | \"deposit\" | \"withdrawal\" | \"app_deposit\" | \"app_withdrawal\" | \"escrow_lock\" | \"escrow_unlock\"| `\"transfer\"`  \n`offset`| number| No| Pagination offset| 0| -| -  \n`limit`| number| No| Number of transactions to return| 10 (max 100)| -| -  \n`sort`| string| No| Sort order by created_at| \"desc\"| \"asc\" | \"desc\"| -  \n  \n### Responseâ€‹\n\nParameter| Type| Description| Example  \n---|---|---|---  \n`ledger_transactions`| array<LedgerTransaction>| List of transactions| See structure below  \n  \n#### LedgerTransaction Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`id`| number| Unique transaction identifier| `1`  \n`tx_type`| string| Transaction type| `\"transfer\"`  \n`from_account`| string| Sender account identifier (wallet, channel, or app session)| `\"0x742d35Cc...\"`  \n`from_account_tag`| string| Sender's user tag (empty if none)| `\"NQKO7C\"`  \n`to_account`| string| Receiver account identifier (wallet, channel, or app session)| `\"0x8B3192f2...\"`  \n`to_account_tag`| string| Receiver's user tag (empty if none)| `\"UX123D\"`  \n`asset`| string| Asset symbol| `\"usdc\"`  \n`amount`| string| Transaction amount| `\"50.0\"`  \n`created_at`| string| Transaction timestamp (ISO 8601)| `\"2023-05-01T12:00:00Z\"`  \n  \n`from_account` and `to_account` mirror the brokerâ€™s internal `AccountID` values, so they can reference wallets, app session escrow accounts, or channel escrows.\n\n### Transaction Typesâ€‹\n\nType| Description| Direction  \n---|---|---  \n**transfer**|  Direct transfer between unified balances| Off-chain â†” Off-chain  \n**deposit**|  Funds deposited from channel to unified balance| On-chain â†’ Off-chain  \n**withdrawal**|  Funds withdrawn from unified balance to channel| Off-chain â†’ On-chain  \n**app_deposit**|  Funds moved from unified balance into app session| Unified â†’ App Session  \n**app_withdrawal**|  Funds released from app session to unified balance| App Session â†’ Unified  \n**escrow_lock**|  Funds temporarily locked for blockchain operations| Unified â†’ Escrow  \n**escrow_unlock**|  Funds released from escrow after blockchain confirmation| Escrow â†’ Unified  \n  \n**Use Cases** :\n\n  * Display transaction history in UI\n  * Export transaction records\n  * Monitor specific transaction types\n  * Track payment flows\n\n* * *\n\nSummary: Provides a high-level, user-facing transaction history that simplifies complex ledger accounting into readable records of transfers, deposits, and app session operations.\n\nRelated terms: transaction history, payment history, activity log, ledger query, audit trail, financial reporting, asset tracking, get_ledger_transactions, pagination, filtering, escrow history, deposit records, withdrawal tracking, transcation history\n\nUse cases: Displaying a simplified transaction history in a user dashboard, Auditing escrow locks and unlocks for specific assets, Generating paginated financial reports for app session deposits and withdrawals",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a high-level, user-facing transaction history that simplifies complex ledger accounting into readable records of transfers, deposits, and app session operations.",
      "keywords": [
        "transaction history",
        "payment history",
        "activity log",
        "ledger query",
        "audit trail",
        "financial reporting",
        "asset tracking",
        "get_ledger_transactions",
        "pagination",
        "filtering",
        "escrow history",
        "deposit records",
        "withdrawal tracking",
        "transcation history"
      ],
      "function_name": "get_ledger_transactions",
      "intent": "api_reference",
      "use_cases": [
        "Displaying a simplified transaction history in a user dashboard",
        "Auditing escrow locks and unlocks for specific assets",
        "Generating paginated financial reports for app session deposits and withdrawals"
      ],
      "function_names": [
        "from_account",
        "escrow_lock",
        "from_account_tag",
        "app_deposit",
        "to_account_tag"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## get_rpc_historyâ€‹\n\n\n### Nameâ€‹\n\n`get_rpc_history`\n\n### Usageâ€‹\n\nReturns the authenticated user's recent RPC invocations, including signed request and response payloads. Useful for audit trails and debugging client integrations.\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example  \n---|---|---|---|---|---  \n`offset`| number| No| Pagination offset| `0`| `20`  \n`limit`| number| No| Maximum entries to return| `10` (max 100)| `25`  \n`sort`| string| No| Sort order by timestamp| `\"desc\"`| `\"asc\"`  \n  \n### Responseâ€‹\n\nParameter| Type| Description| See Also  \n---|---|---|---  \n`rpc_entries`| array<RPCEntry>| Recorded invocations| See structure below  \n  \n#### RPCEntry Structureâ€‹\n\nField| Type| Description  \n---|---|---  \n`id`| number| Internal history identifier  \n`sender`| string| Wallet that issued the call  \n`req_id`| number| Request sequence number  \n`method`| string| RPC method name  \n`params`| string| JSON-encoded request parameters  \n`timestamp`| number| Unix timestamp (seconds)  \n`req_sig`| array<Signature>| Signatures attached to the request  \n`response`| string| JSON-encoded response payload  \n`res_sig`| array<Signature>| Response signatures  \n  \n**Use Cases** :\n\n  * Debug client/server mismatches\n  * Provide user-facing audit logs\n  * Verify signed payloads during dispute resolution\n\n* * *\n\nSummary: Provides a paginated history of authenticated RPC invocations, including signed request and response payloads, for auditing and debugging purposes.\n\nRelated terms: get_rpc_history, audit trail, call logs, request history, signed payloads, debugging, dispute resolution, RPC invocation, signature verification, transaction logs, getRPCHistory, api logs, payload verification\n\nUse cases: debugging client-server communication mismatches, providing user-facing audit logs, verifying signed payloads during dispute resolution",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a paginated history of authenticated RPC invocations, including signed request and response payloads, for auditing and debugging purposes.",
      "keywords": [
        "get_rpc_history",
        "audit trail",
        "call logs",
        "request history",
        "signed payloads",
        "debugging",
        "dispute resolution",
        "RPC invocation",
        "signature verification",
        "transaction logs",
        "getRPCHistory",
        "api logs",
        "payload verification"
      ],
      "function_name": "get_rpc_history",
      "intent": "api_reference",
      "use_cases": [
        "debugging client-server communication mismatches",
        "providing user-facing audit logs",
        "verifying signed payloads during dispute resolution"
      ],
      "function_names": [
        "req_sig",
        "res_sig",
        "get_rpc_history",
        "rpc_entries",
        "req_id"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## get_user_tagâ€‹\n\n\n### Nameâ€‹\n\n`get_user_tag`\n\n### Usageâ€‹\n\nRetrieves the authenticated user's unique alphanumeric tag. User tags provide a human-readable alternative to addresses for [transfer](/docs/protocol/off-chain/transfers) operations, similar to username systems. Tags are automatically generated upon first interaction with a clearnode and remain constant. This is a convenience feature for improving user experience.\n\n### Requestâ€‹\n\nNo parameters.\n\n### Responseâ€‹\n\nParameter| Type| Description| Format| Example| Notes  \n---|---|---|---|---|---  \n`tag`| string| User's unique alphanumeric tag| 6 uppercase alphanumeric characters| `\"UX123D\"`| Can be used in transfer operations as destination_user_tag  \n  \n### Usage in Transfersâ€‹\n\nInstead of using full address:\n    \n    \n    transfer({destination: \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\", ...})  \n    \n\nUsers can use the tag:\n    \n    \n    transfer({destination_user_tag: \"UX123D\", ...})  \n    \n\nHuman-Readable Addresses\n\nUser tags make it easier for users to share their \"address\" verbally or in non-technical contexts, similar to payment apps like Venmo or Cash App usernames.\n\n* * *\n\nSummary: Retrieves a persistent, human-readable alphanumeric alias for an authenticated user's blockchain address to simplify off-chain transfer operations and improve user experience.\n\nRelated terms: get_user_tag, username, alias, human-readable address, user identifier, off-chain transfer, destination_user_tag, clearnode, account tag, payment handle, user tag, address mapping, get_tag\n\nUse cases: simplifying peer-to-peer transfers, sharing payment identifiers verbally, improving user experience in wallet interfaces",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Retrieves a persistent, human-readable alphanumeric alias for an authenticated user's blockchain address to simplify off-chain transfer operations and improve user experience.",
      "keywords": [
        "get_user_tag",
        "username",
        "alias",
        "human-readable address",
        "user identifier",
        "off-chain transfer",
        "destination_user_tag",
        "clearnode",
        "account tag",
        "payment handle",
        "user tag",
        "address mapping",
        "get_tag"
      ],
      "function_name": "get_user_tag",
      "intent": "api_reference",
      "use_cases": [
        "simplifying peer-to-peer transfers",
        "sharing payment identifiers verbally",
        "improving user experience in wallet interfaces"
      ],
      "function_names": [
        "destination_user_tag",
        "get_user_tag"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## get_session_keysâ€‹\n\n\n### Nameâ€‹\n\n`get_session_keys`\n\n### Usageâ€‹\n\nRetrieves all active (non-expired) session keys for the authenticated user. Shows each session key's address, application name, spending allowances, current usage, expiration, and permissions. Used for managing delegated keys and monitoring spending caps. Only returns session keys (not custody signers).\n\n### Authenticationâ€‹\n\nRequired (private method)\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Default| Example  \n---|---|---|---|---|---  \n`offset`| number| No| Pagination offset| `0`| `20`  \n`limit`| number| No| Results per page| `10` (max 100)| `25`  \n`sort`| string| No| Sort order by created_at| `\"desc\"`| `\"asc\"`  \n  \n### Responseâ€‹\n\nParameter| Type| Description| See Also  \n---|---|---|---  \n`session_keys`| array<SessionKeyInfo>| List of active session keys| See structure below  \n  \n#### SessionKeyInfo Structureâ€‹\n\nField| Type| Description| Default| Notes  \n---|---|---|---|---  \n`id`| number| Internal identifier| â€”| â€”  \n`session_key`| string (address)| Session key address| â€”| â€”  \n`application`| string| Application name for this session| `\"clearnode\"`| â€”  \n`allowances`| array<AllowanceUsage>| Spending limits and usage| â€”| See structure below  \n`scope`| string| Permission scope| â€”| Future feature, not fully enforced yet  \n`expires_at`| string (timestamp)| Session expiration time (ISO 8601 format)| â€”| â€”  \n`created_at`| string (timestamp)| Session creation time (ISO 8601 format)| â€”| â€”  \n  \n**Example** :\n    \n    \n    {  \n      \"id\": 1,  \n      \"session_key\": \"0x9876543210fedcba...\",  \n      \"application\": \"Chess Game\",  \n      \"allowances\": [  \n        {\"asset\": \"usdc\", \"allowance\": \"100.0\", \"used\": \"45.0\"}  \n      ],  \n      \"scope\": \"app.create,transfer\",  \n      \"expires_at\": \"2023-05-02T12:00:00Z\",  \n      \"created_at\": \"2023-05-01T12:00:00Z\"  \n    }  \n    \n\n#### AllowanceUsageâ€‹\n\nField| Type| Description  \n---|---|---  \n`asset`| string| Asset identifier (e.g., `\"usdc\"`)  \n`allowance`| string| Total spending limit  \n`used`| string| Amount already spent  \n  \n### Spending Trackingâ€‹\n\nThe clearnode tracks session key spending by monitoring all ledger debit operations:\n    \n    \n    Initial: allowance = 100 USDC, used = 0 USDC  \n    After transfer of 45 USDC: allowance = 100 USDC, used = 45 USDC  \n    Remaining = 55 USDC available for future operations  \n    \n\nWhen a session key reaches its spending cap, further operations are rejected:\n    \n    \n    Error: \"operation denied: insufficient session key allowance: 60 required, 55 available\"  \n    \n\nSpending Caps\n\nSession key allowances provide important security: even if a session key is compromised, the maximum loss is limited to the allowance amount.\n\n**Use Cases** :\n\n  * Display active sessions in UI\n  * Monitor spending against caps\n  * Manage session lifecycles\n  * Security auditing\n\n* * *\n\nSummary: This method retrieves a list of active, non-expired session keys for an authenticated user, providing detailed metadata on spending allowances, permissions, and expiration. It enables system architects to implement session management and monitor delegated signing keys and their associated spending caps.\n\nRelated terms: get_session_keys, session management, delegated keys, spending limits, allowances, active sessions, api keys, permissions, authentication, monitoring, getsessionkeys, spending caps, session security\n\nUse cases: monitoring delegated key spending limits, auditing active application sessions, managing session expiration for automated agents",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This method retrieves a list of active, non-expired session keys for an authenticated user, providing detailed metadata on spending allowances, permissions, and expiration. It enables system architects to implement session management and monitor delegated signing keys and their associated spending caps.",
      "keywords": [
        "get_session_keys",
        "session management",
        "delegated keys",
        "spending limits",
        "allowances",
        "active sessions",
        "api keys",
        "permissions",
        "authentication",
        "monitoring",
        "getsessionkeys",
        "spending caps",
        "session security"
      ],
      "function_name": "get_session_keys",
      "intent": "api_reference",
      "use_cases": [
        "monitoring delegated key spending limits",
        "auditing active application sessions",
        "managing session expiration for automated agents"
      ],
      "function_names": [
        "get_session_keys",
        "session_keys",
        "expires_at",
        "created_at",
        "session_key"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## pingâ€‹\n\n\n### Nameâ€‹\n\n`ping`\n\n### Usageâ€‹\n\nSimple connectivity check to verify the clearnode is responsive and the RPC connection is alive. Returns immediately with success. Used for heartbeat, connection testing, and latency measurement.\n\n### Authenticationâ€‹\n\nNot required (public method)\n\n### Requestâ€‹\n\nNo parameters required (empty object `{}`).\n\n### Responseâ€‹\n\nThe response method should be `\"pong\"`.\n\nParameter| Type| Description| Value/Example| Notes  \n---|---|---|---|---  \n(empty)| object| Empty object or confirmation data| `{}`| Response indicates successful connection  \n  \n### Use Casesâ€‹\n\n**Heartbeat** : Periodic ping to keep RPC connection alive\n    \n    \n    setInterval(() => clearnode.call(\"ping\"), 30000)  // Every 30 seconds  \n    \n\n**Latency Measurement** : Measure round-trip time\n    \n    \n    const start = Date.now()  \n    await clearnode.call(\"ping\")  \n    const latency = Date.now() - start  \n    console.log(`Latency: ${latency}ms`)  \n    \n\n**Health Check** : Verify connection before critical operations\n    \n    \n    try {  \n      await clearnode.call(\"ping\")  \n      // Connection healthy, proceed with operation  \n    } catch (error) {  \n      // Connection lost, reconnect  \n    }  \n    \n\n**Authentication Status** : Test if session is still valid\n    \n    \n    const response = await clearnode.call(\"ping\")  \n    // If no auth error, session is active  \n    \n\n* * *\n\nSummary: Provides a lightweight, unauthenticated RPC method to verify clearnode responsiveness and measure network latency.\n\nRelated terms: ping, pong, heartbeat, connectivity check, latency measurement, health check, RPC connection, clearnode, keep-alive, round-trip time, RTT, connection test, status check, network diagnostic\n\nUse cases: Periodic heartbeat to maintain RPC connection, Measuring network round-trip time (latency), Pre-operation health check for connection stability, Verifying session activity and authentication status",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a lightweight, unauthenticated RPC method to verify clearnode responsiveness and measure network latency.",
      "keywords": [
        "ping",
        "pong",
        "heartbeat",
        "connectivity check",
        "latency measurement",
        "health check",
        "RPC connection",
        "clearnode",
        "keep-alive",
        "round-trip time",
        "RTT",
        "connection test",
        "status check",
        "network diagnostic"
      ],
      "function_name": "ping",
      "intent": "api_reference",
      "use_cases": [
        "Periodic heartbeat to maintain RPC connection",
        "Measuring network round-trip time (latency)",
        "Pre-operation health check for connection stability",
        "Verifying session activity and authentication status"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Notifications (Server-to-Client)â€‹\n\n\nThe clearnode sends unsolicited notifications to clients via RPC when certain events occur. These are not responses to requests, but asynchronous messages initiated by the server.\n\nEventsClearnodeClientEvent SourceClearnodeClientEvent SourceClearnodeClientRPC Connection EstablishedTransfer (incoming/outgoing)tr (transfer) notificationBalance changedbu (balance update) notificationChannel openedcu (channel update) notificationApp session updatedasu (app session update) notification\n\n### Notification Typesâ€‹\n\nMethod| Description| Data Structure  \n---|---|---  \n`bu`| Balance update| `balance_updates` array with updated balances  \n`cu`| Channel update| Full `Channel` object  \n`tr`| Transfer (incoming/outgoing)| `transactions` array with transfer details  \n`asu`| App session update| `app_session` object and `participant_allocations`  \n  \n* * *\n\nSummary: This component defines the asynchronous server-to-client notification system used by the Clearnode to push real-time updates regarding balance changes, channel states, transfers, and application sessions. It enables reactive client-side architectures by providing event-driven state synchronization via RPC.\n\nRelated terms: notifications, server-to-client, RPC, asynchronous, balance update, channel update, transfer, app session, real-time events, clearnode, state synchronization, push messages, event-driven, pub-sub, message bus\n\nUse cases: Real-time balance tracking in a wallet UI, Monitoring state changes in a multi-party payment channel, Automated reaction to incoming fund transfers, Synchronizing application state across distributed participants",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the asynchronous server-to-client notification system used by the Clearnode to push real-time updates regarding balance changes, channel states, transfers, and application sessions. It enables reactive client-side architectures by providing event-driven state synchronization via RPC.",
      "keywords": [
        "notifications",
        "server-to-client",
        "RPC",
        "asynchronous",
        "balance update",
        "channel update",
        "transfer",
        "app session",
        "real-time events",
        "clearnode",
        "state synchronization",
        "push messages",
        "event-driven",
        "pub-sub",
        "message bus"
      ],
      "function_name": "app_session",
      "intent": "api_reference",
      "use_cases": [
        "Real-time balance tracking in a wallet UI",
        "Monitoring state changes in a multi-party payment channel",
        "Automated reaction to incoming fund transfers",
        "Synchronizing application state across distributed participants"
      ],
      "function_names": [
        "participant_allocations",
        "app_session",
        "balance_updates"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## bu (Balance Update)â€‹\n\n\n### Methodâ€‹\n\n`bu`\n\n### When Sentâ€‹\n\nWhenever account balances change due to transfers, app session operations, or channel operations.\n\n### Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`balance_updates`| array<LedgerBalance>| Updated balances for affected accounts| See structure below  \n  \n#### LedgerBalance Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`asset`| string| Asset symbol| `\"usdc\"`  \n`amount`| string| New balance amount| `\"150.0\"`  \n  \n**Use Cases** :\n\n  * Update balance display in real-time\n  * Trigger UI animations for balance changes\n  * Log balance history for analytics\n\n* * *\n\nSummary: This component provides real-time notifications for account balance changes across assets, triggered by transfers, app sessions, or channel operations.\n\nRelated terms: balance update, bu, ledger balance, real-time notification, asset tracking, account balance, crypto wallet, transaction update, state change, balance_updates, ledger state, payment notification, balance sync\n\nUse cases: real-time balance tracking, transaction history logging, UI state synchronization",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component provides real-time notifications for account balance changes across assets, triggered by transfers, app sessions, or channel operations.",
      "keywords": [
        "balance update",
        "bu",
        "ledger balance",
        "real-time notification",
        "asset tracking",
        "account balance",
        "crypto wallet",
        "transaction update",
        "state change",
        "balance_updates",
        "ledger state",
        "payment notification",
        "balance sync"
      ],
      "function_name": "bu",
      "intent": "api_reference",
      "use_cases": [
        "real-time balance tracking",
        "transaction history logging",
        "UI state synchronization"
      ],
      "function_names": [
        "balance_updates"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## cu (Channel Update)â€‹\n\n\n### Methodâ€‹\n\n`cu`\n\n### When Sentâ€‹\n\nWhen a channel's state changes (opened, resized, challenged, closed).\n\n### Structureâ€‹\n\nThe notification contains the complete updated `Channel` object. See Channel Structure in the `get_channels` section for the full field list.\n\n**Use Cases** :\n\n  * Update channel status in UI\n  * Alert user when channel becomes active\n  * Monitor for unexpected channel closures\n\n* * *\n\nSummary: Provides real-time notifications for payment channel state transitions, enabling systems to synchronize local state with protocol-level changes such as opening, resizing, or closing.\n\nRelated terms: channel update, state change, cu, notification, payment channel, channel status, channel lifecycle, state update, channel monitoring, channel event, channel closed, channel opened, channel resized, yellow network\n\nUse cases: real-time UI status updates, monitoring channel lifecycle events, detecting unexpected channel closures, automated response to channel challenges",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides real-time notifications for payment channel state transitions, enabling systems to synchronize local state with protocol-level changes such as opening, resizing, or closing.",
      "keywords": [
        "channel update",
        "state change",
        "cu",
        "notification",
        "payment channel",
        "channel status",
        "channel lifecycle",
        "state update",
        "channel monitoring",
        "channel event",
        "channel closed",
        "channel opened",
        "channel resized",
        "yellow network"
      ],
      "function_name": "cu",
      "intent": "api_reference",
      "use_cases": [
        "real-time UI status updates",
        "monitoring channel lifecycle events",
        "detecting unexpected channel closures",
        "automated response to channel challenges"
      ],
      "function_names": [
        "get_channels"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## tr (Transfer)â€‹\n\n\n### Methodâ€‹\n\n`tr`\n\n### When Sentâ€‹\n\nWhen a transfer affects the user's account (both incoming and outgoing transfers).\n\n### Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`transactions`| array<LedgerTransaction>| Array of transaction objects for the transfer| See structure below  \n  \nThe `LedgerTransaction` structure is identical to the one returned by `get_ledger_transactions`. See LedgerTransaction Structure for the full field list.\n\n**Use Cases** :\n\n  * Display incoming/outgoing payment notifications\n  * Play sound/show toast for transfers\n  * Update transaction history in real-time\n\nReal-Time Payments\n\nCombine `tr` notifications with `bu` (balance update) to provide immediate feedback when users send or receive funds.\n\n* * *\n\nSummary: Provides real-time notifications for incoming and outgoing ledger transfers, allowing systems to synchronize transaction history and trigger user alerts immediately.\n\nRelated terms: transfer, payment notification, incoming funds, outgoing funds, ledger transaction, real-time updates, transaction history, tr method, crypto transfer, balance change, event listener, transaction alert, ledger update, money transfer\n\nUse cases: real-time payment notifications, transaction history synchronization, UI alerts for fund transfers",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides real-time notifications for incoming and outgoing ledger transfers, allowing systems to synchronize transaction history and trigger user alerts immediately.",
      "keywords": [
        "transfer",
        "payment notification",
        "incoming funds",
        "outgoing funds",
        "ledger transaction",
        "real-time updates",
        "transaction history",
        "tr method",
        "crypto transfer",
        "balance change",
        "event listener",
        "transaction alert",
        "ledger update",
        "money transfer"
      ],
      "function_name": "tr",
      "intent": "api_reference",
      "use_cases": [
        "real-time payment notifications",
        "transaction history synchronization",
        "UI alerts for fund transfers"
      ],
      "function_names": [
        "get_ledger_transactions"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## asu (App Session Update)â€‹\n\n\n### Methodâ€‹\n\n`asu`\n\n### When Sentâ€‹\n\nWhen an app session state changes (new state submitted, session closed, deposits/withdrawals).\n\n### Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`app_session`| AppSession| Complete app session object| See `get_app_sessions` for structure  \n`participant_allocations`| array<AppAllocation>| Current allocations for each participant| See structure below  \n  \n#### AppAllocation Structureâ€‹\n\nField| Type| Description| Example  \n---|---|---|---  \n`participant`| string| Participant wallet address| `\"0x742d35Cc...\"`  \n`asset`| string| Asset symbol| `\"usdc\"`  \n`amount`| string| Allocated amount| `\"50.0\"`  \n  \n**Use Cases** :\n\n  * Update game UI when opponent makes a move\n  * Refresh session state in real-time\n  * Alert when session is closed\n  * Sync multi-participant applications\n\n* * *\n\nSummary: Provides real-time notifications and state synchronization for application sessions, ensuring all participants receive updates on state changes, deposits, withdrawals, or session closures.\n\nRelated terms: asu, App Session Update, real-time notification, state synchronization, session state, participant allocations, wallet balance update, event listener, multi-party sync, app_session, asset allocation, session closure, state change, push update\n\nUse cases: Updating game UI during turn-based play, Real-time balance tracking for multi-participant sessions, Automated alerts for session termination or closure, Synchronizing state across distributed application instances",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides real-time notifications and state synchronization for application sessions, ensuring all participants receive updates on state changes, deposits, withdrawals, or session closures.",
      "keywords": [
        "asu",
        "App Session Update",
        "real-time notification",
        "state synchronization",
        "session state",
        "participant allocations",
        "wallet balance update",
        "event listener",
        "multi-party sync",
        "app_session",
        "asset allocation",
        "session closure",
        "state change",
        "push update"
      ],
      "function_name": "asu",
      "intent": "api_reference",
      "use_cases": [
        "Updating game UI during turn-based play",
        "Real-time balance tracking for multi-participant sessions",
        "Automated alerts for session termination or closure",
        "Synchronizing state across distributed application instances"
      ],
      "function_names": [
        "app_session",
        "get_app_sessions",
        "participant_allocations"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Implementation Notesâ€‹\n\n\n**Connection Management** :\n\n  * Maintain persistent connection for notifications\n  * Implement automatic reconnection on disconnect\n  * Re-fetch current state after reconnection\n\n**Notification Handling** :\n\n  * All notifications are asynchronous\n  * No response required from client\n  * Multiple notifications may arrive rapidly (batch if needed)\n\n**Best Practices** :\n\n  * Use query methods for initial state retrieval\n  * Use notifications for ongoing monitoring\n  * Don't rely solely on notifications (could be missed during disconnect)\n  * Implement periodic state refresh as backup\n\n**Pagination** :\n\n  * For methods with pagination, use reasonable `limit` values\n\n* * *\n\nSummary: Provides architectural guidelines for maintaining real-time state synchronization through persistent connections, asynchronous notification handling, and robust reconnection strategies.\n\nRelated terms: real-time updates, websocket, persistent connection, asynchronous notifications, state synchronization, reconnection logic, pagination, event handling, status monitoring, batching, network resilience, notifcation, async\n\nUse cases: Real-time balance monitoring, Handling network interruptions in payment channels, Synchronizing client state with blockchain events, Efficiently fetching large datasets via paginated queries",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides architectural guidelines for maintaining real-time state synchronization through persistent connections, asynchronous notification handling, and robust reconnection strategies.",
      "keywords": [
        "real-time updates",
        "websocket",
        "persistent connection",
        "asynchronous notifications",
        "state synchronization",
        "reconnection logic",
        "pagination",
        "event handling",
        "status monitoring",
        "batching",
        "network resilience",
        "notifcation",
        "async"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Real-time balance monitoring",
        "Handling network interruptions in payment channels",
        "Synchronizing client state with blockchain events",
        "Efficiently fetching large datasets via paginated queries"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nExplore other protocol features:\n\n  * **[App Sessions](/docs/protocol/off-chain/app-sessions)** \\- Create and manage multi-party applications\n  * **[Transfers](/docs/protocol/off-chain/transfers)** \\- Send funds between users\n  * **[Channel Methods](/docs/protocol/off-chain/channel-methods)** \\- Manage payment channels\n\nFor protocol fundamentals:\n\n  * **[Authentication](/docs/protocol/off-chain/authentication)** \\- Manage session keys\n  * **[Message Format](/docs/protocol/off-chain/message-format)** \\- Understand request/response structure\n\n\n\n[PreviousApp Session Methods](/docs/protocol/off-chain/app-sessions)[NextCross-Layer Communication Flows](/docs/protocol/communication-flows)\n\n  * Overview\n  * Query Methods Summary\n  * get_config\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_assets\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_app_definition\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_channels\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_app_sessions\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_ledger_balances\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_ledger_entries\n    * Name\n    * Usage\n    * Request\n    * Response\n    * Double-Entry Bookkeeping\n  * get_ledger_transactions\n    * Name\n    * Usage\n    * Request\n    * Response\n    * Transaction Types\n  * get_rpc_history\n    * Name\n    * Usage\n    * Request\n    * Response\n  * get_user_tag\n    * Name\n    * Usage\n    * Request\n    * Response\n    * Usage in Transfers\n  * get_session_keys\n    * Name\n    * Usage\n    * Authentication\n    * Request\n    * Response\n    * Spending Tracking\n  * ping\n    * Name\n    * Usage\n    * Authentication\n    * Request\n    * Response\n    * Use Cases\n  * Notifications (Server-to-Client)\n    * Notification Types\n  * bu (Balance Update)\n    * Method\n    * When Sent\n    * Structure\n  * cu (Channel Update)\n    * Method\n    * When Sent\n    * Structure\n  * tr (Transfer)\n    * Method\n    * When Sent\n    * Structure\n  * asu (App Session Update)\n    * Method\n    * When Sent\n    * Structure\n  * Implementation Notes\n  * Next Steps\n\nSummary: Provides a comprehensive suite of query methods and real-time notifications for monitoring protocol state, including ledger balances, channel updates, and session configurations.\n\nRelated terms: check balance, view history, status updates, query methods, notifications, ledger entries, RPC history, balance update, channel state, off-chain state, real-time events, double-entry bookkeeping, session keys, get_config, get_assets\n\nUse cases: Real-time balance and transaction monitoring, Auditing ledger entries and bookkeeping, Tracking payment channel state changes, Verifying session authentication and limits",
    "metadata": {
      "title": "Query Methods & Notifications | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/queries",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides a comprehensive suite of query methods and real-time notifications for monitoring protocol state, including ledger balances, channel updates, and session configurations.",
      "keywords": [
        "check balance",
        "view history",
        "status updates",
        "query methods",
        "notifications",
        "ledger entries",
        "RPC history",
        "balance update",
        "channel state",
        "off-chain state",
        "real-time events",
        "double-entry bookkeeping",
        "session keys",
        "get_config",
        "get_assets"
      ],
      "function_name": "get_config",
      "intent": "api_reference",
      "use_cases": [
        "Real-time balance and transaction monitoring",
        "Auditing ledger entries and bookkeeping",
        "Tracking payment channel state changes",
        "Verifying session authentication and limits"
      ],
      "function_names": [
        "get_app_definition",
        "get_config",
        "get_ledger_entries",
        "get_assets",
        "get_session_keys"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "* Off-Chain RPC Protocol\n  * Transfer Method\n\n\n\n# Transfer Method\n\nTransfer method enable instant, off-chain fund movement between users.\n\n* * *\n\nSummary: The Transfer Method facilitates immediate, off-chain asset movements between protocol participants, enabling high-speed value exchange without the latency of on-chain settlement.\n\nRelated terms: send money, transfer funds, instant payment, off-chain, RPC protocol, peer-to-peer, P2P, layer 2, asset movement, offchain, state update, ledger, micro-payments, xfer\n\nUse cases: high-frequency peer-to-peer trading, instant micro-payment processing, off-chain liquidity rebalancing",
    "metadata": {
      "title": "Transfer Method | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/transfers",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The Transfer Method facilitates immediate, off-chain asset movements between protocol participants, enabling high-speed value exchange without the latency of on-chain settlement.",
      "keywords": [
        "send money",
        "transfer funds",
        "instant payment",
        "off-chain",
        "RPC protocol",
        "peer-to-peer",
        "P2P",
        "layer 2",
        "asset movement",
        "offchain",
        "state update",
        "ledger",
        "micro-payments",
        "xfer"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency peer-to-peer trading",
        "instant micro-payment processing",
        "off-chain liquidity rebalancing"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Overviewâ€‹\n\n\nThe transfer system allows users to send funds to each other instantly using their unified balance, without any on-chain transactions. Transfers are backed by the security of underlying payment channels and use double-entry bookkeeping for accounting accuracy.\n\n### Why Use Transfer?â€‹\n\n**Instant Settlement** : Transfers complete immediately with instant finality.\n\n**No Blockchain Fees** : No blockchain transactions means no gas costs for both sender and recipient.\n\n**Cross-Chain Unified** : Send from your unified balance across multiple chains.\n\n**Auditable** : Complete transaction history with double-entry ledger tracking.\n\nInstant Off-Chain Payments\n\nTransfers provide the speed and convenience of traditional payment networks while maintaining the security guarantees of blockchain-backed channels.\n\n* * *\n\nSummary: The Transfer Method facilitates instant, off-chain peer-to-peer asset transfers using a unified balance system backed by payment channels and double-entry bookkeeping. It allows for gasless, cross-chain settlements with immediate finality and a complete audit trail.\n\nRelated terms: send money, instant payment, gasless transfer, off-chain, payment channel, double-entry bookkeeping, unified balance, cross-chain, P2P, settlement, ledger, offchain, gas-free, audit trail\n\nUse cases: Instant peer-to-peer payments, Gasless micro-transactions, Cross-chain asset movement, Auditable internal ledger transfers",
    "metadata": {
      "title": "Transfer Method | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/transfers",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The Transfer Method facilitates instant, off-chain peer-to-peer asset transfers using a unified balance system backed by payment channels and double-entry bookkeeping. It allows for gasless, cross-chain settlements with immediate finality and a complete audit trail.",
      "keywords": [
        "send money",
        "instant payment",
        "gasless transfer",
        "off-chain",
        "payment channel",
        "double-entry bookkeeping",
        "unified balance",
        "cross-chain",
        "P2P",
        "settlement",
        "ledger",
        "offchain",
        "gas-free",
        "audit trail"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Instant peer-to-peer payments",
        "Gasless micro-transactions",
        "Cross-chain asset movement",
        "Auditable internal ledger transfers"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## transferâ€‹\n\n\n### Nameâ€‹\n\n`transfer`\n\n### Usageâ€‹\n\nTransfer funds from the authenticated user's unified balance to another user's unified balance within the Yellow Network. This is a purely off-chain operation, which results in instant settlement. The transfer updates internal ledger entries using double-entry bookkeeping principles and creates a transaction record for both parties. The security guarantee comes from the underlying on-chain channels that back the unified balance.\n\n### When to Useâ€‹\n\nWhen sending funds to another Yellow Network user. Common use cases include peer-to-peer payments, merchant payments, tipping.\n\n### Prerequisitesâ€‹\n\n  * Sender must be [authenticated](/docs/protocol/off-chain/authentication)\n  * Sender must have sufficient available balance in unified account\n  * Recipient must be identified by valid wallet address or user tag\n\nRecipient Requirements\n\nThe recipient does not need to have an existing balance or account on the clearnode. Transfers can be sent to any valid wallet address, and the recipient's account will be created automatically on the first login if it doesn't exist.\n\n### Requestâ€‹\n\nParameter| Type| Required| Description| Format| Example| Notes  \n---|---|---|---|---|---|---  \n`destination`| string (wallet address)| Yes (if `destination_user_tag` not provided)| Recipient's wallet address| 0x-prefixed hex string (20 bytes)| `\"0x8B3192f2F7b1b34f2e4e7B8C9D1E0F2A3B4C5D6E\"`| -  \n`destination_user_tag`| string| Yes (if destination not provided)| Recipient's randomly generated user identifier| Alphanumeric string| `\"UX123D\"`| Alternative to address; internal feature, may change  \n`allocations`| TransferAllocation[]| Yes (minimum: 1)| Assets and amounts to transfer| Array of allocation objects| `[{\"asset\": \"usdc\", \"amount\": \"50.0\"}]`| See structure below  \n  \n#### TransferAllocation Structureâ€‹\n\nEach allocation in the `allocations` array specifies an asset and amount to transfer:\n\nField| Type| Required| Description| Format| Example  \n---|---|---|---|---|---  \n`asset`| string| Yes| Asset symbol identifier| Lowercase string| `\"usdc\"`, `\"eth\"`, `\"weth\"`, `\"btc\"`  \n`amount`| string| Yes| Amount to transfer in human-readable format| Decimal string| `\"50.0\"`, `\"0.01\"`  \n  \n**Notes** :\n\n  * Asset symbols must be lowercase\n  * Use `get_assets` method to see all supported assets\n  * Amounts are in human-readable format (e.g., \"50.0\" for 50 USDC)\n  * Clearnode handles conversion to smallest unit internally\n  * Multiple assets can be transferred in a single operation\n\n**Example** :\n    \n    \n    {  \n      \"allocations\": [  \n        {  \n          \"asset\": \"usdc\",  \n          \"amount\": \"50.0\"  \n        },  \n        {  \n          \"asset\": \"eth\",  \n          \"amount\": \"0.01\"  \n        }  \n      ]  \n    }  \n    \n\n### Responseâ€‹\n\nThe response contains an array of transactions, with one transaction for each asset being transferred:\n\nParameter| Type| Description| Example| Notes  \n---|---|---|---|---  \n`transactions`| LedgerTransaction[]| Array of transaction objects for each asset| See below| One transaction per asset transferred  \n  \n**LedgerTransaction Structure** (per transaction):\n\nField| Type| Description| Example  \n---|---|---|---  \n`id`| number| Numeric transaction identifier| `1`  \n`tx_type`| string| Transaction type| `\"transfer\"`  \n`from_account`| string| Sender account identifier (wallet/app session/channel)| `\"0x1234567890abcdef...\"`  \n`from_account_tag`| string| Sender's user tag (if exists)| `\"NQKO7C\"`  \n`to_account`| string| Recipient account identifier| `\"0x9876543210abcdef...\"`  \n`to_account_tag`| string| Recipient's user tag (if exists)| `\"UX123D\"`  \n`asset`| string| Asset symbol that was transferred| `\"usdc\"`  \n`amount`| string| Amount transferred for this asset (decimal string)| `\"50.0\"`  \n`created_at`| string| ISO 8601 timestamp| `\"2023-05-01T12:00:00Z\"`  \n  \n**Example Response** :\n    \n    \n    {  \n      \"transactions\": [  \n        {  \n          \"id\": 1,  \n          \"tx_type\": \"transfer\",  \n          \"from_account\": \"0x1234567890abcdef...\",  \n          \"from_account_tag\": \"NQKO7C\",  \n          \"to_account\": \"0x9876543210abcdef...\",  \n          \"to_account_tag\": \"UX123D\",  \n          \"asset\": \"usdc\",  \n          \"amount\": \"50.0\",  \n          \"created_at\": \"2023-05-01T12:00:00Z\"  \n        },  \n        {  \n          \"id\": 2,  \n          \"tx_type\": \"transfer\",  \n          \"from_account\": \"0x1234567890abcdef...\",  \n          \"from_account_tag\": \"NQKO7C\",  \n          \"to_account\": \"0x9876543210abcdef...\",  \n          \"to_account_tag\": \"UX123D\",  \n          \"asset\": \"eth\",  \n          \"amount\": \"0.1\",  \n          \"created_at\": \"2023-05-01T12:00:00Z\"  \n        }  \n      ]  \n    }  \n    \n\n* * *\n\nSummary: The transfer method enables instant, off-chain movement of funds between users' unified balances within the Yellow Network via internal ledger updates. It ensures secure settlement backed by on-chain channels, allowing for immediate transaction finality without direct blockchain latency.\n\nRelated terms: transfer, send funds, P2P payment, off-chain settlement, unified balance, ledger update, instant payment, internal transfer, wallet address, user tag, double-entry bookkeeping, clearnode, asset allocation, merchant payment, tipping\n\nUse cases: peer-to-peer payments, merchant payments, tipping, internal fund movement",
    "metadata": {
      "title": "Transfer Method | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/transfers",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The transfer method enables instant, off-chain movement of funds between users' unified balances within the Yellow Network via internal ledger updates. It ensures secure settlement backed by on-chain channels, allowing for immediate transaction finality without direct blockchain latency.",
      "keywords": [
        "transfer",
        "send funds",
        "P2P payment",
        "off-chain settlement",
        "unified balance",
        "ledger update",
        "instant payment",
        "internal transfer",
        "wallet address",
        "user tag",
        "double-entry bookkeeping",
        "clearnode",
        "asset allocation",
        "merchant payment",
        "tipping"
      ],
      "function_name": "transfer",
      "intent": "api_reference",
      "use_cases": [
        "peer-to-peer payments",
        "merchant payments",
        "tipping",
        "internal fund movement"
      ],
      "function_names": [
        "destination_user_tag",
        "get_assets",
        "from_account_tag",
        "tx_type",
        "to_account"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Off-Chain Processingâ€‹\n\n\nWhen a transfer is executed, the clearnode performs the following operations:\n\nClient BServiceClient AClient B (Recipient)ClearnodeClient A (Sender)Client B (Recipient)ClearnodeClient A (Sender)1\\. Send Transfer Request2\\. Validate3\\. Update Ledger4\\. Send Responses & Notifications5\\. Balance Updatedtransfer({ destination, allocations })Verify authenticationCheck available balanceValidate allocationsCreate debit entry (Alice -50 USDC)Create credit entry (Bob +50 USDC)Record transactionBalance +50 USDCtr (transfer) notificationbu (balance update) notificationtr (transfer) notificationbu (balance update) notificationresponse\n\n### Step-by-Step Processâ€‹\n\n#### 1\\. Validates Requestâ€‹\n\nThe clearnode performs comprehensive validation:\n\n  * Verifies authentication and signature\n  * Checks sender has sufficient available balance in unified account\n  * Validates allocations format and asset support\n\n#### 2\\. Updates Ledger (Double-Entry Bookkeeping)â€‹\n\nEvery transfer creates two ledger entries - one for the sender and one for the recipient. The ledger uses double-entry bookkeeping principles where each entry has both `credit` and `debit` fields, with amounts always recorded as positive values.\n\nDouble-Entry Bookkeeping\n\nThe double-entry system ensures that the total of all debits always equals the total of all credits, providing mathematical proof of accounting accuracy. Every transfer is recorded twice - once as a debit to the sender's account and once as a credit to the recipient's account.\n\n#### 3\\. Records Transactionâ€‹\n\nA user-facing transaction record is created for each asset being transferred, containing information about the sender, recipient, asset, and amount.\n\n#### 4\\. Sends Notificationsâ€‹\n\n  * **Both parties** receive `tr` (transfer) notification with transaction details\n  * **Both parties** receive `bu` (balance update) notification with updated balances\n\n#### 5\\. Responseâ€‹\n\n  * **Sender** receives response with transaction details\n\n* * *\n\nSummary: Manages the off-chain execution of asset transfers using a double-entry bookkeeping system to ensure ledger integrity and real-time balance synchronization between participants.\n\nRelated terms: transfer funds, off-chain processing, clearnode, double-entry bookkeeping, ledger update, balance update, crypto payment, transaction validation, debit and credit, asset allocation, clear node, real-time settlement\n\nUse cases: Internal ledger transfers between network participants, Real-time balance synchronization for trading, Off-chain settlement of crypto assets",
    "metadata": {
      "title": "Transfer Method | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/transfers",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Manages the off-chain execution of asset transfers using a double-entry bookkeeping system to ensure ledger integrity and real-time balance synchronization between participants.",
      "keywords": [
        "transfer funds",
        "off-chain processing",
        "clearnode",
        "double-entry bookkeeping",
        "ledger update",
        "balance update",
        "crypto payment",
        "transaction validation",
        "debit and credit",
        "asset allocation",
        "clear node",
        "real-time settlement"
      ],
      "function_name": "transfer",
      "intent": "concept",
      "use_cases": [
        "Internal ledger transfers between network participants",
        "Real-time balance synchronization for trading",
        "Off-chain settlement of crypto assets"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Unified Balance Mechanicsâ€‹\n\n\nThe unified balance aggregates funds from all chains.\n\n### Example: Multi-Chain Aggregationâ€‹\n    \n    \n    User deposited:  \n      $10 USDC on Ethereum  \n      $5 USDC on Polygon  \n      $3 USDC on Base  \n        \n    Unified Balance: $18 USDC total  \n      \n    User can transfer: Any amount up to $18 USDC  \n    \n\n### Account Typesâ€‹\n\nThe ledger system maintains three types of accounts:\n\n  1. **Unified Account** : Main account identified by wallet address. This is where user funds are stored and can be transferred or withdrawn.\n\n  2. **App Session Account** : Identified by app session ID. Participant wallets are beneficiaries of this account. Funds in app sessions are locked for the duration of the session.\n\n  3. **Channel Escrow Account** : Temporary account that locks funds when user requests blockchain operations like resize. Funds remain in this account until the transaction is confirmed on-chain.\n\n\n* * *\n\nSummary: This component defines the ledger's unified balance system, which aggregates liquidity across multiple blockchains into a single spendable balance while managing fund states through specialized account types like App Sessions and Escrow.\n\nRelated terms: unified balance, cross-chain aggregation, multi-chain liquidity, ledger system, app session account, channel escrow, fund locking, wallet balance, Ethereum, Polygon, Base, crosschain, liquidity management, stateful accounts, multi chain\n\nUse cases: Cross-chain liquidity aggregation, Session-based fund locking, On-chain transaction settlement, Multi-network asset management",
    "metadata": {
      "title": "Transfer Method | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/transfers",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the ledger's unified balance system, which aggregates liquidity across multiple blockchains into a single spendable balance while managing fund states through specialized account types like App Sessions and Escrow.",
      "keywords": [
        "unified balance",
        "cross-chain aggregation",
        "multi-chain liquidity",
        "ledger system",
        "app session account",
        "channel escrow",
        "fund locking",
        "wallet balance",
        "Ethereum",
        "Polygon",
        "Base",
        "crosschain",
        "liquidity management",
        "stateful accounts",
        "multi chain"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Cross-chain liquidity aggregation",
        "Session-based fund locking",
        "On-chain transaction settlement",
        "Multi-network asset management"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Transaction History Query Methodsâ€‹\n\n\nUsers can query their transfer history using two methods for different levels of detail.\n\n* * *\n\n### get_ledger_transactionsâ€‹\n\nRetrieves user-facing transaction log with sender, recipient, amount, and type. This endpoint provides a view of transactions where the specified account appears as either the sender or receiver.\n\nPublic Endpoint\n\nThis is a public endpoint - authentication is not required.\n\n#### Requestâ€‹\n\nParameter| Type| Required| Description| Format| Example| Notes  \n---|---|---|---|---|---|---  \n`account_id`| string| No| Filter by account ID (wallet, app session, or channel)| Hex string or ID| `\"0x1234567890abcdef...\"`| Returns transactions for this account  \n`asset`| string| No| Filter by asset symbol| Lowercase string| `\"usdc\"`| Returns transactions for this asset only  \n`tx_type`| string| No| Filter by transaction type| `transfer`, `deposit`, `withdrawal`, `app_deposit`, `app_withdrawal`, `escrow_lock`, `escrow_unlock`| `\"transfer\"`| Returns only this type of transaction  \n`offset`| number| No| Pagination offset| `0`| `42`| Defaults to `0`  \n`limit`| number| No| Number of transactions to return| `10` (max 100)| `10`| Defaults to 10 if omitted  \n`sort`| string| No| Sort order by created_at| `\"asc\"` or `\"desc\"`| `\"desc\"`| Default: `\"desc\"`  \n  \n#### Responseâ€‹\n\nParameter| Type| Description  \n---|---|---  \n`ledger_transactions`| LedgerTransaction[]| Array of transaction objects  \n  \n**LedgerTransaction Structure** :\n\nField| Type| Description  \n---|---|---  \n`id`| number| Unique transaction reference  \n`tx_type`| string| Transaction type  \n`from_account`| string| Sender account identifier  \n`from_account_tag`| string| Sender's user tag (empty if none)  \n`to_account`| string| Recipient account identifier  \n`to_account_tag`| string| Recipient's user tag (empty if none)  \n`asset`| string| Asset symbol  \n`amount`| string| Transaction amount (decimal string)  \n`created_at`| string| ISO 8601 timestamp  \n  \n* * *\n\n### get_ledger_entriesâ€‹\n\nRetrieves detailed accounting entries showing all debits and credits. This endpoint provides double-entry bookkeeping records for detailed reconciliation and audit trails.\n\nPublic Endpoint\n\nThis is a public endpoint - authentication is not required.\n\n#### Requestâ€‹\n\nParameter| Type| Required| Description| Format| Example| Notes  \n---|---|---|---|---|---|---  \n`account_id`| string| No| Filter by account ID (wallet/app session/channel)| Hex string or ID| `\"0x1234567890abcdef...\"`| Returns entries for this account  \n`wallet`| string| No| Filter by participant wallet| 0x-prefixed hex string (20 bytes)| `\"0x1234567890abcdef...\"`| Returns entries for this participant  \n`asset`| string| No| Filter by asset symbol| Lowercase string| `\"usdc\"`| Returns entries for this asset only  \n`offset`| number| No| Pagination offset| `0`| `42`| Defaults to `0`  \n`limit`| number| No| Number of entries to return| `10` (max 100)| `10`| Defaults to 10 if omitted  \n`sort`| string| No| Sort order by created_at| `\"asc\"` or `\"desc\"`| `\"desc\"`| Default: `\"desc\"`  \n  \n#### Responseâ€‹\n\nParameter| Type| Description  \n---|---|---  \n`ledger_entries`| LedgerEntry[]| Array of ledger entry objects  \n  \n**LedgerEntry Structure** :\n\nField| Type| Description  \n---|---|---  \n`id`| number| Unique entry ID  \n`account_id`| string| Account identifier  \n`account_type`| number| Account type (`1000`=asset, `2000`=liability, etc.)  \n`asset`| string| Asset symbol  \n`participant`| string| Participant wallet address  \n`credit`| string| Credit amount (positive value or \"0.0\")  \n`debit`| string| Debit amount (positive value or \"0.0\")  \n`created_at`| string| ISO 8601 timestamp  \n  \n* * *\n\nSummary: Provides public endpoints for querying historical transaction data, enabling system architects to integrate audit trails and activity logs for wallets, app sessions, or channels.\n\nRelated terms: transaction history, ledger, audit trail, payment log, get_ledger_transactions, account activity, tx history, transfer history, deposit history, withdrawal history, ledger query, transaction filtering, activity feed, ledger entries\n\nUse cases: auditing account activity, displaying transaction history in user dashboards, reconciling multi-party transfers, tracking asset-specific movements",
    "metadata": {
      "title": "Transfer Method | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/transfers",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides public endpoints for querying historical transaction data, enabling system architects to integrate audit trails and activity logs for wallets, app sessions, or channels.",
      "keywords": [
        "transaction history",
        "ledger",
        "audit trail",
        "payment log",
        "get_ledger_transactions",
        "account activity",
        "tx history",
        "transfer history",
        "deposit history",
        "withdrawal history",
        "ledger query",
        "transaction filtering",
        "activity feed",
        "ledger entries"
      ],
      "function_name": "get_ledger_transactions",
      "intent": "api_reference",
      "use_cases": [
        "auditing account activity",
        "displaying transaction history in user dashboards",
        "reconciling multi-party transfers",
        "tracking asset-specific movements"
      ],
      "function_names": [
        "from_account",
        "escrow_lock",
        "get_ledger_entries",
        "from_account_tag",
        "app_deposit"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Implementation Notesâ€‹\n\n\n**Performance** :\n\n  * Transfers are instant (< 1 second) and atomic\n  * No blockchain transaction required\n  * No blockchain fees\n\n**Features** :\n\n  * Unified balance is updated immediately\n  * Transfer can include multiple assets in one operation\n  * Transaction IDs can be used to track and query transfer status via `get_ledger_transactions`\n\n**Audit Trail** :\n\n  * Clearnode maintains complete audit trail of all transfers\n  * Double-entry bookkeeping ensures mathematical accuracy\n  * All records queryable via `get_ledger_*` methods\n\n* * *\n\nSummary: Provides high-performance, off-chain atomic transfers with instant settlement and zero blockchain fees, maintaining a complete audit trail via double-entry bookkeeping.\n\nRelated terms: transfer, off-chain, atomic, zero-fee, instant settlement, ledger, audit trail, double-entry bookkeeping, multi-asset, clearnode, transaction history, unified balance, get_ledger_transactions, asset movement\n\nUse cases: High-frequency internal asset rebalancing, Instant peer-to-peer value exchange, Multi-currency settlement without gas fees, Auditable financial reporting",
    "metadata": {
      "title": "Transfer Method | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/transfers",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides high-performance, off-chain atomic transfers with instant settlement and zero blockchain fees, maintaining a complete audit trail via double-entry bookkeeping.",
      "keywords": [
        "transfer",
        "off-chain",
        "atomic",
        "zero-fee",
        "instant settlement",
        "ledger",
        "audit trail",
        "double-entry bookkeeping",
        "multi-asset",
        "clearnode",
        "transaction history",
        "unified balance",
        "get_ledger_transactions",
        "asset movement"
      ],
      "function_name": "get_ledger_transactions",
      "intent": "concept",
      "use_cases": [
        "High-frequency internal asset rebalancing",
        "Instant peer-to-peer value exchange",
        "Multi-currency settlement without gas fees",
        "Auditable financial reporting"
      ],
      "function_names": [
        "get_ledger_transactions",
        "get_ledger_"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nExplore other off-chain operations:\n\n  * **[App Sessions](/docs/protocol/off-chain/app-sessions)** \\- Create multi-party application channels\n  * **[Queries& Notifications](/docs/protocol/off-chain/queries)** \\- Check balances, transactions, and receive updates\n  * **[Channel Methods](/docs/protocol/off-chain/channel-methods)** \\- Manage payment channels\n\nFor protocol fundamentals:\n\n  * **[Authentication](/docs/protocol/off-chain/authentication)** \\- Understand authorization and session management\n  * **[Message Format](/docs/protocol/off-chain/message-format)** \\- Learn request/response structure\n\n\n\n[PreviousChannel Management Methods](/docs/protocol/off-chain/channel-methods)[NextApp Session Methods](/docs/protocol/off-chain/app-sessions)\n\n  * Overview\n    * Why Use Transfer?\n  * transfer\n    * Name\n    * Usage\n    * When to Use\n    * Prerequisites\n    * Request\n    * Response\n  * Off-Chain Processing\n    * Step-by-Step Process\n  * Unified Balance Mechanics\n    * Example: Multi-Chain Aggregation\n    * Account Types\n  * Transaction History Query Methods\n    * get_ledger_transactions\n    * get_ledger_entries\n  * Implementation Notes\n  * Next Steps\n\nSummary: Provides the interface for executing off-chain asset transfers and querying ledger history, supporting unified balance management across multiple blockchain networks.\n\nRelated terms: transfer funds, send crypto, off-chain transfer, ledger entries, transaction history, unified balance, multi-chain aggregation, get_ledger_transactions, get_ledger_entries, payment channel, cross-chain settlement, account management\n\nUse cases: Real-time off-chain asset transfers between peers, Unified balance tracking across multiple chains, Auditing and retrieving transaction history",
    "metadata": {
      "title": "Transfer Method | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/off-chain/transfers",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides the interface for executing off-chain asset transfers and querying ledger history, supporting unified balance management across multiple blockchain networks.",
      "keywords": [
        "transfer funds",
        "send crypto",
        "off-chain transfer",
        "ledger entries",
        "transaction history",
        "unified balance",
        "multi-chain aggregation",
        "get_ledger_transactions",
        "get_ledger_entries",
        "payment channel",
        "cross-chain settlement",
        "account management"
      ],
      "function_name": "transfer",
      "intent": "api_reference",
      "use_cases": [
        "Real-time off-chain asset transfers between peers",
        "Unified balance tracking across multiple chains",
        "Auditing and retrieving transaction history"
      ],
      "function_names": [
        "get_ledger_transactions",
        "get_ledger_entries"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "* On-Chain Protocol\n  * Channel Lifecycle\n\n\n\n# Channel Lifecycle\n\nSummary: Defines the end-to-end stages of a state channel within the Yellow Network, covering initialization, funding, state transitions, and final on-chain settlement.\n\nRelated terms: channel lifecycle, state channel, payment channel, on-chain settlement, channel opening, channel closing, funding, dispute resolution, off-chain state, yellow network, channel management, settlement layer, channel state, protocol stages\n\nUse cases: managing payment channel states, on-chain settlement of off-chain transactions, handling channel disputes, initializing secure peer-to-peer links",
    "metadata": {
      "title": "Channel Lifecycle | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/channel-lifecycle",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the end-to-end stages of a state channel within the Yellow Network, covering initialization, funding, state transitions, and final on-chain settlement.",
      "keywords": [
        "channel lifecycle",
        "state channel",
        "payment channel",
        "on-chain settlement",
        "channel opening",
        "channel closing",
        "funding",
        "dispute resolution",
        "off-chain state",
        "yellow network",
        "channel management",
        "settlement layer",
        "channel state",
        "protocol stages"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "managing payment channel states",
        "on-chain settlement of off-chain transactions",
        "handling channel disputes",
        "initializing secure peer-to-peer links"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## State Transitions Overviewâ€‹\n\n\nThe lifecycle of a channel moves through well-defined states depending on how participants interact with the custody contract.\n\ncreate()\n\ncreate() (sigs from all participants)\n\njoin() (all participants)\n\ncheckpoint()\n\nchallenge()\n\nclose() (cooperative)\n\ncheckpoint() (newer state)\n\nchallenge period expires\n\nVOID\n\nINITIAL\n\nACTIVE\n\nDISPUTE\n\nFINAL\n\nOperational state  \nOff-chain updates occur here\n\nChallenge period active  \nParties can submit newer states\n\nUse the sections below for details on each phase.\n\nSummary: Defines the state machine and lifecycle stages of a payment channel, outlining how participants transition from initialization to active off-chain updates and final settlement.\n\nRelated terms: channel lifecycle, state machine, payment channel, off-chain updates, dispute resolution, challenge period, custody contract, settlement, state transition, multi-party channel, cooperative close, checkpointing, yellow network, state channel\n\nUse cases: managing payment channel states, handling off-chain transaction disputes, implementing secure channel closure",
    "metadata": {
      "title": "Channel Lifecycle | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/channel-lifecycle",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the state machine and lifecycle stages of a payment channel, outlining how participants transition from initialization to active off-chain updates and final settlement.",
      "keywords": [
        "channel lifecycle",
        "state machine",
        "payment channel",
        "off-chain updates",
        "dispute resolution",
        "challenge period",
        "custody contract",
        "settlement",
        "state transition",
        "multi-party channel",
        "cooperative close",
        "checkpointing",
        "yellow network",
        "state channel"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "managing payment channel states",
        "handling off-chain transaction disputes",
        "implementing secure channel closure"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Creation Phaseâ€‹\n\n\n**Purpose** : Initiate a new channel with specified participants and initial funding.\n\n**Process** :\n\n  1. The Creator:\n     * Constructs a Channel configuration with participants, adjudicator, challenge period, and nonce\n     * Prepares an initial State with application-specific app data\n     * Defines expected token deposits for all participants in `state.allocations`\n     * Signs the computed packedState of this initial state\n     * Includes Creator's signature in `state.sigs` at position 0\n     * Calls either `create(...)` or `depositAndCreate(...)` function with the channel configuration and initial signed state\n\nImplicit Join (Immediate Activation)\n\nIf the Creator obtains the second participant's signature on the initial state **before** calling `create()`, they can supply both signatures in `state.sigs` (positions 0 and 1). When the contract detects `sigs.length == 2`:\n\n  * It verifies both signatures\n  * Locks funds from both participants\n  * Transitions directly to `ACTIVE` status (skipping `INITIAL`)\n  * Emits both `Joined` and `Opened` events\n\nThis \"implicit join\" is the **recommended approach** for faster channel activation and reduced gas costs (single transaction instead of two).\n\n  2. The contract:\n     * Verifies the Creator's signature on the funding packedState\n     * Verifies Creator has sufficient balance to fund their allocation\n     * Locks the Creator's funds according to the allocation\n     * Sets the channel status to `INITIAL`\n     * Emits a `Created` event with channelId, channel configuration, and expected deposits\n\nContractCreatorContractCreatorStatus = VOIDStatus = INITIALConstruct Channel configCreate initial StateSign packedStatecreate(channel, state)Verify signatureLock Creator fundsSet status to INITIALEmit Created event\n\nParticipant versus Caller address\n\nThe first participant address is usually different from the caller (EOA or contract), thus enabling channel operation delegation. This can be fruitful as users can fund channels for other ones.\n\nSummary: Defines the initialization and funding phase of a state channel, allowing participants to establish a secure off-chain communication link with locked collateral through either sequential or atomic multi-signature activation.\n\nRelated terms: open channel, start payment, initial funding, channel creation, state initialization, packedState, signature verification, implicit join, gas optimization, multi-sig, channel lifecycle, adjudicator, nonce, allocation\n\nUse cases: Establishing a secure off-chain payment link between two parties, Optimizing gas costs via atomic channel activation and funding, Delegating channel operation to a non-participant address for automated management",
    "metadata": {
      "title": "Channel Lifecycle | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/channel-lifecycle",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the initialization and funding phase of a state channel, allowing participants to establish a secure off-chain communication link with locked collateral through either sequential or atomic multi-signature activation.",
      "keywords": [
        "open channel",
        "start payment",
        "initial funding",
        "channel creation",
        "state initialization",
        "packedState",
        "signature verification",
        "implicit join",
        "gas optimization",
        "multi-sig",
        "channel lifecycle",
        "adjudicator",
        "nonce",
        "allocation"
      ],
      "function_name": "create",
      "intent": "concept",
      "use_cases": [
        "Establishing a secure off-chain payment link between two parties",
        "Optimizing gas costs via atomic channel activation and funding",
        "Delegating channel operation to a non-participant address for automated management"
      ],
      "function_names": [
        "create",
        "depositAndCreate"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Joining Phaseâ€‹\n\n\nTwo Channel Opening Flows\n\nThere are two ways to open a channel:\n\n  1. **Modern/Recommended** : Provide ALL signatures in `create()` â†’ channel immediately ACTIVE (see [Architecture](/docs/protocol/architecture#channel-opening))\n  2. **Legacy/Manual** : Provide only creator's signature in `create()` â†’ status INITIAL â†’ separate `join()` calls â†’ ACTIVE\n\nThis section documents flow #2. Most implementations use flow #1.\n\n**Purpose** : Allow other participants to join and fund the channel (when using separate join flow).\n\n**Process** :\n\n  1. Each non-Creator participant:\n\n     * Verifies the channelId and expected allocations\n     * Signs the same funding packedState\n     * Calls the `join` function with channelId, their participant index, and signature\n  2. The contract:\n\n     * Verifies the participant's signature against the funding packedState\n     * Confirms the signer matches the expected participant at the given index\n     * Locks the participant's funds according to the allocation\n     * Tracks the actual deposit in the channel metadata\n     * Emits a `Joined` event with channelId and participant index\n  3. When all participants have joined, the contract:\n\n     * Verifies that all expected deposits are fulfilled\n     * Sets the channel status to `ACTIVE`\n     * Emits an `Opened` event with channelId\n\nSystemContractParticipantSystemContractParticipantStatus INITIALStatus ACTIVEalt[All participants joined]Sign funding packedStatejoin(channelId, index, signature)Verify signatureLock participant fundsEmit Joined eventSet status to ACTIVEEmit Opened event\n\nChannel Activation\n\nThe channel becomes operational only when ALL participants have successfully joined and funded their allocations.\n\nSummary: This component manages the multi-party channel initialization process where participants sequentially join, sign state updates, and deposit funds to transition a channel from an initial state to active. It ensures all required collateral is locked and verified on-chain before the channel becomes operational for off-chain transactions.\n\nRelated terms: open channel, deposit funds, fund channel, channel lifecycle, state update, packedState, signature verification, participant index, multi-party, escrow, on-chain settlement, chanel, join channel, channel activation\n\nUse cases: multi-party payment channel setup, collaborative funding of a state channel, on-chain collateral locking for off-chain trading, sequential participant onboarding",
    "metadata": {
      "title": "Channel Lifecycle | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/channel-lifecycle",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component manages the multi-party channel initialization process where participants sequentially join, sign state updates, and deposit funds to transition a channel from an initial state to active. It ensures all required collateral is locked and verified on-chain before the channel becomes operational for off-chain transactions.",
      "keywords": [
        "open channel",
        "deposit funds",
        "fund channel",
        "channel lifecycle",
        "state update",
        "packedState",
        "signature verification",
        "participant index",
        "multi-party",
        "escrow",
        "on-chain settlement",
        "chanel",
        "join channel",
        "channel activation"
      ],
      "function_name": "join",
      "intent": "concept",
      "use_cases": [
        "multi-party payment channel setup",
        "collaborative funding of a state channel",
        "on-chain collateral locking for off-chain trading",
        "sequential participant onboarding"
      ],
      "function_names": [
        "join",
        "create"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Active Phaseâ€‹\n\n\n**Purpose** : Enable off-chain state updates while channel is operational.\n\n### Off-Chain Updatesâ€‹\n\nParticipants:\n\n  * Exchange and sign state updates off-chain via the Nitro RPC protocol\n  * Maintain a record of the latest valid state\n  * Use application-specific data in the `state.data` field\n\nEach new state:\n\n  * May update allocations when assets are transferred (though allocations can remain unchanged between states, e.g., game moves without fund transfers)\n  * MUST be signed by the necessary participants according to adjudicator rules\n  * MUST comply with the validation rules of the channel's adjudicator\n\nThe on-chain contract remains unchanged during the active phase unless participants choose to checkpoint a state.\n\nOff-Chain Efficiency\n\nDuring the active phase, state updates occur entirely off-chain with zero gas costs and sub-second latency.\n\nSummary: The Active Phase enables participants to perform rapid, zero-gas off-chain state updates and asset reallocations while maintaining cryptographic security for eventual on-chain settlement. It leverages the Nitro RPC protocol to ensure all transitions comply with adjudicator validation rules without requiring immediate blockchain transactions.\n\nRelated terms: off-chain updates, state transition, Nitro RPC, zero gas, sub-second latency, digital signature, adjudicator rules, channel state, asset allocation, checkpoint, real-time payments, state channel, offchain\n\nUse cases: high-frequency trading, micro-payments, real-time gaming moves, instant asset transfers",
    "metadata": {
      "title": "Channel Lifecycle | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/channel-lifecycle",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The Active Phase enables participants to perform rapid, zero-gas off-chain state updates and asset reallocations while maintaining cryptographic security for eventual on-chain settlement. It leverages the Nitro RPC protocol to ensure all transitions comply with adjudicator validation rules without requiring immediate blockchain transactions.",
      "keywords": [
        "off-chain updates",
        "state transition",
        "Nitro RPC",
        "zero gas",
        "sub-second latency",
        "digital signature",
        "adjudicator rules",
        "channel state",
        "asset allocation",
        "checkpoint",
        "real-time payments",
        "state channel",
        "offchain"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "high-frequency trading",
        "micro-payments",
        "real-time gaming moves",
        "instant asset transfers"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Checkpointingâ€‹\n\n\n**Purpose** : Record a state on-chain without entering dispute mode.\n\n**Process** :\n\n  1. Any participant:\n\n     * Calls the `checkpoint` function with a valid state and required proofs\n  2. The contract:\n\n     * Verifies the submitted state via the adjudicator\n     * If valid and more recent than the previously checkpointed state, stores it\n     * Emits a `Checkpointed` event with channelId\n\ncheckpoint\n\nValid\n\nActive Channel  \nStatus: ACTIVE\n\nVerify State\n\nStore State\n\nEmit Event\n\nRemain Active  \nStatus: ACTIVE\n\nOptional Operation\n\nCheckpointing is optional but recommended for long-lived channels or after significant value transfers.\n\nSummary: Enables participants to record the current off-chain state of a payment channel onto the blockchain without initiating a dispute or closing the channel. This mechanism provides a secure on-chain reference point for long-lived channels while maintaining operational continuity.\n\nRelated terms: checkpoint, checkpointing, state persistence, on-chain record, channel lifecycle, adjudicator, proof verification, sync state, check-point, secure state, payment channel, state update, off-chain synchronization\n\nUse cases: Securing high-value transfers in long-running channels, Periodic state synchronization for risk mitigation, Updating on-chain state without interrupting off-chain operations",
    "metadata": {
      "title": "Channel Lifecycle | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/channel-lifecycle",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Enables participants to record the current off-chain state of a payment channel onto the blockchain without initiating a dispute or closing the channel. This mechanism provides a secure on-chain reference point for long-lived channels while maintaining operational continuity.",
      "keywords": [
        "checkpoint",
        "checkpointing",
        "state persistence",
        "on-chain record",
        "channel lifecycle",
        "adjudicator",
        "proof verification",
        "sync state",
        "check-point",
        "secure state",
        "payment channel",
        "state update",
        "off-chain synchronization"
      ],
      "function_name": "checkpoint",
      "intent": "concept",
      "use_cases": [
        "Securing high-value transfers in long-running channels",
        "Periodic state synchronization for risk mitigation",
        "Updating on-chain state without interrupting off-chain operations"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Closure - Cooperativeâ€‹\n\n\n**Purpose** : Close channel to distribute locked funds, after all participants have agreed on the final state.\n\n**Process** :\n\n  1. Any participant:\n\n     * Prepare a final State with `intent` equal to `FINALIZE`.\n     * Collects signatures from all participants on this final state\n     * Calls the `close` function with channelId, final state, and any required proofs\n  2. The contract:\n\n     * Verifies all participant signatures on the closing packedState\n     * Verifies the state has `intent` equal to `FINALIZE`.\n     * Distributes funds according to the final state's allocations\n     * Sets the channel status to `FINAL`\n     * Deletes the channel metadata\n     * Emits a `Closed` event\n\nContractUserContractUserStatus = ACTIVEStatus = FINALCreate final State (intent=FINALIZE)Collect all signaturesclose(channelId, state, proofs)Verify all signaturesVerify intent = FINALIZEDistribute fundsSet status to FINALDelete metadataEmit Closed event\n\nPreferred Method\n\n**This is the preferred closure method as it is fast and gas-efficient.** It requires only one transaction and completes immediately without a challenge period.\n\nSummary: Defines the cooperative closure mechanism for payment channels, enabling participants to mutually agree on a final state and settle funds instantly without a challenge period. This process ensures gas efficiency and immediate fund distribution through unanimous cryptographic signatures.\n\nRelated terms: close channel, cooperative closure, settle funds, FINALIZE intent, state update, multi-party signature, instant settlement, gas-efficient, channel termination, withdraw funds, off-chain finality, channelId, packedState\n\nUse cases: Finalizing a trading session between parties, Instant withdrawal of funds from a state channel, Mutual termination of a payment stream",
    "metadata": {
      "title": "Channel Lifecycle | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/channel-lifecycle",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the cooperative closure mechanism for payment channels, enabling participants to mutually agree on a final state and settle funds instantly without a challenge period. This process ensures gas efficiency and immediate fund distribution through unanimous cryptographic signatures.",
      "keywords": [
        "close channel",
        "cooperative closure",
        "settle funds",
        "FINALIZE intent",
        "state update",
        "multi-party signature",
        "instant settlement",
        "gas-efficient",
        "channel termination",
        "withdraw funds",
        "off-chain finality",
        "channelId",
        "packedState"
      ],
      "function_name": "close",
      "intent": "concept",
      "use_cases": [
        "Finalizing a trading session between parties",
        "Instant withdrawal of funds from a state channel",
        "Mutual termination of a payment stream"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Closure - Challenge-Responseâ€‹\n\n\n**Purpose** : Handle closure when participants disagree or one party is unresponsive.\n\n### Challenge Processâ€‹\n\n  1. To initiate a challenge, a participant:\n     * Calls the `challenge` function with their latest valid state and required proofs\n\nLatest State Location\n\nThe participant's latest state may only exist off-chain and not be known on-chain yet. The challenge process brings this off-chain state on-chain for validation.\n\n  2. The contract:\n     * Verifies the submitted state via the adjudicator\n     * If valid, stores the state and starts the challenge period\n     * Sets a challenge expiration timestamp (current time + challenge duration)\n     * Sets the channel status to `DISPUTE`\n     * Emits a `Challenged` event with channelId and expiration time\n\nTimerContractUserTimerContractUserStatus = ACTIVEStatus = DISPUTEchallenge(channelId, state, proofs)Verify stateStore stateSet status to DISPUTEStart challenge periodEmit Challenged event\n\n### Resolving Challenge with Checkpointâ€‹\n\nDuring the challenge period, any participant:\n\n  * Submits a more recent valid state by calling `checkpoint()`\n  * If the new state is valid and more recent (as determined by the adjudicator or IComparable interface), the contract updates the stored state, resets the challenge period, and returns the channel to `ACTIVE` status\n\n### Challenge Period Elapseâ€‹\n\nAfter the challenge period expires, any participant:\n\n  * Call `close` with an empty candidate and proof to distribute funds according to the last valid challenged state\n\nThe contract:\n\n  * Verifies the challenge period has elapsed\n  * Distributes funds according to the challenged state's allocations\n  * Sets channel status to `FINAL`\n  * Deletes the channel metadata\n  * Emits a `Closed` event\n\nKey Principle\n\nThe challenge mechanism gives parties time to prove they have a newer state. If no one responds with a newer state, the challenged state is assumed correct.\n\n**Complete Challenge-Response Flow** :\n\nchallenge()\n\ncheckpoint() with newer state\n\nclose() after timeout\n\nActive\n\nDispute\n\nFinal\n\nChallenge period active  \nParties can submit  \nnewer states\n\nSummary: This component defines the dispute resolution and settlement mechanism for state channels, enabling participants to handle disagreements or unresponsive peers by bringing off-chain states on-chain for verification. It ensures protocol integrity through a time-bound challenge-response period that determines the final distribution of funds based on the latest valid state.\n\nRelated terms: dispute resolution, channel closure, challenge-response, checkpoint, on-chain verification, state channel, settlement, unresponsive peer, adjudicator, fund distribution, DISPUTE status, FINAL status, challange, proof verification\n\nUse cases: resolving counterparty disputes, handling unresponsive peers, on-chain state verification, finalizing channel settlement",
    "metadata": {
      "title": "Channel Lifecycle | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/channel-lifecycle",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the dispute resolution and settlement mechanism for state channels, enabling participants to handle disagreements or unresponsive peers by bringing off-chain states on-chain for verification. It ensures protocol integrity through a time-bound challenge-response period that determines the final distribution of funds based on the latest valid state.",
      "keywords": [
        "dispute resolution",
        "channel closure",
        "challenge-response",
        "checkpoint",
        "on-chain verification",
        "state channel",
        "settlement",
        "unresponsive peer",
        "adjudicator",
        "fund distribution",
        "DISPUTE status",
        "FINAL status",
        "challange",
        "proof verification"
      ],
      "function_name": "checkpoint",
      "intent": "concept",
      "use_cases": [
        "resolving counterparty disputes",
        "handling unresponsive peers",
        "on-chain state verification",
        "finalizing channel settlement"
      ],
      "function_names": [
        "checkpoint"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Resize Protocolâ€‹\n\n\n**Purpose** : Adjust funds locked in the channel by locking or unlocking funds **without closing the channel**.\n\n**Process** :\n\n  1. Any participant:\n     * Calls the `resize` function with:\n       * The channelId (remains unchanged)\n       * A candidate State with:\n         * `intent` = `StateIntent.RESIZE`\n         * `version` = precedingState.version + 1\n         * `data` = ABI-encoded `int256[]` containing delta amounts (positive for deposit, negative for withdrawal) respectively for participants\n         * `allocations` = Allocation[] after resize (absolute amounts)\n         * Signatures from **ALL participants** (consensus required)\n       * An array of proof states containing the previous state (`version-1`) first and its proof later in the array\n\nDeposit Requirement\n\nThe participant depositing must have at least the corresponding amount in their Custody ledger account (available balance) to lock additional funds to the channel.\n\n  2. The contract:\n\n     * Verifies the channel is in ACTIVE status\n     * Verifies all participants have signed the resize state\n     * Decodes delta amounts from `candidate.data`\n     * Validates adjudicator approves the preceding state\n     * For positive deltas: Locks additional funds from custody account\n     * For negative deltas: Unlocks funds back to custody account\n     * Updates expected deposits to match new allocations\n     * Emits `Resized(channelId, deltaAllocations)` event\n  3. The channel:\n\n     * **channelId remains UNCHANGED** (same channel persists)\n     * Status remains **ACTIVE** throughout\n     * Version increments by 1\n     * No new channel is created\n\nContractUserContractUserStatus = ACTIVESame channelIdState version + 1Intent = RESIZEStatus = ACTIVESame channelIdChannel still ACTIVEresize(channelId, resizeState, proofs)Verify signatures (all participants)Decode delta amounts from state.dataLock funds (positive deltas)Unlock funds (negative deltas)Update expected depositsResized(channelId, deltas)\n\n**Use Cases** :\n\n  * Increasing funds locked in the channel (positive delta: adding funds)\n  * Decreasing funds locked in the channel (negative delta: removing funds)\n  * Adjusting fund distribution while maintaining channel continuity\n\nIn-Place Update\n\nThe resize operation updates the channel **in place**. The channelId stays the same, and the channel remains ACTIVE throughout. This differs from closing and reopening, which would create a new channel.\n\nImplicit Transfer with Resize\n\nIt is possible to combine a transfer (change of allocations among participants) with a resize operation. For example:\n\n  * Previous state allocations: `[5, 10]`\n  * Desired transfer: 2 tokens from second to first participant â†’ `[7, 8]`\n  * Additional changes: first participant withdraws all 7, second participant deposits 6\n  * Delta amounts: `[-7, 6]`\n  * Resize state allocations: `[0, 14]`\n\n**Rule** : `sum(allocations_resize_state) = sum(allocations_prev_state) + sum(delta_amounts)`  \nFor this example: `14 = 15 + (-1)` âœ“\n\nSummary: The Resize Protocol enables participants to dynamically adjust the total value locked in an active payment channel through deposits or withdrawals without terminating the channel or changing its unique identifier.\n\nRelated terms: resize, deposit, withdrawal, channel lifecycle, state update, delta amounts, fund adjustment, top up, consensus signing, custody ledger, active channel, rebalancing, re-size\n\nUse cases: Adding liquidity to an active trading channel, Partial withdrawal of funds without closing session, Dynamic rebalancing of multi-party channel allocations",
    "metadata": {
      "title": "Channel Lifecycle | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/channel-lifecycle",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The Resize Protocol enables participants to dynamically adjust the total value locked in an active payment channel through deposits or withdrawals without terminating the channel or changing its unique identifier.",
      "keywords": [
        "resize",
        "deposit",
        "withdrawal",
        "channel lifecycle",
        "state update",
        "delta amounts",
        "fund adjustment",
        "top up",
        "consensus signing",
        "custody ledger",
        "active channel",
        "rebalancing",
        "re-size"
      ],
      "function_name": "resize",
      "intent": "concept",
      "use_cases": [
        "Adding liquidity to an active trading channel",
        "Partial withdrawal of funds without closing session",
        "Dynamic rebalancing of multi-party channel allocations"
      ],
      "function_names": [
        "allocations_prev_state",
        "sum",
        "delta_amounts",
        "allocations_resize_state",
        "Resized"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## State Transition Summaryâ€‹\n\n\nThe complete channel lifecycle state machine:\n\nInitial\n\ncreate()\n\ncreate() with all sigs\n\njoin() all\n\nresize()\n\nchallenge()\n\nclose() cooperative\n\ncheckpoint() newer\n\nclose() after timeout\n\nDeleted\n\nVOID\n\nINITIAL\n\nACTIVE\n\nDISPUTE\n\nFINAL\n\nChannel does not exist\n\nAwaiting participants\n\nOperational  \nOff-chain updates\n\nChallenge active  \nResponse period\n\nFunds distributed  \nReady for deletion\n\n**Valid Transitions** :\n\nFrom| To| Trigger| Requirements  \n---|---|---|---  \nVOID| INITIAL| `create()`| Creator signature, sufficient balance, INITIALIZE intent  \nINITIAL| ACTIVE| `join()`| All participants joined and funded  \nACTIVE| ACTIVE| `checkpoint()`| Valid newer state  \nACTIVE| ACTIVE| `resize()`| All signatures, valid deltas, sufficient balance  \nACTIVE| DISPUTE| `challenge()`| Valid state newer than latest known on-chain  \nACTIVE| FINAL| `close()`| All signatures, FINALIZE intent  \nDISPUTE| ACTIVE| `checkpoint()`| Valid newer state  \nDISPUTE| FINAL| `close()`| Challenge period expired  \nFINAL| VOID| Automatic| Metadata deleted  \n  \nChannel Deletion\n\nWhen a channel reaches FINAL status, the channel metadata is deleted from the chain and funds are distributed according to the final state allocations.\n\n\n\n[PreviousData Structures](/docs/protocol/on-chain/data-structures)[NextSignature Formats](/docs/protocol/on-chain/signature-formats)\n\n  * State Transitions Overview\n  * Creation Phase\n  * Joining Phase\n  * Active Phase\n    * Off-Chain Updates\n  * Checkpointing\n  * Closure - Cooperative\n  * Closure - Challenge-Response\n    * Challenge Process\n    * Resolving Challenge with Checkpoint\n    * Challenge Period Elapse\n  * Resize Protocol\n  * State Transition Summary\n\nSummary: This component defines the state machine and lifecycle transitions for payment channels, detailing the triggers and requirements for moving between initialization, active operation, dispute resolution, and final settlement.\n\nRelated terms: channel lifecycle, state machine, off-chain updates, dispute resolution, checkpointing, channel closure, settlement, multi-party signatures, resize channel, payment channel, chanel, lifecyle, on-chain settlement\n\nUse cases: off-chain payment processing, dispute management and resolution, dynamic channel liquidity adjustment, cooperative channel closure",
    "metadata": {
      "title": "Channel Lifecycle | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/channel-lifecycle",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the state machine and lifecycle transitions for payment channels, detailing the triggers and requirements for moving between initialization, active operation, dispute resolution, and final settlement.",
      "keywords": [
        "channel lifecycle",
        "state machine",
        "off-chain updates",
        "dispute resolution",
        "checkpointing",
        "channel closure",
        "settlement",
        "multi-party signatures",
        "resize channel",
        "payment channel",
        "chanel",
        "lifecyle",
        "on-chain settlement"
      ],
      "function_name": "checkpoint",
      "intent": "concept",
      "use_cases": [
        "off-chain payment processing",
        "dispute management and resolution",
        "dynamic channel liquidity adjustment",
        "cooperative channel closure"
      ],
      "function_names": [
        "checkpoint",
        "close",
        "resize",
        "join",
        "challenge"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "* On-Chain Protocol\n  * Data Structures\n\n\n\n# Data Structures\n\nSummary: Defines the core data models and schemas used by the Yellow Network on-chain protocol to ensure consistent state representation and interoperability across the ecosystem.\n\nRelated terms: data structures, on-chain protocol, schema, state representation, smart contract models, blockchain data, Yellow Network, protocol definitions, object models, data types, structs, encoding, serialization, payload format\n\nUse cases: Defining smart contract state, Standardizing cross-chain messages, Validating transaction payloads",
    "metadata": {
      "title": "Data Structures | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/data-structures",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the core data models and schemas used by the Yellow Network on-chain protocol to ensure consistent state representation and interoperability across the ecosystem.",
      "keywords": [
        "data structures",
        "on-chain protocol",
        "schema",
        "state representation",
        "smart contract models",
        "blockchain data",
        "Yellow Network",
        "protocol definitions",
        "object models",
        "data types",
        "structs",
        "encoding",
        "serialization",
        "payload format"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Defining smart contract state",
        "Standardizing cross-chain messages",
        "Validating transaction payloads"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Channelâ€‹\n\n\nRepresents the configuration of a state channel.\n    \n    \n    struct Channel {  \n        address[] participants;  // List of participants in the channel  \n        address adjudicator;     // Contract that validates state transitions  \n        uint64 challenge;        // Duration in seconds for dispute resolution  \n        uint64 nonce;           // Unique identifier for the channel  \n    }  \n    \n\n**Fields** :\n\n  * `participants`: An ordered array of participant addresses. Index 0 is typically the Creator, index 1 is the clearnode.\n  * `adjudicator`: Address of the adjudicator contract responsible for validating state transitions.\n  * `challenge`: Challenge period duration in seconds. Determines a time window when a challenge can be resolved by a counterparty. Otherwise, a channel is considered closed and funds can be withdrawn.\n  * `nonce`: A unique number that, combined with other fields, creates a unique channel identifier.\n\nParticipant versus Caller Address\n\nThe first participant address is usually different from the caller (EOA or contract), thus enabling channel operation delegation. This can be fruitful as users can fund channels for other ones.\n\nSummary: Defines the fundamental configuration for a state channel, specifying the participating entities, the governing adjudicator contract for dispute resolution, and unique identification parameters.\n\nRelated terms: Channel, state channel, participants, adjudicator, challenge period, nonce, dispute resolution, channel configuration, smart contract, chanel, state transition, delegation, on-chain validation\n\nUse cases: Initializing a state channel between a user and a clearnode, Setting dispute resolution timeframes for off-chain transactions, Delegating channel creation and funding to a proxy address",
    "metadata": {
      "title": "Data Structures | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/data-structures",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the fundamental configuration for a state channel, specifying the participating entities, the governing adjudicator contract for dispute resolution, and unique identification parameters.",
      "keywords": [
        "Channel",
        "state channel",
        "participants",
        "adjudicator",
        "challenge period",
        "nonce",
        "dispute resolution",
        "channel configuration",
        "smart contract",
        "chanel",
        "state transition",
        "delegation",
        "on-chain validation"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "Initializing a state channel between a user and a clearnode",
        "Setting dispute resolution timeframes for off-chain transactions",
        "Delegating channel creation and funding to a proxy address"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Stateâ€‹\n\n\nRepresents a snapshot of channel state at a point in time.\n    \n    \n    struct State {  \n        StateIntent intent;       // Intent of the state (INITIALIZE, OPERATE, RESIZE, FINALIZE)  \n        uint256 version;          // State version incremental number to compare most recent  \n        bytes data;               // Application-specific data  \n        Allocation[] allocations; // Asset allocation for each participant  \n        bytes[] sigs;             // Participant signatures authorizing the packed state payload  \n    }  \n    \n\n**Fields** :\n\n  * `intent`: The intent of this state, indicating its purpose (see StateIntent enum).\n  * `version`: Incremental version number used to compare and validate state freshness. Higher versions supersede lower versions.\n  * `data`: Application-specific data which adjudicators can operate on. For a `resize(...)` state must contain `allocationDeltas`. For more information, please check the [resize operation docs](/docs/protocol/on-chain/channel-lifecycle#resize-protocol).\n  * `allocations`: Array of allocations defining how funds are distributed.\n  * `sigs`: Array of participant signatures over the canonical packed state payload. Order corresponds to the Channel's participants array.\n\nSummary: Defines the core State data structure used to represent a cryptographically signed snapshot of a payment channel's status, including asset allocations, versioning, and operational intent.\n\nRelated terms: State struct, channel state, state update, asset allocation, multi-party signatures, versioning, off-chain state, resize operation, payment channel, state intent, adjudicator data, cryptographic proof, balance snapshot\n\nUse cases: off-chain balance tracking, liquidity resizing, dispute resolution, multi-party state authorization",
    "metadata": {
      "title": "Data Structures | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/data-structures",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the core State data structure used to represent a cryptographically signed snapshot of a payment channel's status, including asset allocations, versioning, and operational intent.",
      "keywords": [
        "State struct",
        "channel state",
        "state update",
        "asset allocation",
        "multi-party signatures",
        "versioning",
        "off-chain state",
        "resize operation",
        "payment channel",
        "state intent",
        "adjudicator data",
        "cryptographic proof",
        "balance snapshot"
      ],
      "function_name": "resize",
      "intent": "api_reference",
      "use_cases": [
        "off-chain balance tracking",
        "liquidity resizing",
        "dispute resolution",
        "multi-party state authorization"
      ],
      "function_names": [
        "resize"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Allocationâ€‹\n\n\nSpecifies how a particular amount of a token should be allocated.\n    \n    \n    struct Allocation {  \n        address destination;  // Recipient of funds  \n        address token;        // ERC-20 token address  \n        uint256 amount;       // Token amount in smallest unit  \n    }  \n    \n\n**Fields** :\n\n  * `destination`: Address that will receive the funds when channel closes.\n  * `token`: Contract address of the ERC-20 token (or zero address for native currency).\n  * `amount`: Amount in the token's smallest unit (wei for ETH, considering decimals for ERC-20).\n\nSummary: Defines the data structure for distributing specific token amounts to a recipient address, primarily used to manage fund distribution during channel settlement.\n\nRelated terms: allocation, distribution, payout, settlement, recipient, ERC-20, token amount, destination address, fund allocation, channel closure, wei, asset distribution, alocation, payout structure, token transfer\n\nUse cases: channel settlement, multi-asset distribution, payment routing, state channel exit",
    "metadata": {
      "title": "Data Structures | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/data-structures",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the data structure for distributing specific token amounts to a recipient address, primarily used to manage fund distribution during channel settlement.",
      "keywords": [
        "allocation",
        "distribution",
        "payout",
        "settlement",
        "recipient",
        "ERC-20",
        "token amount",
        "destination address",
        "fund allocation",
        "channel closure",
        "wei",
        "asset distribution",
        "alocation",
        "payout structure",
        "token transfer"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "channel settlement",
        "multi-asset distribution",
        "payment routing",
        "state channel exit"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Signaturesâ€‹\n\n\nSignatures in Nitrolite are stored as raw `bytes` so the protocol can validate multiple scheme formats.\n    \n    \n    struct Signature {  \n        uint8 v;      // Recovery identifier  \n        bytes32 r;    // First 32 bytes of signature  \n        bytes32 s;    // Second 32 bytes of signature  \n    }  \n    \n\nAt a minimum Nitrolite currently recognizes the following signature families (see the [Signature Formats](/docs/protocol/on-chain/signature-formats) reference for the full specification):\n\n  * **Raw/Pre-EIP-191 ECDSA** â€“ Signs `keccak256(packedState)` without any prefix.\n  * **EIP-191 (version`0x45`)** â€“ Signs a structured message that prefixes the packed state with the Ethereum signed message header and length.\n  * **EIP-712 Typed Data** â€“ Signs `keccak256(abi.encode(domainSeparator, hashStruct(state)))`.\n  * **EIP-1271 Smart-Contract Signatures** â€“ Arbitrary bytes validated via `isValidSignature` on the signer contract.\n  * **EIP-6492 Counterfactual Signatures** â€“ Wraps deployment data to prove a not-yet-deployed ERC-4337 wallet authorized the state.\n\nRefer to the dedicated page for verification order, payload layouts, and implementation guidance.\n\nSummary: Defines the universal Signature data structure and supported cryptographic schemes for validating state updates and transaction authorization within the Nitrolite protocol. It provides a unified interface for EOA, smart contract, and counterfactual wallet signatures to ensure cross-platform compatibility.\n\nRelated terms: digital signature, ECDSA, EIP-712, EIP-191, EIP-1271, EIP-6492, keccak256, v r s, recovery identifier, smart contract wallet, account abstraction, state validation, authorization, signture\n\nUse cases: Authorizing off-chain state transitions in payment channels, Verifying transactions from smart contract wallets like Gnosis Safe, Validating messages from not-yet-deployed ERC-4337 accounts, Implementing multi-party signing for protocol security",
    "metadata": {
      "title": "Data Structures | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/data-structures",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the universal Signature data structure and supported cryptographic schemes for validating state updates and transaction authorization within the Nitrolite protocol. It provides a unified interface for EOA, smart contract, and counterfactual wallet signatures to ensure cross-platform compatibility.",
      "keywords": [
        "digital signature",
        "ECDSA",
        "EIP-712",
        "EIP-191",
        "EIP-1271",
        "EIP-6492",
        "keccak256",
        "v r s",
        "recovery identifier",
        "smart contract wallet",
        "account abstraction",
        "state validation",
        "authorization",
        "signture"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Authorizing off-chain state transitions in payment channels",
        "Verifying transactions from smart contract wallets like Gnosis Safe",
        "Validating messages from not-yet-deployed ERC-4337 accounts",
        "Implementing multi-party signing for protocol security"
      ],
      "function_names": [
        "keccak256"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Amountâ€‹\n\n\nRepresents a quantity of a specific token.\n    \n    \n    struct Amount {  \n        address token;    // ERC-20 token address  \n        uint256 amount;   // Token amount  \n    }\n\nSummary: Defines a standardized data structure for representing a specific quantity of an ERC-20 token, pairing the contract address with the numerical value.\n\nRelated terms: amount, token address, ERC-20, asset quantity, balance, value, currency, token, uint256, crypto amount, payment value, ammount, token identifier\n\nUse cases: specifying payment amounts, defining collateral requirements, representing account balances",
    "metadata": {
      "title": "Data Structures | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/data-structures",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines a standardized data structure for representing a specific quantity of an ERC-20 token, pairing the contract address with the numerical value.",
      "keywords": [
        "amount",
        "token address",
        "ERC-20",
        "asset quantity",
        "balance",
        "value",
        "currency",
        "token",
        "uint256",
        "crypto amount",
        "payment value",
        "ammount",
        "token identifier"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "specifying payment amounts",
        "defining collateral requirements",
        "representing account balances"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Channel Statusâ€‹\n\n\nEnum representing the lifecycle stage of a channel.\n    \n    \n    enum Status {  \n        VOID,      // Channel does not exist  \n        INITIAL,   // Creation in progress, awaiting all participants  \n        ACTIVE,    // Fully funded and operational  \n        DISPUTE,   // Challenge period active  \n        FINAL      // Ready to be closed and deleted  \n    }\n\nSummary: Defines the lifecycle stages of a payment channel, enabling system architects to track state transitions from initialization and active operation through to dispute resolution and final settlement.\n\nRelated terms: channel status, lifecycle, state machine, payment channel, dispute resolution, settlement, funding, VOID, INITIAL, ACTIVE, DISPUTE, FINAL, channel state, transaction status\n\nUse cases: Monitoring payment channel health, Handling dispute challenge periods, Validating channel readiness for transactions, Managing channel closure workflows",
    "metadata": {
      "title": "Data Structures | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/data-structures",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the lifecycle stages of a payment channel, enabling system architects to track state transitions from initialization and active operation through to dispute resolution and final settlement.",
      "keywords": [
        "channel status",
        "lifecycle",
        "state machine",
        "payment channel",
        "dispute resolution",
        "settlement",
        "funding",
        "VOID",
        "INITIAL",
        "ACTIVE",
        "DISPUTE",
        "FINAL",
        "channel state",
        "transaction status"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "Monitoring payment channel health",
        "Handling dispute challenge periods",
        "Validating channel readiness for transactions",
        "Managing channel closure workflows"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Protocol Constantsâ€‹\n\n\n### Participant Indicesâ€‹\n    \n    \n    constant uint256 CLIENT_IDX = 0;   // Client/Creator participant index  \n    constant uint256 SERVER_IDX = 1;   // Server/Clearnode participant index  \n    constant uint256 PART_NUM = 2;     // Number of participants (always 2)  \n    \n\n### Challenge Periodâ€‹\n    \n    \n    uint256 public constant MIN_CHALLENGE_PERIOD = 1 hours;  \n    \n\nThe minimum challenge period enforced by the Custody Contract. Channel configurations must specify a challenge period of at least 1 hour.\n\n### EIP-712 Type Hashesâ€‹\n\nThe protocol uses EIP-712 structured data signing with the following domain parameters:\n    \n    \n    // EIP-712 Domain  \n    name: \"Nitrolite:Custody\"  \n    version: \"0.3.0\"  \n    \n\nType hashes for state validation:\n    \n    \n    // State hash computation for signatures  \n    bytes32 constant STATE_TYPEHASH = keccak256(  \n        \"AllowStateHash(bytes32 channelId,uint8 intent,uint256 version,bytes data,Allocation[] allocations)Allocation(address destination,address token,uint256 amount)\"  \n    );  \n      \n    // Challenge state hash computation  \n    bytes32 public constant CHALLENGE_STATE_TYPEHASH = keccak256(  \n        \"AllowChallengeStateHash(bytes32 channelId,uint8 intent,uint256 version,bytes data,Allocation[] allocations)Allocation(address destination,address token,uint256 amount)\"  \n    );  \n    \n\nThese type hashes enable human-readable signature prompts in wallets and improve security by preventing signature replay attacks across different contexts.\n\nSummary: Defines the foundational constants and cryptographic schemas used for state validation, participant identification, and security parameters within the Yellow Network protocol. It establishes the EIP-712 domain and type hashes required for secure, human-readable message signing between clients and servers.\n\nRelated terms: EIP-712, typehash, challenge period, participant index, state validation, signature replay protection, structured data signing, Nitrolite, custody contract, keccak256, domain separator, security timeout, EIP712, signing messages\n\nUse cases: Implementing EIP-712 signature verification in a custom client, Configuring channel dispute timeouts for security, Identifying client and server roles in state updates",
    "metadata": {
      "title": "Data Structures | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/data-structures",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the foundational constants and cryptographic schemas used for state validation, participant identification, and security parameters within the Yellow Network protocol. It establishes the EIP-712 domain and type hashes required for secure, human-readable message signing between clients and servers.",
      "keywords": [
        "EIP-712",
        "typehash",
        "challenge period",
        "participant index",
        "state validation",
        "signature replay protection",
        "structured data signing",
        "Nitrolite",
        "custody contract",
        "keccak256",
        "domain separator",
        "security timeout",
        "EIP712",
        "signing messages"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "Implementing EIP-712 signature verification in a custom client",
        "Configuring channel dispute timeouts for security",
        "Identifying client and server roles in state updates"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Identifier Computationâ€‹\n\n\n### Channel Identifierâ€‹\n\nThe channelId MUST be computed as:\n    \n    \n    channelId = keccak256(  \n        abi.encode(  \n            channel.participants,  \n            channel.adjudicator,  \n            channel.challenge,  \n            channel.nonce,  \n            chainId  \n        )  \n    )  \n    \n\nThis creates a deterministic, unique identifier for each channel.\n\nApp Session Identifiers\n\nApp sessions use a different computation: `keccak256(JSON.stringify(definition))` where definition includes the app configuration but **not** `chainId`, since sessions are entirely off-chain. See [Off-chain â€º App Sessions â€º Session Identifier](/docs/protocol/off-chain/app-sessions#session-identifier) for details.\n\nDeterministic IDs\n\nChannel IDs are deterministically computed from the channel configuration, ensuring the same configuration always produces the same identifier.\n\n### Packed Stateâ€‹\n\nThe legacy state hash concept was removed in v0.3.0 when non-ECDSA signatures were introduced. Instead, participants use the **packed state** payload for signing:\n    \n    \n    packedState = abi.encode(  \n        channelId,  \n        state.intent,  \n        state.version,  \n        state.data,  \n        state.allocations  \n    )  \n    \n\nThe packed state is simply `abi.encode(channelId, state.intent, state.version, state.data, state.allocations)`. This byte array is fed into the selected signing scheme (EIP-712 hashing, ERC-1271 contract checks, NO_EIP712 fallback, etc.). Each scheme may wrap or hash `packedState` as needed, but the canonical payload MUST be the input.\n\nSignature Verification\n\nAll state updates MUST be verified by checking signatures against the canonical `packedState` payload (after the signing method applies its required hashing/wrapping) before accepting them on-chain.\n\n\n\n[PreviousOverview](/docs/protocol/on-chain/overview)[NextChannel Lifecycle](/docs/protocol/on-chain/channel-lifecycle)\n\n  * Channel\n  * State\n  * Allocation\n  * Signatures\n  * Amount\n  * Channel Status\n  * Protocol Constants\n    * Participant Indices\n    * Challenge Period\n    * EIP-712 Type Hashes\n  * Identifier Computation\n    * Channel Identifier\n    * Packed State\n\nSummary: Defines the deterministic computation of unique identifiers for channels and app sessions, alongside the canonical packed state format required for secure multi-party signature verification.\n\nRelated terms: channelId, packedState, keccak256, abi.encode, deterministic identifier, signature verification, off-chain session, state update, EIP-712, ERC-1271, multi-party signing, channel configuration, session identifier\n\nUse cases: Generating unique channel identifiers, Preparing state payloads for signing, Verifying off-chain state updates, Creating chain-agnostic app sessions",
    "metadata": {
      "title": "Data Structures | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/data-structures",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the deterministic computation of unique identifiers for channels and app sessions, alongside the canonical packed state format required for secure multi-party signature verification.",
      "keywords": [
        "channelId",
        "packedState",
        "keccak256",
        "abi.encode",
        "deterministic identifier",
        "signature verification",
        "off-chain session",
        "state update",
        "EIP-712",
        "ERC-1271",
        "multi-party signing",
        "channel configuration",
        "session identifier"
      ],
      "function_name": "keccak256",
      "intent": "concept",
      "use_cases": [
        "Generating unique channel identifiers",
        "Preparing state payloads for signing",
        "Verifying off-chain state updates",
        "Creating chain-agnostic app sessions"
      ],
      "function_names": [
        "keccak256"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "* On-Chain Protocol\n  * Overview\n\n\n\n# On-Chain Protocol Overview\n\nThe on-chain protocol defines the smart contract interfaces and data structures that form the foundation of Nitrolite's security guarantees. This layer operates on the blockchain and handles:\n\n  * **Fund Custody** : Secure locking and unlocking of participant assets\n  * **Dispute Resolution** : Challenge-response mechanism for disagreements\n  * **Final Settlement** : Distribution of funds according to validated states\n  * **Channel Lifecycle**: State transitions from creation to closure\n\nSummary: The on-chain protocol serves as the security foundation for Nitrolite, managing smart contract interfaces for fund custody, dispute resolution, and the complete lifecycle of payment channels. It ensures trustless asset distribution and final settlement through validated state transitions on the blockchain.\n\nRelated terms: on-chain protocol, smart contract, fund custody, dispute resolution, final settlement, channel lifecycle, challenge-response, state transition, asset locking, Nitrolite, blockchain security, onchain, payment channel, trustless settlement\n\nUse cases: Securing participant assets in a trustless environment, Resolving conflicts between parties using challenge-response mechanisms, Managing the lifecycle of a state channel from opening to final settlement",
    "metadata": {
      "title": "Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/overview",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The on-chain protocol serves as the security foundation for Nitrolite, managing smart contract interfaces for fund custody, dispute resolution, and the complete lifecycle of payment channels. It ensures trustless asset distribution and final settlement through validated state transitions on the blockchain.",
      "keywords": [
        "on-chain protocol",
        "smart contract",
        "fund custody",
        "dispute resolution",
        "final settlement",
        "channel lifecycle",
        "challenge-response",
        "state transition",
        "asset locking",
        "Nitrolite",
        "blockchain security",
        "onchain",
        "payment channel",
        "trustless settlement"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Securing participant assets in a trustless environment",
        "Resolving conflicts between parties using challenge-response mechanisms",
        "Managing the lifecycle of a state channel from opening to final settlement"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Key Responsibilitiesâ€‹\n\n\nThe on-chain layer MUST provide:\n\n  1. **Deterministic channel identifiers** computed from channel configuration\n  2. **Signature verification** to authenticate state updates\n  3. **State validation** through adjudicator contracts\n  4. **Challenge periods** to ensure fair dispute resolution\n  5. **Fund safety** guaranteeing users can always recover their assets\n\nEVM Compatibility\n\nThe initial version of Nitrolite is designed for EVM-compatible blockchains including Ethereum, Polygon, Base, and other EVM chains. Support for additional networks is continuously expanding.\n\nSummary: The on-chain layer serves as the security and settlement foundation for the protocol, providing deterministic channel identification, cryptographic state validation, and a robust dispute resolution framework across EVM-compatible networks.\n\nRelated terms: on-chain layer, EVM compatibility, signature verification, state validation, adjudicator contracts, challenge period, fund safety, asset recovery, dispute resolution, Nitrolite, Ethereum, Polygon, Base, deterministic identifiers\n\nUse cases: Securing off-chain state transitions, Trustless dispute resolution for payment channels, Cross-chain payment infrastructure deployment, Guaranteed asset recovery in state channels",
    "metadata": {
      "title": "Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/overview",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "The on-chain layer serves as the security and settlement foundation for the protocol, providing deterministic channel identification, cryptographic state validation, and a robust dispute resolution framework across EVM-compatible networks.",
      "keywords": [
        "on-chain layer",
        "EVM compatibility",
        "signature verification",
        "state validation",
        "adjudicator contracts",
        "challenge period",
        "fund safety",
        "asset recovery",
        "dispute resolution",
        "Nitrolite",
        "Ethereum",
        "Polygon",
        "Base",
        "deterministic identifiers"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Securing off-chain state transitions",
        "Trustless dispute resolution for payment channels",
        "Cross-chain payment infrastructure deployment",
        "Guaranteed asset recovery in state channels"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Contract Interfacesâ€‹\n\n\nThe protocol defines three primary contract interfaces:\n\n  * **IChannel** : Core channel lifecycle operations (create, join, challenge, close)\n  * **IDeposit** : Token deposit and withdrawal management\n  * **IChannelReader** : Read-only queries for channel state and status\n\nThese interfaces are implemented by the **Custody Contract** , which serves as the main entry point for on-chain operations.\n\nSummary: Defines the core smart contract interfaces for managing payment channel lifecycles, token custody, and state queries within the Yellow Network protocol.\n\nRelated terms: IChannel, IDeposit, IChannelReader, Custody Contract, payment channel, smart contract interface, token management, on-chain operations, channel lifecycle, deposit, withdrawal, state query, Yellow Network, crypto protocol\n\nUse cases: Managing on-chain token deposits and withdrawals, Initializing and closing payment channels, Querying the current status of a channel on-chain",
    "metadata": {
      "title": "Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/overview",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the core smart contract interfaces for managing payment channel lifecycles, token custody, and state queries within the Yellow Network protocol.",
      "keywords": [
        "IChannel",
        "IDeposit",
        "IChannelReader",
        "Custody Contract",
        "payment channel",
        "smart contract interface",
        "token management",
        "on-chain operations",
        "channel lifecycle",
        "deposit",
        "withdrawal",
        "state query",
        "Yellow Network",
        "crypto protocol"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Managing on-chain token deposits and withdrawals",
        "Initializing and closing payment channels",
        "Querying the current status of a channel on-chain"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nThe following sections detail:\n\n  * [Data Structures](/docs/protocol/on-chain/data-structures): Core types and identifier computation\n  * [Channel Lifecycle](/docs/protocol/on-chain/channel-lifecycle): Complete state machine and operations\n  * [Security Considerations](/docs/protocol/on-chain/security): Threat model and best practices\n\n\n\n[PreviousArchitecture](/docs/protocol/architecture)[NextData Structures](/docs/protocol/on-chain/data-structures)\n\n  * Key Responsibilities\n  * Contract Interfaces\n  * Next Steps\n\nSummary: This section serves as a high-level roadmap for the Yellow Network protocol, outlining core components such as data structures, channel state management, and security protocols.\n\nRelated terms: Yellow Network, Protocol overview, Channel lifecycle, State machine, Data structures, Security model, Contract interfaces, On-chain operations, Payment channel, Crypto protocol, Threat model, Identifier computation, Yello Network, Smart contract integration\n\nUse cases: Navigating protocol documentation, Understanding on-chain architecture, Planning security audits for payment channels, Implementing state machine transitions",
    "metadata": {
      "title": "Overview | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/overview",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section serves as a high-level roadmap for the Yellow Network protocol, outlining core components such as data structures, channel state management, and security protocols.",
      "keywords": [
        "Yellow Network",
        "Protocol overview",
        "Channel lifecycle",
        "State machine",
        "Data structures",
        "Security model",
        "Contract interfaces",
        "On-chain operations",
        "Payment channel",
        "Crypto protocol",
        "Threat model",
        "Identifier computation",
        "Yello Network",
        "Smart contract integration"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Navigating protocol documentation",
        "Understanding on-chain architecture",
        "Planning security audits for payment channels",
        "Implementing state machine transitions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* On-Chain Protocol\n  * Security Considerations\n\n\n\n# Security Considerations\n\nSummary: Provides an overview of the security architecture and risk mitigation strategies for the Yellow Network's on-chain protocol to ensure transaction integrity and fund safety.\n\nRelated terms: security, risk mitigation, on-chain safety, protocol integrity, vulnerability, threat model, smart contract security, audit, protection, securty, safety measures, encryption, trustless\n\nUse cases: evaluating protocol safety, securing on-chain settlements, risk management for developers, auditing payment channel security",
    "metadata": {
      "title": "Security Considerations | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/security",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Provides an overview of the security architecture and risk mitigation strategies for the Yellow Network's on-chain protocol to ensure transaction integrity and fund safety.",
      "keywords": [
        "security",
        "risk mitigation",
        "on-chain safety",
        "protocol integrity",
        "vulnerability",
        "threat model",
        "smart contract security",
        "audit",
        "protection",
        "securty",
        "safety measures",
        "encryption",
        "trustless"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "evaluating protocol safety",
        "securing on-chain settlements",
        "risk management for developers",
        "auditing payment channel security"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Current Limitationsâ€‹\n\n\nThe current Custody contract implementation has the following limitations:\n\n  * **Two-participant channels only** : Channels support exactly 2 participants\n  * **Participant role constraint** : First participant must always be a client, while second must be a Clearnode\n  * **Single allocation per participant** : Each participant can have only 1 allocation\n  * **Same-token allocations** : Both allocations must be for the same token\n  * **Minimum challenge duration** : Challenge duration is set to be no less than 1 hour\n  * **No re-challenge** : It is not possible to challenge an already challenged channel\n  * **No direct EOA resize** : It is not possible to resize directly from or to your EOA; you must deposit to or withdraw funds from the Custody contract first\n  * **Channel required for withdrawal** : It is not possible to withdraw your funds from the Unified Balance on a chain with no open channel without opening a channel first. In a future major release, we plan to merge these steps in one operation\n  * **Separate resize and balance operations** : It is not possible to top-up a Unified Balance from or withdraw to your EOA balance in the same `resize(...)` operation. You must deposit your funds prior to or withdraw after the `resize(...)` operation. In a future major release, we plan to merge these steps in one operation\n\nFuture Improvements\n\nMany of these limitations are implementation-specific and are planned to be addressed in future major releases. They do not represent fundamental protocol constraints.\n\nSummary: This section outlines the architectural constraints and operational limitations of the current Custody contract implementation, focusing on channel participants, fund management, and challenge mechanisms.\n\nRelated terms: custody contract, state channel, resize, unified balance, clearnode, deposit, withdraw, challenge duration, EOA, liquidity management, protocol limitations, fund allocation\n\nUse cases: Establishing a client-to-clearnode payment channel, Managing liquidity within the Custody contract, Dispute resolution and challenge period management",
    "metadata": {
      "title": "Security Considerations | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/security",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the architectural constraints and operational limitations of the current Custody contract implementation, focusing on channel participants, fund management, and challenge mechanisms.",
      "keywords": [
        "custody contract",
        "state channel",
        "resize",
        "unified balance",
        "clearnode",
        "deposit",
        "withdraw",
        "challenge duration",
        "EOA",
        "liquidity management",
        "protocol limitations",
        "fund allocation"
      ],
      "function_name": "resize",
      "intent": "concept",
      "use_cases": [
        "Establishing a client-to-clearnode payment channel",
        "Managing liquidity within the Custody contract",
        "Dispute resolution and challenge period management"
      ],
      "function_names": [
        "resize"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Threat Modelâ€‹\n\n\n### Assumptionsâ€‹\n\nThe protocol operates under the following security assumptions:\n\n  * **At least one honest party per channel** willing to enforce their rights\n  * **Blockchain is secure and censorship-resistant** within reasonable bounds\n  * **Cryptographic primitives are secure** (ECDSA, keccak256)\n  * **Participants have access to the blockchain** to submit challenges within the challenge period\n\nTrust Model\n\nNitrolite is designed as a **trustless protocol** \\- no single party can steal funds or prevent others from recovering their legitimate share.\n\n### Protected Againstâ€‹\n\nThe protocol provides protection against:\n\n  * **Replay attacks** via version number checking in Custody contract\n  * **State withholding** via challenge mechanism\n  * **Unauthorized state transitions** via signature verification\n  * **Funds theft** \\- all transitions require valid signatures from appropriate parties\n\n### Not Protected Againstâ€‹\n\nThe protocol cannot protect against:\n\n  * **All participants colluding** to violate application rules\n  * **Blockchain -level attacks** (51% attacks, MEV exploitation, etc.)\n  * **Denial of service by blockchain congestion** \\- may affect ability to respond to challenges\n\nBlockchain Dependency\n\nThe security of Nitrolite channels depends on the underlying blockchain's liveness and security. Extended blockchain downtime during a challenge period could prevent parties from responding.\n\nSummary: This section outlines the Nitrolite protocol's security architecture, defining the trust model, cryptographic assumptions, and specific attack vectors the system mitigates or remains susceptible to.\n\nRelated terms: security, threat model, trustless, replay protection, state withholding, signature verification, challenge period, blockchain liveness, ECDSA, keccak256, censorship resistance, collusion, MEV, denial of service, Nitrolite\n\nUse cases: evaluating protocol security for enterprise deployment, designing monitoring systems for challenge periods, conducting risk analysis for multi-party channels",
    "metadata": {
      "title": "Security Considerations | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/security",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the Nitrolite protocol's security architecture, defining the trust model, cryptographic assumptions, and specific attack vectors the system mitigates or remains susceptible to.",
      "keywords": [
        "security",
        "threat model",
        "trustless",
        "replay protection",
        "state withholding",
        "signature verification",
        "challenge period",
        "blockchain liveness",
        "ECDSA",
        "keccak256",
        "censorship resistance",
        "collusion",
        "MEV",
        "denial of service",
        "Nitrolite"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "evaluating protocol security for enterprise deployment",
        "designing monitoring systems for challenge periods",
        "conducting risk analysis for multi-party channels"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Security Propertiesâ€‹\n\n\n### Funds Safetyâ€‹\n\n**Property** : Participants can always recover their funds according to the latest valid signed state, even if other participants become unresponsive.\n\n**Mechanism** : The challenge-response system ensures that:\n\n  1. Any party can initiate closure unilaterally\n  2. Challenge period allows time for others to respond with newer states\n  3. Newest valid state always wins\n  4. Funds are distributed according to the final accepted state\n\nYes\n\nNo\n\nNo\n\nYes\n\nUser has latest  \nsigned state\n\nOther participant responsive?\n\nCooperative close  \nFast & cheap\n\nChallenge with  \nlatest state\n\nWait challenge  \nperiod\n\nCommunication continuation suggested?\n\nClose & recover funds\n\nCreate and submit a  \nnewer state via checkpoint(...)\n\n### State Validityâ€‹\n\n**Property** : Only states signed by the required participants (as determined by the adjudicator) can be accepted.\n\n**Mechanism** :\n\n  * Every state update requires cryptographic signatures\n  * Signatures are verified against the packedState\n  * Adjudicator validates state transitions according to application rules\n  * Invalid states are rejected on-chain\n\nCryptographic Security\n\nState validity is enforced through [supported signatures](/docs/protocol/on-chain/signature-formats), all of which are supported by Ethereum itself.\n\n#### EIP-712 Signature Supportâ€‹\n\nNitrolite supports **EIP-712 (Typed Structured Data)** signatures in addition to raw ECDSA and EIP-191. This provides significant security and user experience advantages:\n\n**Security Benefits** :\n\n  * **Domain Separation** : Signatures are bound to a specific contract and chain, preventing replay attacks across different applications or networks\n  * **Type Safety** : Structured data hashing ensures only valid state structures can be signed, preventing malformed data injection\n  * **Semantic Clarity** : Each field's type and purpose is cryptographically enforced, reducing ambiguity attacks\n\n**User Experience Benefits** :\n\n  * **Human-Readable** : Modern wallets (MetaMask, Ledger, etc.) display EIP-712 signatures as structured fields instead of opaque hex strings\n  * **Transparency** : Users see exactly what `channelId`, `intent`, `version`, `allocations`, and `data` they're signing\n  * **Trust** : Clear presentation reduces phishing risks and increases user confidence\n\n**Example Wallet Display** :\n    \n    \n    Sign Typed Data:  \n      channelId: 0xabcd1234...  \n      intent: OPERATE (1)  \n      version: 5  \n      allocations:  \n        [0] destination: 0x742d35Cc..., token: USDC, amount: 100.00  \n        [1] destination: 0x123456Cc..., token: USDC, amount: 0.00  \n    \n\nCompared to EIP-191 which would show:\n    \n    \n    Sign Message:  \n    0x1ec5000000000000000000000000000000000000000000000000000000001234abcd...  \n    [500+ more hex characters]  \n    \n\n**Implementation Note** : The protocol accepts **all three formats** (raw ECDSA, EIP-191, EIP-712) for maximum compatibility, but EIP-712 is **strongly recommended** for production applications due to its superior security and UX properties.\n\nSupporting EIP-712 signatures also differentiates Nitrolite by keeping state channel operations wallet-friendly and lowering integration friction compared to protocols limited to raw message signing.\n\n### Livenessâ€‹\n\n**Property** : As long as the blockchain is live and accepts transactions within the challenge period, honest participants can enforce their rights.\n\n**Requirements** :\n\n  * Blockchain must be operational\n  * Participant must be able to submit transactions\n  * Challenge period must be sufficient for transaction confirmation\n\n**Recommended Challenge Periods** :\n\n  * **High-value channels**: 24-48 hours (default: 24 hours / 86400 seconds)\n  * **Medium-value channels** : 12-24 hours\n  * **Low-value rapid channels** : 6-12 hours\n\nChallenge Period Trade-offs\n\nLonger challenge periods provide more security but slower dispute resolution. Shorter periods enable faster closure but require more vigilant monitoring.\n\n### Censorship Resistanceâ€‹\n\n**Property** : Since anyone can submit challenges and responses, censorship of a single participant does not prevent channel closure.\n\n**Mechanism** :\n\n  * Any participant can initiate challenge\n  * Any participant can respond to challenge\n  * Multiple participants can attempt the same operation\n  * As long as one honest party can transact, the channel can be resolved\n\nSummary: This component outlines the protocol's security framework, detailing how funds are protected through challenge-response mechanisms and how state integrity is maintained via EIP-712 cryptographic signatures.\n\nRelated terms: funds safety, state validity, EIP-712, challenge-response, unilateral closure, cryptographic signatures, domain separation, replay protection, Nitrolite, adjudicator, state channel, multi-party security, typed data, Ethereum signatures, fund recovery\n\nUse cases: unilateral channel closure, dispute resolution, secure state transitions, preventing replay attacks",
    "metadata": {
      "title": "Security Considerations | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/security",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component outlines the protocol's security framework, detailing how funds are protected through challenge-response mechanisms and how state integrity is maintained via EIP-712 cryptographic signatures.",
      "keywords": [
        "funds safety",
        "state validity",
        "EIP-712",
        "challenge-response",
        "unilateral closure",
        "cryptographic signatures",
        "domain separation",
        "replay protection",
        "Nitrolite",
        "adjudicator",
        "state channel",
        "multi-party security",
        "typed data",
        "Ethereum signatures",
        "fund recovery"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "unilateral channel closure",
        "dispute resolution",
        "secure state transitions",
        "preventing replay attacks"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Attack Vectors and Mitigationsâ€‹\n\n\n### Replay Attacksâ€‹\n\n**Attack** : Resubmitting old signed states to revert channel to a previous favorable allocation.\n\n**Mitigation** :\n\n  * Adjudicators MUST implement version checking to verify that a supplied \"candidate\" is indeed supported by a supplied \"proof\".\n  * Higher version numbers supersede lower versions\n  * On-chain contract tracks the highest version seen\n  * Old states are automatically rejected\n\nv10 > v5\n\nv10 < v20\n\nState v10 submitted\n\nCompare versions\n\nAccept new state\n\nReject old state\n\nVersion Monotonicity\n\nAlways ensure state versions increase monotonically. Never sign two different states with the same version number.\n\n### State Withholdingâ€‹\n\n**Attack** : Refusing to cooperate in closing channel, holding funds hostage.\n\n**Mitigation** :\n\n  * Challenge mechanism allows unilateral closure\n  * Challenge period ensures fair dispute resolution\n  * Latest signed state always prevails\n\n**Example Scenario** :\n    \n    \n    1. Alice and Bob have channel with $1000 each  \n    2. After trading, valid state shows Alice: $1500, Bob: $500  \n    3. Bob refuses to cooperate in cooperative close  \n    4. Alice initiates challenge with latest signed state  \n    5. Bob has access only to an older state, meaning he is unable to resolve the challenge  \n    6. After challenge period elapses, Alice's state becomes the final one  \n    7. Alice recovers her $1500  \n    \n\n### Challenge Griefingâ€‹\n\n**Attack** : Repeatedly challenging with old states to delay closure and grief the counterparty.\n\n**Mitigation** :\n\n  * Each valid newer state resets the challenge period\n  * Attacker must pay gas for each challenge attempt\n  * Eventually attacker runs out of old states\n  * Newest state always wins regardless of challenge count\n  * The party being griefed can checkpoint with the latest valid state, impeding the griefer from challenging with any intermediate state\n\nEconomic Disincentive\n\nChallenge griefing is economically costly for the attacker (gas fees) while only causing time delay, not fund loss, for the victim.\n\n### Front-Runningâ€‹\n\n**Attack** : Observing pending challenge transaction and front-running with a newer state.\n\n**Mitigation** :\n\n  * **This is actually desired behavior** in Nitrolite\n  * The newest state should always win\n  * Front-running helps ensure the most recent state is used\n  * Both parties benefit from accurate state resolution\n\nSummary: This section outlines the security architecture of the Yellow Network, detailing how the protocol mitigates common state channel vulnerabilities like replay attacks, state withholding, and challenge griefing through version monotonicity and on-chain adjudication.\n\nRelated terms: security, replay attack, state withholding, challenge period, versioning, monotonicity, adjudicator, dispute resolution, fraud prevention, state channel security, gas costs, settlement protection, challenge griefing\n\nUse cases: Preventing a counterparty from reverting a transaction to an earlier balance, Recovering funds when a peer becomes unresponsive or refuses to sign a closing state, Defending against malicious actors attempting to delay channel settlement through repeated challenges",
    "metadata": {
      "title": "Security Considerations | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/security",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the security architecture of the Yellow Network, detailing how the protocol mitigates common state channel vulnerabilities like replay attacks, state withholding, and challenge griefing through version monotonicity and on-chain adjudication.",
      "keywords": [
        "security",
        "replay attack",
        "state withholding",
        "challenge period",
        "versioning",
        "monotonicity",
        "adjudicator",
        "dispute resolution",
        "fraud prevention",
        "state channel security",
        "gas costs",
        "settlement protection",
        "challenge griefing"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Preventing a counterparty from reverting a transaction to an earlier balance",
        "Recovering funds when a peer becomes unresponsive or refuses to sign a closing state",
        "Defending against malicious actors attempting to delay channel settlement through repeated challenges"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Best Practicesâ€‹\n\n\n### For Usersâ€‹\n\n**Essential Practices** :\n\n  1. **Never sign duplicate versions** : Never sign two different states with the same version number\n  2. **Keep records** : Maintain a record of the latest state you've signed\n  3. **Monitor events** : Watch the blockchain for channel events (Challenged, Closed)\n  4. **Respond promptly** : React to challenges within the challenge period\n  5. **Verify adjudicators** : Only use adjudicator contracts from trusted sources\n\nCritical Rule\n\n**NEVER sign two different states with the same version number.** This creates ambiguity about the true latest state and can lead to disputes.\n\n### For Implementersâ€‹\n\n**Implementation Requirements** :\n\n  1. **Validate thoroughly** : Check all inputs before submitting transactions\n  2. **Use adjudicators wisely** : Leverage adjudicators to enforce application rules\n  3. **Set appropriate challenge periods** : Balance security needs with user experience\n  4. **Implement proper key management** : Secure storage for participant private keys\n  5. **Log state transitions** : Maintain audit trail of all state updates\n\n**Sample Validation Checklist** :\n    \n    \n    Before submitting state on-chain:  \n    â˜ Verify all required signatures present  \n    â˜ Verify signatures are valid for expected participants  \n    â˜ Verify state version is sequential  \n    â˜ Verify allocations sum correctly  \n    â˜ Verify magic numbers (CHANOPEN/CHANCLOSE) if applicable  \n    â˜ Verify channelId matches expected value  \n    â˜ Test with small amounts first  \n    \n\n### For Adjudicator Developersâ€‹\n\n**Critical Requirements** :\n\n  1. **Implement strict version comparison** : Ensure newer states always supersede older ones\n  2. **Validate state transitions** : Enforce application-specific rules correctly\n  3. **Optimize for gas efficiency** : Validation happens on-chain during disputes\n  4. **Consider edge cases** : Handle all possible state transition scenarios\n  5. **Audit thoroughly** : Security review before deployment is essential\n\nAdjudicator Responsibility\n\nAdjudicators are critical to channel security. A flawed adjudicator can undermine the entire channel's safety guarantees.\n\nBefore Implementing Your Own Adjudicator\n\nThe Adjudicator is an incredibly important part of the Nitrolite protocol. Yellow Network is built on top of a specific adjudicator, which if changed, will render interoperability and security guarantees impossible. Before starting to implement your own Adjudicator, please be sure to advise the Nitrolite developer team, so that your work is not left out.\n\nSummary: This section outlines critical security protocols and operational best practices for users, developers, and adjudicators to ensure the integrity of state channels and prevent disputes. It emphasizes strict state versioning, signature validation, and proactive blockchain monitoring to maintain a secure multi-party payment environment.\n\nRelated terms: security best practices, state versioning, signature validation, adjudicator contract, challenge period, state transition, key management, on-chain validation, dispute resolution, blockchain monitoring, audit trail, multi-party security, transaction safety\n\nUse cases: Preventing state ambiguity and double-signing in payment channels, Implementing secure on-chain dispute resolution logic, Designing robust key management for participant wallets, Monitoring blockchain events to respond to channel challenges",
    "metadata": {
      "title": "Security Considerations | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/security",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines critical security protocols and operational best practices for users, developers, and adjudicators to ensure the integrity of state channels and prevent disputes. It emphasizes strict state versioning, signature validation, and proactive blockchain monitoring to maintain a secure multi-party payment environment.",
      "keywords": [
        "security best practices",
        "state versioning",
        "signature validation",
        "adjudicator contract",
        "challenge period",
        "state transition",
        "key management",
        "on-chain validation",
        "dispute resolution",
        "blockchain monitoring",
        "audit trail",
        "multi-party security",
        "transaction safety"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Preventing state ambiguity and double-signing in payment channels",
        "Implementing secure on-chain dispute resolution logic",
        "Designing robust key management for participant wallets",
        "Monitoring blockchain events to respond to channel challenges"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Security Guarantees Summaryâ€‹\n\n\nProperty| Guarantee| Mechanism  \n---|---|---  \n**Funds Safety**|  Cannot lose funds with valid signed state| Challenge-response + signatures  \n**State Validity**|  Only properly signed states accepted| Signature verification  \n**Liveness**|  Can always close if blockchain is live| Unilateral challenge mechanism  \n**Censorship Resistance**|  Any party can enforce closure| Multiple submission paths  \n**No Replay**|  Old states cannot be reused| Version number validation  \n  \nStrong Security Model\n\nNitrolite provides **strong security guarantees** built on top of Layer 1 blockchain security, while enabling Layer 2 scalability and efficiency.\n\nSummary: This section outlines the core security properties of the Nitrolite protocol, detailing how it leverages Layer 1 security to ensure funds safety, state integrity, and censorship resistance through mechanisms like signature verification and unilateral challenges.\n\nRelated terms: security guarantees, funds safety, state validity, liveness, censorship resistance, no replay, signature verification, challenge-response, unilateral closure, Nitrolite, Layer 2 security, version number validation, L2 scalability, blockchain security, trustless\n\nUse cases: evaluating protocol security risks, designing trustless payment channels, implementing dispute resolution mechanisms, architecting non-custodial trading systems",
    "metadata": {
      "title": "Security Considerations | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/security",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines the core security properties of the Nitrolite protocol, detailing how it leverages Layer 1 security to ensure funds safety, state integrity, and censorship resistance through mechanisms like signature verification and unilateral challenges.",
      "keywords": [
        "security guarantees",
        "funds safety",
        "state validity",
        "liveness",
        "censorship resistance",
        "no replay",
        "signature verification",
        "challenge-response",
        "unilateral closure",
        "Nitrolite",
        "Layer 2 security",
        "version number validation",
        "L2 scalability",
        "blockchain security",
        "trustless"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "evaluating protocol security risks",
        "designing trustless payment channels",
        "implementing dispute resolution mechanisms",
        "architecting non-custodial trading systems"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Emergency Proceduresâ€‹\n\n\n### If a Clearnode Becomes Unresponsiveâ€‹\n\n  1. **Retrieve latest signed state** from local storage\n  2. **Initiate challenge** on-chain with latest state\n  3. **Close the channel** after challenge period expires\n  4. **Funds are recovered** according to latest valid state\n\n### If You Have Been Challengedâ€‹\n\n  1. **Check for the latest state** \\- make sure the channel was challenged with the latest state. If not, you should checkpoint it with one to avoid funds loss\n  2. **Ensure blockchain access** \\- check network connectivity\n  3. **Use appropriate gas prices** \\- ensure timely confirmation\n  4. **Have backup RPC endpoints** \\- don't rely on single provider\n\nMonitoring Best Practice\n\nSet up automated monitoring with alerts for channel events. This ensures you can respond quickly to challenges even if you're not actively watching.\n\n\n\n[PreviousSignature Formats](/docs/protocol/on-chain/signature-formats)[NextOff-Chain RPC Overview](/docs/protocol/off-chain/overview)\n\n  * Current Limitations\n  * Threat Model\n    * Assumptions\n    * Protected Against\n    * Not Protected Against\n  * Security Properties\n    * Funds Safety\n    * State Validity\n    * Liveness\n    * Censorship Resistance\n  * Attack Vectors and Mitigations\n    * Replay Attacks\n    * State Withholding\n    * Challenge Griefing\n    * Front-Running\n  * Best Practices\n    * For Users\n    * For Implementers\n    * For Adjudicator Developers\n  * Security Guarantees Summary\n  * Emergency Procedures\n    * If a Clearnode Becomes Unresponsive\n    * If You Have Been Challenged\n\nSummary: This section outlines emergency protocols and security best practices for handling unresponsive nodes and on-chain challenges to ensure funds recovery and state integrity.\n\nRelated terms: recover funds, emergency exit, node failure, dispute resolution, on-chain challenge, state checkpoint, clearnode, channel closure, RPC endpoint, gas price, security, monitoring, liveness, censorship resistance, replay attack\n\nUse cases: Recovering funds from an offline peer, Responding to a malicious on-chain challenge, Setting up automated channel monitoring, Mitigating state withholding attacks",
    "metadata": {
      "title": "Security Considerations | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/security",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section outlines emergency protocols and security best practices for handling unresponsive nodes and on-chain challenges to ensure funds recovery and state integrity.",
      "keywords": [
        "recover funds",
        "emergency exit",
        "node failure",
        "dispute resolution",
        "on-chain challenge",
        "state checkpoint",
        "clearnode",
        "channel closure",
        "RPC endpoint",
        "gas price",
        "security",
        "monitoring",
        "liveness",
        "censorship resistance",
        "replay attack"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Recovering funds from an offline peer",
        "Responding to a malicious on-chain challenge",
        "Setting up automated channel monitoring",
        "Mitigating state withholding attacks"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* On-Chain Protocol\n  * Signature Formats\n\n\n\n# Signature Formats\n\nNitrolite treats each signature inside `State.sigs` as an opaque `bytes` value. At verification time the Custody contract inspects that payload to detect which validation flow to run. This page captures the current formats the protocol accepts and how they are evaluated.\n\nSummary: Defines how the Nitrolite protocol handles and validates cryptographic signatures within state updates, allowing the Custody contract to determine the appropriate verification logic for different signature types.\n\nRelated terms: signature, validation, verification, Nitrolite, Custody contract, State.sigs, cryptographic proof, signing, multi-sig, on-chain protocol, signture, payload, authentication\n\nUse cases: Implementing custom signature verification logic, Ensuring compatibility with the Custody contract's validation flows, Debugging state update signature failures",
    "metadata": {
      "title": "Signature Formats | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/signature-formats",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines how the Nitrolite protocol handles and validates cryptographic signatures within state updates, allowing the Custody contract to determine the appropriate verification logic for different signature types.",
      "keywords": [
        "signature",
        "validation",
        "verification",
        "Nitrolite",
        "Custody contract",
        "State.sigs",
        "cryptographic proof",
        "signing",
        "multi-sig",
        "on-chain protocol",
        "signture",
        "payload",
        "authentication"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Implementing custom signature verification logic",
        "Ensuring compatibility with the Custody contract's validation flows",
        "Debugging state update signature failures"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Supported Formatsâ€‹\n\n\n### Raw / Pre-EIP-191 ECDSAâ€‹\n\n  * Signs the raw packedState with no prefix.\n  * Produces the canonical `(v, r, s)` tuple encoded as 65 bytes.\n  * Recommended for chain-agnostic clients or when hardware-wallet compatibility is required.\n\n### EIP-191 (`0x45`) Ethereum Signed Messageâ€‹\n\n  * Payload: `keccak256(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" + len(packedState) + packedState)`.\n  * Matches the UX most wallets expose when calling `eth_sign`.\n  * Nitrolite stores the resulting `(v, r, s)` so adjudicators can re-create the prefixed hash for verification.\n\n### EIP-712 Typed Dataâ€‹\n\n  * Payload: `keccak256(\\\"\\\\x19\\\\x01\\\" ++ domainSeparator ++ hashStruct(state))`.\n  * Domain separator includes chain ID, verifying contract, and an application-specific salt to prevent replay.\n  * Provides the strongest replay protection when both parties agree on the domain definition.\n\n### EIP-1271 Smart-Contract Signaturesâ€‹\n\n  * Supports smart contract wallets (multi-sigs, modules, account abstraction).\n  * The `bytes` payload is passed to the signer's `isValidSignature(hash, bytes signature)` function.\n  * Implementations can encode arbitrary metadata (e.g., batched approvals, guardians).\n\n### EIP-6492 Counterfactual Signaturesâ€‹\n\n  * Wraps an EIP-1271 signature with deployment bytecode and a detection suffix `0x6492649264926492649264926492649264926492649264926492649264926492`.\n  * Allows a not-yet-deployed ERC-4337 smart wallet to attest to a state.\n  * During verification Nitrolite simulates or deploys the wallet, then forwards the inner signature to the regular EIP-1271 flow.\n\nSummary: This component defines the supported cryptographic signature schemes for the Yellow Network, ensuring compatibility between standard Externally Owned Accounts (EOAs), hardware wallets, and advanced Account Abstraction smart contract wallets.\n\nRelated terms: signature, ECDSA, EIP-191, EIP-712, EIP-1271, EIP-6492, signing, verification, account abstraction, smart contract wallet, hardware wallet, replay protection, multi-sig, eth_sign, keccak256\n\nUse cases: hardware wallet integration, smart contract wallet authentication, replay-protected state updates, counterfactual account verification",
    "metadata": {
      "title": "Signature Formats | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/signature-formats",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the supported cryptographic signature schemes for the Yellow Network, ensuring compatibility between standard Externally Owned Accounts (EOAs), hardware wallets, and advanced Account Abstraction smart contract wallets.",
      "keywords": [
        "signature",
        "ECDSA",
        "EIP-191",
        "EIP-712",
        "EIP-1271",
        "EIP-6492",
        "signing",
        "verification",
        "account abstraction",
        "smart contract wallet",
        "hardware wallet",
        "replay protection",
        "multi-sig",
        "eth_sign",
        "keccak256"
      ],
      "function_name": "isValidSignature",
      "intent": "concept",
      "use_cases": [
        "hardware wallet integration",
        "smart contract wallet authentication",
        "replay-protected state updates",
        "counterfactual account verification"
      ],
      "function_names": [
        "isValidSignature",
        "keccak256",
        "eth_sign"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Verification Orderâ€‹\n\n\nThe Custody contract attempts the following strategies in order:\n\n  1. **EIP-6492** â€“ If the detection suffix is present, unwrap and validate as counterfactual.\n  2. **EIP-1271** â€“ If the signer currently has contract code, call `isValidSignature`.\n  3. **ECDSA / EIP-191 / EIP-712** â€“ Otherwise treat it as an externally owned account signature and recover the signer using the appropriate hash for the advertised format.\n\nImplementations should persist metadata about which scheme was used so that adjudicators and monitoring services can reproduce the expected hash locally.\n\nSummary: Defines the hierarchical signature verification sequence used by the Custody contract to support diverse account types, including smart contract wallets, counterfactual addresses, and standard externally owned accounts.\n\nRelated terms: signature verification, EIP-6492, EIP-1271, ECDSA, EIP-191, EIP-712, smart contract wallet, EOA, counterfactual, isValidSignature, custody contract, authentication, signing, sig validation\n\nUse cases: validating smart contract wallet signatures, supporting account abstraction wallets, verifying off-chain messages, multi-signature wallet integration",
    "metadata": {
      "title": "Signature Formats | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/signature-formats",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the hierarchical signature verification sequence used by the Custody contract to support diverse account types, including smart contract wallets, counterfactual addresses, and standard externally owned accounts.",
      "keywords": [
        "signature verification",
        "EIP-6492",
        "EIP-1271",
        "ECDSA",
        "EIP-191",
        "EIP-712",
        "smart contract wallet",
        "EOA",
        "counterfactual",
        "isValidSignature",
        "custody contract",
        "authentication",
        "signing",
        "sig validation"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "validating smart contract wallet signatures",
        "supporting account abstraction wallets",
        "verifying off-chain messages",
        "multi-signature wallet integration"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Implementation Notesâ€‹\n\n\n  * `bytes[] sigs` preserves the ordering of channel participants, but each entry may come from a different signature family.\n  * Wallets should expose the format they used when signing to aid debugging.\n  * Future versions may extend this list; storing opaque bytes ensures backward compatibility.\n\n\n\n[PreviousChannel Lifecycle](/docs/protocol/on-chain/channel-lifecycle)[NextSecurity Considerations](/docs/protocol/on-chain/security)\n\n  * Supported Formats\n    * Raw / Pre-EIP-191 ECDSA\n    * EIP-191 (`0x45`) Ethereum Signed Message\n    * EIP-712 Typed Data\n    * EIP-1271 Smart-Contract Signatures\n    * EIP-6492 Counterfactual Signatures\n  * Verification Order\n  * Implementation Notes\n\nSummary: Defines the supported cryptographic signature standards and implementation requirements for authenticating state transitions and channel operations across various wallet types.\n\nRelated terms: signature formats, ECDSA, EIP-191, EIP-712, EIP-1271, EIP-6492, smart contract wallet, message signing, typed data, cryptographic verification, multi-party signing, authentication, counterfactual signatures, sig verification, eth_sign\n\nUse cases: Authenticating multi-party state updates in a payment channel, Integrating smart contract wallets for protocol interactions, Verifying signatures for counterfactual wallet deployments, Debugging signature mismatches between different wallet providers",
    "metadata": {
      "title": "Signature Formats | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/on-chain/signature-formats",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the supported cryptographic signature standards and implementation requirements for authenticating state transitions and channel operations across various wallet types.",
      "keywords": [
        "signature formats",
        "ECDSA",
        "EIP-191",
        "EIP-712",
        "EIP-1271",
        "EIP-6492",
        "smart contract wallet",
        "message signing",
        "typed data",
        "cryptographic verification",
        "multi-party signing",
        "authentication",
        "counterfactual signatures",
        "sig verification",
        "eth_sign"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Authenticating multi-party state updates in a payment channel",
        "Integrating smart contract wallets for protocol interactions",
        "Verifying signatures for counterfactual wallet deployments",
        "Debugging signature mismatches between different wallet providers"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Protocol Reference\n\n\n\n# Protocol Reference\n\nQuick reference guide for protocol versions, constants, standards, and specifications.\n\nQuick Navigation\n\nJump to a section:\n\n  * Protocol Versions \\- Nitrolite & Nitro RPC versions\n  * State Intent System \\- Channel state classification\n  * Participant Indices \\- Creator & Clearnode positions\n  * Channel Status \\- Status transitions\n  * Signature Standards \\- On-chain & off-chain formats\n  * EIP References \\- Ethereum standards used\n  * Protocol Constants \\- Core constants\n\n* * *\n\nSummary: A comprehensive technical reference for the Yellow Network protocol, detailing versioning, state management, participant roles, and adherence to Ethereum standards.\n\nRelated terms: protocol reference, Nitrolite, Nitro RPC, state intent, channel status, participant indices, EIP standards, signature formats, constants, Ethereum, off-chain, on-chain, Clearnode, state machine, yellow network\n\nUse cases: Verifying protocol version compatibility, Implementing state transition logic, Ensuring signature compliance with EIP standards, Configuring participant roles in a channel",
    "metadata": {
      "title": "Protocol Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/protocol-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "A comprehensive technical reference for the Yellow Network protocol, detailing versioning, state management, participant roles, and adherence to Ethereum standards.",
      "keywords": [
        "protocol reference",
        "Nitrolite",
        "Nitro RPC",
        "state intent",
        "channel status",
        "participant indices",
        "EIP standards",
        "signature formats",
        "constants",
        "Ethereum",
        "off-chain",
        "on-chain",
        "Clearnode",
        "state machine",
        "yellow network"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "Verifying protocol version compatibility",
        "Implementing state transition logic",
        "Ensuring signature compliance with EIP standards",
        "Configuring participant roles in a channel"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Protocol Versionsâ€‹\n\n\n### Nitrolite Protocolâ€‹\n\nProperty| Value  \n---|---  \n**Version**|  0.5.0  \n**Status**|  Mainnet deployments live; not production yet  \n**Compatibility**|  EVM-compatible chains  \n  \n**Supported Chains** : Ethereum, Polygon, Arbitrum One, Optimism, Base, and other EVM-compatible networks.\n\n### Nitro RPC Protocolâ€‹\n\nVersion| Status| Features  \n---|---|---  \n**0.2**|  Legacy| Basic state updates only  \n**0.4**|  Current| Intent system (OPERATE, DEPOSIT, WITHDRAW)  \n  \nVersion Recommendation\n\n**Always use NitroRPC/0.4** for new implementations. Version 0.4 adds the intent system for app sessions, enabling dynamic fund management (deposits and withdrawals) within active sessions.\n\n**Breaking Changes** :\n\n  * NitroRPC/0.4 introduces the `intent` parameter in `submit_app_state`\n  * NitroRPC/0.2 sessions cannot use DEPOSIT or WITHDRAW intents\n  * Protocol version is set during app session creation and cannot be changed\n\n* * *\n\nSummary: This reference outlines the Nitrolite and Nitro RPC protocol versions, detailing the transition to an intent-based system for dynamic fund management and state updates on EVM-compatible chains.\n\nRelated terms: Nitrolite, Nitro RPC, EVM compatibility, intent system, state update, deposit, withdraw, session management, protocol versioning, submit_app_state, NitroRPC, Ethereum, Polygon, Arbitrum, payment protocol\n\nUse cases: Upgrading legacy integrations to support intent-based fund management, Implementing dynamic deposits and withdrawals within active app sessions, Configuring protocol versions for new EVM-compatible network deployments",
    "metadata": {
      "title": "Protocol Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/protocol-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This reference outlines the Nitrolite and Nitro RPC protocol versions, detailing the transition to an intent-based system for dynamic fund management and state updates on EVM-compatible chains.",
      "keywords": [
        "Nitrolite",
        "Nitro RPC",
        "EVM compatibility",
        "intent system",
        "state update",
        "deposit",
        "withdraw",
        "session management",
        "protocol versioning",
        "submit_app_state",
        "NitroRPC",
        "Ethereum",
        "Polygon",
        "Arbitrum",
        "payment protocol"
      ],
      "function_name": "submit_app_state",
      "intent": "api_reference",
      "use_cases": [
        "Upgrading legacy integrations to support intent-based fund management",
        "Implementing dynamic deposits and withdrawals within active app sessions",
        "Configuring protocol versions for new EVM-compatible network deployments"
      ],
      "function_names": [
        "submit_app_state"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## State Intent Systemâ€‹\n\n\nChannel states are classified by `state.intent` (uint8) to signal their purpose. The Solidity enum defines:\n\n### StateIntent Enumerationâ€‹\n    \n    \n    enum StateIntent {  \n        OPERATE,     // 0: Normal updates (challenge/checkpoint)  \n        INITIALIZE,  // 1: Channel funding/creation  \n        RESIZE,      // 2: In-place capacity change  \n        FINALIZE     // 3: Cooperative closure  \n    }  \n    \n\n### Intent Usageâ€‹\n\nIntent| Value| When Used| Method  \n---|---|---|---  \n`INITIALIZE`| 1| Channel creation| `Custody.create()`  \n`RESIZE`| 2| Channel resize| `Custody.resize()`  \n`FINALIZE`| 3| Cooperative closure| `Custody.close()`  \n`OPERATE`| 0| Challenge/checkpoint| `Custody.challenge()`, `Custody.checkpoint()`  \n  \n**Example** :\n    \n    \n    // Creation state  \n    state.intent = 1  // INITIALIZE  \n    state.version = 0  \n    state.data = \"0x\"  // Empty for basic channels  \n      \n    // Closing state  \n    state.intent = 3  // FINALIZE  \n    state.version = currentVersion + 1  \n    state.data = \"0x\"  \n    \n\nIntent Validation\n\nSmart contracts validate the `intent` field to ensure proper channel lifecycle. Incorrect intent values will cause transactions to revert.\n\n* * *\n\nSummary: Defines a state classification system that signals the lifecycle stage of a payment channel to ensure smart contract validation during creation, operation, resizing, and closure.\n\nRelated terms: StateIntent, channel lifecycle, channel funding, channel closure, channel resize, state update, smart contract validation, Custody contract, state versioning, OPERATE, INITIALIZE, FINALIZE, RESIZE, payment channel, state machine\n\nUse cases: Opening a new payment channel, Modifying channel capacity, Cooperative channel closure, State dispute resolution",
    "metadata": {
      "title": "Protocol Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/protocol-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines a state classification system that signals the lifecycle stage of a payment channel to ensure smart contract validation during creation, operation, resizing, and closure.",
      "keywords": [
        "StateIntent",
        "channel lifecycle",
        "channel funding",
        "channel closure",
        "channel resize",
        "state update",
        "smart contract validation",
        "Custody contract",
        "state versioning",
        "OPERATE",
        "INITIALIZE",
        "FINALIZE",
        "RESIZE",
        "payment channel",
        "state machine"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "Opening a new payment channel",
        "Modifying channel capacity",
        "Cooperative channel closure",
        "State dispute resolution"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Participant Indicesâ€‹\n\n\nIn a standard payment channel, participants are identified by their array index.\n\n### Index 0: Creator (User)â€‹\n\n**Role** : Creator\n\n**Responsibilities** :\n\n  * Initiates channel creation\n  * Typically the one depositing funds\n  * First to sign states (`state.sigs[0]`)\n  * Calls `Custody.create()` on-chain\n\n**Example** :\n    \n    \n    channel.participants[0] = \"0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\" // User  \n    \n\n### Index 1: Clearnodeâ€‹\n\n**Role** : Service provider\n\n**Responsibilities** :\n\n  * Co-signs the initial state before on-chain `create()`; there is no separate `join()` call\n  * Provides off-chain services (Nitro RPC, unified balance management)\n  * Second to sign states (`state.sigs[1]`)\n\n**Example** :\n    \n    \n    channel.participants[1] = \"0x123456789abcdef0123456789abcdef012345678\" // Clearnode  \n    \n\nSignature Order Critical\n\nSignatures array order **MUST** match participants array order. Mismatched signatures will cause transaction failures.\n    \n    \n    state.sigs[0] = creator_signature   // Must be from participants[0]  \n    state.sigs[1] = clearnode_signature // Must be from participants[1]  \n    \n\n* * *\n\nSummary: Defines the roles and indexing requirements for participants in a Yellow Network payment channel, specifying the responsibilities of the Creator and Clearnode. It mandates a strict signature ordering protocol where the Creator occupies index 0 and the Clearnode occupies index 1 to ensure valid state transitions.\n\nRelated terms: participant index, payment channel, creator, clearnode, signature order, state signing, custody, on-chain creation, off-chain services, Nitro RPC, multi-party signature, channel participants, state.sigs, signature mismatch\n\nUse cases: Initializing a payment channel, Validating multi-party signatures, On-chain custody creation, Off-chain state synchronization",
    "metadata": {
      "title": "Protocol Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/protocol-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the roles and indexing requirements for participants in a Yellow Network payment channel, specifying the responsibilities of the Creator and Clearnode. It mandates a strict signature ordering protocol where the Creator occupies index 0 and the Clearnode occupies index 1 to ensure valid state transitions.",
      "keywords": [
        "participant index",
        "payment channel",
        "creator",
        "clearnode",
        "signature order",
        "state signing",
        "custody",
        "on-chain creation",
        "off-chain services",
        "Nitro RPC",
        "multi-party signature",
        "channel participants",
        "state.sigs",
        "signature mismatch"
      ],
      "function_name": "create",
      "intent": "concept",
      "use_cases": [
        "Initializing a payment channel",
        "Validating multi-party signatures",
        "On-chain custody creation",
        "Off-chain state synchronization"
      ],
      "function_names": [
        "clearnode_signature",
        "join",
        "create",
        "creator_signature"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Channel Status State Machineâ€‹\n\n\nChannel lifecycle is governed by status transitions.\n\n### Status Enumerationâ€‹\n    \n    \n    enum Status {  \n        VOID,      // 0: Channel does not exist  \n        INITIAL,   // 1: Creation in progress, awaiting all participants  \n        ACTIVE,    // 2: Fully funded and operational  \n        DISPUTE,   // 3: Challenge period active  \n        FINAL      // 4: Ready to be closed and deleted  \n    }  \n    \n\n### State Transition Diagramâ€‹\n\ncreate() (creator only)\n\ncreate() (all sigs present)\n\njoin() (remaining participants)\n\nchallenge()\n\nclose() (cooperative)\n\ncheckpoint() (newer state)\n\nclose() (after timeout)\n\nVOID\n\nINITIAL\n\nACTIVE\n\nDISPUTE\n\nFINAL\n\nChannel does not exist  \non blockchain\n\nCreator has joined,  \nawaiting other participants\n\nOperational state,  \ncan perform off-chain updates\n\nChallenge active,  \nparties can submit newer states\n\nReady for deletion,  \nfunds distributed\n\n### Valid Transitionsâ€‹\n\nFrom| To| Trigger| Notes  \n---|---|---|---  \n`VOID`| `INITIAL`| `create()` (creator only)| Legacy flow; awaiting other participants  \n`VOID`| `ACTIVE`| `create()` (all sigs present)| Current flow; both participants co-sign initial state  \n`INITIAL`| `ACTIVE`| `join()`| Remaining participants join  \n`ACTIVE`| `DISPUTE`| `challenge()`| Dispute initiated  \n`ACTIVE`| `FINAL`| `close()`| Cooperative closure  \n`DISPUTE`| `ACTIVE`| `checkpoint()`| Newer state accepted  \n`DISPUTE`| `FINAL`| `close()`| Challenge timeout  \n  \nQuick Closure\n\nThe fastest way to close a channel is **ACTIVE â†’ FINAL** via cooperative `close()`. This skips the challenge period entirely.\n\n* * *\n\nSummary: This component defines the formal state machine and lifecycle transitions for payment channels, governing how they move from initialization to active operation, dispute resolution, and final settlement.\n\nRelated terms: payment channel, state machine, lifecycle, off-chain updates, dispute resolution, channel status, cooperative closure, challenge period, settlement, state transition, funding, multi-sig, blockchain synchronization, channel closure, status enumeration\n\nUse cases: Managing payment channel lifecycle, Resolving off-chain transaction disputes, Cooperative channel settlement, Initializing multi-party payment sessions",
    "metadata": {
      "title": "Protocol Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/protocol-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This component defines the formal state machine and lifecycle transitions for payment channels, governing how they move from initialization to active operation, dispute resolution, and final settlement.",
      "keywords": [
        "payment channel",
        "state machine",
        "lifecycle",
        "off-chain updates",
        "dispute resolution",
        "channel status",
        "cooperative closure",
        "challenge period",
        "settlement",
        "state transition",
        "funding",
        "multi-sig",
        "blockchain synchronization",
        "channel closure",
        "status enumeration"
      ],
      "function_name": "create",
      "intent": "api_reference",
      "use_cases": [
        "Managing payment channel lifecycle",
        "Resolving off-chain transaction disputes",
        "Cooperative channel settlement",
        "Initializing multi-party payment sessions"
      ],
      "function_names": [
        "checkpoint",
        "close",
        "join",
        "challenge",
        "create"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Signature Standardsâ€‹\n\n\n### On-Chain Signatures (Solidity)â€‹\n\nUsed in smart contract transactions (`create`, `join`, `close`, `challenge`, `resize`).\n\n**Format** : Variable-length byte arrays supporting multiple signature types (since v0.3.0)\n\n**Structure** :\n    \n    \n    struct State {  \n        // ... other fields ...  \n        bytes[] sigs;  // Array of signatures from participants  \n    }  \n    \n\n**Supported Types** :\n\n  * **ECDSA** (65 bytes): Standard signatures from EOA wallets\n  * **ERC-1271** : Smart contract wallet signatures\n  * **ERC-6492** : Counterfactual contract signatures (not yet deployed)\n\n**Hash** : Raw `packedState` (no EIP-191 prefix for chain-agnostic compatibility)\n\n**Example** :\n    \n    \n    packedState = keccak256(abi.encode(channelId, state.intent, state.version, state.data, state.allocations))  \n    signature = sign(packedState, participantPrivateKey) // Raw hash, no prefix  \n    \n\n### Off-Chain Signatures (Nitro RPC)â€‹\n\nUsed in RPC requests and responses over RPC.\n\n**Format** : 0x-prefixed hex string (typically ECDSA from session keys)\n\n**Typical Length** : 65 bytes for ECDSA\n\n  * `r`: 32 bytes\n  * `s`: 32 bytes\n  * `v`: 1 byte\n\n**Representation** : 130 hex characters + `0x` prefix\n\n**Example** :\n    \n    \n    signature = \"0x1234567890abcdef...xyz\" // 132 characters total (ECDSA)  \n    \n\n**Computed Over** :\n    \n    \n    rpcHash = keccak256(JSON.stringify(req))  \n    signature = sign(rpcHash, sessionPrivateKey)  \n    \n\nSession Key Signatures\n\nOff-chain RPC signatures are typically ECDSA from session keys (EOA wallets), but the protocol supports other signature types for future flexibility.\n\nChain-Agnostic Signatures\n\nOn-chain signatures do NOT use EIP-191 or EIP-712 prefixes to maintain chain-agnostic compatibility. This differs from typical Ethereum signing patterns. Off-chain RPC signatures (e.g., authentication) DO use EIP-712 for better wallet UX.\n\n* * *\n\nSummary: Defines the cryptographic signature standards for the Yellow Network, specifying formats for chain-agnostic on-chain state updates and EIP-712 compliant off-chain RPC communication.\n\nRelated terms: ECDSA, ERC-1271, ERC-6492, on-chain signatures, off-chain signatures, Nitro RPC, session keys, chain-agnostic, EIP-712, EIP-191, cryptographic proof, state channel signing, packed state, smart contract wallet, signing\n\nUse cases: Authorizing state channel transitions like closing or resizing, Authenticating RPC requests using ephemeral session keys, Integrating multi-sig or smart contract wallets via ERC-1271, Implementing cross-chain compatible state verification",
    "metadata": {
      "title": "Protocol Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/protocol-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the cryptographic signature standards for the Yellow Network, specifying formats for chain-agnostic on-chain state updates and EIP-712 compliant off-chain RPC communication.",
      "keywords": [
        "ECDSA",
        "ERC-1271",
        "ERC-6492",
        "on-chain signatures",
        "off-chain signatures",
        "Nitro RPC",
        "session keys",
        "chain-agnostic",
        "EIP-712",
        "EIP-191",
        "cryptographic proof",
        "state channel signing",
        "packed state",
        "smart contract wallet",
        "signing"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "Authorizing state channel transitions like closing or resizing",
        "Authenticating RPC requests using ephemeral session keys",
        "Integrating multi-sig or smart contract wallets via ERC-1271",
        "Implementing cross-chain compatible state verification"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## EIP Referencesâ€‹\n\n\nEthereum Improvement Proposals referenced or used by the protocol.\n\n### EIP-191: Signed Data Standardâ€‹\n\n**Status** : Not used in on-chain signatures (chain-agnostic design)  \n**Link** : <https://eips.ethereum.org/EIPS/eip-191>\n\n**Why not used for on-chain** : On-chain signatures are computed over raw `packedState` hash without EIP-191 prefix to maintain compatibility across different EVM chains and potential non-EVM implementations.\n\n### EIP-712: Typed Structured Data Hashingâ€‹\n\n**Status** : Used for off-chain RPC authentication  \n**Link** : <https://eips.ethereum.org/EIPS/eip-712>\n\n**Usage** : Authentication flow uses EIP-712 typed data for signing the Policy structure (challenge, wallet, session_key, expires_at, scope, allowances) with the main wallet. This provides better wallet UX by displaying human-readable signing data.\n\n### EIP-1271: Contract Signature Validationâ€‹\n\n**Status** : Supported by adjudicators  \n**Link** : <https://eips.ethereum.org/EIPS/eip-1271>\n\n**Usage** : Enables smart contract wallets to sign state updates as participants.\n\n### EIP-20 (ERC-20): Token Standardâ€‹\n\n**Status** : Required for all assets  \n**Link** : <https://eips.ethereum.org/EIPS/eip-20>\n\n**Usage** : All assets must be ERC-20 compliant tokens. The Custody Contract uses `transferFrom` and `transfer` methods.\n\nStandards Compliance\n\nWhile the protocol references these EIPs, implementation details may vary. Always consult the specific smart contract code for authoritative behavior.\n\n* * *\n\nSummary: This reference outlines the protocol's compliance with Ethereum standards for signing, authentication, and asset management, detailing how EIPs are utilized to ensure cross-chain compatibility and smart contract wallet support.\n\nRelated terms: EIP-712, EIP-191, EIP-1271, ERC-20, signing standards, off-chain authentication, typed data hashing, smart contract wallet, signature validation, token compliance, session management, chain-agnostic, RPC authentication, Ethereum Improvement Proposals\n\nUse cases: Implementing secure off-chain RPC authentication, Integrating smart contract wallets for state update signing, Ensuring ERC-20 token compatibility with custody contracts, Designing cross-chain compatible signature verification",
    "metadata": {
      "title": "Protocol Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/protocol-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This reference outlines the protocol's compliance with Ethereum standards for signing, authentication, and asset management, detailing how EIPs are utilized to ensure cross-chain compatibility and smart contract wallet support.",
      "keywords": [
        "EIP-712",
        "EIP-191",
        "EIP-1271",
        "ERC-20",
        "signing standards",
        "off-chain authentication",
        "typed data hashing",
        "smart contract wallet",
        "signature validation",
        "token compliance",
        "session management",
        "chain-agnostic",
        "RPC authentication",
        "Ethereum Improvement Proposals"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Implementing secure off-chain RPC authentication",
        "Integrating smart contract wallets for state update signing",
        "Ensuring ERC-20 token compatibility with custody contracts",
        "Designing cross-chain compatible signature verification"
      ],
      "function_names": [
        "session_key",
        "expires_at"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Protocol Constantsâ€‹\n\n\nThe only protocol-wide constants defined in code are:\n    \n    \n    uint256 constant PART_NUM   = 2; // Channels are always 2-party  \n    uint256 constant CLIENT_IDX = 0; // Client/creator participant index  \n    uint256 constant SERVER_IDX = 1; // Server/clearnode participant index  \n    \n\nAll channel arrays (participants, allocations, sigs) and state validation logic rely on these indices and fixed participant count.\n\n* * *\n\nSummary: Defines the fundamental structural constants for the Yellow Network protocol, establishing a fixed two-party architecture between a client and a server for all state channel operations.\n\nRelated terms: protocol constants, PART_NUM, CLIENT_IDX, SERVER_IDX, two-party channel, state channel architecture, participant index, clearnode, client-server model, fixed participants, channel arrays, state validation, yellow network, 2-party\n\nUse cases: defining state channel participants, validating multi-party signatures, initializing channel arrays",
    "metadata": {
      "title": "Protocol Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/protocol-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the fundamental structural constants for the Yellow Network protocol, establishing a fixed two-party architecture between a client and a server for all state channel operations.",
      "keywords": [
        "protocol constants",
        "PART_NUM",
        "CLIENT_IDX",
        "SERVER_IDX",
        "two-party channel",
        "state channel architecture",
        "participant index",
        "clearnode",
        "client-server model",
        "fixed participants",
        "channel arrays",
        "state validation",
        "yellow network",
        "2-party"
      ],
      "function_name": null,
      "intent": "api_reference",
      "use_cases": [
        "defining state channel participants",
        "validating multi-party signatures",
        "initializing channel arrays"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Next Stepsâ€‹\n\n\nNow that you have the complete protocol reference:\n\n  1. **Terminology** : Review [Terminology](/docs/protocol/terminology) for all term definitions\n  2. **Communication Flows** : See [Communication Flows](/docs/protocol/communication-flows) for sequence diagrams\n  3. **Implementation Guide** : Follow [Implementation Checklist](/docs/protocol/implementation-checklist) to build compliant clients\n  4. **Channel Lifecycle** : See [Channel Lifecycle](/docs/on-chain/channel-lifecycle) for detailed state transitions\n\nReference Updates\n\nThis reference reflects protocol version 0.5.0. For the latest updates, check the [Nitrolite repository](https://github.com/layer-3/nitrolite) or use `get_config` to query clearnode capabilities dynamically.\n\n\n\n[PreviousCross-Layer Communication Flows](/docs/protocol/communication-flows)[NextGlossary](/docs/protocol/glossary)\n\n  * Protocol Versions\n    * Nitrolite Protocol\n    * Nitro RPC Protocol\n  * State Intent System\n    * StateIntent Enumeration\n    * Intent Usage\n  * Participant Indices\n    * Index 0: Creator (User)\n    * Index 1: Clearnode\n  * Channel Status State Machine\n    * Status Enumeration\n    * State Transition Diagram\n    * Valid Transitions\n  * Signature Standards\n    * On-Chain Signatures (Solidity)\n    * Off-Chain Signatures (Nitro RPC)\n  * EIP References\n    * EIP-191: Signed Data Standard\n    * EIP-712: Typed Structured Data Hashing\n    * EIP-1271: Contract Signature Validation\n    * EIP-20 (ERC-20): Token Standard\n  * Protocol Constants\n  * Next Steps\n\nSummary: This section serves as a high-level architectural map for the Yellow Network protocol, outlining the state machine logic, signature standards, and participant roles required to build compliant payment channel clients.\n\nRelated terms: Yellow Network, Nitrolite, Nitro RPC, state machine, channel lifecycle, EIP-712, EIP-191, EIP-1271, Clearnode, state intent, signature validation, payment channel, off-chain signatures, protocol versioning, get_config\n\nUse cases: Building a compliant Yellow Network client, Implementing off-chain state transitions, Verifying multi-party signatures in payment channels, Querying node capabilities dynamically",
    "metadata": {
      "title": "Protocol Reference | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/protocol-reference",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section serves as a high-level architectural map for the Yellow Network protocol, outlining the state machine logic, signature standards, and participant roles required to build compliant payment channel clients.",
      "keywords": [
        "Yellow Network",
        "Nitrolite",
        "Nitro RPC",
        "state machine",
        "channel lifecycle",
        "EIP-712",
        "EIP-191",
        "EIP-1271",
        "Clearnode",
        "state intent",
        "signature validation",
        "payment channel",
        "off-chain signatures",
        "protocol versioning",
        "get_config"
      ],
      "function_name": "get_config",
      "intent": "concept",
      "use_cases": [
        "Building a compliant Yellow Network client",
        "Implementing off-chain state transitions",
        "Verifying multi-party signatures in payment channels",
        "Querying node capabilities dynamically"
      ],
      "function_names": [
        "get_config"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Core Conceptsâ€‹\n\n\n**Channel** : A secure communication pathway between participants that locks funds in an on-chain smart contract while enabling off-chain state updates.\n\n**State** : A snapshot of the channel at any point in time, including fund allocations and application-specific data.\n\n**Participant** : An entity (identified by a wallet address) that is part of a channel.\n\n**Clearnode** : A server implementing a virtual ledger layer that provides a unified ledger (through Nitro RPC), coordinates state channels (through Nitrolite), and enables chain abstraction for developers and users\n\n**Creator** : The participant at index 0 in a channel who initiates channel creation.\n\n**App Sessions** : Off-chain channels built on top of payment channels, intended to be used by app developers to enable application-specific interactions and transactions without touching the blockchain.\n\n**Unified Balance** : An abstraction that aggregates users' funds across multiple blockchain networks, managed by a clearnode.\n\n**Session Key** : A temporary cryptographic key delegated by a user's main wallet that provides a flexible way for the user to manage security of their funds by giving specific permissions and allowances for specific apps.\n\nSummary: Defines the foundational architectural components of the Yellow Network, including off-chain state channels, virtual ledger nodes, and secure session management for cross-chain interoperability.\n\nRelated terms: channel, state channel, off-chain, clearnode, app session, unified balance, session key, virtual ledger, chain abstraction, nitro rpc, nitrolite, multi-chain, cross-chain, wallet delegation, state update\n\nUse cases: architecting off-chain state updates, implementing cross-chain fund management, securing app interactions with delegated keys, coordinating multi-party transactions",
    "metadata": {
      "title": "Terminology | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/terminology",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the foundational architectural components of the Yellow Network, including off-chain state channels, virtual ledger nodes, and secure session management for cross-chain interoperability.",
      "keywords": [
        "channel",
        "state channel",
        "off-chain",
        "clearnode",
        "app session",
        "unified balance",
        "session key",
        "virtual ledger",
        "chain abstraction",
        "nitro rpc",
        "nitrolite",
        "multi-chain",
        "cross-chain",
        "wallet delegation",
        "state update"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "architecting off-chain state updates",
        "implementing cross-chain fund management",
        "securing app interactions with delegated keys",
        "coordinating multi-party transactions"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## Identifiersâ€‹\n\n\n**channelId** : A unique identifier for a channel, computed as the hash of the channel configuration, formatted as a 0x-prefixed hex string (32 bytes).\n\n**packedState** : A specific encoding of a channelId, state.intent, state.version, state.data, state.allocations, used for signing and signature verification.\n\n**requestId** : A unique identifier for an RPC request, used for correlating requests and responses formatted as a 0x-prefixed hex string (32 bytes).\n\n**appSessionId** : A unique identifier for an app session, formatted as a 0x-prefixed hex string (32 bytes). Used for all subsequent operations on that specific app session.\n\n**accountId** : An identifier for an account or app session within the unified ledger. Can be either a 0x-prefixed hex string or a wallet address.\n\n**chainId** : A blockchain network identifier (uint64). Examples: 1 (Ethereum Mainnet), 137 (Polygon), 8453 (Base), 42161 (Arbitrum One), 10 (Optimism).\n\n**assetSymbol** : A lowercase string identifier for a supported asset. Asset symbols are consistent across chains.\n\n**walletAddress** : A user's blockchain address (0x-prefixed hex string, 20 bytes) that identifies their account and owns funds. Used to identify participants in channels and app sessions.\n\n**userId** : Identifies a user after authentication to the Clearnode. Currently, this is always equivalent to the user's walletAddress.\n\nSummary: This section defines the core identifiers and data formats used within the Yellow Network protocol to uniquely reference channels, sessions, requests, and participants. It establishes the foundational vocabulary and technical specifications for addressing entities across the unified ledger and multi-chain environment.\n\nRelated terms: channelId, packedState, requestId, appSessionId, accountId, chainId, assetSymbol, walletAddress, userId, identifier, hex string, session management, state verification, blockchain network, request correlation\n\nUse cases: Identifying payment channels and app sessions for state updates, Correlating asynchronous RPC requests with responses, Cross-chain asset and network identification, Cryptographic state signing and verification",
    "metadata": {
      "title": "Terminology | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/terminology",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "This section defines the core identifiers and data formats used within the Yellow Network protocol to uniquely reference channels, sessions, requests, and participants. It establishes the foundational vocabulary and technical specifications for addressing entities across the unified ledger and multi-chain environment.",
      "keywords": [
        "channelId",
        "packedState",
        "requestId",
        "appSessionId",
        "accountId",
        "chainId",
        "assetSymbol",
        "walletAddress",
        "userId",
        "identifier",
        "hex string",
        "session management",
        "state verification",
        "blockchain network",
        "request correlation"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "Identifying payment channels and app sessions for state updates",
        "Correlating asynchronous RPC requests with responses",
        "Cross-chain asset and network identification",
        "Cryptographic state signing and verification"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "## On-Chain Contractsâ€‹\n\n\n**Custody Contract** : The main on-chain contract implementing the Nitrolite protocol. It provides the functionality to lock and unlock funds; create, close and challenge a channel; track channel state, and coordinate with adjudicators to validate state transitions on state updates.\n\n**Adjudicator** : A smart contract that defines the rules for validating state transitions during all channel lifecycle operations. The adjudicator's `adjudicate(...)` function is called by the Custody contract to verify whether a new state is valid based on previous states and application-specific logic. Examples include SimpleConsensus (requires both signatures) and Remittance (only sender must sign).\n\nSummary: Defines the core on-chain components of the Nitrolite protocol, specifically the Custody Contract for fund management and channel lifecycle, and Adjudicator contracts for state transition validation.\n\nRelated terms: Custody Contract, Adjudicator, Nitrolite, state transition, channel lifecycle, fund locking, challenge period, smart contract, adjudicate, state update, consensus, remittance, on-chain validation, payment channel, settlement\n\nUse cases: Managing on-chain funds and channel security, Implementing custom state transition rules, Resolving disputes through on-chain challenges",
    "metadata": {
      "title": "Terminology | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/terminology",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the core on-chain components of the Nitrolite protocol, specifically the Custody Contract for fund management and channel lifecycle, and Adjudicator contracts for state transition validation.",
      "keywords": [
        "Custody Contract",
        "Adjudicator",
        "Nitrolite",
        "state transition",
        "channel lifecycle",
        "fund locking",
        "challenge period",
        "smart contract",
        "adjudicate",
        "state update",
        "consensus",
        "remittance",
        "on-chain validation",
        "payment channel",
        "settlement"
      ],
      "function_name": "adjudicate",
      "intent": "concept",
      "use_cases": [
        "Managing on-chain funds and channel security",
        "Implementing custom state transition rules",
        "Resolving disputes through on-chain challenges"
      ],
      "function_names": [
        "adjudicate"
      ],
      "enriched": true
    }
  },
  {
    "page_content": "## Protocol Componentsâ€‹\n\n\n**Nitrolite** : The on-chain smart contract protocol.\n\n**Nitro RPC** : The off-chain communication protocol.\n\nQuick Reference\n\nThese terms are used throughout the protocol specification. Bookmark this page for easy reference while reading other sections.\n\n\n\n[PreviousIntroduction](/docs/protocol/introduction)[NextArchitecture](/docs/protocol/architecture)\n\n  * Core Concepts\n  * Identifiers\n  * On-Chain Contracts\n  * Protocol Components\n\nSummary: Defines the core architectural components of the Yellow Network, distinguishing between the Nitrolite on-chain smart contract protocol and the Nitro RPC off-chain communication layer.\n\nRelated terms: Nitrolite, Nitro RPC, on-chain, off-chain, smart contract, communication protocol, layer 2, state channel, Yellow Network, glossary, terminology, RPC, blockchain architecture\n\nUse cases: understanding protocol architecture, distinguishing on-chain vs off-chain layers, onboarding to Yellow Network development",
    "metadata": {
      "title": "Terminology | Yellow Network",
      "url": "https://docs.yellow.org/docs/protocol/terminology",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "Defines the core architectural components of the Yellow Network, distinguishing between the Nitrolite on-chain smart contract protocol and the Nitro RPC off-chain communication layer.",
      "keywords": [
        "Nitrolite",
        "Nitro RPC",
        "on-chain",
        "off-chain",
        "smart contract",
        "communication protocol",
        "layer 2",
        "state channel",
        "Yellow Network",
        "glossary",
        "terminology",
        "RPC",
        "blockchain architecture"
      ],
      "function_name": null,
      "intent": "concept",
      "use_cases": [
        "understanding protocol architecture",
        "distinguishing on-chain vs off-chain layers",
        "onboarding to Yellow Network development"
      ],
      "function_names": [],
      "enriched": true
    }
  },
  {
    "page_content": "* Tutorials\n\n# Tutorials\n\nWork in Progress\n\nThis section is currently under development. Step-by-step tutorials and comprehensive guides will be available soon.\n\nComing soon: Interactive tutorials covering various development scenarios and use cases.\n\nSummary: A placeholder section for upcoming step-by-step guides and interactive tutorials designed to assist developers in implementing various scenarios using the Yellow Network SDK.\n\nRelated terms: tutorials, guides, walkthroughs, how-to, getting started, implementation examples, development scenarios, interactive learning, yellow network sdk, crypto integration, step-by-step, learning resources, tuts, tutotials\n\nUse cases: onboarding new developers, learning SDK implementation, exploring development scenarios",
    "metadata": {
      "title": "Tutorials | Yellow Network",
      "url": "https://docs.yellow.org/docs/tutorials",
      "source": "yellow-docs",
      "chunk_type": "guide_section",
      "summary": "A placeholder section for upcoming step-by-step guides and interactive tutorials designed to assist developers in implementing various scenarios using the Yellow Network SDK.",
      "keywords": [
        "tutorials",
        "guides",
        "walkthroughs",
        "how-to",
        "getting started",
        "implementation examples",
        "development scenarios",
        "interactive learning",
        "yellow network sdk",
        "crypto integration",
        "step-by-step",
        "learning resources",
        "tuts",
        "tutotials"
      ],
      "function_name": null,
      "intent": "tutorial",
      "use_cases": [
        "onboarding new developers",
        "learning SDK implementation",
        "exploring development scenarios"
      ],
      "function_names": [],
      "enriched": true
    }
  }
]